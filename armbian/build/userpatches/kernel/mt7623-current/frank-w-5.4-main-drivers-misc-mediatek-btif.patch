diff --git a/drivers/misc/mediatek/btif/Kconfig b/drivers/misc/mediatek/btif/Kconfig
new file mode 100644
index 00000000..908898b
--- /dev/null
+++ b/drivers/misc/mediatek/btif/Kconfig
@@ -0,0 +1,4 @@
+config MTK_BTIF
+	tristate"MediaTek BTIF Driver"
+	help
+	  MTK connectivity BTIF driver for A/D die
diff --git a/drivers/misc/mediatek/btif/Makefile b/drivers/misc/mediatek/btif/Makefile
new file mode 100644
index 00000000..e0fc286
--- /dev/null
+++ b/drivers/misc/mediatek/btif/Makefile
@@ -0,0 +1,37 @@
+#
+# Copyright (C) 2015 MediaTek Inc.
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+
+# BTIF driver for AD DIE
+# If KERNELRELEASE is defined, we've been invoked from the
+# kernel build system and can use its language.
+ifneq ($(KERNELRELEASE),)
+	#subdir-ccflags-y can be used in 2.6.34 in the future
+	MTK_PLATFORM := $(subst ",,$(CONFIG_MTK_PLATFORM))
+	subdir-ccflags-y += -I$(srctree)/drivers/misc/mediatek/include/mt-plat/$(MTK_PLATFORM)/include
+	subdir-ccflags-y += -I$(srctree)/arch/arm/mach-$(MTK_PLATFORM)/include/mach
+	subdir-ccflags-y += -I$(srctree)/drivers/misc/mediatek/include/mt-plat
+
+    obj-y += common/
+
+# Otherwise we were called directly from the command
+# line; invoke the kernel build system.
+else
+    KERNELDIR ?= /lib/modules/$(shell uname -r)/build
+    PWD  := $(shell pwd)
+default:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
+clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) clean
+kernel:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD)
+endif
diff --git a/drivers/misc/mediatek/btif/common/Makefile b/drivers/misc/mediatek/btif/common/Makefile
new file mode 100644
index 00000000..8ce6ab5
--- /dev/null
+++ b/drivers/misc/mediatek/btif/common/Makefile
@@ -0,0 +1,33 @@
+#
+# Copyright (C) 2015 MediaTek Inc.
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+
+# BTIF driver for AD DIE
+# If KERNELRELEASE is defined, we've been invoked from the
+# kernel build system and can use its language.
+ifneq ($(KERNELRELEASE),)
+	ccflags-y += -I$(srctree)/$(src)/inc
+	ccflags-y += -I$(srctree)/$(src)/plat_inc
+
+	obj-$(CONFIG_MTK_BTIF) += btif.o
+	btif-objs := mtk_btif.o mtk_btif_exp.o btif_dma_plat.o btif_plat.o
+
+# Otherwise we were called directly from the command
+# line; invoke the kernel build system.
+else
+    KERNELDIR ?= /lib/modules/$(shell uname -r)/build
+    PWD  := $(shell pwd)
+default:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
+clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) clean
+endif
diff --git a/drivers/misc/mediatek/btif/common/btif_dma_plat.c b/drivers/misc/mediatek/btif/common/btif_dma_plat.c
new file mode 100644
index 00000000..58be4692
--- /dev/null
+++ b/drivers/misc/mediatek/btif/common/btif_dma_plat.c
@@ -0,0 +1,1436 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <mtk_lpae.h>
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG "MTK-BTIF-DMA"
+
+#include "btif_dma_priv.h"
+
+#define DMA_USER_ID "btif_driver"
+
+/************************************Global variable***********************************/
+
+static MTK_BTIF_DMA_VFIFO mtk_tx_dma_vfifo = {
+	.vfifo = {
+		  .p_vir_addr = NULL,
+		  .phy_addr = 0,
+		  .vfifo_size = TX_DMA_VFF_SIZE,
+		  .thre = DMA_TX_THRE(TX_DMA_VFF_SIZE),
+		  },
+	.wpt = 0,
+	.last_wpt_wrap = 0,
+	.rpt = 0,
+	.last_rpt_wrap = 0,
+};
+
+static MTK_BTIF_IRQ_STR mtk_btif_tx_dma_irq = {
+	.name = "mtk btif tx dma irq",
+	.is_irq_sup = true,
+	.reg_flag = false,
+#ifdef CONFIG_OF
+	.irq_flags = IRQF_TRIGGER_NONE,
+#else
+	.irq_id = MT_DMA_BTIF_TX_IRQ_ID,
+	.sens_type = IRQ_SENS_LVL,
+	.lvl_type = IRQ_LVL_LOW,
+#endif
+	.p_irq_handler = NULL,
+};
+
+static MTK_BTIF_DMA_VFIFO mtk_rx_dma_vfifo = {
+	.vfifo = {
+		  .p_vir_addr = NULL,
+		  .phy_addr = 0,
+		  .vfifo_size = RX_DMA_VFF_SIZE,
+		  .thre = DMA_RX_THRE(RX_DMA_VFF_SIZE),
+		  },
+
+	.wpt = 0,
+	.last_wpt_wrap = 0,
+	.rpt = 0,
+	.last_rpt_wrap = 0,
+};
+
+static MTK_BTIF_IRQ_STR mtk_btif_rx_dma_irq = {
+	.name = "mtk btif rx dma irq",
+	.is_irq_sup = true,
+	.reg_flag = false,
+#ifdef CONFIG_OF
+	.irq_flags = IRQF_TRIGGER_NONE,
+#else
+	.irq_id = MT_DMA_BTIF_RX_IRQ_ID,
+	.sens_type = IRQ_SENS_LVL,
+	.lvl_type = IRQ_LVL_LOW,
+#endif
+	.p_irq_handler = NULL,
+};
+
+static MTK_DMA_INFO_STR mtk_btif_tx_dma = {
+#ifndef CONFIG_OF
+	.base = AP_DMA_BASE + BTIF_TX_DMA_OFFSET,
+#endif
+	.dir = DMA_DIR_TX,
+	.p_irq = &mtk_btif_tx_dma_irq,
+	.p_vfifo = &(mtk_tx_dma_vfifo.vfifo),
+};
+
+static MTK_DMA_INFO_STR mtk_btif_rx_dma = {
+#ifndef CONFIG_OF
+	.base = AP_DMA_BASE + BTIF_RX_DMA_OFFSET,
+#endif
+	.dir = DMA_DIR_RX,
+	.p_irq = &mtk_btif_rx_dma_irq,
+	.p_vfifo = &(mtk_rx_dma_vfifo.vfifo),
+};
+
+static spinlock_t g_clk_cg_spinlock;	/*dma clock's spinlock */
+
+/************************************Function declearation***********************************/
+static int _is_tx_dma_in_flush(P_MTK_DMA_INFO_STR p_dma_info);
+static int _tx_dma_flush(P_MTK_DMA_INFO_STR p_dma_info);
+static int btif_rx_dma_ctrl(P_MTK_DMA_INFO_STR p_dma_info,
+			    ENUM_DMA_CTRL ctrl_id);
+static int btif_tx_dma_ctrl(P_MTK_DMA_INFO_STR p_dma_info,
+			    ENUM_DMA_CTRL ctrl_id);
+static int btif_rx_dma_ier_ctrl(P_MTK_DMA_INFO_STR p_dma_info, bool en);
+static int btif_tx_dma_ier_ctrl(P_MTK_DMA_INFO_STR p_dma_info, bool en);
+static int hal_rx_dma_dump_reg(P_MTK_DMA_INFO_STR p_dma_info,
+			       ENUM_BTIF_REG_ID flag);
+static int hal_tx_dma_dump_reg(P_MTK_DMA_INFO_STR p_dma_info,
+			       ENUM_BTIF_REG_ID flag);
+static int is_tx_dma_irq_finish_done(P_MTK_DMA_INFO_STR p_dma_info);
+static int _btif_dma_dump_dbg_reg(void);
+static void hal_btif_tx_dma_vff_set_for_4g(void);
+static void hal_btif_rx_dma_vff_set_for_4g(void);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_tx_dma_ier_ctrl
+* DESCRIPTION
+*  BTIF Tx DMA's interrupt enable/disable
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* enable    [IN]        control if tx interrupt enabled or not
+* dma_dir  [IN]         DMA's direction
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+static int hal_btif_dma_ier_ctrl(P_MTK_DMA_INFO_STR p_dma_info, bool en);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_dma_receive_data
+* DESCRIPTION
+*  receive data from btif module in DMA polling mode
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* p_buf     [IN/OUT] pointer to rx data buffer
+* max_len  [IN]        max length of rx buffer
+* RETURNS
+*  positive means data is available, 0 means no data available
+*****************************************************************************/
+#ifndef MTK_BTIF_MARK_UNUSED_API
+static int hal_dma_receive_data(P_MTK_DMA_INFO_STR p_dma_info,
+				unsigned char *p_buf,
+				const unsigned int max_len);
+
+/************************************Function***********************************/
+#endif
+
+#ifdef CONFIG_OF
+static void hal_dma_set_default_setting(ENUM_DMA_DIR dma_dir)
+{
+	struct device_node *node = NULL;
+	unsigned int irq_info[3] = {0, 0, 0};
+	unsigned int phy_base;
+
+	if (dma_dir == DMA_DIR_RX) {
+		node = of_find_compatible_node(NULL, NULL, "mediatek,btif_rx");
+		if (node) {
+			mtk_btif_rx_dma.p_irq->irq_id = irq_of_parse_and_map(node, 0);
+			/*fixme, be compitable arch 64bits*/
+			mtk_btif_rx_dma.base = (unsigned long)of_iomap(node, 0);
+			BTIF_INFO_FUNC("get rx_dma irq(%d),register base(0x%lx)\n",
+				mtk_btif_rx_dma.p_irq->irq_id, mtk_btif_rx_dma.base);
+		} else {
+			BTIF_ERR_FUNC("get rx_dma device node fail\n");
+		}
+		/* get the interrupt line behaviour */
+		if (of_property_read_u32_array(node, "interrupts", irq_info, ARRAY_SIZE(irq_info))) {
+			BTIF_ERR_FUNC("get interrupt flag from DTS fail\n");
+		} else {
+			mtk_btif_rx_dma.p_irq->irq_flags = irq_info[2];
+			BTIF_INFO_FUNC("get interrupt flag(0x%x)\n",
+				mtk_btif_rx_dma.p_irq->irq_flags);
+		}
+		if (of_property_read_u32_index(node, "reg", 1, &phy_base)) {
+			BTIF_ERR_FUNC("get register phy base from DTS fail,dma_dir(%d)\n",
+					dma_dir);
+		} else {
+			BTIF_INFO_FUNC("get register phy base dma_dir(%d)(0x%x)\n",
+					dma_dir, (unsigned int)phy_base);
+		}
+	} else if (dma_dir == DMA_DIR_TX) {
+		node = of_find_compatible_node(NULL, NULL, "mediatek,btif_tx");
+		if (node) {
+			mtk_btif_tx_dma.p_irq->irq_id = irq_of_parse_and_map(node, 0);
+			/*fixme, be compitable arch 64bits*/
+			mtk_btif_tx_dma.base = (unsigned long)of_iomap(node, 0);
+			BTIF_INFO_FUNC("get tx_dma irq(%d),register base(0x%lx)\n",
+				mtk_btif_tx_dma.p_irq->irq_id, mtk_btif_tx_dma.base);
+		} else {
+			BTIF_ERR_FUNC("get tx_dma device node fail\n");
+		}
+		/* get the interrupt line behaviour */
+		if (of_property_read_u32_array(node, "interrupts", irq_info, ARRAY_SIZE(irq_info))) {
+			BTIF_ERR_FUNC("get interrupt flag from DTS fail\n");
+		} else {
+			mtk_btif_tx_dma.p_irq->irq_flags = irq_info[2];
+			BTIF_INFO_FUNC("get interrupt flag(0x%x)\n",
+				mtk_btif_tx_dma.p_irq->irq_flags);
+		}
+
+		if (of_property_read_u32_index(node, "reg", 1, &phy_base)) {
+			BTIF_ERR_FUNC("get register phy base from DTS fail,dma_dir(%d)\n",
+				dma_dir);
+		} else {
+			BTIF_INFO_FUNC("get register phy base dma_dir(%d)(0x%x)\n",
+					dma_dir, (unsigned int)phy_base);
+		}
+	}
+
+}
+#endif
+
+/*****************************************************************************
+* FUNCTION
+*  hal_tx_dma_info_get
+* DESCRIPTION
+*  get btif tx dma channel's information
+* PARAMETERS
+* dma_dir        [IN]         DMA's direction
+* RETURNS
+*  pointer to btif dma's information structure
+*****************************************************************************/
+P_MTK_DMA_INFO_STR hal_btif_dma_info_get(ENUM_DMA_DIR dma_dir)
+{
+	P_MTK_DMA_INFO_STR p_dma_info = NULL;
+
+	BTIF_TRC_FUNC();
+#ifdef CONFIG_OF
+	hal_dma_set_default_setting(dma_dir);
+#endif
+	if (dma_dir == DMA_DIR_RX)
+		/*Rx DMA*/
+		p_dma_info = &mtk_btif_rx_dma;
+	else if (dma_dir == DMA_DIR_TX)
+		/*Tx DMA*/
+		p_dma_info = &mtk_btif_tx_dma;
+	else
+		/*print error log*/
+		BTIF_ERR_FUNC("invalid DMA dir (%d)\n", dma_dir);
+	spin_lock_init(&g_clk_cg_spinlock);
+	BTIF_TRC_FUNC();
+	return p_dma_info;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_clk_ctrl
+* DESCRIPTION
+*  control clock output enable/disable of DMA module
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_dma_clk_ctrl(P_MTK_DMA_INFO_STR p_dma_info, ENUM_CLOCK_CTRL flag)
+{
+/*In MTK DMA BTIF channel, there's only one global CG on AP_DMA, no sub channel's CG bit*/
+/*according to Artis's comment, clock of DMA and BTIF is default off, so we assume it to be off by default*/
+	int i_ret = 0;
+	unsigned long irq_flag = 0;
+
+#if MTK_BTIF_ENABLE_CLK_REF_COUNTER
+	static atomic_t s_clk_ref = ATOMIC_INIT(0);
+#else
+	static ENUM_CLOCK_CTRL status = CLK_OUT_DISABLE;
+#endif
+
+	spin_lock_irqsave(&(g_clk_cg_spinlock), irq_flag);
+
+#if MTK_BTIF_ENABLE_CLK_CTL
+
+#if MTK_BTIF_ENABLE_CLK_REF_COUNTER
+
+	if (flag == CLK_OUT_ENABLE) {
+		if (atomic_inc_return(&s_clk_ref) == 1) {
+#if defined(CONFIG_MTK_CLKMGR)
+			i_ret = enable_clock(MTK_BTIF_APDMA_CLK_CG, DMA_USER_ID);
+#else
+			BTIF_DBG_FUNC("[CCF]enable clk_btif_apdma\n");
+			i_ret = clk_enable(clk_btif_apdma);
+#endif /* defined(CONFIG_MTK_CLKMGR) */
+			if (i_ret) {
+				BTIF_WARN_FUNC
+					("enable_clock for MTK_BTIF_APDMA_CLK_CG failed, ret:%d",
+					 i_ret);
+			}
+		}
+	} else if (flag == CLK_OUT_DISABLE) {
+		if (atomic_dec_return(&s_clk_ref) == 0) {
+#if defined(CONFIG_MTK_CLKMGR)
+			i_ret = disable_clock(MTK_BTIF_APDMA_CLK_CG, DMA_USER_ID);
+			if (i_ret) {
+				BTIF_WARN_FUNC
+					("disable_clock for MTK_BTIF_APDMA_CLK_CG failed, ret:%d",
+					 i_ret);
+			}
+#else
+			BTIF_DBG_FUNC("[CCF] clk_disable(clk_btif_apdma) calling\n");
+			clk_disable(clk_btif_apdma);
+#endif /* defined(CONFIG_MTK_CLKMGR) */
+		}
+	} else {
+		i_ret = ERR_INVALID_PAR;
+		BTIF_ERR_FUNC("invalid  clock ctrl flag (%d)\n", flag);
+	}
+
+#else
+
+	if (status == flag) {
+		i_ret = 0;
+		BTIF_DBG_FUNC("dma clock already %s\n",
+			      CLK_OUT_ENABLE ==
+			      status ? "enabled" : "disabled");
+	} else {
+		if (flag == CLK_OUT_ENABLE) {
+#if defined(CONFIG_MTK_CLKMGR)
+			i_ret = enable_clock(MTK_BTIF_APDMA_CLK_CG, DMA_USER_ID);
+#else
+			BTIF_DBG_FUNC("[CCF]enable clk_btif_apdma\n");
+			i_ret = clk_enable(clk_btif_apdma);
+#endif /* defined(CONFIG_MTK_CLKMGR) */
+			status = (i_ret == 0) ? flag : status;
+			if (i_ret) {
+				BTIF_WARN_FUNC
+					("enable_clock for MTK_BTIF_APDMA_CLK_CG failed, ret:%d",
+					 i_ret);
+			}
+		} else if (flag == CLK_OUT_DISABLE) {
+#if defined(CONFIG_MTK_CLKMGR)
+			i_ret = disable_clock(MTK_BTIF_APDMA_CLK_CG, DMA_USER_ID);
+			status = (i_ret == 0) ? flag : status;
+			if (i_ret) {
+				BTIF_WARN_FUNC
+					("disable_clock for MTK_BTIF_APDMA_CLK_CG failed, ret:%d",
+					 i_ret);
+			}
+#else
+			BTIF_DBG_FUNC("[CCF] clk_disable_unprepare(clk_btif_apdma) calling\n");
+			clk_disable(clk_btif_apdma);
+#endif /* defined(CONFIG_MTK_CLKMGR) */
+		} else {
+			i_ret = ERR_INVALID_PAR;
+			BTIF_ERR_FUNC("invalid  clock ctrl flag (%d)\n", flag);
+		}
+	}
+#endif
+
+#else
+
+#if MTK_BTIF_ENABLE_CLK_REF_COUNTER
+
+#else
+
+	status = flag;
+#endif
+
+	i_ret = 0;
+#endif
+
+	spin_unlock_irqrestore(&(g_clk_cg_spinlock), irq_flag);
+
+#if MTK_BTIF_ENABLE_CLK_REF_COUNTER
+	if (i_ret == 0) {
+		BTIF_DBG_FUNC("dma clock %s\n", flag == CLK_OUT_ENABLE ? "enabled" : "disabled");
+	} else {
+		BTIF_ERR_FUNC("%s dma clock failed, ret(%d)\n",
+				flag == CLK_OUT_ENABLE ? "enable" : "disable", i_ret);
+	}
+#else
+
+	if (i_ret == 0) {
+		BTIF_DBG_FUNC("dma clock %s\n", flag == CLK_OUT_ENABLE ? "enabled" : "disabled");
+	} else {
+		BTIF_ERR_FUNC("%s dma clock failed, ret(%d)\n",
+				flag == CLK_OUT_ENABLE ? "enable" : "disable", i_ret);
+	}
+#endif
+#if defined(CONFIG_MTK_CLKMGR)
+	BTIF_DBG_FUNC("DMA's clock is %s\n", (clock_is_on(MTK_BTIF_APDMA_CLK_CG) == 0) ? "off" : "on");
+#endif
+	return i_ret;
+}
+
+int hal_btif_dma_hw_init(P_MTK_DMA_INFO_STR p_dma_info)
+{
+	int i_ret = 0;
+	unsigned int dat = 0;
+	unsigned long base = p_dma_info->base;
+	unsigned long addr_h = 0;
+	P_DMA_VFIFO p_vfifo = p_dma_info->p_vfifo;
+	P_MTK_BTIF_DMA_VFIFO p_mtk_dma_vfifo = container_of(p_vfifo,
+							    MTK_BTIF_DMA_VFIFO,
+							    vfifo);
+
+	if (p_dma_info->dir == DMA_DIR_RX) {
+		/*Rx DMA*/
+		/*do hardware reset*/
+		/*		BTIF_SET_BIT(RX_DMA_RST(base), DMA_HARD_RST);*/
+		/*		BTIF_CLR_BIT(RX_DMA_RST(base), DMA_HARD_RST);*/
+		BTIF_SET_BIT(RX_DMA_RST(base), DMA_WARM_RST);
+		do {
+			dat = BTIF_READ32(RX_DMA_EN(base));
+		} while (0x01 & dat);
+		/*write vfifo base address to VFF_ADDR*/
+		btif_reg_sync_writel(p_vfifo->phy_addr, RX_DMA_VFF_ADDR(base));
+		if (enable_4G())
+			hal_btif_rx_dma_vff_set_for_4g();
+		else {
+			addr_h = p_vfifo->phy_addr >> 16;
+			addr_h = addr_h >> 16;
+			btif_reg_sync_writel(addr_h, RX_DMA_VFF_ADDR_H(base));
+		}
+		/*write vfifo length to VFF_LEN*/
+		btif_reg_sync_writel(p_vfifo->vfifo_size, RX_DMA_VFF_LEN(base));
+		/*write wpt to VFF_WPT*/
+		btif_reg_sync_writel(p_mtk_dma_vfifo->wpt,
+				     RX_DMA_VFF_WPT(base));
+		btif_reg_sync_writel(p_mtk_dma_vfifo->rpt,
+					 RX_DMA_VFF_RPT(base));
+		/*write vff_thre to VFF_THRESHOLD*/
+		btif_reg_sync_writel(p_vfifo->thre, RX_DMA_VFF_THRE(base));
+		/*clear Rx DMA's interrupt status*/
+		BTIF_SET_BIT(RX_DMA_INT_FLAG(base),
+			     RX_DMA_INT_DONE | RX_DMA_INT_THRE);
+
+		/*enable Rx IER by default*/
+		btif_rx_dma_ier_ctrl(p_dma_info, true);
+	} else {
+/*Tx DMA*/
+/*do hardware reset*/
+/*		BTIF_SET_BIT(TX_DMA_RST(base), DMA_HARD_RST);*/
+/*		BTIF_CLR_BIT(TX_DMA_RST(base), DMA_HARD_RST);*/
+		BTIF_SET_BIT(TX_DMA_RST(base), DMA_WARM_RST);
+		do {
+			dat = BTIF_READ32(TX_DMA_EN(base));
+		} while (0x01 & dat);
+/*write vfifo base address to VFF_ADDR*/
+		btif_reg_sync_writel(p_vfifo->phy_addr, TX_DMA_VFF_ADDR(base));
+		if (enable_4G())
+			hal_btif_tx_dma_vff_set_for_4g();
+		else {
+			addr_h = p_vfifo->phy_addr >> 16;
+			addr_h = addr_h >> 16;
+			btif_reg_sync_writel(addr_h, TX_DMA_VFF_ADDR_H(base));
+		}
+/*write vfifo length to VFF_LEN*/
+		btif_reg_sync_writel(p_vfifo->vfifo_size, TX_DMA_VFF_LEN(base));
+/*write wpt to VFF_WPT*/
+		btif_reg_sync_writel(p_mtk_dma_vfifo->wpt,
+				     TX_DMA_VFF_WPT(base));
+		btif_reg_sync_writel(p_mtk_dma_vfifo->rpt,
+				     TX_DMA_VFF_RPT(base));
+/*write vff_thre to VFF_THRESHOLD*/
+		btif_reg_sync_writel(p_vfifo->thre, TX_DMA_VFF_THRE(base));
+
+		BTIF_CLR_BIT(TX_DMA_INT_FLAG(base), TX_DMA_INT_FLAG_MASK);
+
+		hal_btif_dma_ier_ctrl(p_dma_info, false);
+	}
+
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_tx_dma_ctrl
+* DESCRIPTION
+* enable/disable Tx DMA channel
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* ctrl_id          [IN]        enable/disable ID
+* RETURNS
+*  0 means success; negative means fail
+*****************************************************************************/
+int hal_btif_dma_ctrl(P_MTK_DMA_INFO_STR p_dma_info, ENUM_DMA_CTRL ctrl_id)
+{
+	unsigned int i_ret = -1;
+	ENUM_DMA_DIR dir = p_dma_info->dir;
+
+	if (dir == DMA_DIR_RX)
+		i_ret = btif_rx_dma_ctrl(p_dma_info, ctrl_id);
+	else if (dir == DMA_DIR_TX)
+		i_ret = btif_tx_dma_ctrl(p_dma_info, ctrl_id);
+	else {
+		/*TODO: print error log*/
+		BTIF_ERR_FUNC("invalid dma ctrl id (%d)\n", ctrl_id);
+		i_ret = ERR_INVALID_PAR;
+	}
+	return i_ret;
+}
+
+int hal_btif_dma_rx_cb_reg(P_MTK_DMA_INFO_STR p_dma_info,
+			   dma_rx_buf_write rx_cb)
+{
+	if (p_dma_info->rx_cb != NULL) {
+		BTIF_DBG_FUNC
+		    ("rx_cb already registered, replace (0x%p) with (0x%p)\n",
+		     p_dma_info->rx_cb, rx_cb);
+	}
+	p_dma_info->rx_cb = rx_cb;
+	return 0;
+}
+
+int btif_tx_dma_ctrl(P_MTK_DMA_INFO_STR p_dma_info, ENUM_DMA_CTRL ctrl_id)
+{
+	unsigned int i_ret = -1;
+	unsigned long base = p_dma_info->base;
+	unsigned int dat;
+
+	BTIF_TRC_FUNC();
+	if (ctrl_id == DMA_CTRL_DISABLE) {
+		/*if write 0 to EN bit, DMA will be stopped imediately*/
+		/*if write 1 to STOP bit, DMA will be stopped after current transaction finished*/
+		/*BTIF_CLR_BIT(TX_DMA_EN(base), DMA_EN_BIT);*/
+		BTIF_SET_BIT(TX_DMA_STOP(base), DMA_STOP_BIT);
+		do {
+			dat = BTIF_READ32(TX_DMA_STOP(base));
+		} while (0x1 & dat);
+		BTIF_DBG_FUNC("BTIF Tx DMA disabled,EN(0x%x),STOP(0x%x)\n",
+			BTIF_READ32(TX_DMA_EN(base)), BTIF_READ32(TX_DMA_STOP(base)));
+		i_ret = 0;
+	} else if (ctrl_id == DMA_CTRL_ENABLE) {
+		BTIF_SET_BIT(TX_DMA_EN(base), DMA_EN_BIT);
+		BTIF_DBG_FUNC("BTIF Tx DMA enabled\n");
+		i_ret = 0;
+	} else {
+/*TODO: print error log*/
+		BTIF_ERR_FUNC("invalid DMA ctrl_id (%d)\n", ctrl_id);
+		i_ret = ERR_INVALID_PAR;
+	}
+	BTIF_TRC_FUNC();
+	return i_ret;
+}
+
+int btif_rx_dma_ctrl(P_MTK_DMA_INFO_STR p_dma_info, ENUM_DMA_CTRL ctrl_id)
+{
+	unsigned int i_ret = -1;
+	unsigned long base = p_dma_info->base;
+	unsigned int dat;
+
+	BTIF_TRC_FUNC();
+
+	if (ctrl_id == DMA_CTRL_DISABLE) {
+		/*if write 0 to EN bit, DMA will be stopped imediately*/
+		/*if write 1 to STOP bit, DMA will be stopped after current transaction finished*/
+		/*BTIF_CLR_BIT(RX_DMA_EN(base), DMA_EN_BIT);*/
+		BTIF_SET_BIT(RX_DMA_STOP(base), DMA_STOP_BIT);
+		do {
+			dat = BTIF_READ32(RX_DMA_STOP(base));
+		} while (0x1 & dat);
+		BTIF_DBG_FUNC("BTIF Rx DMA disabled,EN(0x%x),STOP(0x%x)\n",
+			BTIF_READ32(RX_DMA_EN(base)), BTIF_READ32(RX_DMA_STOP(base)));
+		i_ret = 0;
+	} else if (ctrl_id == DMA_CTRL_ENABLE) {
+		BTIF_SET_BIT(RX_DMA_EN(base), DMA_EN_BIT);
+		BTIF_DBG_FUNC("BTIF Rx DMA enabled\n");
+		i_ret = 0;
+	} else {
+/*TODO: print error log*/
+		BTIF_ERR_FUNC("invalid DMA ctrl_id (%d)\n", ctrl_id);
+		i_ret = ERR_INVALID_PAR;
+	}
+	BTIF_TRC_FUNC();
+
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_tx_vfifo_reset
+* DESCRIPTION
+*  reset tx virtual fifo information, except memory information
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_vfifo_reset(P_MTK_DMA_INFO_STR p_dma_info)
+{
+	unsigned int i_ret = -1;
+	P_DMA_VFIFO p_vfifo = p_dma_info->p_vfifo;
+	P_MTK_BTIF_DMA_VFIFO p_mtk_dma_vfifo = container_of(p_vfifo,
+							    MTK_BTIF_DMA_VFIFO,
+							    vfifo);
+
+	BTIF_TRC_FUNC();
+	p_mtk_dma_vfifo->rpt = 0;
+	p_mtk_dma_vfifo->last_rpt_wrap = 0;
+	p_mtk_dma_vfifo->wpt = 0;
+	p_mtk_dma_vfifo->last_wpt_wrap = 0;
+	BTIF_TRC_FUNC();
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_tx_dma_ier_ctrl
+* DESCRIPTION
+*  BTIF Tx DMA's interrupt enable/disable
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* enable    [IN]        control if tx interrupt enabled or not
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_dma_ier_ctrl(P_MTK_DMA_INFO_STR p_dma_info, bool en)
+{
+	unsigned int i_ret = -1;
+	ENUM_DMA_DIR dir = p_dma_info->dir;
+
+	if (dir == DMA_DIR_RX) {
+		i_ret = btif_rx_dma_ier_ctrl(p_dma_info, en);
+	} else if (dir == DMA_DIR_TX) {
+		i_ret = btif_tx_dma_ier_ctrl(p_dma_info, en);
+	} else {
+/*TODO: print error log*/
+		BTIF_ERR_FUNC("invalid DMA dma dir (%d)\n", dir);
+		i_ret = ERR_INVALID_PAR;
+	}
+
+	return i_ret;
+}
+
+int btif_rx_dma_ier_ctrl(P_MTK_DMA_INFO_STR p_dma_info, bool en)
+{
+	unsigned int i_ret = -1;
+	unsigned long base = p_dma_info->base;
+
+	BTIF_TRC_FUNC();
+	if (!en) {
+		BTIF_CLR_BIT(RX_DMA_INT_EN(base),
+			     (RX_DMA_INT_THRE_EN | RX_DMA_INT_DONE_EN));
+	} else {
+		BTIF_SET_BIT(RX_DMA_INT_EN(base),
+			     (RX_DMA_INT_THRE_EN | RX_DMA_INT_DONE_EN));
+	}
+	i_ret = 0;
+	BTIF_TRC_FUNC();
+
+	return i_ret;
+}
+
+int btif_tx_dma_ier_ctrl(P_MTK_DMA_INFO_STR p_dma_info, bool en)
+{
+	unsigned int i_ret = -1;
+	unsigned long base = p_dma_info->base;
+
+	BTIF_TRC_FUNC();
+	if (!en)
+		BTIF_CLR_BIT(TX_DMA_INT_EN(base), TX_DMA_INTEN_BIT);
+	else
+		BTIF_SET_BIT(TX_DMA_INT_EN(base), TX_DMA_INTEN_BIT);
+	i_ret = 0;
+	BTIF_TRC_FUNC();
+
+	return i_ret;
+}
+
+static int is_tx_dma_irq_finish_done(P_MTK_DMA_INFO_STR p_dma_info)
+{
+	int tx_irq_done = 0;
+#if MTK_BTIF_ENABLE_CLK_REF_COUNTER
+/*if we enable this clock reference couner, just return , because when enter IRQ handler, DMA's clock will be opened*/
+	tx_irq_done = 1;
+#else
+	unsigned long flag = 0;
+	unsigned long base = p_dma_info->base;
+
+	spin_lock_irqsave(&(g_clk_cg_spinlock), flag);
+	tx_irq_done = ((BTIF_READ32(TX_DMA_INT_FLAG(base)) & TX_DMA_INT_FLAG_MASK) == 0) ? 1 : 0;
+	spin_unlock_irqrestore(&(g_clk_cg_spinlock), flag);
+#endif
+	return tx_irq_done;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_tx_dma_irq_handler
+* DESCRIPTION
+*  lower level tx interrupt handler
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_tx_dma_irq_handler(P_MTK_DMA_INFO_STR p_dma_info)
+{
+#define MAX_CONTINIOUS_TIMES 512
+	unsigned int i_ret = -1;
+	unsigned int valid_size = 0;
+	unsigned int vff_len = 0;
+	unsigned int left_len = 0;
+	unsigned long base = p_dma_info->base;
+	static int flush_irq_counter;
+	static struct timeval start_timer;
+	static struct timeval end_timer;
+	unsigned long flag = 0;
+
+	spin_lock_irqsave(&(g_clk_cg_spinlock), flag);
+
+#if defined(CONFIG_MTK_CLKMGR)
+	if (clock_is_on(MTK_BTIF_APDMA_CLK_CG) == 0) {
+		spin_unlock_irqrestore(&(g_clk_cg_spinlock), flag);
+		BTIF_ERR_FUNC
+		    ("%s: clock is off before irq status clear done!!!\n",
+		     __FILE__);
+		return i_ret;
+	}
+#endif
+/*check if Tx VFF Left Size equal to VFIFO size or not*/
+	vff_len = BTIF_READ32(TX_DMA_VFF_LEN(base));
+	valid_size = BTIF_READ32(TX_DMA_VFF_VALID_SIZE(base));
+	left_len = BTIF_READ32(TX_DMA_VFF_LEFT_SIZE(base));
+	if (flush_irq_counter == 0)
+		do_gettimeofday(&start_timer);
+	if ((valid_size > 0) && (valid_size < 8)) {
+		i_ret = _tx_dma_flush(p_dma_info);
+		flush_irq_counter++;
+		if (flush_irq_counter >= MAX_CONTINIOUS_TIMES) {
+			do_gettimeofday(&end_timer);
+/*
+ * when btif tx fifo cannot accept any data and counts of bytes left in tx vfifo < 8 for a while
+ * we assume that btif cannot send data for a long time
+ * in order not to generate interrupt continiously, which may effect system's performance.
+ * we clear tx flag and disable btif tx interrupt
+ */
+/*clear interrupt flag*/
+			BTIF_CLR_BIT(TX_DMA_INT_FLAG(base),
+				     TX_DMA_INT_FLAG_MASK);
+/*vFIFO data has been read by DMA controller, just disable tx dma's irq*/
+			i_ret = hal_btif_dma_ier_ctrl(p_dma_info, false);
+			BTIF_ERR_FUNC
+			    ("**********************ERROR, ERROR, ERROR**************************\n");
+			BTIF_ERR_FUNC
+			    ("BTIF Tx IRQ happened %d times (continiously), between %d.%d and %d.%d\n",
+			     MAX_CONTINIOUS_TIMES, start_timer.tv_sec,
+			     start_timer.tv_usec, end_timer.tv_usec,
+			     end_timer.tv_usec);
+		}
+	} else if (vff_len == left_len) {
+		flush_irq_counter = 0;
+/*clear interrupt flag*/
+		BTIF_CLR_BIT(TX_DMA_INT_FLAG(base), TX_DMA_INT_FLAG_MASK);
+/*vFIFO data has been read by DMA controller, just disable tx dma's irq*/
+		i_ret = hal_btif_dma_ier_ctrl(p_dma_info, false);
+	} else {
+#if 0
+		BTIF_ERR_FUNC
+		    ("**********************WARNING**************************\n");
+		BTIF_ERR_FUNC("invalid irq condition, dump register\n");
+		hal_dma_dump_reg(p_dma_info, REG_TX_DMA_ALL);
+#endif
+		BTIF_DBG_FUNC
+		    ("superious IRQ occurs, vff_len(%d), valid_size(%d), left_len(%d)\n",
+		     vff_len, valid_size, left_len);
+	}
+
+	spin_unlock_irqrestore(&(g_clk_cg_spinlock), flag);
+
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_dma_send_data
+* DESCRIPTION
+*  send data through btif in DMA mode
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* p_buf     [IN]        pointer to rx data buffer
+* max_len  [IN]        tx buffer length
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_dma_send_data(P_MTK_DMA_INFO_STR p_dma_info,
+		      const unsigned char *p_buf, const unsigned int buf_len)
+{
+	unsigned int i_ret = -1;
+	unsigned long base = p_dma_info->base;
+	P_DMA_VFIFO p_vfifo = p_dma_info->p_vfifo;
+	unsigned int len_to_send = buf_len;
+	unsigned int ava_len = 0;
+	unsigned int wpt = 0;
+	unsigned int last_wpt_wrap = 0;
+	unsigned int vff_size = 0;
+	unsigned char *p_data = (unsigned char *)p_buf;
+	P_MTK_BTIF_DMA_VFIFO p_mtk_vfifo = container_of(p_vfifo,
+							MTK_BTIF_DMA_VFIFO,
+							vfifo);
+
+	BTIF_TRC_FUNC();
+	if ((p_buf == NULL) || (buf_len == 0)) {
+		i_ret = ERR_INVALID_PAR;
+		BTIF_ERR_FUNC("invalid parameters, p_buf:0x%p, buf_len:%d\n",
+			      p_buf, buf_len);
+		return i_ret;
+	}
+/*check if tx dma in flush operation? if yes, should wait until DMA finish flush operation*/
+/*currently uplayer logic will make sure this pre-condition*/
+/*disable Tx IER, in case Tx irq happens, flush bit may be set in irq handler*/
+	btif_tx_dma_ier_ctrl(p_dma_info, false);
+
+	vff_size = p_mtk_vfifo->vfifo.vfifo_size;
+	ava_len = BTIF_READ32(TX_DMA_VFF_LEFT_SIZE(base));
+	wpt = BTIF_READ32(TX_DMA_VFF_WPT(base)) & DMA_WPT_MASK;
+	last_wpt_wrap = BTIF_READ32(TX_DMA_VFF_WPT(base)) & DMA_WPT_WRAP;
+
+/*
+ * copy data to vFIFO, Note: ava_len should always large than buf_len,
+ * otherwise common logic layer will not call hal_dma_send_data
+ */
+	if (buf_len > ava_len) {
+		BTIF_ERR_FUNC
+		    ("length to send:(%d) < length available(%d), abnormal!!!---!!!\n",
+		     buf_len, ava_len);
+		WARN_ON(buf_len > ava_len);	/* this will cause kernel panic */
+	}
+
+	len_to_send = buf_len < ava_len ? buf_len : ava_len;
+	if (len_to_send + wpt >= vff_size) {
+		unsigned int tail_len = vff_size - wpt;
+
+		memcpy((p_mtk_vfifo->vfifo.p_vir_addr + wpt), p_data, tail_len);
+		p_data += tail_len;
+		memcpy(p_mtk_vfifo->vfifo.p_vir_addr,
+		       p_data, len_to_send - tail_len);
+/*make sure all data write to memory area tx vfifo locates*/
+		mb();
+
+/*calculate WPT*/
+		wpt = wpt + len_to_send - vff_size;
+		last_wpt_wrap ^= DMA_WPT_WRAP;
+	} else {
+		memcpy((p_mtk_vfifo->vfifo.p_vir_addr + wpt),
+		       p_data, len_to_send);
+/*make sure all data write to memory area tx vfifo locates*/
+		mb();
+
+/*calculate WPT*/
+		wpt += len_to_send;
+	}
+	p_mtk_vfifo->wpt = wpt;
+	p_mtk_vfifo->last_wpt_wrap = last_wpt_wrap;
+
+/*make sure tx dma is allowed(tx flush bit is not set) to use before update WPT*/
+	if (hal_dma_is_tx_allow(p_dma_info)) {
+		/*make sure tx dma enabled*/
+		hal_btif_dma_ctrl(p_dma_info, DMA_CTRL_ENABLE);
+
+		/*update WTP to Tx DMA controller's control register*/
+		btif_reg_sync_writel(wpt | last_wpt_wrap, TX_DMA_VFF_WPT(base));
+
+		if ((BTIF_READ32(TX_DMA_VFF_VALID_SIZE(base)) < 8) &&
+		    (BTIF_READ32(TX_DMA_VFF_VALID_SIZE(base)) > 0)) {
+			/*
+			 * 0 < valid size in Tx vFIFO < 8 && TX Flush is not in process<should always be done>?
+			 * if yes, set flush bit to DMA
+			 */
+			_tx_dma_flush(p_dma_info);
+		}
+		i_ret = len_to_send;
+	} else {
+/*TODO: print error log*/
+		BTIF_ERR_FUNC("Tx DMA flush operation is in process, this case should never happen,",
+		"please check if tx operation is allowed before call this API\n");
+/*if flush operation is in process , we will return 0*/
+		i_ret = 0;
+	}
+
+/*Enable Tx IER*/
+	btif_tx_dma_ier_ctrl(p_dma_info, true);
+
+	BTIF_TRC_FUNC();
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_dma_is_tx_complete
+* DESCRIPTION
+*  get tx complete flag
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* RETURNS
+*  true means tx complete, false means tx in process
+*****************************************************************************/
+bool hal_dma_is_tx_complete(P_MTK_DMA_INFO_STR p_dma_info)
+{
+	bool b_ret = -1;
+	unsigned long base = p_dma_info->base;
+	unsigned int valid_size = BTIF_READ32(TX_DMA_VFF_VALID_SIZE(base));
+	unsigned int inter_size = BTIF_READ32(TX_DMA_INT_BUF_SIZE(base));
+	unsigned int tx_done = is_tx_dma_irq_finish_done(p_dma_info);
+
+/*
+ * only when virtual FIFO valid size and Tx channel internal buffer size are both becomes to be 0,
+ * we can identify tx operation finished
+ * confirmed with DE.
+ */
+	if ((valid_size == 0) && (inter_size == 0) && (tx_done == 1)) {
+		b_ret = true;
+		BTIF_DBG_FUNC("DMA tx finished.\n");
+	} else {
+		BTIF_DBG_FUNC
+		    ("DMA tx is in process. vfifo valid size(%d), dma internal size (%d), tx_done(%d)\n",
+		     valid_size, inter_size, tx_done);
+		b_ret = false;
+	}
+
+	return b_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_dma_get_ava_room
+* DESCRIPTION
+*  get tx available room
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* RETURNS
+*  available room  size
+*****************************************************************************/
+int hal_dma_get_ava_room(P_MTK_DMA_INFO_STR p_dma_info)
+{
+	int i_ret = -1;
+	unsigned long base = p_dma_info->base;
+
+/*read vFIFO's left size*/
+	i_ret = BTIF_READ32(TX_DMA_VFF_LEFT_SIZE(base));
+	BTIF_DBG_FUNC("DMA tx ava room (%d).\n", i_ret);
+	if (i_ret == 0)
+		BTIF_INFO_FUNC("DMA tx vfifo is full.\n");
+
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_dma_is_tx_allow
+* DESCRIPTION
+*  is tx operation allowed by DMA
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* RETURNS
+*  true if tx operation is allowed; false if tx is not allowed
+*****************************************************************************/
+bool hal_dma_is_tx_allow(P_MTK_DMA_INFO_STR p_dma_info)
+{
+#define MIN_TX_MB ((26 * 1000000 / 13) / 1000000)
+#define AVE_TX_MB ((26 * 1000000 / 8) / 1000000)
+
+	bool b_ret = false;
+	unsigned int wait_us = 8 / MIN_TX_MB;	/*only ava length */
+/*see if flush operation is in process*/
+	b_ret = _is_tx_dma_in_flush(p_dma_info) ? false : true;
+	if (!b_ret) {
+		usleep_range(wait_us, 2 * wait_us);
+		b_ret = _is_tx_dma_in_flush(p_dma_info) ? false : true;
+	}
+	if (!b_ret)
+		BTIF_WARN_FUNC("btif tx dma is not allowed\n");
+/*after Tx flush operation finished, HW will set DMA_EN back to 0 and stop DMA*/
+	return b_ret;
+}
+
+
+/*****************************************************************************
+* FUNCTION
+*  hal_rx_dma_irq_handler
+* DESCRIPTION
+*  lower level rx interrupt handler
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* p_buf     [IN/OUT] pointer to rx data buffer
+* max_len  [IN]        max length of rx buffer
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_rx_dma_irq_handler(P_MTK_DMA_INFO_STR p_dma_info,
+			   unsigned char *p_buf, const unsigned int max_len)
+{
+	int i_ret = -1;
+	unsigned int valid_len = 0;
+	unsigned int wpt_wrap = 0;
+	unsigned int rpt_wrap = 0;
+	unsigned int wpt = 0;
+	unsigned int rpt = 0;
+	unsigned int tail_len = 0;
+	unsigned int real_len = 0;
+	unsigned long base = p_dma_info->base;
+	P_DMA_VFIFO p_vfifo = p_dma_info->p_vfifo;
+	dma_rx_buf_write rx_cb = p_dma_info->rx_cb;
+	unsigned char *p_vff_buf = NULL;
+	unsigned char *vff_base = p_vfifo->p_vir_addr;
+	unsigned int vff_size = p_vfifo->vfifo_size;
+	P_MTK_BTIF_DMA_VFIFO p_mtk_vfifo = container_of(p_vfifo,
+							MTK_BTIF_DMA_VFIFO,
+							vfifo);
+	unsigned long flag = 0;
+
+	spin_lock_irqsave(&(g_clk_cg_spinlock), flag);
+#if defined(CONFIG_MTK_CLKMGR)
+	if (clock_is_on(MTK_BTIF_APDMA_CLK_CG) == 0) {
+		spin_unlock_irqrestore(&(g_clk_cg_spinlock), flag);
+		BTIF_ERR_FUNC("%s: clock is off before irq handle done!!!\n",
+			      __FILE__);
+		return i_ret;
+	}
+#endif
+/*disable DMA Rx IER*/
+	hal_btif_dma_ier_ctrl(p_dma_info, false);
+
+/*clear Rx DMA's interrupt status*/
+	BTIF_SET_BIT(RX_DMA_INT_FLAG(base), RX_DMA_INT_DONE | RX_DMA_INT_THRE);
+
+	valid_len = BTIF_READ32(RX_DMA_VFF_VALID_SIZE(base));
+	rpt = BTIF_READ32(RX_DMA_VFF_RPT(base));
+	wpt = BTIF_READ32(RX_DMA_VFF_WPT(base));
+	if ((valid_len == 0) && (rpt == wpt)) {
+		BTIF_DBG_FUNC
+		    ("rx interrupt, no data available in Rx DMA, wpt(0x%08x), rpt(0x%08x)\n",
+		     rpt, wpt);
+	}
+
+	i_ret = 0;
+
+	while ((valid_len > 0) || (rpt != wpt)) {
+		rpt_wrap = rpt & DMA_RPT_WRAP;
+		wpt_wrap = wpt & DMA_WPT_WRAP;
+		rpt &= DMA_RPT_MASK;
+		wpt &= DMA_WPT_MASK;
+
+/*calcaute length of available data  in vFIFO*/
+		if (wpt_wrap != p_mtk_vfifo->last_wpt_wrap)
+			real_len = wpt + vff_size - rpt;
+		else
+			real_len = wpt - rpt;
+
+		if (rx_cb != NULL) {
+			tail_len = vff_size - rpt;
+			p_vff_buf = vff_base + rpt;
+			if (tail_len >= real_len) {
+				(*rx_cb) (p_dma_info, p_vff_buf, real_len);
+			} else {
+				(*rx_cb) (p_dma_info, p_vff_buf, tail_len);
+				p_vff_buf = vff_base;
+				(*rx_cb) (p_dma_info, p_vff_buf, real_len -
+					  tail_len);
+			}
+			i_ret += real_len;
+		} else
+			BTIF_ERR_FUNC("no rx_cb found, please check your init process\n");
+		mb();
+		rpt += real_len;
+		if (rpt >= vff_size) {
+			/*read wrap bit should be revert*/
+			rpt_wrap ^= DMA_RPT_WRAP;
+			rpt %= vff_size;
+		}
+		rpt |= rpt_wrap;
+/*record wpt, last_wpt_wrap, rpt, last_rpt_wrap*/
+		p_mtk_vfifo->wpt = wpt;
+		p_mtk_vfifo->last_wpt_wrap = wpt_wrap;
+
+		p_mtk_vfifo->rpt = rpt;
+		p_mtk_vfifo->last_rpt_wrap = rpt_wrap;
+
+/*update rpt information to DMA controller*/
+		btif_reg_sync_writel(rpt, RX_DMA_VFF_RPT(base));
+
+/*get vff valid size again and check if rx data is processed completely*/
+		valid_len = BTIF_READ32(RX_DMA_VFF_VALID_SIZE(base));
+
+		rpt = BTIF_READ32(RX_DMA_VFF_RPT(base));
+		wpt = BTIF_READ32(RX_DMA_VFF_WPT(base));
+	}
+
+/*enable DMA Rx IER*/
+	hal_btif_dma_ier_ctrl(p_dma_info, true);
+
+	spin_unlock_irqrestore(&(g_clk_cg_spinlock), flag);
+
+	return i_ret;
+}
+
+static int hal_tx_dma_dump_reg(P_MTK_DMA_INFO_STR p_dma_info,
+			       ENUM_BTIF_REG_ID flag)
+{
+	int i_ret = -1;
+	unsigned long base = p_dma_info->base;
+	unsigned int int_flag = 0;
+	unsigned int enable = 0;
+	unsigned int stop = 0;
+	unsigned int flush = 0;
+	unsigned int wpt = 0;
+	unsigned int rpt = 0;
+	unsigned int int_buf = 0;
+	unsigned int valid_size = 0;
+	/*unsigned long irq_flag = 0;*/
+
+#if defined(CONFIG_MTK_CLKMGR)
+	/*spin_lock_irqsave(&(g_clk_cg_spinlock), irq_flag);*/
+	if (clock_is_on(MTK_BTIF_APDMA_CLK_CG) == 0) {
+		/*spin_unlock_irqrestore(&(g_clk_cg_spinlock), irq_flag);*/
+		BTIF_ERR_FUNC("%s: clock is off, this should never happen!!!\n",
+			      __FILE__);
+		return i_ret;
+	}
+#endif
+	int_flag = BTIF_READ32(TX_DMA_INT_FLAG(base));
+	enable = BTIF_READ32(TX_DMA_EN(base));
+	stop = BTIF_READ32(TX_DMA_STOP(base));
+	flush = BTIF_READ32(TX_DMA_FLUSH(base));
+	wpt = BTIF_READ32(TX_DMA_VFF_WPT(base));
+	rpt = BTIF_READ32(TX_DMA_VFF_RPT(base));
+	int_buf = BTIF_READ32(TX_DMA_INT_BUF_SIZE(base));
+	valid_size = BTIF_READ32(TX_DMA_VFF_VALID_SIZE(base));
+	/*spin_unlock_irqrestore(&(g_clk_cg_spinlock), irq_flag);*/
+
+	BTIF_INFO_FUNC("DMA's clock is on\n");
+	BTIF_INFO_FUNC("Tx DMA's base address: 0x%lx\n", base);
+
+	if (flag == REG_TX_DMA_ALL) {
+		BTIF_INFO_FUNC("TX_EN(:0x%x\n", enable);
+		BTIF_INFO_FUNC("INT_FLAG:0x%x\n", int_flag);
+		BTIF_INFO_FUNC("TX_STOP:0x%x\n", stop);
+		BTIF_INFO_FUNC("TX_FLUSH:0x%x\n", flush);
+		BTIF_INFO_FUNC("TX_WPT:0x%x\n", wpt);
+		BTIF_INFO_FUNC("TX_RPT:0x%x\n", rpt);
+		BTIF_INFO_FUNC("INT_BUF_SIZE:0x%x\n", int_buf);
+		BTIF_INFO_FUNC("VALID_SIZE:0x%x\n", valid_size);
+		BTIF_INFO_FUNC("INT_EN:0x%x\n",
+			       BTIF_READ32(TX_DMA_INT_EN(base)));
+		BTIF_INFO_FUNC("TX_RST:0x%x\n", BTIF_READ32(TX_DMA_RST(base)));
+		BTIF_INFO_FUNC("VFF_ADDR:0x%x\n",
+			       BTIF_READ32(TX_DMA_VFF_ADDR(base)));
+		BTIF_INFO_FUNC("VFF_LEN:0x%x\n",
+			       BTIF_READ32(TX_DMA_VFF_LEN(base)));
+		BTIF_INFO_FUNC("TX_THRE:0x%x\n",
+			       BTIF_READ32(TX_DMA_VFF_THRE(base)));
+		BTIF_INFO_FUNC("W_INT_BUF_SIZE:0x%x\n",
+			       BTIF_READ32(TX_DMA_W_INT_BUF_SIZE(base)));
+		BTIF_INFO_FUNC("LEFT_SIZE:0x%x\n",
+			       BTIF_READ32(TX_DMA_VFF_LEFT_SIZE(base)));
+		BTIF_INFO_FUNC("DBG_STATUS:0x%x\n",
+			       BTIF_READ32(TX_DMA_DEBUG_STATUS(base)));
+		i_ret = 0;
+	} else {
+		BTIF_WARN_FUNC("unknown flag:%d\n", flag);
+	}
+	BTIF_INFO_FUNC("tx dma %s\n", (enable & DMA_EN_BIT) &&
+		       (!(stop && DMA_STOP_BIT)) ? "enabled" : "stopped");
+	BTIF_INFO_FUNC("data in tx dma is %s sent by HW\n",
+		       ((wpt == rpt) &&
+			(int_buf == 0)) ? "completely" : "not completely");
+
+	return i_ret;
+}
+
+static int hal_rx_dma_dump_reg(P_MTK_DMA_INFO_STR p_dma_info,
+			       ENUM_BTIF_REG_ID flag)
+{
+	int i_ret = -1;
+	unsigned long base = p_dma_info->base;
+	unsigned int int_flag = 0;
+	unsigned int enable = 0;
+	unsigned int stop = 0;
+	unsigned int flush = 0;
+	unsigned int wpt = 0;
+	unsigned int rpt = 0;
+	unsigned int int_buf = 0;
+	unsigned int valid_size = 0;
+	/*unsigned long irq_flag = 0;*/
+#if defined(CONFIG_MTK_CLKMGR)
+	/*spin_lock_irqsave(&(g_clk_cg_spinlock), irq_flag);*/
+	if (clock_is_on(MTK_BTIF_APDMA_CLK_CG) == 0) {
+		/*spin_unlock_irqrestore(&(g_clk_cg_spinlock), irq_flag);*/
+		BTIF_ERR_FUNC("%s: clock is off, this should never happen!!!\n",
+			      __FILE__);
+		return i_ret;
+	}
+#endif
+	BTIF_INFO_FUNC("dump DMA status register\n");
+	_btif_dma_dump_dbg_reg();
+
+	int_flag = BTIF_READ32(RX_DMA_INT_FLAG(base));
+	enable = BTIF_READ32(RX_DMA_EN(base));
+	stop = BTIF_READ32(RX_DMA_STOP(base));
+	flush = BTIF_READ32(RX_DMA_FLUSH(base));
+	wpt = BTIF_READ32(RX_DMA_VFF_WPT(base));
+	rpt = BTIF_READ32(RX_DMA_VFF_RPT(base));
+	int_buf = BTIF_READ32(RX_DMA_INT_BUF_SIZE(base));
+	valid_size = BTIF_READ32(RX_DMA_VFF_VALID_SIZE(base));
+	/*spin_unlock_irqrestore(&(g_clk_cg_spinlock), irq_flag);*/
+
+	BTIF_INFO_FUNC("DMA's clock is on\n");
+	BTIF_INFO_FUNC("Rx DMA's base address: 0x%lx\n", base);
+
+	if (flag == REG_RX_DMA_ALL) {
+		BTIF_INFO_FUNC("RX_EN(:0x%x\n", enable);
+		BTIF_INFO_FUNC("RX_STOP:0x%x\n", stop);
+		BTIF_INFO_FUNC("RX_FLUSH:0x%x\n", flush);
+		BTIF_INFO_FUNC("INT_FLAG:0x%x\n", int_flag);
+		BTIF_INFO_FUNC("RX_WPT:0x%x\n", wpt);
+		BTIF_INFO_FUNC("RX_RPT:0x%x\n", rpt);
+		BTIF_INFO_FUNC("INT_BUF_SIZE:0x%x\n", int_buf);
+		BTIF_INFO_FUNC("VALID_SIZE:0x%x\n", valid_size);
+		BTIF_INFO_FUNC("INT_EN:0x%x\n",
+			       BTIF_READ32(RX_DMA_INT_EN(base)));
+		BTIF_INFO_FUNC("RX_RST:0x%x\n", BTIF_READ32(RX_DMA_RST(base)));
+		BTIF_INFO_FUNC("VFF_ADDR:0x%x\n",
+			       BTIF_READ32(RX_DMA_VFF_ADDR(base)));
+		BTIF_INFO_FUNC("VFF_LEN:0x%x\n",
+			       BTIF_READ32(RX_DMA_VFF_LEN(base)));
+		BTIF_INFO_FUNC("RX_THRE:0x%x\n",
+			       BTIF_READ32(RX_DMA_VFF_THRE(base)));
+		BTIF_INFO_FUNC("RX_FLOW_CTRL_THRE:0x%x\n",
+			       BTIF_READ32(RX_DMA_FLOW_CTRL_THRE(base)));
+		BTIF_INFO_FUNC("LEFT_SIZE:0x%x\n",
+			       BTIF_READ32(RX_DMA_VFF_LEFT_SIZE(base)));
+		BTIF_INFO_FUNC("DBG_STATUS:0x%x\n",
+			       BTIF_READ32(RX_DMA_DEBUG_STATUS(base)));
+		i_ret = 0;
+	} else {
+		BTIF_WARN_FUNC("unknown flag:%d\n", flag);
+	}
+	BTIF_INFO_FUNC("rx dma %s\n", (enable & DMA_EN_BIT) &&
+		       (!(stop && DMA_STOP_BIT)) ? "enabled" : "stopped");
+	BTIF_INFO_FUNC("data in rx dma is %s by driver\n",
+		       ((wpt == rpt) &&
+			(int_buf == 0)) ? "received" : "not received");
+
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_dma_dump_reg
+* DESCRIPTION
+*  dump BTIF module's information when needed
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* flag             [IN]        register id flag
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_dma_dump_reg(P_MTK_DMA_INFO_STR p_dma_info, ENUM_BTIF_REG_ID flag)
+{
+	unsigned int i_ret = -1;
+
+	if (p_dma_info->dir == DMA_DIR_TX)
+		i_ret = hal_tx_dma_dump_reg(p_dma_info, flag);
+	else if (p_dma_info->dir == DMA_DIR_RX)
+		i_ret = hal_rx_dma_dump_reg(p_dma_info, flag);
+	else
+		BTIF_WARN_FUNC("unknown dir:%d\n", p_dma_info->dir);
+
+	return i_ret;
+}
+
+static int _tx_dma_flush(P_MTK_DMA_INFO_STR p_dma_info)
+{
+	unsigned int i_ret = -1;
+	unsigned long base = p_dma_info->base;
+	unsigned int stop = BTIF_READ32(TX_DMA_STOP(base));
+
+/*in MTK DMA BTIF channel we cannot set STOP and FLUSH bit at the same time*/
+	if ((stop && DMA_STOP_BIT) != 0)
+		BTIF_ERR_FUNC("BTIF's DMA in stop state, omit flush operation\n");
+	else {
+		BTIF_DBG_FUNC("flush tx dma\n");
+		BTIF_SET_BIT(TX_DMA_FLUSH(base), DMA_FLUSH_BIT);
+		i_ret = 0;
+	}
+	return i_ret;
+}
+
+static int _is_tx_dma_in_flush(P_MTK_DMA_INFO_STR p_dma_info)
+{
+	bool b_ret = true;
+	unsigned long base = p_dma_info->base;
+
+/*see if flush operation is in process*/
+	b_ret = ((DMA_FLUSH_BIT & BTIF_READ32(TX_DMA_FLUSH(base))) != 0) ? true : false;
+
+	return b_ret;
+}
+
+int hal_dma_pm_ops(P_MTK_DMA_INFO_STR p_dma_info, MTK_BTIF_PM_OPID opid)
+{
+	int i_ret = -1;
+
+	BTIF_INFO_FUNC("op id: %d\n", opid);
+	switch (opid) {
+	case BTIF_PM_DPIDLE_EN:
+		i_ret = 0;
+		break;
+	case BTIF_PM_DPIDLE_DIS:
+		i_ret = 0;
+		break;
+	case BTIF_PM_SUSPEND:
+		i_ret = 0;
+		break;
+	case BTIF_PM_RESUME:
+		i_ret = 0;
+		break;
+	case BTIF_PM_RESTORE_NOIRQ:{
+			unsigned int flag = 0;
+			P_MTK_BTIF_IRQ_STR p_irq = p_dma_info->p_irq;
+
+#ifdef CONFIG_OF
+			flag = p_irq->irq_flags;
+#else
+			switch (p_irq->sens_type) {
+			case IRQ_SENS_EDGE:
+				if (p_irq->edge_type == IRQ_EDGE_FALL)
+					flag = IRQF_TRIGGER_FALLING;
+				else if (p_irq->edge_type == IRQ_EDGE_RAISE)
+					flag = IRQF_TRIGGER_RISING;
+				else if (p_irq->edge_type == IRQ_EDGE_BOTH)
+					flag = IRQF_TRIGGER_RISING |
+					    IRQF_TRIGGER_FALLING;
+				else
+					flag = IRQF_TRIGGER_FALLING;	/*make this as default type */
+				break;
+			case IRQ_SENS_LVL:
+				if (p_irq->lvl_type == IRQ_LVL_LOW)
+					flag = IRQF_TRIGGER_LOW;
+				else if (p_irq->lvl_type == IRQ_LVL_HIGH)
+					flag = IRQF_TRIGGER_HIGH;
+				else
+					flag = IRQF_TRIGGER_LOW;	/*make this as default type */
+				break;
+			default:
+				flag = IRQF_TRIGGER_LOW;	/*make this as default type */
+				break;
+			}
+#endif
+/* irq_set_irq_type(p_irq->irq_id, flag); */
+			i_ret = 0;
+		}
+		i_ret = 0;
+		break;
+	default:
+		i_ret = ERR_INVALID_PAR;
+		break;
+	}
+
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_dma_receive_data
+* DESCRIPTION
+*  receive data from btif module in DMA polling mode
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* p_buf     [IN/OUT] pointer to rx data buffer
+* max_len  [IN]        max length of rx buffer
+* RETURNS
+*  positive means data is available, 0 means no data available
+*****************************************************************************/
+#ifndef MTK_BTIF_MARK_UNUSED_API
+int hal_dma_receive_data(P_MTK_DMA_INFO_STR p_dma_info,
+			 unsigned char *p_buf, const unsigned int max_len)
+{
+	unsigned int i_ret = -1;
+
+	return i_ret;
+}
+#endif
+
+int _btif_dma_dump_dbg_reg(void)
+{
+#if 0
+	static MTK_BTIF_DMA_REG_DMP_DBG g_dma_dbg_regs[] = {
+		{0x10201180, 0x0},
+		{0x10201184, 0x0},
+		{0x10201188, 0x0},
+		{0x1020118C, 0x0},
+		{0x10201190, 0x0},
+		{0x1000320C, 0x0},
+		{0x10003210, 0x0},
+		{0x10003214, 0x0},
+	};
+
+	int i = 0;
+	char *addr1 = NULL;
+	char *addr2 = NULL;
+
+	int array_num = ARRAY_SIZE(g_dma_dbg_regs)
+
+	addr1 = ioremap(g_dma_dbg_regs[0].reg_addr, 0x20);
+	if (addr1) {
+		for (i = 0; i < 5; i++)
+			g_dma_dbg_regs[i].reg_val = *(volatile unsigned int*)(addr1 + i*4);
+		iounmap(addr1);
+	}
+
+	addr2 = ioremap(g_dma_dbg_regs[5].reg_addr, 0x10);
+	if (addr2) {
+		g_dma_dbg_regs[5].reg_val = *(volatile unsigned int*)(addr2);
+		g_dma_dbg_regs[6].reg_val = *(volatile unsigned int*)(addr2+4);
+		g_dma_dbg_regs[7].reg_val = *(volatile unsigned int*)(addr2+8);
+		iounmap(addr2);
+	}
+
+	for (i = 0; i < array_num; i++)
+		BTIF_INFO_FUNC("<reg, val>-<0x%lx, 0x%08x>\n", g_dma_dbg_regs[i].reg_addr, g_dma_dbg_regs[i].reg_val);
+#endif
+	return 0;
+}
+
+static void hal_btif_tx_dma_vff_set_for_4g(void)
+{
+	BTIF_DBG_FUNC("Set btif tx_vff_addr bit29\n");
+	BTIF_SET_BIT(TX_DMA_VFF_ADDR_H(mtk_btif_tx_dma.base), DMA_VFF_BIT29_OFFSET);
+	BTIF_DBG_FUNC("Dump value of bit29 0x%x:(0x%x)\n", TX_DMA_VFF_ADDR_H(mtk_btif_tx_dma.base),
+					BTIF_READ32(TX_DMA_VFF_ADDR_H(mtk_btif_tx_dma.base)));
+}
+static void hal_btif_rx_dma_vff_set_for_4g(void)
+{
+	BTIF_DBG_FUNC("Set btif rx_vff_addr bit29\n");
+	BTIF_SET_BIT(RX_DMA_VFF_ADDR_H(mtk_btif_rx_dma.base), DMA_VFF_BIT29_OFFSET);
+	BTIF_DBG_FUNC("Dump value of bit29 0x%x:(0x%x)\n", RX_DMA_VFF_ADDR_H(mtk_btif_rx_dma.base),
+					BTIF_READ32(RX_DMA_VFF_ADDR_H(mtk_btif_rx_dma.base)));
+}
+
diff --git a/drivers/misc/mediatek/btif/common/btif_plat.c b/drivers/misc/mediatek/btif/common/btif_plat.c
new file mode 100644
index 00000000..e098e90
--- /dev/null
+++ b/drivers/misc/mediatek/btif/common/btif_plat.c
@@ -0,0 +1,1396 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG "MTK-BTIF"
+
+#define NEW_TX_HANDLING_SUPPORT 1
+
+#include "btif_pub.h"
+#include "btif_priv.h"
+
+#define BTIF_USER_ID "btif_driver"
+
+static spinlock_t g_clk_cg_spinlock;	/*BTIF clock's spinlock */
+
+/*-----------------------------BTIF Module Clock and Power Control Defination------------------*/
+
+MTK_BTIF_IRQ_STR mtk_btif_irq = {
+	.name = "mtk btif irq",
+	.is_irq_sup = true,
+	.reg_flag = false,
+#ifdef CONFIG_OF
+	.irq_flags = IRQF_TRIGGER_NONE,
+#else
+	.irq_id = MT_BTIF_IRQ_ID,
+	.sens_type = IRQ_SENS_LVL,
+	.lvl_type = IRQ_LVL_LOW,
+#endif
+	.p_irq_handler = NULL,
+};
+
+/*
+ * will call clock manager's API export by WCP to control BTIF's clock,
+ * but we may need to access these registers in case of btif clock control logic is wrong in clock manager
+ */
+
+MTK_BTIF_INFO_STR mtk_btif = {
+#ifndef CONFIG_OF
+	.base = MTK_BTIF_REG_BASE,
+#endif
+	.p_irq = &mtk_btif_irq,
+	.tx_fifo_size = BTIF_TX_FIFO_SIZE,
+	.rx_fifo_size = BTIF_RX_FIFO_SIZE,
+	.tx_tri_lvl = BTIF_TX_FIFO_THRE,
+	.rx_tri_lvl = BTIF_RX_FIFO_THRE,
+	.rx_data_len = 0,
+	.p_tx_fifo = NULL,
+};
+#if !(NEW_TX_HANDLING_SUPPORT)
+static bool _btif_is_tx_allow(P_MTK_BTIF_INFO_STR p_btif);
+#endif
+
+static int btif_rx_irq_handler(P_MTK_BTIF_INFO_STR p_btif_info,
+			       unsigned char *p_buf,
+			       const unsigned int max_len);
+static int btif_tx_irq_handler(P_MTK_BTIF_INFO_STR p_btif);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_rx_ier_ctrl
+* DESCRIPTION
+*  BTIF Rx interrupt enable/disable
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* enable    [IN]        control if rx interrupt enabled or not
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+static int hal_btif_rx_ier_ctrl(P_MTK_BTIF_INFO_STR p_btif, bool en);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_tx_ier_ctrl
+* DESCRIPTION
+*  BTIF Tx interrupt enable/disable
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* enable    [IN]        control if tx interrupt enabled or not
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+static int hal_btif_tx_ier_ctrl(P_MTK_BTIF_INFO_STR p_btif, bool en);
+
+#ifndef MTK_BTIF_MARK_UNUSED_API
+static int btif_sleep_ctrl(P_MTK_BTIF_INFO_STR p_btif, bool en);
+
+/*****************************************************************************
+* FUNCTION
+*  _btif_receive_data
+* DESCRIPTION
+*  receive data from btif module in FIFO polling mode
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* p_buf     [IN/OUT] pointer to rx data buffer
+* max_len  [IN]        max length of rx buffer
+* RETURNS
+*  positive means data is available, 0 means no data available
+*****************************************************************************/
+static int _btif_receive_data(P_MTK_BTIF_INFO_STR p_btif,
+			      unsigned char *p_buf, const unsigned int max_len);
+static int btif_tx_thr_set(P_MTK_BTIF_INFO_STR p_btif, unsigned int thr_count);
+#endif
+
+static int btif_dump_array(char *string, char *p_buf, int len)
+{
+	unsigned int idx = 0;
+	unsigned char str[30];
+	unsigned char *p_str;
+
+	pr_debug("========dump %s start <length:%d>========\n", string, len);
+	p_str = &str[0];
+	for (idx = 0; idx < len; idx++, p_buf++) {
+		sprintf(p_str, "%02x ", *p_buf);
+		p_str += 3;
+		if (7 == (idx % 8)) {
+			*p_str++ = '\n';
+			*p_str = '\0';
+			pr_debug("%s", str);
+			p_str = &str[0];
+		}
+	}
+	if (len % 8) {
+		*p_str++ = '\n';
+		*p_str = '\0';
+		pr_debug("%s", str);
+	}
+	pr_debug("========dump %s end========\n", string);
+	return 0;
+}
+
+#if NEW_TX_HANDLING_SUPPORT
+static int _btif_tx_fifo_init(P_MTK_BTIF_INFO_STR p_btif_info)
+{
+	int i_ret = -1;
+
+	spin_lock_init(&(p_btif_info->tx_fifo_spinlock));
+
+	if (p_btif_info->p_tx_fifo == NULL) {
+		p_btif_info->p_tx_fifo = kzalloc(sizeof(struct kfifo),
+						 GFP_ATOMIC);
+		if (p_btif_info->p_tx_fifo == NULL) {
+			i_ret = -ENOMEM;
+			BTIF_ERR_FUNC("kzalloc for p_btif->p_tx_fifo failed\n");
+			goto ret;
+		}
+
+		i_ret = kfifo_alloc(p_btif_info->p_tx_fifo,
+				    BTIF_HAL_TX_FIFO_SIZE, GFP_ATOMIC);
+		if (i_ret != 0) {
+			BTIF_ERR_FUNC("kfifo_alloc failed, errno(%d)\n", i_ret);
+			i_ret = -ENOMEM;
+			goto ret;
+		}
+		i_ret = 0;
+	} else {
+		BTIF_WARN_FUNC
+		    ("p_btif_info->p_tx_fifo is already init p_btif_info->p_tx_fifo(0x%p)\n",
+		     p_btif_info->p_tx_fifo);
+		i_ret = 0;
+	}
+ret:
+	return i_ret;
+}
+
+static int _get_btif_tx_fifo_room(P_MTK_BTIF_INFO_STR p_btif_info)
+{
+	int i_ret = 0;
+	unsigned long flag = 0;
+
+	spin_lock_irqsave(&(p_btif_info->tx_fifo_spinlock), flag);
+	if (p_btif_info->p_tx_fifo == NULL)
+		i_ret = 0;
+	else
+		i_ret = kfifo_avail(p_btif_info->p_tx_fifo);
+	spin_unlock_irqrestore(&(p_btif_info->tx_fifo_spinlock), flag);
+	BTIF_DBG_FUNC("tx kfifo:0x%p, available room:%d\n", p_btif_info->p_tx_fifo, i_ret);
+	return i_ret;
+}
+
+static int _btif_tx_fifo_reset(P_MTK_BTIF_INFO_STR p_btif_info)
+{
+	int i_ret = 0;
+
+	if (p_btif_info->p_tx_fifo != NULL)
+		kfifo_reset(p_btif_info->p_tx_fifo);
+	return i_ret;
+}
+
+#endif
+
+#ifdef CONFIG_OF
+static void _btif_set_default_setting(void)
+{
+	struct device_node *node = NULL;
+	unsigned int irq_info[3] = {0, 0, 0};
+	unsigned int phy_base;
+
+	node = of_find_compatible_node(NULL, NULL, "mediatek,mtk-btif");
+	if (node) {
+		mtk_btif.p_irq->irq_id = irq_of_parse_and_map(node, 0);
+		/*fixme, be compitable arch 64bits*/
+		mtk_btif.base = (unsigned long)of_iomap(node, 0);
+		BTIF_INFO_FUNC("get btif irq(%d),register base(0x%lx)\n",
+			mtk_btif.p_irq->irq_id, mtk_btif.base);
+	} else {
+		BTIF_ERR_FUNC("get btif device node fail\n");
+	}
+
+	/* get the interrupt line behaviour */
+	if (of_property_read_u32_array(node, "interrupts", irq_info, ARRAY_SIZE(irq_info))) {
+		BTIF_ERR_FUNC("get interrupt flag from DTS fail\n");
+	} else {
+		mtk_btif.p_irq->irq_flags = irq_info[2];
+		BTIF_INFO_FUNC("get interrupt flag(0x%x)\n", mtk_btif.p_irq->irq_flags);
+	}
+
+	if (of_property_read_u32_index(node, "reg", 1, &phy_base))
+		BTIF_ERR_FUNC("get register phy base from DTS fail\n");
+	else
+		BTIF_INFO_FUNC("get register phy base(0x%x)\n", (unsigned int)phy_base);
+}
+#endif
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_info_get
+* DESCRIPTION
+*  get btif's information included base address , irq related information
+* PARAMETERS
+* RETURNS
+*  BTIF's information
+*****************************************************************************/
+P_MTK_BTIF_INFO_STR hal_btif_info_get(void)
+{
+#if NEW_TX_HANDLING_SUPPORT
+	int i_ret = 0;
+/*tx fifo and fifo lock init*/
+	i_ret = _btif_tx_fifo_init(&mtk_btif);
+	if (i_ret == 0)
+		BTIF_INFO_FUNC("_btif_tx_fifo_init succeed\n");
+	else
+		BTIF_ERR_FUNC("_btif_tx_fifo_init failed, i_ret:%d\n", i_ret);
+
+#endif
+
+#ifdef CONFIG_OF
+	_btif_set_default_setting();
+#endif
+
+	spin_lock_init(&g_clk_cg_spinlock);
+
+	return &mtk_btif;
+}
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_clk_get_and_prepare
+* DESCRIPTION
+*  get clock from device tree and prepare for enable/disable control
+* PARAMETERS
+* pdev  device pointer
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+#if !defined(CONFIG_MTK_CLKMGR)
+int hal_btif_clk_get_and_prepare(struct platform_device *pdev)
+{
+		int i_ret = -1;
+
+		clk_btif = devm_clk_get(&pdev->dev, "main");
+		if (IS_ERR(clk_btif)) {
+			BTIF_ERR_FUNC("[CCF]cannot get clk_btif clock.\n");
+			return PTR_ERR(clk_btif);
+		}
+		BTIF_ERR_FUNC("[CCF]clk_btif=%p\n", clk_btif);
+		clk_btif_apdma = devm_clk_get(&pdev->dev, "apdmac");
+		if (IS_ERR(clk_btif_apdma)) {
+			BTIF_ERR_FUNC("[CCF]cannot get clk_btif_apdma clock.\n");
+			return PTR_ERR(clk_btif_apdma);
+		}
+		BTIF_ERR_FUNC("[CCF]clk_btif_apdma=%p\n", clk_btif_apdma);
+
+		i_ret = clk_prepare(clk_btif);
+		if (i_ret != 0) {
+			BTIF_ERR_FUNC("clk_prepare clk_btif failed! ret:%d\n", i_ret);
+			return i_ret;
+		}
+
+		i_ret = clk_prepare(clk_btif_apdma);
+		if (i_ret != 0) {
+			BTIF_ERR_FUNC("clk_prepare clk_btif_apdma failed! ret:%d\n", i_ret);
+			return i_ret;
+		}
+		return i_ret;
+}
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_clk_unprepare
+* DESCRIPTION
+*  unprepare btif clock and apdma clock
+* PARAMETERS
+* none
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_clk_unprepare(void)
+{
+	clk_unprepare(clk_btif);
+	clk_unprepare(clk_btif_apdma);
+	return 0;
+}
+#endif
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_clk_ctrl
+* DESCRIPTION
+*  control clock output enable/disable of BTIF module
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_clk_ctrl(P_MTK_BTIF_INFO_STR p_btif, ENUM_CLOCK_CTRL flag)
+{
+/*In MTK BTIF, there's only one global CG on AP_DMA, no sub channel's CG bit*/
+/*according to Artis's comment, clock of DMA and BTIF is default off, so we assume it to be off by default*/
+	int i_ret = 0;
+	unsigned long irq_flag = 0;
+
+#if MTK_BTIF_ENABLE_CLK_REF_COUNTER
+	static atomic_t s_clk_ref = ATOMIC_INIT(0);
+#else
+	static ENUM_CLOCK_CTRL status = CLK_OUT_DISABLE;
+#endif
+
+	spin_lock_irqsave(&(g_clk_cg_spinlock), irq_flag);
+
+#if MTK_BTIF_ENABLE_CLK_CTL
+
+#if MTK_BTIF_ENABLE_CLK_REF_COUNTER
+
+	if (flag == CLK_OUT_ENABLE) {
+		if (atomic_inc_return(&s_clk_ref) == 1) {
+#if defined(CONFIG_MTK_CLKMGR)
+			i_ret = enable_clock(MTK_BTIF_CG_BIT, BTIF_USER_ID);
+#else
+			BTIF_DBG_FUNC("[CCF]enable clk_btif\n");
+			i_ret = clk_enable(clk_btif);
+#endif /* defined(CONFIG_MTK_CLKMGR) */
+			if (i_ret) {
+				BTIF_WARN_FUNC
+					("enable_clock for MTK_BTIF_CG_BIT failed, ret:%d",
+					 i_ret);
+			}
+		}
+	} else if (flag == CLK_OUT_DISABLE) {
+		if (atomic_dec_return(&s_clk_ref) == 0) {
+#if defined(CONFIG_MTK_CLKMGR)
+			i_ret = disable_clock(MTK_BTIF_CG_BIT, BTIF_USER_ID);
+			if (i_ret) {
+				BTIF_WARN_FUNC
+					("disable_clock for MTK_BTIF_CG_BIT failed, ret:%d",
+					 i_ret);
+			}
+#else
+			BTIF_DBG_FUNC("[CCF] clk_disable(clk_btif) calling\n");
+			clk_disable(clk_btif);
+#endif /* defined(CONFIG_MTK_CLKMGR) */
+		}
+	} else {
+		i_ret = ERR_INVALID_PAR;
+		BTIF_ERR_FUNC("invalid	clock ctrl flag (%d)\n", flag);
+	}
+
+#else
+
+	if (status == flag) {
+		i_ret = 0;
+		BTIF_DBG_FUNC("btif clock already %s\n",
+			      CLK_OUT_ENABLE ==
+			      status ? "enabled" : "disabled");
+	} else {
+		if (flag == CLK_OUT_ENABLE) {
+#if defined(CONFIG_MTK_CLKMGR)
+			i_ret = enable_clock(MTK_BTIF_CG_BIT, BTIF_USER_ID);
+#else
+			BTIF_DBG_FUNC("[CCF]enable clk_btif\n");
+			i_ret = clk_enable(clk_btif);
+#endif /* defined(CONFIG_MTK_CLKMGR) */
+			status = (i_ret == 0) ? flag : status;
+			if (i_ret) {
+				BTIF_WARN_FUNC
+					("enable_clock for MTK_BTIF_CG_BIT failed, ret:%d",
+					 i_ret);
+			}
+		} else if (flag == CLK_OUT_DISABLE) {
+#if defined(CONFIG_MTK_CLKMGR)
+			i_ret = disable_clock(MTK_BTIF_CG_BIT, BTIF_USER_ID);
+			status = (i_ret == 0) ? flag : status;
+			if (i_ret) {
+				BTIF_WARN_FUNC
+					("disable_clock for MTK_BTIF_CG_BIT failed, ret:%d",
+					 i_ret);
+			}
+#else
+			BTIF_DBG_FUNC("[CCF] clk_disable(clk_btif) calling\n");
+			clk_disable(clk_btif);
+#endif /* defined(CONFIG_MTK_CLKMGR) */
+		} else {
+			i_ret = ERR_INVALID_PAR;
+			BTIF_ERR_FUNC("invalid	clock ctrl flag (%d)\n", flag);
+		}
+	}
+#endif
+
+#else
+
+#if MTK_BTIF_ENABLE_CLK_REF_COUNTER
+
+#else
+
+	status = flag;
+#endif
+
+	i_ret = 0;
+#endif
+
+	spin_unlock_irqrestore(&(g_clk_cg_spinlock), irq_flag);
+
+#if MTK_BTIF_ENABLE_CLK_REF_COUNTER
+	if (i_ret == 0) {
+		BTIF_DBG_FUNC("btif clock %s\n", flag == CLK_OUT_ENABLE ? "enabled" : "disabled");
+	} else {
+		BTIF_ERR_FUNC("%s btif clock failed, ret(%d)\n",
+				flag == CLK_OUT_ENABLE ? "enable" : "disable", i_ret);
+	}
+#else
+
+	if (i_ret == 0) {
+		BTIF_DBG_FUNC("btif clock %s\n", flag == CLK_OUT_ENABLE ? "enabled" : "disabled");
+	} else {
+		BTIF_ERR_FUNC("%s btif clock failed, ret(%d)\n",
+			      flag == CLK_OUT_ENABLE ? "enable" : "disable", i_ret);
+	}
+#endif
+#if defined(CONFIG_MTK_CLKMGR)
+	BTIF_DBG_FUNC("BTIF's clock is %s\n", (clock_is_on(MTK_BTIF_CG_BIT) == 0) ? "off" : "on");
+#endif
+	return i_ret;
+}
+
+static int btif_new_handshake_ctrl(P_MTK_BTIF_INFO_STR p_btif, bool enable)
+{
+	unsigned long base = p_btif->base;
+
+	if (enable == true)
+		BTIF_SET_BIT(BTIF_HANDSHAKE(base), BTIF_HANDSHAKE_EN_HANDSHAKE);
+	else
+		BTIF_CLR_BIT(BTIF_HANDSHAKE(base), BTIF_HANDSHAKE_EN_HANDSHAKE);
+	return true;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_hw_init
+* DESCRIPTION
+*  BTIF hardware init
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_hw_init(P_MTK_BTIF_INFO_STR p_btif)
+{
+/*Chaozhong: To be implement*/
+	int i_ret = -1;
+	unsigned long base = p_btif->base;
+
+#if NEW_TX_HANDLING_SUPPORT
+	_btif_tx_fifo_reset(p_btif);
+#endif
+
+/*set to normal mode*/
+	btif_reg_sync_writel(BTIF_FAKELCR_NORMAL_MODE, BTIF_FAKELCR(base));
+/*set to newhandshake mode*/
+	btif_new_handshake_ctrl(p_btif, true);
+/*No need to access: enable sleep mode*/
+/*No need to access: set Rx timeout count*/
+/*set Tx threshold*/
+/*set Rx threshold*/
+/*disable internal loopback test*/
+
+/*set Rx FIFO clear bit to 1*/
+	BTIF_SET_BIT(BTIF_FIFOCTRL(base), BTIF_FIFOCTRL_CLR_RX);
+/*clear Rx FIFO clear bit to 0*/
+	BTIF_CLR_BIT(BTIF_FIFOCTRL(base), BTIF_FIFOCTRL_CLR_RX);
+/*set Tx FIFO clear bit to 1*/
+	BTIF_SET_BIT(BTIF_FIFOCTRL(base), BTIF_FIFOCTRL_CLR_TX);
+/*clear Tx FIFO clear bit to 0*/
+	BTIF_CLR_BIT(BTIF_FIFOCTRL(base), BTIF_FIFOCTRL_CLR_TX);
+
+	btif_reg_sync_writel(BTIF_TRI_LVL_TX(p_btif->tx_tri_lvl)
+			     | BTIF_TRI_LVL_RX(p_btif->rx_tri_lvl)
+			     | BTIF_TRI_LOOP_DIS, BTIF_TRI_LVL(base));
+	hal_btif_loopback_ctrl(p_btif, false);
+/*disable BTIF Tx DMA mode*/
+	hal_btif_tx_mode_ctrl(p_btif, false);
+/*disable BTIF Rx DMA mode*/
+	hal_btif_rx_mode_ctrl(p_btif, false);
+/*auto reset*/
+	BTIF_SET_BIT(BTIF_DMA_EN(base), BTIF_DMA_EN_AUTORST_EN);
+/*disable Tx IER*/
+	hal_btif_tx_ier_ctrl(p_btif, false);
+/*enable Rx IER by default*/
+	hal_btif_rx_ier_ctrl(p_btif, true);
+
+	i_ret = 0;
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_rx_ier_ctrl
+* DESCRIPTION
+*  BTIF Rx interrupt enable/disable
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* enable    [IN]        control if rx interrupt enabled or not
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_rx_ier_ctrl(P_MTK_BTIF_INFO_STR p_btif, bool en)
+{
+	int i_ret = -1;
+	unsigned long base = p_btif->base;
+
+	if (en == false)
+		BTIF_CLR_BIT(BTIF_IER(base), BTIF_IER_RXFEN);
+	else
+		BTIF_SET_BIT(BTIF_IER(base), BTIF_IER_RXFEN);
+
+/*TODO:do we need to read back ? Answer: no*/
+	i_ret = 0;
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_tx_ier_ctrl
+* DESCRIPTION
+*  BTIF Tx interrupt enable/disable
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* enable    [IN]        control if tx interrupt enabled or not
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_tx_ier_ctrl(P_MTK_BTIF_INFO_STR p_btif, bool en)
+{
+	int i_ret = -1;
+	unsigned long base = p_btif->base;
+
+	if (en == false)
+		BTIF_CLR_BIT(BTIF_IER(base), BTIF_IER_TXEEN);
+	else
+		BTIF_SET_BIT(BTIF_IER(base), BTIF_IER_TXEEN);
+
+/*TODO:do we need to read back ? Answer: no*/
+	i_ret = 0;
+
+	return i_ret;
+}
+
+#ifndef MTK_BTIF_MARK_UNUSED_API
+
+/*****************************************************************************
+* FUNCTION
+*  _btif_receive_data
+* DESCRIPTION
+*  receive data from btif module in FIFO polling mode
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* p_buf     [IN/OUT] pointer to rx data buffer
+* max_len  [IN]        max length of rx buffer
+* RETURNS
+*  positive means data is available, 0 means no data available
+*****************************************************************************/
+int _btif_receive_data(P_MTK_BTIF_INFO_STR p_btif,
+		       unsigned char *p_buf, const unsigned int max_len)
+{
+/*Chaozhong: To be implement*/
+	int i_ret = -1;
+
+/*check parameter valid or not*/
+	if ((p_buf == NULL) || (max_len == 0)) {
+		i_ret = ERR_INVALID_PAR;
+		return i_ret;
+	}
+	i_ret = btif_rx_irq_handler(p_btif, p_buf, max_len);
+
+	return i_ret;
+}
+
+int btif_sleep_ctrl(P_MTK_BTIF_INFO_STR p_btif, bool en)
+{
+	int i_ret = -1;
+	unsigned long base = p_btif->base;
+
+	if (en == false)
+		BTIF_CLR_BIT(BTIF_SLEEP_EN(base), BTIF_SLEEP_EN_BIT);
+	else
+		BTIF_SET_BIT(BTIF_SLEEP_EN(base), BTIF_SLEEP_EN_BIT);
+
+/*TODO:do we need to read back ? Answer: no*/
+/*TODO:do we need to dsb?*/
+	i_ret = 0;
+	return i_ret;
+}
+
+static int btif_tx_thr_set(P_MTK_BTIF_INFO_STR p_btif, unsigned int thr_count)
+{
+	int i_ret = -1;
+	unsigned long base = p_btif->base;
+	unsigned int value = 0;
+
+/*read BTIF_TRI_LVL*/
+	value = BTIF_READ32(BTIF_TRI_LVL(base));
+/*clear Tx threshold bits*/
+	value &= (~BTIF_TRI_LVL_TX_MASK);
+/*set tx threshold bits*/
+	value |= BTIF_TRI_LVL_TX(BTIF_TX_FIFO_THRE);
+/*write back to BTIF_TRI_LVL*/
+	btif_reg_sync_writel(value, BTIF_TRI_LVL(base));
+
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  btif_rx_fifo_reset
+* DESCRIPTION
+*  reset BTIF's rx fifo
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* ec         [IN]        control if loopback mode is enabled or not
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+static int btif_rx_fifo_reset(P_MTK_BTIF_INFO_STR p_btif)
+{
+/*Chaozhong: To be implement*/
+	int i_ret = -1;
+	unsigned long base = p_btif->base;
+
+/*set Rx FIFO clear bit to 1*/
+	BTIF_SET_BIT(BTIF_FIFOCTRL(base), BTIF_FIFOCTRL_CLR_RX);
+
+/*clear Rx FIFO clear bit to 0*/
+	BTIF_CLR_BIT(BTIF_FIFOCTRL(base), BTIF_FIFOCTRL_CLR_RX);
+
+/*TODO:do we need to read back ? Answer: no*/
+/*TODO:do we need to dsb?*/
+	i_ret = 0;
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  btif_tx_fifo_reset
+* DESCRIPTION
+*  reset BTIF's tx fifo
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+static int btif_tx_fifo_reset(P_MTK_BTIF_INFO_STR p_btif)
+{
+	int i_ret = -1;
+	unsigned long base = p_btif->base;
+
+/*set Tx FIFO clear bit to 1*/
+	BTIF_SET_BIT(BTIF_FIFOCTRL(base), BTIF_FIFOCTRL_CLR_TX);
+
+/*clear Tx FIFO clear bit to 0*/
+	BTIF_CLR_BIT(BTIF_FIFOCTRL(base), BTIF_FIFOCTRL_CLR_TX);
+
+/*TODO:do we need to read back ? Answer: no*/
+/*TODO:do we need to dsb?*/
+	i_ret = 0;
+	return i_ret;
+}
+
+#endif
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_loopback_ctrl
+* DESCRIPTION
+*  BTIF Tx/Rx loopback mode set, this operation can only be done after set BTIF to normal mode
+* PARAMETERS
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_loopback_ctrl(P_MTK_BTIF_INFO_STR p_btif, bool en)
+{
+	int i_ret = -1;
+	unsigned long base = p_btif->base;
+
+	if (en == false)
+		BTIF_CLR_BIT(BTIF_TRI_LVL(base), BTIF_TRI_LOOP_EN);
+	else
+		BTIF_SET_BIT(BTIF_TRI_LVL(base), BTIF_TRI_LOOP_EN);
+
+/*TODO:do we need to read back ? Answer: no*/
+/*TODO:do we need to dsb?*/
+	i_ret = 0;
+	return i_ret;
+}
+
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_rx_handler
+* DESCRIPTION
+*  lower level interrupt handler
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* p_buf     [IN/OUT] pointer to rx data buffer
+* max_len  [IN]        max length of rx buffer
+* RETURNS
+*  0 means success; negative means fail; positive means rx data length
+*****************************************************************************/
+int hal_btif_irq_handler(P_MTK_BTIF_INFO_STR p_btif,
+			 unsigned char *p_buf, const unsigned int max_len)
+{
+/*Chaozhong: To be implement*/
+	int i_ret = -1;
+	unsigned int iir = 0;
+	unsigned int rx_len = 0;
+	unsigned long base = p_btif->base;
+
+#if 0
+/*check parameter valid or not*/
+	if ((p_buf == NULL) || (max_len == 0)) {
+		i_ret = ERR_INVALID_PAR;
+		return i_ret;
+	}
+#endif
+	unsigned long irq_flag = 0;
+
+	spin_lock_irqsave(&(g_clk_cg_spinlock), irq_flag);
+
+#if defined(CONFIG_MTK_CLKMGR)
+	if (clock_is_on(MTK_BTIF_CG_BIT) == 0) {
+		spin_unlock_irqrestore(&(g_clk_cg_spinlock), irq_flag);
+		BTIF_ERR_FUNC("%s: clock is off before irq handle done!!!\n",
+			      __FILE__);
+		return i_ret;
+	}
+#endif
+/*read interrupt identifier register*/
+	iir = BTIF_READ32(BTIF_IIR(base));
+
+/*is rx interrupt exist?*/
+#if 0
+	while ((iir & BTIF_IIR_RX) && (rx_len < max_len)) {
+		rx_len +=
+		    btif_rx_irq_handler(p_btif, (p_buf + rx_len),
+					(max_len - rx_len));
+
+/*update IIR*/
+		iir = BTIF_READ32(BTIF_IIR(base));
+	}
+#endif
+
+	while (iir & (BTIF_IIR_RX | BTIF_IIR_RX_TIMEOUT)) {
+		rx_len += btif_rx_irq_handler(p_btif, p_buf, max_len);
+
+/*update IIR*/
+		iir = BTIF_READ32(BTIF_IIR(base));
+	}
+
+/*is tx interrupt exist?*/
+	if (iir & BTIF_IIR_TX_EMPTY)
+		i_ret = btif_tx_irq_handler(p_btif);
+	spin_unlock_irqrestore(&(g_clk_cg_spinlock), irq_flag);
+
+	i_ret = rx_len != 0 ? rx_len : i_ret;
+	return i_ret;
+}
+
+int hal_btif_rx_cb_reg(P_MTK_BTIF_INFO_STR p_btif_info, btif_rx_buf_write rx_cb)
+{
+	if (p_btif_info->rx_cb != NULL)
+		BTIF_DBG_FUNC("rx_cb already registered, replace (0x%p) with (0x%p)\n",
+		     p_btif_info->rx_cb, rx_cb);
+	p_btif_info->rx_cb = rx_cb;
+
+	return 0;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  btif_rx_irq_handler
+* DESCRIPTION
+*  lower level rx interrupt handler
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* RETURNS
+*  positive means length of rx data , negative means fail
+*****************************************************************************/
+static int btif_rx_irq_handler(P_MTK_BTIF_INFO_STR p_btif_info,
+			       unsigned char *p_buf, const unsigned int max_len)
+{
+/*Chaozhong: To be implement*/
+	int i_ret = 0;
+	unsigned int iir = 0;
+	unsigned int rx_len = 0;
+	unsigned long base = p_btif_info->base;
+	unsigned char rx_buf[256];
+	unsigned int local_buf_len = 256;
+	btif_rx_buf_write rx_cb = p_btif_info->rx_cb;
+	unsigned int total_len = 0;
+
+/*read interrupt identifier register*/
+	iir = BTIF_READ32(BTIF_IIR(base));
+	while ((iir & (BTIF_IIR_RX | BTIF_IIR_RX_TIMEOUT)) &&
+	       (rx_len < local_buf_len)) {
+		rx_buf[rx_len] = BTIF_READ8(base);
+		rx_len++;
+/*need to consult CC Hwang for advice */
+/*
+ * whether we need to do memory barrier here
+ * Ans: no
+ */
+/*
+ * whether we need to d memory barrier when call BTIF_SET_BIT or BTIF_CLR_BIT
+ * Ans: no
+ */
+		if (rx_len == local_buf_len) {
+			if (rx_cb)
+				(*rx_cb) (p_btif_info, rx_buf, rx_len);
+			rx_len = 0;
+			total_len += rx_len;
+		}
+		iir = BTIF_READ32(BTIF_IIR(base));
+	}
+	total_len += rx_len;
+	if (rx_len && rx_cb)
+		(*rx_cb) (p_btif_info, rx_buf, rx_len);
+
+/*
+ * make sure all data write back to memory, mb or dsb?
+ * need to consult CC Hwang for advice
+ * Ans: no need here
+ */
+	i_ret = total_len;
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  btif_tx_irq_handler
+* DESCRIPTION
+*  lower level tx interrupt handler
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* p_buf     [IN/OUT] pointer to rx data buffer
+* max_len  [IN]        max length of rx buffer
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+static int btif_tx_irq_handler(P_MTK_BTIF_INFO_STR p_btif)
+{
+	int i_ret = -1;
+
+#if NEW_TX_HANDLING_SUPPORT
+	int how_many = 0;
+	unsigned int lsr;
+	unsigned int ava_len = 0;
+	unsigned long base = p_btif->base;
+	char local_buf[BTIF_TX_FIFO_SIZE];
+	char *p_data = local_buf;
+	unsigned long flag = 0;
+
+	struct kfifo *p_tx_fifo = p_btif->p_tx_fifo;
+
+/*read LSR and check THER or TEMT, either one is 1 means can accept tx data*/
+	lsr = BTIF_READ32(BTIF_LSR(base));
+
+	if (lsr & BTIF_LSR_TEMT_BIT)
+		/*Tx Holding Register if empty, which means we can write tx FIFO count to BTIF*/
+		ava_len = BTIF_TX_FIFO_SIZE;
+	else if (lsr & BTIF_LSR_THRE_BIT)
+		/*Tx Holding Register if empty, which means we can write (Tx FIFO count - Tx threshold)to BTIF*/
+		ava_len = BTIF_TX_FIFO_SIZE - BTIF_TX_FIFO_THRE;
+	else {
+		/*this means data size in tx FIFO is more than Tx threshold, we will not write data to THR*/
+		ava_len = 0;
+		goto ret;
+	}
+	spin_lock_irqsave(&(p_btif->tx_fifo_spinlock), flag);
+	how_many = kfifo_out(p_tx_fifo, local_buf, ava_len);
+	spin_unlock_irqrestore(&(p_btif->tx_fifo_spinlock), flag);
+	BTIF_DBG_FUNC("BTIF tx size %d done, left:%d\n", how_many,
+		      kfifo_avail(p_tx_fifo));
+	while (how_many--)
+		btif_reg_sync_writeb(*(p_data++), BTIF_THR(base));
+
+	spin_lock_irqsave(&(p_btif->tx_fifo_spinlock), flag);
+/*clear Tx enable flag if necessary*/
+	if (kfifo_is_empty(p_tx_fifo)) {
+		hal_btif_tx_ier_ctrl(p_btif, false);
+		BTIF_DBG_FUNC("BTIF tx FIFO is empty\n");
+	}
+	spin_unlock_irqrestore(&(p_btif->tx_fifo_spinlock), flag);
+ret:
+#else
+/*clear Tx enable flag*/
+	hal_btif_tx_ier_ctrl(p_btif, false);
+#endif
+	i_ret = 0;
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_tx_mode_ctrl
+* DESCRIPTION
+*  set BTIF tx to corresponding mode (PIO/DMA)
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* mode     [IN]        rx mode <PIO/DMA>
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_tx_mode_ctrl(P_MTK_BTIF_INFO_STR p_btif, ENUM_BTIF_MODE mode)
+{
+	int i_ret = -1;
+	unsigned long base = p_btif->base;
+
+	if (mode == BTIF_MODE_DMA)
+		/*set to DMA mode*/
+		BTIF_SET_BIT(BTIF_DMA_EN(base), BTIF_DMA_EN_TX);
+	else
+		/*set to PIO mode*/
+		BTIF_CLR_BIT(BTIF_DMA_EN(base), BTIF_DMA_EN_TX);
+
+	i_ret = 0;
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_rx_mode_ctrl
+* DESCRIPTION
+*  set BTIF rx to corresponding mode (PIO/DMA)
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* mode     [IN]        rx mode <PIO/DMA>
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_rx_mode_ctrl(P_MTK_BTIF_INFO_STR p_btif, ENUM_BTIF_MODE mode)
+{
+	int i_ret = -1;
+	unsigned long base = p_btif->base;
+
+	if (mode == BTIF_MODE_DMA)
+		/*set to DMA mode*/
+		BTIF_SET_BIT(BTIF_DMA_EN(base), BTIF_DMA_EN_RX);
+	else
+		/*set to PIO mode*/
+		BTIF_CLR_BIT(BTIF_DMA_EN(base), BTIF_DMA_EN_RX);
+
+	i_ret = 0;
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_send_data
+* DESCRIPTION
+*  send data through btif in FIFO mode
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* p_buf     [IN]        pointer to rx data buffer
+* max_len  [IN]        tx buffer length
+* RETURNS
+*   positive means number of data sent; 0 means no data put to FIFO; negative means error happens
+*****************************************************************************/
+int hal_btif_send_data(P_MTK_BTIF_INFO_STR p_btif,
+		       const unsigned char *p_buf, const unsigned int buf_len)
+{
+/*Chaozhong: To be implement*/
+	int i_ret = -1;
+
+	unsigned int ava_len = 0;
+	unsigned int sent_len = 0;
+
+#if !(NEW_TX_HANDLING_SUPPORT)
+	unsigned long base = p_btif->base;
+	unsigned int lsr = 0;
+	unsigned int left_len = 0;
+	unsigned char *p_data = (unsigned char *)p_buf;
+#endif
+
+/*check parameter valid or not*/
+	if ((p_buf == NULL) || (buf_len == 0)) {
+		i_ret = ERR_INVALID_PAR;
+		return i_ret;
+	}
+#if NEW_TX_HANDLING_SUPPORT
+	ava_len = _get_btif_tx_fifo_room(p_btif);
+	sent_len = buf_len <= ava_len ? buf_len : ava_len;
+	if (sent_len > 0) {
+		int enqueue_len = 0;
+		unsigned long flag = 0;
+
+		spin_lock_irqsave(&(p_btif->tx_fifo_spinlock), flag);
+		enqueue_len = kfifo_in(p_btif->p_tx_fifo,
+				       (unsigned char *)p_buf, sent_len);
+		if (sent_len != enqueue_len) {
+			BTIF_ERR_FUNC("target tx len:%d, len sent:%d\n",
+				      sent_len, enqueue_len);
+		}
+		i_ret = enqueue_len;
+		mb();
+/*enable BTIF Tx IRQ*/
+		hal_btif_tx_ier_ctrl(p_btif, true);
+		spin_unlock_irqrestore(&(p_btif->tx_fifo_spinlock), flag);
+		BTIF_DBG_FUNC("enqueue len:%d\n", enqueue_len);
+	} else {
+		i_ret = 0;
+	}
+#else
+	while ((_btif_is_tx_allow(p_btif)) && (sent_len < buf_len)) {
+		/*read LSR and check THER or TEMT, either one is 1 means can accept tx data*/
+		lsr = BTIF_READ32(BTIF_LSR(base));
+
+		if (lsr & BTIF_LSR_TEMT_BIT)
+			/*Tx Holding Register if empty, which means we can write tx FIFO count to BTIF*/
+			ava_len = BTIF_TX_FIFO_SIZE;
+		else if (lsr & BTIF_LSR_THRE_BIT)
+			/*Tx Holding Register if empty, which means we can write (Tx FIFO count - Tx threshold)to BTIF*/
+			ava_len = BTIF_TX_FIFO_SIZE - BTIF_TX_FIFO_THRE;
+		else {
+			/*this means data size in tx FIFO is more than Tx threshold, we will not write data to THR*/
+			ava_len = 0;
+			break;
+		}
+
+		left_len = buf_len - sent_len;
+/*ava_len will be real length will write to BTIF THR*/
+		ava_len = ava_len > left_len ? left_len : ava_len;
+/*update sent length valud after this operation*/
+		sent_len += ava_len;
+/*
+ * whether we need memory barrier here?
+ * Ans: No, no memory ordering issue exist,
+ * CPU will make sure logically right
+ */
+		while (ava_len--)
+			btif_reg_sync_writeb(*(p_data++), BTIF_THR(base));
+
+	}
+/* while ((hal_btif_is_tx_allow()) && (sent_len < buf_len)); */
+
+	i_ret = sent_len;
+
+/*enable BTIF Tx IRQ*/
+	hal_btif_tx_ier_ctrl(p_btif, true);
+#endif
+	return i_ret;
+}
+
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_raise_wak_sig
+* DESCRIPTION
+*  raise wakeup signal to counterpart
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_raise_wak_sig(P_MTK_BTIF_INFO_STR p_btif)
+{
+	int i_ret = -1;
+	unsigned long base = p_btif->base;
+#if defined(CONFIG_MTK_CLKMGR)
+	if (clock_is_on(MTK_BTIF_CG_BIT) == 0) {
+		BTIF_ERR_FUNC("%s: clock is off before send wakeup signal!!!\n",
+			      __FILE__);
+		return i_ret;
+	}
+#endif
+/*write 0  to BTIF_WAK to pull ap_wakeup_consyss low */
+	BTIF_CLR_BIT(BTIF_WAK(base), BTIF_WAK_BIT);
+
+/*wait for a period for longer than 1/32k period, here we use 40us*/
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	usleep_range(128, 160);
+/*
+ * according to linux/documentation/timers/timers-how-to, we choose usleep_range
+ * SLEEPING FOR ~USECS OR SMALL MSECS ( 10us - 20ms):      * Use usleep_range
+ */
+/*write 1 to pull ap_wakeup_consyss high*/
+	BTIF_SET_BIT(BTIF_WAK(base), BTIF_WAK_BIT);
+	i_ret = 0;
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_dump_reg
+* DESCRIPTION
+*  dump BTIF module's information when needed
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* flag        [IN]        register id flag
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_dump_reg(P_MTK_BTIF_INFO_STR p_btif, ENUM_BTIF_REG_ID flag)
+{
+/*Chaozhong: To be implement*/
+	int i_ret = -1;
+	int idx = 0;
+	/*unsigned long irq_flag = 0;*/
+	unsigned long base = p_btif->base;
+	unsigned char reg_map[0xE0 / 4] = { 0 };
+	unsigned int lsr = 0x0;
+	unsigned int dma_en = 0;
+
+	/*spin_lock_irqsave(&(g_clk_cg_spinlock), irq_flag);*/
+#if defined(CONFIG_MTK_CLKMGR)
+	if (clock_is_on(MTK_BTIF_CG_BIT) == 0) {
+		/*spin_unlock_irqrestore(&(g_clk_cg_spinlock), irq_flag);*/
+		BTIF_ERR_FUNC("%s: clock is off, this should never happen!!!\n",
+			      __FILE__);
+		return i_ret;
+	}
+#endif
+	lsr = BTIF_READ32(BTIF_LSR(base));
+	dma_en = BTIF_READ32(BTIF_DMA_EN(base));
+	/*
+	 * here we omit 1st register which is THR/RBR register to avoid
+	 * Rx data read by this debug information accidently
+	 */
+	for (idx = 1; idx < sizeof(reg_map); idx++)
+		reg_map[idx] = BTIF_READ8(p_btif->base + (4 * idx));
+	/*spin_unlock_irqrestore(&(g_clk_cg_spinlock), irq_flag);*/
+	BTIF_INFO_FUNC("BTIF's clock is on\n");
+	BTIF_INFO_FUNC("base address: 0x%lx\n", base);
+	switch (flag) {
+	case REG_BTIF_ALL:
+#if 0
+		BTIF_INFO_FUNC("BTIF_IER:0x%x\n", BTIF_READ32(BTIF_IER(base)));
+		BTIF_INFO_FUNC("BTIF_IIR:0x%x\n", BTIF_READ32(BTIF_IIR(base)));
+		BTIF_INFO_FUNC("BTIF_FAKELCR:0x%x\n",
+			       BTIF_READ32(BTIF_FAKELCR(base)));
+		BTIF_INFO_FUNC("BTIF_LSR:0x%x\n", BTIF_READ32(BTIF_LSR(base)));
+		BTIF_INFO_FUNC("BTIF_SLEEP_EN:0x%x\n",
+			       BTIF_READ32(BTIF_SLEEP_EN(base)));
+		BTIF_INFO_FUNC("BTIF_DMA_EN:0x%x\n",
+			       BTIF_READ32(BTIF_DMA_EN(base)));
+		BTIF_INFO_FUNC("BTIF_RTOCNT:0x%x\n",
+			       BTIF_READ32(BTIF_RTOCNT(base)));
+		BTIF_INFO_FUNC("BTIF_TRI_LVL:0x%x\n",
+			       BTIF_READ32(BTIF_TRI_LVL(base)));
+		BTIF_INFO_FUNC("BTIF_WAT_TIME:0x%x\n",
+			       BTIF_READ32(BTIF_WAT_TIME(base)));
+		BTIF_INFO_FUNC("BTIF_HANDSHAKE:0x%x\n",
+			       BTIF_READ32(BTIF_HANDSHAKE(base)));
+#endif
+		btif_dump_array("BTIF register", reg_map, sizeof(reg_map));
+		break;
+	default:
+		break;
+	}
+
+	BTIF_INFO_FUNC("Tx DMA %s\n",
+		       (dma_en & BTIF_DMA_EN_TX) ? "enabled" : "disabled");
+	BTIF_INFO_FUNC("Rx DMA %s\n",
+		       (dma_en & BTIF_DMA_EN_RX) ? "enabled" : "disabled");
+
+	BTIF_INFO_FUNC("Rx data is %s\n",
+		       (lsr & BTIF_LSR_DR_BIT) ? "not empty" : "empty");
+	BTIF_INFO_FUNC("Tx data is %s\n",
+		       (lsr & BTIF_LSR_TEMT_BIT) ? "empty" : "not empty");
+
+	return i_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_is_tx_complete
+* DESCRIPTION
+*  get tx complete flag
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* RETURNS
+*  true means tx complete, false means tx in process
+*****************************************************************************/
+bool hal_btif_is_tx_complete(P_MTK_BTIF_INFO_STR p_btif)
+{
+/*Chaozhong: To be implement*/
+	bool b_ret = false;
+	unsigned int lsr = 0;
+	unsigned long flags = 0;
+	unsigned long base = p_btif->base;
+	unsigned int tx_empty = 0;
+	unsigned int rx_dr = 0;
+	unsigned int tx_irq_disable = 0;
+
+/*
+ * 3 conditions allow clock to be disable
+ * 1. if TEMT is set or not
+ * 2. if DR is set or not
+ * 3. Tx IRQ is disabled or not
+ */
+	lsr = BTIF_READ32(BTIF_LSR(base));
+	tx_empty = lsr & BTIF_LSR_TEMT_BIT;
+	rx_dr = lsr & BTIF_LSR_DR_BIT;
+	tx_irq_disable = BTIF_READ32(BTIF_IER(base)) & BTIF_IER_TXEEN;
+
+	b_ret =
+	    (tx_empty && (tx_irq_disable == 0) && (rx_dr == 0)) ? true : false;
+	if (!b_ret) {
+		BTIF_DBG_FUNC
+		    ("BTIF flag, tx_empty:%d, rx_dr:%d, tx_irq_disable:%d\n",
+		     tx_empty, rx_dr, tx_irq_disable);
+	}
+#if NEW_TX_HANDLING_SUPPORT
+	spin_lock_irqsave(&(p_btif->tx_fifo_spinlock), flags);
+/*clear Tx enable flag if necessary*/
+	if (!(kfifo_is_empty(p_btif->p_tx_fifo))) {
+		BTIF_DBG_FUNC("BTIF tx FIFO is not empty\n");
+		b_ret = false;
+	}
+	spin_unlock_irqrestore(&(p_btif->tx_fifo_spinlock), flags);
+#endif
+	return b_ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_is_tx_allow
+* DESCRIPTION
+*  whether tx is allowed
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* RETURNS
+* true if tx operation is allowed; false if tx is not allowed
+*****************************************************************************/
+bool hal_btif_is_tx_allow(P_MTK_BTIF_INFO_STR p_btif)
+{
+#define MIN_TX_MB ((26 * 1000000 / 13) / 1000000)
+#define AVE_TX_MB ((26 * 1000000 / 8) / 1000000)
+
+/*Chaozhong: To be implement*/
+	bool b_ret = false;
+
+#if NEW_TX_HANDLING_SUPPORT
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&(p_btif->tx_fifo_spinlock), flags);
+/*clear Tx enable flag if necessary*/
+	if (kfifo_is_full(p_btif->p_tx_fifo)) {
+		BTIF_WARN_FUNC("BTIF tx FIFO is full\n");
+		b_ret = false;
+	} else {
+		b_ret = true;
+	}
+	spin_unlock_irqrestore(&(p_btif->tx_fifo_spinlock), flags);
+#else
+	unsigned int lsr = 0;
+	unsigned long base = p_btif->base;
+	unsigned int wait_us = (BTIF_TX_FIFO_SIZE - BTIF_TX_FIFO_THRE) / MIN_TX_MB; /*only ava length */
+
+/*read LSR and check THER or TEMT, either one is 1 means can accept tx data*/
+	lsr = BTIF_READ32(BTIF_LSR(base));
+
+	if (!(lsr & (BTIF_LSR_TEMT_BIT | BTIF_LSR_THRE_BIT))) {
+		BTIF_DBG_FUNC("wait for %d ~ %d us\n", wait_us, 3 * wait_us);
+/* usleep_range(wait_us, 3 * 10 * wait_us); */
+		usleep_range(wait_us, 3 * wait_us);
+	}
+	lsr = BTIF_READ32(BTIF_LSR(base));
+	b_ret = (lsr & (BTIF_LSR_TEMT_BIT | BTIF_LSR_THRE_BIT)) ? true : false;
+	if (!b_ret)
+		BTIF_DBG_FUNC(" tx is not allowed for the moment\n");
+	else
+		BTIF_DBG_FUNC(" tx is allowed\n");
+#endif
+	return b_ret;
+}
+
+#if !(NEW_TX_HANDLING_SUPPORT)
+
+static bool _btif_is_tx_allow(P_MTK_BTIF_INFO_STR p_btif)
+{
+/*Chaozhong: To be implement*/
+	bool b_ret = false;
+	unsigned long base = p_btif->base;
+	unsigned int lsr = 0;
+
+/*read LSR and check THER or TEMT, either one is 1 means can accept tx data*/
+	lsr = BTIF_READ32(BTIF_LSR(base));
+	b_ret = (lsr & (BTIF_LSR_TEMT_BIT | BTIF_LSR_THRE_BIT)) ? true : false;
+	return b_ret;
+}
+#endif
+
+int hal_btif_pm_ops(P_MTK_BTIF_INFO_STR p_btif_info, MTK_BTIF_PM_OPID opid)
+{
+	int i_ret = -1;
+
+	BTIF_DBG_FUNC("op id: %d\n", opid);
+	switch (opid) {
+	case BTIF_PM_DPIDLE_EN:
+		i_ret = 0;
+		break;
+	case BTIF_PM_DPIDLE_DIS:
+		i_ret = 0;
+		break;
+	case BTIF_PM_SUSPEND:
+		i_ret = 0;
+		break;
+	case BTIF_PM_RESUME:
+		i_ret = 0;
+		break;
+	case BTIF_PM_RESTORE_NOIRQ:{
+			unsigned int flag = 0;
+			P_MTK_BTIF_IRQ_STR p_irq = p_btif_info->p_irq;
+
+#ifdef CONFIG_OF
+			flag = p_irq->irq_flags;
+#else
+			switch (p_irq->sens_type) {
+			case IRQ_SENS_EDGE:
+				if (p_irq->edge_type == IRQ_EDGE_FALL)
+					flag = IRQF_TRIGGER_FALLING;
+				else if (p_irq->edge_type == IRQ_EDGE_RAISE)
+					flag = IRQF_TRIGGER_RISING;
+				else if (p_irq->edge_type == IRQ_EDGE_BOTH)
+					flag = IRQF_TRIGGER_RISING |
+					    IRQF_TRIGGER_FALLING;
+				else
+					flag = IRQF_TRIGGER_FALLING;	/*make this as default type */
+				break;
+			case IRQ_SENS_LVL:
+				if (p_irq->lvl_type == IRQ_LVL_LOW)
+					flag = IRQF_TRIGGER_LOW;
+				else if (p_irq->lvl_type == IRQ_LVL_HIGH)
+					flag = IRQF_TRIGGER_HIGH;
+				else
+					flag = IRQF_TRIGGER_LOW;	/*make this as default type */
+				break;
+			default:
+				flag = IRQF_TRIGGER_LOW;	/*make this as default type */
+				break;
+			}
+#endif
+/* irq_set_irq_type(p_irq->irq_id, flag); */
+			i_ret = 0;
+		}
+		break;
+	default:
+		i_ret = ERR_INVALID_PAR;
+		break;
+	}
+
+	return i_ret;
+}
+void mtk_btif_read_cpu_sw_rst_debug_plat(void)
+{
+#define CONSYS_AP2CONN_WAKEUP_OFFSET	0x00000064
+	BTIF_WARN_FUNC("+CONSYS_AP2CONN_WAKEUP_OFFSET(0x%x)\n",
+			   BTIF_READ32(mtk_btif.base + CONSYS_AP2CONN_WAKEUP_OFFSET));
+}
+
diff --git a/drivers/misc/mediatek/btif/common/inc/mtk_btif.h b/drivers/misc/mediatek/btif/common/inc/mtk_btif.h
new file mode 100644
index 00000000..5e2f5a9
--- /dev/null
+++ b/drivers/misc/mediatek/btif/common/inc/mtk_btif.h
@@ -0,0 +1,370 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MTK_BTIF_H_
+#define __MTK_BTIF_H_
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/atomic.h>
+#include <linux/list.h>
+#include <linux/dma-mapping.h>
+#include <linux/vmalloc.h>
+#include <linux/sched.h>
+#include <linux/sched/rt.h>
+#include <linux/kthread.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/string.h>
+#include <linux/time.h>		/* gettimeofday */
+#include <asm-generic/bug.h>
+
+#include "btif_pub.h"
+#include "btif_dma_pub.h"
+#include "mtk_btif_exp.h"
+
+#define BTIF_PORT_NR 1
+#define BTIF_USER_NAME_MAX_LEN 32
+
+/*-------------Register Defination Start ---------------*/
+#if (defined(CONFIG_MTK_GMO_RAM_OPTIMIZE) && !defined(CONFIG_MTK_ENG_BUILD))
+#define BTIF_RX_BUFFER_SIZE (1024 * 32)
+#else
+#define BTIF_RX_BUFFER_SIZE (1024 * 64)
+#endif
+#define BTIF_TX_FIFO_SIZE (1024 * 4)
+
+/*------------Register Defination End ----------------*/
+
+/*------------BTIF Module Clock and Power Control Defination---------------*/
+typedef enum _ENUM_BTIF_RX_TYPE_ {
+	BTIF_IRQ_CTX = 0,
+	BTIF_TASKLET_CTX = BTIF_IRQ_CTX + 1,
+	BTIF_THREAD_CTX = BTIF_TASKLET_CTX + 1,
+	BTIF_WQ_CTX = BTIF_THREAD_CTX + 1,
+	BTIF_RX_TYPE_MAX,
+} ENUM_BTIF_RX_TYPE;
+
+typedef enum _ENUM_BTIF_TX_TYPE_ {
+	BTIF_TX_USER_CTX = 0,
+	BTIF_TX_SINGLE_CTX = BTIF_TX_USER_CTX + 1,
+	BTIF_TX_TYPE_MAX,
+} ENUM_BTIF_TX_TYPE;
+
+typedef enum _ENUM_BTIF_STATE_ {
+	B_S_OFF = 0,
+	B_S_SUSPEND = B_S_OFF + 1,
+	B_S_DPIDLE = B_S_SUSPEND + 1,
+	B_S_ON = B_S_DPIDLE + 1,
+	B_S_MAX,
+} ENUM_BTIF_STATE;
+
+#define ENABLE_BTIF_RX_DMA 1
+#define ENABLE_BTIF_TX_DMA 1
+
+#if ENABLE_BTIF_TX_DMA
+#define BTIF_TX_MODE BTIF_MODE_DMA
+#else
+#define BTIF_TX_MODE BTIF_MODE_PIO
+#endif
+
+#if ENABLE_BTIF_RX_DMA
+#define BTIF_RX_MODE BTIF_MODE_DMA
+#else
+#define BTIF_RX_MODE BTIF_MODE_PIO
+#endif
+
+#define BTIF_RX_BTM_CTX BTIF_THREAD_CTX/*BTIF_WQ_CTX*//* BTIF_TASKLET_CTX */
+/*
+ * -- cannot be used because ,
+ * mtk_wcn_stp_parser data will call *(stp_if_tx) to send ack,
+ * in which context sleepable lock or usleep operation may be used,
+ * these operation is not allowed in tasklet, may cause schedule_bug
+ */
+
+#define BTIF_TX_CTX BTIF_TX_USER_CTX	/* BTIF_TX_SINGLE_CTX */
+
+#define ENABLE_BTIF_RX_THREAD_RT_SCHED 0
+#define MAX_BTIF_RXD_TIME_REC 3
+
+/*Structure Defination*/
+
+/*-----------------BTIF setting--------------*/
+typedef struct _mtk_btif_setting_ {
+	ENUM_BTIF_MODE tx_mode;	/*BTIF Tx Mode Setting */
+	ENUM_BTIF_MODE rx_mode;	/*BTIF Tx Mode Setting */
+	ENUM_BTIF_RX_TYPE rx_type;	/*rx handle type */
+	ENUM_BTIF_TX_TYPE tx_type;	/*tx type */
+} mtk_btif_setting, *p_mtk_btif_setting;
+/*---------------------------------------------------------------------------*/
+
+#if 0
+/*---------------------------------------------------------------------------*/
+typedef struct _mtk_btif_register_ {
+	unsigned int iir;	/*Interrupt Identification Register */
+	unsigned int lsr;	/*Line Status Register */
+	unsigned int fake_lcr;	/*Fake Lcr Regiseter */
+	unsigned int fifo_ctrl;	/*FIFO Control Register */
+	unsigned int ier;	/*Interrupt Enable Register */
+	unsigned int sleep_en;	/*Sleep Enable Register */
+	unsigned int rto_counter;	/*Rx Timeout Counter Register */
+	unsigned int dma_en;	/*DMA Enalbe Register */
+	unsigned int tri_lvl;	/*Tx/Rx Trigger Level Register */
+	unsigned int wat_time;	/*Async Wait Time Register */
+	unsigned int handshake;	/*New HandShake Mode Register */
+	unsigned int sleep_wak;	/*Sleep Wakeup Reigster */
+} mtk_btif_register, *p_mtk_btif_register;
+/*---------------------------------------------------------------------------*/
+
+#endif
+
+typedef struct _btif_buf_str_ {
+	unsigned int size;
+	unsigned char *p_buf;
+	/*
+	 * For Tx: next Tx data pointer to FIFO;
+	 * For Rx: next read data pointer from BTIF user
+	 */
+	unsigned int rd_idx;
+	/*
+	 * For Tx: next Tx data pointer from BTIF user;
+	 * For Rx: next write data(from FIFO) pointer
+	 */
+	unsigned int wr_idx;
+} btif_buf_str, *p_btif_buf_str;
+
+/*---------------------------------------------------------------------------*/
+typedef struct _mtk_btif_dma_ {
+					/*p_mtk_btif*/ void *p_btif;
+					/*BTIF pointer to which DMA belongs */
+
+#if 0
+	unsigned int channel;	/*DMA's channel */
+#endif
+
+	ENUM_BTIF_DIR dir;	/*DMA's direction: */
+	bool enable;		/*DMA enable or disable flag */
+
+	P_MTK_DMA_INFO_STR p_dma_info;	/*DMA's IRQ information */
+
+#if 0
+	mtk_dma_register register;	/*DMA's register */
+#endif
+
+	spinlock_t iolock;	/*io lock for DMA channel */
+	atomic_t entry;		/* entry count */
+} mtk_btif_dma, *p_mtk_btif_dma;
+
+#if (defined(CONFIG_MTK_GMO_RAM_OPTIMIZE) && !defined(CONFIG_MTK_ENG_BUILD))
+#define BTIF_LOG_ENTRY_NUM 10
+#else
+#define BTIF_LOG_ENTRY_NUM 30
+#endif
+
+#define BTIF_LOG_SZ  1536
+
+typedef void (*MTK_BTIF_RX_NOTIFY) (void);
+
+typedef struct _btif_log_buf_t_ {
+	unsigned int len;
+	struct timeval timer;
+	unsigned char buffer[BTIF_LOG_SZ];
+} BTIF_LOG_BUF_T, *P_BTIF_LOG_BUF_T;
+
+typedef struct _btif_log_queue_t_ {
+	ENUM_BTIF_DIR dir;
+	bool enable;
+	bool output_flag;
+	unsigned int in;
+	unsigned int out;
+	unsigned int size;
+	spinlock_t lock;
+	P_BTIF_LOG_BUF_T p_queue[BTIF_LOG_ENTRY_NUM];
+} BTIF_LOG_QUEUE_T, *P_BTIF_LOG_QUEUE_T;
+
+/*---------------------------------------------------------------------------*/
+typedef struct _mtk_btif_ {
+	unsigned int open_counter;	/*open counter */
+	bool enable;		/*BTIF module enable flag */
+	bool lpbk_flag;		/*BTIF module enable flag */
+#if 0
+	unsigned long base;	/* BTIF controller base address */
+#endif
+
+	ENUM_BTIF_STATE state;	/*BTIF state mechanism */
+	struct mutex state_mtx;	/*lock to BTIF state mechanism's state change */
+	struct mutex ops_mtx;	/*lock to BTIF's open and close */
+
+#if 0
+	mtk_btif_register register;	/*BTIF registers */
+#endif
+
+	ENUM_BTIF_MODE tx_mode;	/* BTIF Tx channel mode */
+	ENUM_BTIF_MODE rx_mode;	/* BTIF Rx channel mode */
+	struct mutex tx_mtx;	/*lock to BTIF's tx process */
+/*rx handling */
+	ENUM_BTIF_RX_TYPE btm_type;	/*BTIF Rx bottom half context */
+/*tx handling*/
+	ENUM_BTIF_TX_TYPE tx_ctx;	/*BTIF tx context */
+/* unsigned char rx_buf[BTIF_RX_BUFFER_SIZE]; */
+	btif_buf_str btif_buf;
+	spinlock_t rx_irq_spinlock;	/*lock for rx irq handling */
+
+/*rx workqueue information*/
+	/*lock to BTIF's rx bottom half when kernel thread is used */
+	struct mutex rx_mtx;
+	struct workqueue_struct *p_rx_wq;
+	struct work_struct rx_work;
+
+	struct workqueue_struct *p_tx_wq;
+	struct work_struct tx_work;
+	struct kfifo *p_tx_fifo;
+
+/*rx tasklet information*/
+	struct tasklet_struct rx_tasklet;
+	/*lock to BTIF's rx bottom half when tasklet is used */
+	spinlock_t rx_tasklet_spinlock;
+
+/*rx thread information*/
+	struct task_struct *p_task;
+	struct completion rx_comp;
+
+	mtk_btif_setting *setting;	/*BTIF setting */
+
+	p_mtk_btif_dma p_tx_dma;	/*BTIF Tx channel DMA */
+	p_mtk_btif_dma p_rx_dma;	/*BTIF Rx channel DMA */
+
+	MTK_WCN_BTIF_RX_CB rx_cb;	/*Rx callback function */
+	MTK_BTIF_RX_NOTIFY rx_notify;
+
+	P_MTK_BTIF_INFO_STR p_btif_info;	/*BTIF's information */
+
+/*Log Tx data to buffer*/
+	BTIF_LOG_QUEUE_T tx_log;
+
+/*Log Rx data to buffer*/
+	BTIF_LOG_QUEUE_T rx_log;
+
+/* struct list_head *p_user_list; */
+	struct list_head user_list;
+/* get btif dev pointer*/
+	void *private_data;
+} mtk_btif, *p_mtk_btif;
+/*---------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------*/
+#if 0
+/*---------------------------------------------------------------------------*/
+typedef struct _mtk_dma_register_ {
+	unsigned int int_flag;	/*Tx offset:0x0     Rx offset:0x0 */
+	unsigned int int_enable;	/*Tx offset:0x4     Rx offset:0x4 */
+	unsigned int dma_enable;	/*Tx offset:0x8     Rx offset:0x8 */
+	unsigned int dma_reset;	/*Tx offset:0xc     Rx offset:0xc */
+	unsigned int dma_stop;	/*Tx offset:0x10     Rx offset:0x10 */
+	unsigned int dma_flush;	/*Tx offset:0x14     Rx offset:0x14 */
+	unsigned int vff_addr;	/*Tx offset:0x1c     Rx offset:0x1c */
+	unsigned int vff_len;	/*Tx offset:0x24     Rx offset:0x24 */
+	unsigned int vff_thr;	/*Tx offset:0x28     Rx offset:0x28 */
+	unsigned int vff_wpt;	/*Tx offset:0x2c     Rx offset:0x2c */
+	unsigned int vff_rpt;	/*Tx offset:0x30     Rx offset:0x30 */
+	unsigned int rx_fc_thr;	/*Tx:No this register     Rx offset:0x34 */
+	unsigned int int_buf_size;	/*Tx offset:0x38     Rx offset:0x38 */
+	unsigned int vff_valid_size;	/*Tx offset:0x3c     Rx offset:0x3c */
+	unsigned int vff_left_size;	/*Tx offset:0x40     Rx offset:0x40 */
+	unsigned int debug_status;	/*Tx offset:0x50     Rx offset:0x50 */
+} mtk_dma_register, *p_mtk_dma_register;
+/*---------------------------------------------------------------------------*/
+#endif
+
+/*---------------------------------------------------------------------------*/
+typedef struct _mtk_btif_user_ {
+	bool enable;		/*register its state */
+	struct list_head entry;	/*btif_user's bi-direction list table */
+	/*BTIF's user, static allocation */
+	char u_name[BTIF_USER_NAME_MAX_LEN];
+	unsigned long u_id;
+	p_mtk_btif p_btif;
+} mtk_btif_user, *p_mtk_btif_user;
+
+/*---------------------------------------------------------------------------*/
+#define BBS_PTR(ptr, idx) ((ptr->p_buf) + idx)
+
+#define BBS_SIZE(ptr) ((ptr)->size)
+#define BBS_MASK(ptr) (BBS_SIZE(ptr) - 1)
+#define BBS_COUNT(ptr) ((ptr)->wr_idx >= (ptr)->rd_idx ? (ptr)->wr_idx - \
+(ptr)->rd_idx : BBS_SIZE(ptr) - \
+((ptr)->rd_idx - (ptr)->wr_idx))
+#define BBS_COUNT_CUR(ptr, wr_idx) (wr_idx >= (ptr)->rd_idx ? wr_idx - \
+(ptr)->rd_idx : BBS_SIZE(ptr) - \
+((ptr)->rd_idx - wr_idx))
+
+#define BBS_LEFT(ptr) (BBS_SIZE(ptr) - BBS_COUNT(ptr))
+
+#define BBS_AVL_SIZE(ptr) (BBS_SIZE(ptr) - BBS_COUNT(ptr))
+#define BBS_FULL(ptr) (BBS_COUNT(ptr) - BBS_SIZE(ptr))
+#define BBS_EMPTY(ptr) ((ptr)->wr_idx == (ptr)->rd_idx)
+#define BBS_WRITE_MOVE_NEXT(ptr) ((ptr)->wr_idx = \
+((ptr)->wr_idx + 1) & BBS_MASK(ptr))
+#define BBS_READ_MOVE_NEXT(ptr) ((ptr)->rd_idx = \
+((ptr)->rd_idx + 1) & BBS_MASK(ptr))
+
+#define BBS_INIT(ptr) \
+{ \
+(ptr)->rd_idx = (ptr)->wr_idx = 0; \
+(ptr)->size = BTIF_RX_BUFFER_SIZE; \
+}
+
+
+#define BTIF_MUTEX_UNLOCK(x) mutex_unlock(x)
+
+extern mtk_btif g_btif[];
+
+int btif_open(p_mtk_btif p_btif);
+int btif_close(p_mtk_btif p_btif);
+int btif_send_data(p_mtk_btif p_btif,
+		   const unsigned char *p_buf, unsigned int buf_len);
+int btif_enter_dpidle(p_mtk_btif p_btif);
+int btif_exit_dpidle(p_mtk_btif p_btif);
+int btif_rx_cb_reg(p_mtk_btif p_btif, MTK_WCN_BTIF_RX_CB rx_cb);
+
+/*for test purpose*/
+int _btif_suspend(p_mtk_btif p_btif);
+int _btif_resume(p_mtk_btif p_btif);
+int _btif_restore_noirq(p_mtk_btif p_btif);
+
+int btif_lpbk_ctrl(p_mtk_btif p_btif, bool flag);
+int btif_log_buf_dmp_in(P_BTIF_LOG_QUEUE_T p_log_que, const char *p_buf,
+			int len);
+int btif_dump_data(char *p_buf, int len);
+int btif_log_buf_dmp_out(P_BTIF_LOG_QUEUE_T p_log_que);
+int btif_log_buf_enable(P_BTIF_LOG_QUEUE_T p_log_que);
+int btif_log_buf_disable(P_BTIF_LOG_QUEUE_T p_log_que);
+int btif_log_output_enable(P_BTIF_LOG_QUEUE_T p_log_que);
+int btif_log_output_disable(P_BTIF_LOG_QUEUE_T p_log_que);
+int btif_log_buf_reset(P_BTIF_LOG_QUEUE_T p_log_que);
+int btif_log_buf_init(p_mtk_btif p_btif);
+int btif_dump_reg(p_mtk_btif p_btif);
+int btif_rx_notify_reg(p_mtk_btif p_btif, MTK_BTIF_RX_NOTIFY rx_notify);
+int btif_raise_wak_signal(p_mtk_btif p_btif);
+int btif_clock_ctrl(p_mtk_btif p_btif, int en);
+bool btif_parser_wmt_evt(p_mtk_btif p_btif,
+				const char *sub_str,
+				unsigned int sub_len);
+void mtk_btif_read_cpu_sw_rst_debug(void);
+
+#endif /*__MTK_BTIF_H_*/
diff --git a/drivers/misc/mediatek/btif/common/inc/mtk_btif_exp.h b/drivers/misc/mediatek/btif/common/inc/mtk_btif_exp.h
new file mode 100644
index 00000000..3752644
--- /dev/null
+++ b/drivers/misc/mediatek/btif/common/inc/mtk_btif_exp.h
@@ -0,0 +1,280 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _MTK_BTIF_EXP_H_
+#define _MTK_BTIF_EXP_H_
+
+/*--------------marco defination---------------*/
+#define BTIF_MAX_LEN_PER_PKT 2048
+#define BTIF_RXD_BE_BLOCKED_DETECT 1
+/*--------------Enum Defination---------------*/
+typedef enum _ENUM_BTIF_DPIDLE_ {
+	BTIF_DPIDLE_DISABLE = 0,
+	BTIF_DPIDLE_ENABLE = BTIF_DPIDLE_DISABLE + 1,
+	BTIF_DPIDLE_MAX,
+} ENUM_BTIF_DPIDLE_CTRL;
+
+typedef enum _ENUM_BTIF_LPBK_MODE_ {
+	BTIF_LPBK_DISABLE = 0,
+	BTIF_LPBK_ENABLE = BTIF_LPBK_DISABLE + 1,
+	BTIF_LPBK_MAX,
+} ENUM_BTIF_LPBK_MODE;
+
+typedef enum _ENUM_BTIF_DBG_ID_ {
+	BTIF_DISABLE_LOGGER = 0,
+	BTIF_ENABLE_LOGGER = BTIF_DISABLE_LOGGER + 1,
+	BTIF_DUMP_LOG = BTIF_ENABLE_LOGGER + 1,
+	BTIF_CLR_LOG = BTIF_DUMP_LOG + 1,
+	BTIF_DUMP_BTIF_REG = BTIF_CLR_LOG + 1,
+	BTIF_ENABLE_RT_LOG = BTIF_DUMP_BTIF_REG + 1,
+	BTIF_DISABLE_RT_LOG = BTIF_ENABLE_RT_LOG + 1,
+	BTIF_DBG_MAX,
+} ENUM_BTIF_DBG_ID;
+
+typedef enum _ENUM_BTIF_OP_ERROR_CODE_ {
+	E_BTIF_AGAIN = 0,
+	E_BTIF_FAIL = -1,
+	E_BTIF_BAD_POINTER = -2,
+	E_BTIF_NO_SPACE = -3,
+	E_BTIF_INTR = -4,
+	E_BTIF_INVAL_PARAM = -5,
+	E_BTIF_ALREADY_OPEN = -6,
+	E_BTIF_NOT_OPEN = -7,
+	E_BTIF_INVAL_STATE = -8,
+} ENUM_BTIF_OP_ERROR_CODE;
+
+/*--------------End of Enum Defination---------------*/
+
+/*--------------Type Definition---------------*/
+
+typedef int (*MTK_WCN_BTIF_RX_CB) (const unsigned char *p_buf,
+				   unsigned int len);
+
+/*--------------End of Type Definition---------------*/
+
+/*--------------Normal Mode API declearation---------------*/
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_open
+* DESCRIPTION
+*  open BTIF interface, will do BTIF module HW and SW initialization
+* PARAMETERS
+*  p_owner      [IN] pointer to owner who call this API,
+*                    currently there are 2 owner ("stp" or "btif_tester")
+*                    may use this module
+*                    user's id string must be less than 32 bytes
+*  for "stp", BTIF will call rx callback function to route rx data to STP module
+*  for "stp_tester", BTIF will save rx data
+*  and wait for native process to access
+*  p_id            [IN] BTIF's user id will be put to this address
+* RETURNS
+*  int 0 = succeed; others = fail, for detailed information,
+*      please see ENUM_BTIF_OP_ERROR_CODE
+*      if open success, value p_id will be the only identifier for
+*      user to access BTIF's other operations
+*      including read/write/dpidle_ctrl/rx_cb_retister
+*      this user id is only an identifier used for owner identification
+*****************************************************************************/
+int mtk_wcn_btif_open(char *p_owner, unsigned long *p_id);
+//EXPORT_SYMBOL(mtk_wcn_btif_open)
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_close
+* DESCRIPTION
+*  close BTIF interface, will do BTIF module HW and SW de-initialization
+*  once this API is called, p_btif should never be used by BTIF's user again
+* PARAMETERS
+*  u_id        [IN] BTIF's user id
+* RETURNS
+*  int         0 = succeed;
+*  others = fail, for detailed information, please see ENUM_BTIF_OP_ERROR_CODE
+*****************************************************************************/
+int mtk_wcn_btif_close(unsigned long u_id);
+//EXPORT_SYMBOL(mtk_wcn_btif_close)
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_write
+* DESCRIPTION
+*  send data throuth BTIF module
+*  there's no internal buffer to cache STP data in BTIF driver,
+*  if in DMA mode
+*  btif driver will check if there's enough space
+*  in vFIFO for data to send in DMA mode
+*    if yes, put data to vFIFO and return corresponding data length to caller
+*    if no, corresponding error code will be returned to called
+* PARAMETERS
+*  p_btif      [IN] pointer returned by mtk_wcn_btif_open
+*  p_buf       [IN] pointer to target data to send
+*  len         [IN] data length (should be less than 2014 bytes per STP package)
+*
+*  if in non-DMA mode, BTIF driver will try to write to THR of BTIF controller
+*      if btif driver detected that no space is available in Tx FIFO,
+*      will return E_BTIF_NO_SPACE,
+*      mostly something is wrong with BTIF or consys when this
+*       return value is returned
+* RETURNS
+*  int          positive: data length send through BTIF;
+*        negative: please see ENUM_BTIF_OP_ERROR_CODE
+*        E_BTIF_AGAIN (0) will be returned to caller if btif does not have
+*        enough vFIFO to send data, when caller get 0,
+*        he should wait for a moment (5~10ms maybe) and
+*        try a few times (maybe 10~20)
+*            if still get E_BTIF_AGAIN, should call BTIF's debug API and
+*        dump BTIF driver and BTIF/DMA register information to kernel log
+*        for debug
+*        E_BTIF_BAD_POINTER will be returned to caller if btif is not
+*        opened successfully before call this API
+*        E_BTIF_INVAL_PARAM will be returned if parameter is not valid
+
+*****************************************************************************/
+int mtk_wcn_btif_write(unsigned long u_id,
+		       const unsigned char *p_buf, unsigned int len);
+//EXPORT_SYMBOL(mtk_wcn_btif_write)
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_read
+* DESCRIPTION
+*  read data from BTIF module
+* PARAMETERS
+*  p_btif     [IN] pointer returned by mtk_wcn_btif_open
+*  p_buf      [IN/OUT] pointer to buffer where rx data will be put
+*  max_len    [IN] max buffer length
+* RETURNS
+*  int          positive: data length read from BTIF;
+*  negative: please see ENUM_BTIF_OP_ERROR_CODE
+*****************************************************************************/
+int mtk_wcn_btif_read(unsigned long u_id,
+		      unsigned char *p_buf, unsigned int max_len);
+//EXPORT_SYMBOL(mtk_wcn_btif_read)
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_dpidle_ctrl
+* DESCRIPTION
+*  control if BTIF module allow system enter deepidle state or not
+* PARAMETERS
+*  p_btif      [IN] pointer returned by mtk_wcn_btif_open
+*  en_flag    [IN] one of ENUM_BTIF_DPIDLE_CTRL
+* RETURNS
+*  int          always return 0
+*****************************************************************************/
+int mtk_wcn_btif_dpidle_ctrl(unsigned long u_id, ENUM_BTIF_DPIDLE_CTRL en_flag);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_rx_cb_register
+* DESCRIPTION
+*  register rx callback function to BTIF module by btif user
+* PARAMETERS
+*  p_btif      [IN] pointer returned by mtk_wcn_btif_open
+*  rx_cb       [IN] pointer to stp rx handler callback function,
+*  should be comply with MTK_WCN_BTIF_RX_CB
+* RETURNS
+*  int          0 = succeed;
+*  others = fail, for detailed information, please see ENUM_BTIF_OP_ERROR_CODE
+*****************************************************************************/
+int mtk_wcn_btif_rx_cb_register(unsigned long u_id, MTK_WCN_BTIF_RX_CB rx_cb);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_wakeup_consys
+* DESCRIPTION
+*  once sleep command is sent to con sys,
+*  should call this API before send wakeup command to
+*  make con sys aware host want to send data to consys
+* PARAMETERS
+*  p_btif      [IN] pointer returned by mtk_wcn_btif_open
+* RETURNS
+*  int          0 = succeed;
+*  others = fail, for detailed information, please see ENUM_BTIF_OP_ERROR_CODE
+*****************************************************************************/
+int mtk_wcn_btif_wakeup_consys(unsigned long u_id);
+
+/*--------------End of Normal Mode API declearation----------------*/
+
+/*--------------Debug Purpose API declearation----------------*/
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_loopback_ctrl
+* DESCRIPTION
+*  enable/disable BTIF internal loopback function,
+*  when this function is enabled,
+*  data send to btif will be received by btif itself
+*  only for debug purpose, should never use this function in normal mode
+* PARAMETERS
+*  p_btif      [IN] pointer returned by mtk_wcn_btif_open
+*  enable     [IN] loopback mode control flag, enable or disable,
+*  shou be one of ENUM_BTIF_LPBK_MODE
+* RETURNS
+*  int          0 = succeed;
+*  others = fail, for detailed information, please see ENUM_BTIF_OP_ERROR_CODE
+*****************************************************************************/
+int mtk_wcn_btif_loopback_ctrl(unsigned long u_id, ENUM_BTIF_LPBK_MODE enable);
+//EXPORT_SYMBOL(mtk_wcn_btif_loopback_ctrl)
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_logger_ctrl
+* DESCRIPTION
+*  control BTIF logger function's behavior
+* PARAMETERS
+*  p_btif      [IN] pointer returned by mtk_wcn_btif_open
+*  flag         [IN] should be one of ENUM_BTIF_DBG_ID
+*                      BTIF_DISABLE_LOGGER  - disable btif logger
+*                      BTIF_ENABLE_LOGGER   - enable btif logger
+*                      BTIF_DUMP_LOG           - dump log logged by btif
+*                      BTIF_CLR_LOG             - clear btif log buffer
+*                      BTIF_DUMP_BTIF_REG   - dump btif controller's register
+*                      BTIF_DUMP_DMA_REG   - dump DMA controller's register
+* RETURNS
+*  int   0 = succeed;
+*        others = fail, for detailed information,
+*        please see ENUM_BTIF_OP_ERROR_CODE
+*****************************************************************************/
+int mtk_wcn_btif_dbg_ctrl(unsigned long u_id, ENUM_BTIF_DBG_ID flag);
+//EXPORT_SYMBOL(mtk_wcn_btif_dbg_ctrl);
+/*-----------End of Debug Purpose API declearation------------*/
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_parser_wmt_evt
+* DESCRIPTION
+*  parser wmt sleep/wakeup evt in btif bbs buffer for debug
+* PARAMETERS
+*  p_btif      [IN] pointer returned by mtk_wcn_btif_open
+*  sub_str     [IN] the str to be parsered
+*  str_len     [IN] the length of sub_str
+* RETURNS
+*  bool  true = succeed;
+*        false = fail;
+*****************************************************************************/
+bool mtk_wcn_btif_parser_wmt_evt(unsigned long u_id,
+	const char *sub_str, unsigned int str_len);
+
+int mtk_btif_exp_open_test(void);
+int mtk_btif_exp_close_test(void);
+int mtk_btif_exp_write_test(void);
+int mtk_btif_exp_suspend_test(void);
+int mtk_btif_exp_resume_test(void);
+int mtk_btif_exp_enter_dpidle_test(void);
+int mtk_btif_exp_exit_dpidle_test(void);
+int mtk_btif_exp_write_stress_test(unsigned int length, unsigned int loop);
+int mtk_btif_exp_log_debug_test(int flag);
+int mtk_btif_exp_restore_noirq_test(void);
+int btif_wakeup_consys_no_id(void);
+int mtk_btif_exp_clock_ctrl(int en);
+#if BTIF_RXD_BE_BLOCKED_DETECT
+int mtk_btif_rxd_be_blocked_flag_get(void);
+#endif
+void mtk_btif_read_cpu_sw_rst_debug_exp(void);
+#endif /*_MTK_BTIF_EXP_H_*/
diff --git a/drivers/misc/mediatek/btif/common/mtk_btif.c b/drivers/misc/mediatek/btif/common/mtk_btif.c
new file mode 100644
index 00000000..7d5b65d
--- /dev/null
+++ b/drivers/misc/mediatek/btif/common/mtk_btif.c
@@ -0,0 +1,3473 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+/*-----------linux system header files----------------*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/poll.h>
+
+/*#include <mach/eint.h>*/
+/*-----------driver own header files----------------*/
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG "MTK-BTIF"
+
+#define BTIF_CDEV_SUPPORT 1
+
+#include "btif_pub.h"
+#include "btif_dma_pub.h"
+#include "mtk_btif_exp.h"
+#include "mtk_btif.h"
+
+/*-----------static function declearation----------------*/
+static int mtk_btif_probe(struct platform_device *pdev);
+static int mtk_btif_remove(struct platform_device *pdev);
+static int mtk_btif_suspend(struct platform_device *pdev, pm_message_t state);
+static int mtk_btif_resume(struct platform_device *pdev);
+static int mtk_btif_drv_resume(struct device *dev);
+static int mtk_btif_drv_suspend(struct device *pdev);
+
+static int mtk_btif_restore_noirq(struct device *device);
+static int btif_file_open(struct inode *pinode, struct file *pfile);
+static int btif_file_release(struct inode *pinode, struct file *pfile);
+static ssize_t btif_file_read(struct file *pfile,
+			      char __user *buf, size_t count, loff_t *f_ops);
+static unsigned int btif_poll(struct file *filp, poll_table *wait);
+static int _btif_irq_reg(P_MTK_BTIF_IRQ_STR p_irq,
+		  mtk_btif_irq_handler irq_handler, void *data);
+static int _btif_irq_free(P_MTK_BTIF_IRQ_STR p_irq, void *data);
+static int _btif_irq_ctrl(P_MTK_BTIF_IRQ_STR p_irq, bool en);
+static int _btif_irq_ctrl_sync(P_MTK_BTIF_IRQ_STR p_irq, bool en);
+static irqreturn_t btif_irq_handler(int irq, void *data);
+static unsigned int btif_pio_rx_data_receiver(P_MTK_BTIF_INFO_STR p_btif_info,
+				       unsigned char *p_buf,
+				       unsigned int buf_len);
+
+static irqreturn_t btif_tx_dma_irq_handler(int irq, void *data);
+static irqreturn_t btif_rx_dma_irq_handler(int irq, void *data);
+
+static unsigned int btif_dma_rx_data_receiver(P_MTK_DMA_INFO_STR p_dma_info,
+				       unsigned char *p_buf,
+				       unsigned int buf_len);
+static int _btif_controller_tx_setup(p_mtk_btif p_btif);
+static int _btif_controller_tx_free(p_mtk_btif p_btif);
+static int _btif_controller_rx_setup(p_mtk_btif p_btif);
+static int _btif_controller_rx_free(p_mtk_btif p_btif);
+static int _btif_tx_pio_setup(p_mtk_btif p_btif);
+static int _btif_rx_pio_setup(p_mtk_btif p_btif);
+static int _btif_rx_dma_setup(p_mtk_btif p_btif);
+static int _btif_rx_dma_free(p_mtk_btif p_btif);
+static int _btif_tx_dma_setup(p_mtk_btif p_btif);
+static int _btif_tx_dma_free(p_mtk_btif p_btif);
+static int _btif_controller_setup(p_mtk_btif p_btif);
+static int _btif_controller_free(p_mtk_btif p_btif);
+
+static int _btif_pio_write(p_mtk_btif p_btif,
+		    const unsigned char *p_buf, unsigned int buf_len);
+static int _btif_dma_write(p_mtk_btif p_btif,
+		    const unsigned char *p_buf, unsigned int buf_len);
+
+static unsigned int btif_bbs_wr_direct(p_btif_buf_str p_bbs,
+				unsigned char *p_buf, unsigned int buf_len);
+static unsigned int btif_bbs_read(p_btif_buf_str p_bbs,
+			   unsigned char *p_buf, unsigned int buf_len);
+static unsigned int btif_bbs_write(p_btif_buf_str p_bbs,
+			    unsigned char *p_buf, unsigned int buf_len);
+static void btif_dump_bbs_str(unsigned char *p_str, p_btif_buf_str p_bbs);
+static int _btif_dump_memory(char *str, unsigned char *p_buf, unsigned int buf_len);
+static int _btif_rx_btm_deinit(p_mtk_btif p_btif);
+static int _btif_rx_btm_sched(p_mtk_btif p_btif);
+static int _btif_rx_btm_init(p_mtk_btif p_btif);
+static void btif_rx_tasklet(unsigned long func_data);
+static void btif_rx_worker(struct work_struct *p_work);
+static int btif_rx_thread(void *p_data);
+static int btif_rx_data_consummer(p_mtk_btif p_btif);
+
+static int _btif_tx_ctx_init(p_mtk_btif p_btif);
+static int _btif_tx_ctx_deinit(p_mtk_btif p_btif);
+static void btif_tx_worker(struct work_struct *p_work);
+
+static int _btif_state_deinit(p_mtk_btif p_btif);
+static int _btif_state_release(p_mtk_btif p_btif);
+static ENUM_BTIF_STATE _btif_state_get(p_mtk_btif p_btif);
+static int _btif_state_set(p_mtk_btif p_btif, ENUM_BTIF_STATE state);
+static int _btif_state_hold(p_mtk_btif p_btif);
+static int _btif_state_init(p_mtk_btif p_btif);
+
+static int _btif_dpidle_notify_ctrl(p_mtk_btif p_btif,
+				    ENUM_BTIF_DPIDLE_CTRL en_flag);
+static int _btif_enter_dpidle(p_mtk_btif p_btif);
+static int _btif_exit_dpidle(p_mtk_btif p_btif);
+static int _btif_exit_dpidle_from_sus(p_mtk_btif p_btif);
+static int _btif_exit_dpidle_from_dpidle(p_mtk_btif p_btif);
+static int _btif_enter_dpidle_from_on(p_mtk_btif p_btif);
+static int _btif_enter_dpidle_from_sus(p_mtk_btif p_btif);
+
+#if ENABLE_BTIF_TX_DMA
+static int _btif_vfifo_deinit(p_mtk_btif_dma p_dma);
+static int _btif_vfifo_init(p_mtk_btif_dma p_dma);
+#endif
+
+static bool _btif_is_tx_complete(p_mtk_btif p_btif);
+static int _btif_init(p_mtk_btif p_btif);
+static int _btif_lpbk_ctrl(p_mtk_btif p_btif, bool flag);
+static int btif_rx_dma_mode_set(int en);
+static int btif_tx_dma_mode_set(int en);
+
+static int _btif_send_data(p_mtk_btif p_btif,
+		    const unsigned char *p_buf, unsigned int buf_len);
+
+/*-----------end of static function declearation----------------*/
+
+static const char *g_state[B_S_MAX] = {
+	"OFF",
+	"SUSPEND",
+	"DPIDLE",
+	"ON",
+};
+
+/*-----------BTIF setting--------------*/
+mtk_btif_setting g_btif_setting[BTIF_PORT_NR] = {
+	{
+	 .tx_mode = BTIF_TX_MODE,
+	 .rx_mode = BTIF_RX_MODE,
+	 .rx_type = BTIF_RX_BTM_CTX,
+	 .tx_type = BTIF_TX_CTX,
+	 },
+};
+
+mtk_btif g_btif[BTIF_PORT_NR] = {
+	{
+	 .open_counter = 0,
+	 .state = B_S_OFF,
+	 .setting = &g_btif_setting[0],
+	 .p_tx_dma = NULL,
+	 .p_rx_dma = NULL,
+	 .rx_cb = NULL,
+	 .p_btif_info = NULL,
+	 },
+};
+
+mtk_btif_dma g_dma[BTIF_PORT_NR][BTIF_DIR_MAX] = {
+	{
+	 {
+	  .p_btif = NULL,
+	  .dir = BTIF_TX,
+	  .p_dma_info = NULL,
+	  .entry = ATOMIC_INIT(0),
+	  },
+	 {
+	  .p_btif = NULL,
+	  .dir = BTIF_RX,
+	  .p_dma_info = NULL,
+	  .entry = ATOMIC_INIT(0),
+	  },
+	 },
+};
+
+#define G_MAX_PKG_LEN (7 * 1024)
+static int g_max_pkg_len = G_MAX_PKG_LEN; /*DMA vFIFO is set to 8 * 1024, we set this to 7/8 * vFIFO size*/
+static int g_max_pding_data_size = BTIF_RX_BUFFER_SIZE * 3 / 4;
+
+
+static int mtk_btif_dbg_lvl = BTIF_LOG_ERR;
+
+#if BTIF_RXD_BE_BLOCKED_DETECT
+static struct timeval btif_rxd_time_stamp[MAX_BTIF_RXD_TIME_REC];
+#endif
+/*-----------Platform bus related structures----------------*/
+#define DRV_NAME "mtk_btif"
+
+#ifdef CONFIG_OF
+const struct of_device_id apbtif_of_ids[] = {
+	{ .compatible = "mediatek,mtk-btif", },
+	{}
+};
+#endif
+
+const struct dev_pm_ops mtk_btif_drv_pm_ops = {
+	.restore_noirq = mtk_btif_restore_noirq,
+	.suspend = mtk_btif_drv_suspend,
+	.resume = mtk_btif_drv_resume,
+};
+
+struct platform_driver mtk_btif_dev_drv = {
+	.probe = mtk_btif_probe,
+	.remove = mtk_btif_remove,
+#ifdef CONFIG_PM
+	.suspend = mtk_btif_suspend,
+	.resume = mtk_btif_resume,
+#endif
+	.driver = {
+			.name = DRV_NAME,
+			.owner = THIS_MODULE,
+#ifdef CONFIG_PM
+			.pm = &mtk_btif_drv_pm_ops,
+#endif
+#ifdef CONFIG_OF
+			.of_match_table = apbtif_of_ids,
+#endif
+		   }
+};
+
+#define BTIF_STATE_RELEASE(x) _btif_state_release(x)
+
+/*-----------End of Platform bus related structures----------------*/
+
+/*-----------platform bus related operation APIs----------------*/
+
+static int mtk_btif_probe(struct platform_device *pdev)
+{
+/*Chaozhong: ToDo: to be implement*/
+/*register IRQ for BTIF and Tx Rx DMA and disable them by default*/
+	BTIF_INFO_FUNC("DO BTIF PROBE\n");
+	platform_set_drvdata(pdev, &g_btif[0]);
+	g_btif[0].private_data = (struct device *)&pdev->dev;
+
+#if !defined(CONFIG_MTK_CLKMGR)
+	hal_btif_clk_get_and_prepare(pdev);
+#endif
+
+	return 0;
+}
+
+static int mtk_btif_remove(struct platform_device *pdev)
+{
+/*Chaozhong: ToDo: to be implement*/
+	BTIF_INFO_FUNC("DO BTIF REMOVE\n");
+	platform_set_drvdata(pdev, NULL);
+	g_btif[0].private_data = NULL;
+	return 0;
+}
+
+int _btif_suspend(p_mtk_btif p_btif)
+{
+	int i_ret;
+
+	if (_btif_state_hold(p_btif))
+		return E_BTIF_INTR;
+	if (p_btif != NULL) {
+		if (!(p_btif->enable))
+			i_ret = 0;
+		else {
+			if (_btif_state_get(p_btif) == B_S_ON) {
+				BTIF_ERR_FUNC("BTIF in ON state,",
+					"there are data need to be send or recev,suspend fail\n");
+				i_ret = -1;
+			} else {
+				/*
+				 * before disable BTIF controller and DMA controller
+				 * we need to set BTIF to ON state
+				 */
+				i_ret = _btif_exit_dpidle(p_btif);
+				if (i_ret == 0) {
+					i_ret += _btif_controller_free(p_btif);
+					i_ret = _btif_controller_tx_free(p_btif);
+					i_ret += _btif_controller_rx_free(p_btif);
+				}
+				if (i_ret != 0) {
+					BTIF_INFO_FUNC("failed\n");
+					/*Chaozhong: what if failed*/
+				} else {
+					BTIF_INFO_FUNC("succeed\n");
+					i_ret = _btif_state_set(p_btif, B_S_SUSPEND);
+					if (i_ret && _btif_init(p_btif)) {
+						/*Chaozhong:BTIF re-init failed? what to do*/
+						i_ret = _btif_state_set(p_btif,	B_S_OFF);
+					}
+				}
+			}
+		}
+	} else
+		i_ret = -1;
+	BTIF_STATE_RELEASE(p_btif);
+
+	return i_ret;
+}
+
+
+static int mtk_btif_drv_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	pm_message_t state = PMSG_SUSPEND;
+
+	return mtk_btif_suspend(pdev, state);
+}
+
+static int mtk_btif_drv_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	return mtk_btif_resume(pdev);
+}
+
+static int mtk_btif_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	int i_ret = 0;
+	p_mtk_btif p_btif = NULL;
+
+/*Chaozhong: ToDo: to be implement*/
+	BTIF_DBG_FUNC("++\n");
+	p_btif = platform_get_drvdata(pdev);
+	i_ret = _btif_suspend(p_btif);
+	BTIF_DBG_FUNC("--, i_ret:%d\n", i_ret);
+	return i_ret;
+}
+
+int _btif_restore_noirq(p_mtk_btif p_btif)
+{
+	int i_ret = 0;
+
+/*BTIF IRQ restore no irq*/
+	i_ret = hal_btif_pm_ops(p_btif->p_btif_info, BTIF_PM_RESTORE_NOIRQ);
+	if (i_ret == 0) {
+		BTIF_INFO_FUNC("BTIF HW IRQ restore succeed\n");
+	} else {
+		BTIF_INFO_FUNC("BTIF HW IRQ restore failed, i_ret:%d\n", i_ret);
+		return i_ret;
+	}
+/*BTIF DMA restore no irq*/
+	if (p_btif->tx_mode & BTIF_MODE_DMA) {
+		i_ret = hal_dma_pm_ops(p_btif->p_tx_dma->p_dma_info,
+				       BTIF_PM_RESTORE_NOIRQ);
+		if (i_ret == 0) {
+			BTIF_INFO_FUNC("BTIF Tx DMA IRQ restore succeed\n");
+		} else {
+			BTIF_INFO_FUNC
+			    ("BTIF Tx DMA IRQ restore failed, i_ret:%d\n",
+			     i_ret);
+			return i_ret;
+		}
+	}
+	if (p_btif->rx_mode & BTIF_MODE_DMA) {
+		i_ret = hal_dma_pm_ops(p_btif->p_rx_dma->p_dma_info,
+				       BTIF_PM_RESTORE_NOIRQ);
+		if (i_ret == 0) {
+			BTIF_INFO_FUNC("BTIF Rx DMA IRQ restore succeed\n");
+		} else {
+			BTIF_INFO_FUNC
+			    ("BTIF Rx DMA IRQ restore failed, i_ret:%d\n",
+			     i_ret);
+			return i_ret;
+		}
+	}
+	return i_ret;
+}
+
+static int mtk_btif_restore_noirq(struct device *dev)
+{
+	int i_ret = 0;
+	struct platform_device *pdev = to_platform_device(dev);
+	p_mtk_btif p_btif = platform_get_drvdata(pdev);
+
+	BTIF_INFO_FUNC("++\n");
+	if (_btif_state_hold(p_btif))
+		return E_BTIF_INTR;
+	if (p_btif->enable)
+		BTIF_ERR_FUNC("!!!-----------------!BTIF is not closed before IPOH shutdown!!!---------------!\n");
+	WARN_ON(p_btif->enable);
+
+	i_ret = _btif_restore_noirq(p_btif);
+	BTIF_STATE_RELEASE(p_btif);
+	BTIF_INFO_FUNC("--\n");
+	return 0;
+}
+
+int _btif_resume(p_mtk_btif p_btif)
+{
+	int i_ret = 0;
+	ENUM_BTIF_STATE state = B_S_MAX;
+
+	if (_btif_state_hold(p_btif))
+		return E_BTIF_INTR;
+	if (p_btif != NULL) {
+		state = _btif_state_get(p_btif);
+		if (!(p_btif->enable))
+			i_ret = 0;
+		else if (state == B_S_SUSPEND)
+			i_ret = _btif_enter_dpidle(p_btif);
+		else
+			BTIF_INFO_FUNC
+				("BTIF state: %s before resume, do nothing\n", g_state[state]);
+	} else
+		i_ret = -1;
+	BTIF_STATE_RELEASE(p_btif);
+
+	return i_ret;
+}
+
+static int mtk_btif_resume(struct platform_device *pdev)
+{
+	int i_ret = 0;
+	p_mtk_btif p_btif = NULL;
+/*Chaozhong: ToDo: to be implement*/
+	BTIF_DBG_FUNC("++\n");
+	p_btif = platform_get_drvdata(pdev);
+	i_ret = _btif_resume(p_btif);
+	BTIF_DBG_FUNC("--, i_ret:%d\n", i_ret);
+	return 0;
+}
+
+/*-----------device node----------------*/
+#if BTIF_CDEV_SUPPORT
+
+dev_t btif_dev;
+struct class *p_btif_class;
+struct device *p_btif_dev;
+const char *p_btif_dev_name = "btif";
+static struct semaphore wr_mtx;
+static struct semaphore rd_mtx;
+unsigned char wr_buf[2048];
+unsigned char rd_buf[2048];
+static int rx_notify_flag;
+static DECLARE_WAIT_QUEUE_HEAD(btif_wq);
+static int btif_file_open(struct inode *pinode, struct file *pfile);
+static int btif_file_release(struct inode *pinode, struct file *pfile);
+static ssize_t btif_file_read(struct file *pfile,
+			      char __user *buf, size_t count, loff_t *f_ops);
+
+static ssize_t btif_file_write(struct file *filp,
+			const char __user *buf, size_t count, loff_t *f_pos);
+static long btif_unlocked_ioctl(struct file *filp, unsigned int cmd,
+			 unsigned long arg);
+#ifdef CONFIG_COMPAT
+static long btif_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+#endif
+static struct cdev btif_dev_c;
+static wait_queue_head_t btif_read_inq;	/* read queues */
+
+const struct file_operations mtk_btif_fops = {
+	.owner = THIS_MODULE,
+	.open = btif_file_open,
+	.release = btif_file_release,
+	.read = btif_file_read,
+	.write = btif_file_write,
+	.unlocked_ioctl = btif_unlocked_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = btif_compat_ioctl,
+#endif
+	.poll = btif_poll,
+};
+
+static int btif_chrdev_init(void)
+{
+	int i_ret;
+
+	int i_err;
+
+	/* alloc device number dynamically */
+	i_ret = alloc_chrdev_region(&btif_dev, 0, 1, p_btif_dev_name);
+	if (i_ret) {
+		BTIF_ERR_FUNC("devuce number allocation failed, i_ret:%d\n",
+			      i_ret);
+	} else {
+		BTIF_INFO_FUNC("devuce number allocation succeed\n");
+	}
+	cdev_init(&btif_dev_c, &mtk_btif_fops);
+	btif_dev_c.owner = THIS_MODULE;
+	i_err = cdev_add(&btif_dev_c, btif_dev, 1);
+	if (i_err) {
+		BTIF_ERR_FUNC("error add btif dev to kernel, error code:%d\n",
+			      i_err);
+		unregister_chrdev_region(btif_dev, 1);
+		btif_dev = 0;
+		return -1;
+	}
+	BTIF_INFO_FUNC("add btif dev to kernel succeed\n");
+
+	p_btif_class = class_create(THIS_MODULE, p_btif_dev_name);
+	if (IS_ERR(p_btif_class)) {
+		BTIF_ERR_FUNC("error happened when doing class_create\n");
+		unregister_chrdev_region(btif_dev, 1);
+		btif_dev = 0;
+		return -2;
+	}
+	BTIF_INFO_FUNC("create class for btif succeed\n");
+
+	p_btif_dev = device_create(p_btif_class,
+				   NULL, btif_dev, 0, p_btif_dev_name);
+	if (IS_ERR(p_btif_dev)) {
+		BTIF_ERR_FUNC("error happened when doing device_create\n");
+		class_destroy(p_btif_class);
+		p_btif_class = NULL;
+		unregister_chrdev_region(btif_dev, 1);
+		btif_dev = 0;
+		return -3;
+	}
+	BTIF_INFO_FUNC("create device for btif succeed\n");
+
+	return 0;
+}
+
+void btif_rx_notify_cb(void)
+{
+	BTIF_DBG_FUNC("++\n");
+	rx_notify_flag = 1;
+	wake_up(&btif_wq);
+	wake_up_interruptible(&btif_read_inq);
+	BTIF_DBG_FUNC("--\n");
+}
+
+unsigned int btif_poll(struct file *filp, poll_table *wait)
+{
+	unsigned int mask = 0;
+	unsigned int ava_len = 0;
+/* btif_bbs_read(&(g_btif[0].btif_buf), rd_buf, sizeof(rd_buf)); */
+	unsigned int wr_idx = g_btif[0].btif_buf.wr_idx;
+
+/*    BTIF_Rx_IRQ_Disable(); */
+	ava_len = BBS_COUNT_CUR(&(g_btif[0].btif_buf), wr_idx);
+	BTIF_INFO_FUNC("++\n");
+	if (ava_len == 0) {
+		poll_wait(filp, &btif_read_inq, wait);
+		wr_idx = g_btif[0].btif_buf.wr_idx;
+		ava_len = BBS_COUNT_CUR(&(g_btif[0].btif_buf), wr_idx);
+/* btif_bbs_read(&(g_btif[0].btif_buf), rd_buf, sizeof(rd_buf)); */
+		if (ava_len)
+			mask |= POLLIN | POLLRDNORM;	/* readable */
+	} else {
+		mask |= POLLIN | POLLRDNORM;	/* readable */
+	}
+/*make for writable*/
+	mask |= POLLOUT | POLLWRNORM;	/* writable */
+	BTIF_INFO_FUNC("--, mask:%d\n", mask);
+	return mask;
+}
+
+static int _btif_file_open(void)
+{
+	int i_ret = -1;
+	p_mtk_btif p_btif = &g_btif[0];
+
+	BTIF_INFO_FUNC("++\n");
+
+/*Chaozhong: ToDo: to be implement*/
+	i_ret = btif_open(p_btif);
+	if ((i_ret != 0) && (i_ret != E_BTIF_ALREADY_OPEN)) {
+		BTIF_ERR_FUNC("btif_open failed, error code:%d\n", i_ret);
+	} else {
+		BTIF_INFO_FUNC("btif_open succeed\n");
+		i_ret = 0;
+	}
+/*semaphore for read and write operation init*/
+	sema_init(&wr_mtx, 1);
+	sema_init(&rd_mtx, 1);
+
+/*buffer for read and write init*/
+	memset(wr_buf, 0, sizeof(wr_buf));
+	memset(rd_buf, 0, sizeof(rd_buf));
+	init_waitqueue_head(&(btif_read_inq));
+	btif_rx_notify_reg(p_btif, btif_rx_notify_cb);
+	BTIF_INFO_FUNC("--\n");
+	return i_ret;
+}
+
+static int _btif_file_close(void)
+{
+	int i_ret = -1;
+
+	BTIF_INFO_FUNC("++\n");
+/*Chaozhong: ToDo: to be implement*/
+	i_ret = btif_close(&g_btif[0]);
+	if (i_ret != 0)
+		BTIF_ERR_FUNC("btif_close failed, error code:%d\n", i_ret);
+	else
+		BTIF_INFO_FUNC("btif_close succeed\n");
+
+	BTIF_INFO_FUNC("--\n");
+	return i_ret;
+}
+
+static int btif_file_open(struct inode *pinode, struct file *pfile)
+{
+	int i_ret = -1;
+
+	BTIF_INFO_FUNC("pid:%d\n", current->pid);
+	i_ret = 0;
+	return i_ret;
+}
+
+static int btif_file_release(struct inode *pinode, struct file *pfile)
+{
+	int i_ret = -1;
+
+	BTIF_INFO_FUNC("pid:%d\n", current->pid);
+	i_ret = 0;
+	return i_ret;
+}
+
+static ssize_t btif_file_read(struct file *pfile,
+			      char __user *buf, size_t count, loff_t *f_ops)
+{
+	int i_ret = 0;
+	int rd_len = 0;
+
+	BTIF_INFO_FUNC("++\n");
+	down(&rd_mtx);
+	rd_len = btif_bbs_read(&(g_btif[0].btif_buf), rd_buf, sizeof(rd_buf));
+	while (rd_len == 0) {
+		if (pfile->f_flags & O_NONBLOCK)
+			break;
+
+		wait_event(btif_wq, rx_notify_flag != 0);
+		rx_notify_flag = 0;
+		rd_len =
+		    btif_bbs_read(&(g_btif[0].btif_buf), rd_buf,
+				  sizeof(rd_buf));
+	}
+
+	if (rd_len == 0)
+		i_ret = 0;
+	else if ((rd_len > 0) && (copy_to_user(buf, rd_buf, rd_len) == 0))
+		i_ret = rd_len;
+	else
+		i_ret = -EFAULT;
+
+	up(&rd_mtx);
+	BTIF_INFO_FUNC("--, i_ret:%d\n", i_ret);
+	return i_ret;
+}
+
+ssize_t btif_file_write(struct file *filp,
+			const char __user *buf, size_t count, loff_t *f_pos)
+{
+	int i_ret = 0;
+	int copy_size = 0;
+
+	copy_size = count > sizeof(wr_buf) ? sizeof(wr_buf) : count;
+
+	BTIF_INFO_FUNC("++\n");
+	down(&wr_mtx);
+	if (copy_from_user(&wr_buf[0], &buf[0], copy_size))
+		i_ret = -EFAULT;
+	else
+		i_ret = btif_send_data(&g_btif[0], wr_buf, copy_size);
+
+	up(&wr_mtx);
+	BTIF_INFO_FUNC("--, i_ret:%d\n", i_ret);
+
+	return i_ret;
+}
+#ifdef CONFIG_COMPAT
+long btif_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	long ret;
+
+	BTIF_INFO_FUNC("cmd[0x%x]\n", cmd);
+	ret = btif_unlocked_ioctl(filp, cmd, arg);
+	return ret;
+}
+#endif
+long btif_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+#define BTIF_IOC_MAGIC        0xb0
+#define BTIF_IOCTL_OPEN     _IOW(BTIF_IOC_MAGIC, 1, int)
+#define BTIF_IOCTL_CLOSE    _IOW(BTIF_IOC_MAGIC, 2, int)
+#define BTIF_IOCTL_LPBK_CTRL    _IOWR(BTIF_IOC_MAGIC, 3, int)
+#define BTIF_IOCTL_LOG_FUNC_CTRL    _IOWR(BTIF_IOC_MAGIC, 4, int)
+#define BTIF_IOCTL_RT_LOG_CTRL  _IOWR(BTIF_IOC_MAGIC, 5, int)
+#define BTIF_IOCTL_LOG_DUMP _IOWR(BTIF_IOC_MAGIC, 6, int)
+#define BTIF_IOCTL_REG_DUMP _IOWR(BTIF_IOC_MAGIC, 7, int)
+#define BTIF_IOCTL_DMA_CTRL _IOWR(BTIF_IOC_MAGIC, 8, int)
+
+	long ret = 0;
+/* unsigned char p_buf[NAME_MAX + 1]; */
+	p_mtk_btif p_btif = &g_btif[0];
+
+	BTIF_INFO_FUNC("++\n");
+	BTIF_DBG_FUNC("cmd (%u), arg (0x%lx)\n", cmd, arg);
+
+	switch (cmd) {
+	case BTIF_IOCTL_OPEN:
+		ret = _btif_file_open();
+		break;
+	case BTIF_IOCTL_CLOSE:
+		ret = _btif_file_close();
+		break;
+	case BTIF_IOCTL_LPBK_CTRL:
+		ret = btif_lpbk_ctrl(p_btif, arg == 0 ? 0 : 1);
+		break;
+	case BTIF_IOCTL_LOG_FUNC_CTRL:
+		if (arg == 0) {
+			ret += btif_log_buf_disable(&p_btif->tx_log);
+			ret += btif_log_buf_disable(&p_btif->rx_log);
+		} else {
+			ret += btif_log_buf_enable(&p_btif->tx_log);
+			ret += btif_log_buf_enable(&p_btif->rx_log);
+		}
+		break;
+	case BTIF_IOCTL_RT_LOG_CTRL:
+		if (arg == 0) {
+			ret += btif_log_output_disable(&p_btif->tx_log);
+			ret += btif_log_output_disable(&p_btif->rx_log);
+		} else {
+			ret += btif_log_output_enable(&p_btif->tx_log);
+			ret += btif_log_output_enable(&p_btif->rx_log);
+		}
+		break;
+	case BTIF_IOCTL_LOG_DUMP:
+
+		ret += btif_log_buf_dmp_out(&p_btif->tx_log);
+		ret += btif_log_buf_dmp_out(&p_btif->rx_log);
+		break;
+	case BTIF_IOCTL_REG_DUMP:
+		ret += btif_dump_reg(p_btif);
+		break;
+	case BTIF_IOCTL_DMA_CTRL:
+		if (arg == 0) {
+			ret += btif_tx_dma_mode_set(0);
+			ret += btif_rx_dma_mode_set(0);
+		} else {
+			ret += btif_tx_dma_mode_set(1);
+			ret += btif_rx_dma_mode_set(1);
+		}
+		break;
+	default:
+		BTIF_INFO_FUNC("unknown cmd(%d)\n", cmd);
+		ret = -2;
+		break;
+	}
+	BTIF_INFO_FUNC("--\n");
+	return ret;
+}
+
+#endif
+
+/*-----------device property----------------*/
+//static ssize_t driver_flag_read(struct device_driver *drv, char *buf)
+static ssize_t flag_show(struct device_driver *drv, char *buf)
+{
+	return sprintf(buf, "btif driver debug level:%d\n", mtk_btif_dbg_lvl);
+}
+
+//static ssize_t driver_flag_set(struct device_driver *drv,
+static ssize_t flag_store(struct device_driver *drv,
+			       const char *buffer, size_t count)
+{
+	char buf[256];
+	char *p_buf;
+	unsigned long len = count;
+	long x = 0;
+	long y = 0;
+	long z = 0;
+	int result = 0;
+	char *p_token = NULL;
+	char *p_delimiter = " \t";
+
+	BTIF_INFO_FUNC("buffer = %s, count = %zd\n", buffer, count);
+	if (len >= sizeof(buf)) {
+		BTIF_ERR_FUNC("input handling fail!\n");
+		len = sizeof(buf) - 1;
+		return -1;
+	}
+
+	memcpy(buf, buffer, sizeof(buf));
+	p_buf = buf;
+
+	p_token = strsep(&p_buf, p_delimiter);
+	if (p_token != NULL) {
+		result = kstrtol(p_token, 16, &x);
+		BTIF_INFO_FUNC("x = 0x%08x\n\r", x);
+	} else
+		x = 0;
+/*	x = (NULL != p_token) ? kstrtol(p_token, 16, NULL) : 0;*/
+
+	p_token = strsep(&p_buf, "\t\n ");
+	if (p_token != NULL) {
+		result = kstrtol(p_token, 16, &y);
+		BTIF_INFO_FUNC("y = 0x%08x\n\r", y);
+	} else
+		y = 0;
+
+	p_token = strsep(&p_buf, "\t\n ");
+	if (p_token != NULL)
+		result = kstrtol(p_token, 16, &z);
+	else
+		z = 0;
+
+	BTIF_INFO_FUNC("x(0x%08x), y(0x%08x), z(0x%08x)\n\r", x, y, z);
+
+	switch (x) {
+	case 1:
+		mtk_btif_exp_open_test();
+		break;
+	case 2:
+		mtk_btif_exp_close_test();
+		break;
+	case 3:
+		mtk_btif_exp_write_test();
+		break;
+	case 4:
+		mtk_btif_exp_enter_dpidle_test();
+		break;
+	case 5:
+		mtk_btif_exp_exit_dpidle_test();
+		break;
+	case 6:
+		mtk_btif_exp_suspend_test();
+		break;
+	case 7:
+		mtk_btif_exp_resume_test();
+		break;
+	case 8:
+		if (y > BTIF_LOG_LOUD)
+			mtk_btif_dbg_lvl = BTIF_LOG_LOUD;
+		else if (y < BTIF_LOG_ERR)
+			mtk_btif_dbg_lvl = BTIF_LOG_WARN;
+		else
+			mtk_btif_dbg_lvl = y;
+		BTIF_ERR_FUNC("mtk_btif_dbg_lvl set to %d\n", mtk_btif_dbg_lvl);
+		break;
+	case 9:
+		mtk_btif_exp_open_test();
+		mtk_btif_exp_write_test();
+		mtk_btif_exp_close_test();
+		break;
+	case 0xa:
+		mtk_btif_exp_log_debug_test(y);
+		break;
+	case 0xb:
+		btif_tx_dma_mode_set(1);
+		btif_rx_dma_mode_set(1);
+		break;
+	case 0xc:
+		btif_tx_dma_mode_set(0);
+		btif_rx_dma_mode_set(0);
+		break;
+	case 0xd:
+		mtk_btif_exp_restore_noirq_test();
+		break;
+	case 0xe:
+		btif_wakeup_consys_no_id();
+		break;
+	case 0xf:
+		mtk_btif_exp_clock_ctrl(y);
+		break;
+	case 0x10:
+		y = y > G_MAX_PKG_LEN ? G_MAX_PKG_LEN : y;
+		y = y < 1024 ? 1024 : y;
+		BTIF_INFO_FUNC("g_max_pkg_len is set to %d\n", y);
+		g_max_pkg_len = y;
+		break;
+	case 0x11:
+		y = y > BTIF_RX_BUFFER_SIZE ? BTIF_RX_BUFFER_SIZE : y;
+		y = y < 1024 ? 1024 : y;
+		BTIF_INFO_FUNC("g_max_pding_data_size is set to %d\n", y);
+		g_max_pding_data_size = y;
+		break;
+	default:
+		mtk_btif_exp_open_test();
+		mtk_btif_exp_write_stress_test(3030, 1);
+		mtk_btif_exp_close_test();
+		BTIF_WARN_FUNC("not supported.\n");
+		break;
+	}
+
+	return count;
+}
+
+//FWU: driver_ATTR dropped in 4.14
+//static DRIVER_ATTR(flag, S_IRUGO | S_IWUSR, driver_flag_read, driver_flag_set);
+static DRIVER_ATTR_RW(flag);
+
+/*-----------End of platform bus related operation APIs------------*/
+
+/*-----------------------platform driver ----------------*/
+
+int _btif_irq_reg(P_MTK_BTIF_IRQ_STR p_irq,
+		  mtk_btif_irq_handler irq_handler, void *data)
+{
+	int i_ret = -1;
+	unsigned int irq_id;
+	unsigned int flag;
+
+	if ((p_irq == NULL) || (irq_handler == NULL))
+		return E_BTIF_INVAL_PARAM;
+
+	if (!(p_irq->is_irq_sup)) {
+		BTIF_WARN_FUNC("%s is not supported\n", p_irq->name);
+		return 0;
+	}
+
+	irq_id = p_irq->irq_id;
+
+#ifdef CONFIG_OF
+	flag = p_irq->irq_flags;
+#else
+	switch (p_irq->sens_type) {
+	case IRQ_SENS_EDGE:
+		if (p_irq->edge_type == IRQ_EDGE_FALL)
+			flag = IRQF_TRIGGER_FALLING;
+		else if (p_irq->edge_type == IRQ_EDGE_RAISE)
+			flag = IRQF_TRIGGER_RISING;
+		else if (p_irq->edge_type == IRQ_EDGE_BOTH)
+			flag = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;
+		else
+			/*make this as default type */
+			flag = IRQF_TRIGGER_FALLING;
+		break;
+	case IRQ_SENS_LVL:
+		if (p_irq->lvl_type == IRQ_LVL_LOW)
+			flag = IRQF_TRIGGER_LOW;
+		else if (p_irq->lvl_type == IRQ_LVL_HIGH)
+			flag = IRQF_TRIGGER_HIGH;
+		else
+			/*make this as default type */
+			flag = IRQF_TRIGGER_LOW;
+		break;
+	default:
+		/*make this as default type */
+		flag = IRQF_TRIGGER_LOW;
+		break;
+	}
+#endif
+
+	p_irq->p_irq_handler = irq_handler;
+	i_ret = request_irq(irq_id,
+			    (irq_handler_t) irq_handler,
+			    flag, p_irq->name, data);
+	if (i_ret)
+		return i_ret;
+
+	p_irq->reg_flag = true;
+	return 0;
+}
+
+int _btif_irq_free(P_MTK_BTIF_IRQ_STR p_irq, void *data)
+{
+	int i_ret = 0;
+	unsigned int eint_num = p_irq->irq_id;
+
+	if ((p_irq->is_irq_sup) && (p_irq->reg_flag)) {
+		_btif_irq_ctrl(p_irq, false);
+		free_irq(eint_num, data);
+		p_irq->reg_flag = false;
+	}
+/*do nothing for this operation*/
+	return i_ret;
+}
+
+int _btif_irq_ctrl(P_MTK_BTIF_IRQ_STR p_irq, bool en)
+{
+	unsigned int eint_num = p_irq->irq_id;
+
+	if (en)
+		enable_irq(eint_num);
+	else
+		disable_irq_nosync(eint_num);
+
+	return 0;
+}
+
+int _btif_irq_ctrl_sync(P_MTK_BTIF_IRQ_STR p_irq, bool en)
+{
+	unsigned int eint_num = p_irq->irq_id;
+
+	if (en)
+		enable_irq(eint_num);
+	else
+		disable_irq(eint_num);
+
+	return 0;
+}
+
+
+irqreturn_t btif_irq_handler(int irq, void *data)
+{
+/*search BTIF? just use index 0*/
+/*Chaozhong: do we need lock here?*/
+
+	p_mtk_btif p_btif = (p_mtk_btif) data;	/*&(g_btif[index]); */
+
+	BTIF_DBG_FUNC("++, p_btif(0x%p)\n", data);
+
+	_btif_irq_ctrl(p_btif->p_btif_info->p_irq, false);
+
+#if MTK_BTIF_ENABLE_CLK_REF_COUNTER
+	hal_btif_clk_ctrl(p_btif->p_btif_info, CLK_OUT_ENABLE);
+#endif
+
+	hal_btif_irq_handler(p_btif->p_btif_info, NULL, 0);
+
+#if MTK_BTIF_ENABLE_CLK_REF_COUNTER
+	hal_btif_clk_ctrl(p_btif->p_btif_info, CLK_OUT_DISABLE);
+#endif
+
+	_btif_irq_ctrl(p_btif->p_btif_info->p_irq, true);
+	_btif_rx_btm_sched(p_btif);
+
+	BTIF_DBG_FUNC("--\n");
+	return IRQ_HANDLED;
+}
+
+irqreturn_t btif_tx_dma_irq_handler(int irq, void *data)
+{
+/*search BTIF? just use index 0*/
+
+	p_mtk_btif p_btif = (p_mtk_btif) data;	/*&(g_btif[index]); */
+	p_mtk_btif_dma p_tx_dma = p_btif->p_tx_dma;
+	P_MTK_DMA_INFO_STR p_dma_info = p_tx_dma->p_dma_info;
+
+	BTIF_DBG_FUNC("++, p_btif(0x%p)\n", data);
+	_btif_irq_ctrl(p_dma_info->p_irq, false);
+
+#if MTK_BTIF_ENABLE_CLK_REF_COUNTER
+	hal_btif_dma_clk_ctrl(p_dma_info, CLK_OUT_ENABLE);
+#endif
+
+	hal_tx_dma_irq_handler(p_dma_info);
+
+#if MTK_BTIF_ENABLE_CLK_REF_COUNTER
+	hal_btif_dma_clk_ctrl(p_dma_info, CLK_OUT_DISABLE);
+#endif
+	_btif_irq_ctrl(p_dma_info->p_irq, true);
+	BTIF_DBG_FUNC("--\n");
+	return IRQ_HANDLED;
+}
+
+irqreturn_t btif_rx_dma_irq_handler(int irq, void *data)
+{
+/*search BTIF? just use index 0*/
+
+	p_mtk_btif p_btif = (p_mtk_btif) data;	/*&(g_btif[index]); */
+	p_mtk_btif_dma p_rx_dma = p_btif->p_rx_dma;
+	P_MTK_DMA_INFO_STR p_rx_dma_info = p_rx_dma->p_dma_info;
+
+	BTIF_DBG_FUNC("++, p_btif(0x%p)\n", data);
+
+	_btif_irq_ctrl(p_rx_dma_info->p_irq, false);
+
+#if MTK_BTIF_ENABLE_CLK_REF_COUNTER
+	hal_btif_clk_ctrl(p_btif->p_btif_info, CLK_OUT_ENABLE);
+	hal_btif_dma_clk_ctrl(p_rx_dma_info, CLK_OUT_ENABLE);
+#endif
+
+	hal_rx_dma_irq_handler(p_rx_dma_info, NULL, 0);
+
+#if MTK_BTIF_ENABLE_CLK_REF_COUNTER
+	hal_btif_dma_clk_ctrl(p_rx_dma_info, CLK_OUT_DISABLE);
+	hal_btif_clk_ctrl(p_btif->p_btif_info, CLK_OUT_DISABLE);
+#endif
+
+	_btif_irq_ctrl(p_rx_dma_info->p_irq, true);
+
+	_btif_rx_btm_sched(p_btif);
+
+	BTIF_DBG_FUNC("--\n");
+
+	return IRQ_HANDLED;
+}
+
+unsigned int btif_dma_rx_data_receiver(P_MTK_DMA_INFO_STR p_dma_info,
+				       unsigned char *p_buf,
+				       unsigned int buf_len)
+{
+	unsigned int index = 0;
+	p_mtk_btif p_btif = &(g_btif[index]);
+
+#if 0
+	_btif_dump_memory("<DMA Rx>", p_buf, buf_len);
+#endif
+
+	btif_bbs_write(&(p_btif->btif_buf), p_buf, buf_len);
+/*save DMA Rx packet here*/
+	if (buf_len > 0)
+		btif_log_buf_dmp_in(&p_btif->rx_log, p_buf, buf_len);
+
+	return 0;
+}
+
+unsigned int btif_pio_rx_data_receiver(P_MTK_BTIF_INFO_STR p_btif_info,
+				       unsigned char *p_buf,
+				       unsigned int buf_len)
+{
+	unsigned int index = 0;
+	p_mtk_btif p_btif = &(g_btif[index]);
+
+#if 0
+	_btif_dump_memory("<PIO Rx>", p_buf, buf_len);
+#endif
+	btif_bbs_write(&(p_btif->btif_buf), p_buf, buf_len);
+
+/*save PIO Rx packet here*/
+	if (buf_len > 0)
+		btif_log_buf_dmp_in(&p_btif->rx_log, p_buf, buf_len);
+
+	return 0;
+}
+
+bool btif_parser_wmt_evt(p_mtk_btif p_btif,
+				const char *sub_str,
+				unsigned int str_len)
+{
+	unsigned int data_cnt = 0;
+	unsigned int copy_cnt = 0;
+	char *local_buf = NULL;
+	bool b_ret = false;
+	p_btif_buf_str p_bbs = &(p_btif->btif_buf);
+	unsigned int wr_idx = p_bbs->wr_idx;
+	unsigned int rd_idx = p_bbs->rd_idx;
+
+	data_cnt = copy_cnt =  BBS_COUNT(p_bbs);
+
+	if (data_cnt < str_len) {
+		BTIF_WARN_FUNC("there is not enough data for parser,need(%d),have(%d)\n", str_len, data_cnt);
+		return false;
+	}
+	BTIF_INFO_FUNC("data count in bbs buffer:%d,wr_idx(%d),rd_idx(%d)\n", data_cnt, wr_idx, rd_idx);
+	local_buf = vmalloc((data_cnt + 3) & ~0x3UL);
+	if (!local_buf) {
+		BTIF_WARN_FUNC("vmalloc memory fail\n");
+		return false;
+	}
+
+	if (wr_idx >= rd_idx) {
+		memcpy(local_buf, BBS_PTR(p_bbs, rd_idx), copy_cnt);
+	} else {
+		unsigned int tail_len = BBS_SIZE(p_bbs) - rd_idx;
+
+		BTIF_INFO_FUNC("tail_Len(%d)\n", tail_len);
+		memcpy(local_buf, BBS_PTR(p_bbs, rd_idx), tail_len);
+		memcpy(local_buf + tail_len, BBS_PTR(p_bbs, 0), copy_cnt - tail_len);
+	}
+
+	do {
+		int i = 0;
+		int j = 0;
+		int k = 0;
+		int d = 0;
+
+		BTIF_INFO_FUNC("sub_str_len:%d\n", str_len);
+		for (i = 0; i < copy_cnt; i++) {
+			BTIF_DBG_FUNC("i:%d\n", i);
+			k = i;
+			while (1) {
+				if ((j >= str_len) || (k >= copy_cnt) || (sub_str[j++] != local_buf[k++]))
+					break;
+			}
+
+			if (j == str_len) {
+				for (d = i; d < (str_len + i); d++)
+					BTIF_INFO_FUNC("0x%2x", local_buf[d]);
+				BTIF_INFO_FUNC("find sub str index:%d\n", i);
+				b_ret = true;
+				break;
+			}
+			if (j < str_len)
+				j = 0;
+		}
+
+	} while (0);
+
+	vfree(local_buf);
+	return b_ret;
+}
+int _btif_controller_tx_setup(p_mtk_btif p_btif)
+{
+	int i_ret = -1;
+
+	if (p_btif->tx_mode == BTIF_MODE_DMA) {
+		i_ret = _btif_tx_dma_setup(p_btif);
+		if (i_ret) {
+			BTIF_ERR_FUNC("_btif_tx_dma_setup failed,i_ret(%d),",
+				"set tx to PIO mode\n", i_ret);
+			i_ret = _btif_tx_pio_setup(p_btif);
+		}
+	} else
+/*enable Tx PIO mode*/
+		i_ret = _btif_tx_pio_setup(p_btif);
+
+	return i_ret;
+}
+
+int _btif_controller_tx_free(p_mtk_btif p_btif)
+{
+	int i_ret = -1;
+
+	if (p_btif->tx_mode == BTIF_MODE_DMA) {
+		i_ret = _btif_tx_dma_free(p_btif);
+		if (i_ret) {
+			BTIF_ERR_FUNC("_btif_tx_dma_free failed, i_ret(%d)\n",
+				      i_ret);
+		}
+	} else {
+/*do nothing for Tx PIO mode*/
+	}
+	return i_ret;
+}
+
+int _btif_controller_rx_setup(p_mtk_btif p_btif)
+{
+	int i_ret = -1;
+
+	if (p_btif->rx_mode == BTIF_MODE_DMA) {
+		i_ret = _btif_rx_dma_setup(p_btif);
+		if (i_ret) {
+			BTIF_ERR_FUNC("_btif_tx_dma_setup failed, i_ret(%d),",
+				"set tx to PIO mode\n", i_ret);
+			i_ret = _btif_rx_pio_setup(p_btif);
+		}
+	} else {
+/*enable Tx PIO mode*/
+		i_ret = _btif_rx_pio_setup(p_btif);
+	}
+	return i_ret;
+}
+
+int _btif_controller_rx_free(p_mtk_btif p_btif)
+{
+	int i_ret = -1;
+
+	if (p_btif->rx_mode == BTIF_MODE_DMA) {
+		i_ret = _btif_rx_dma_free(p_btif);
+		if (i_ret) {
+			BTIF_ERR_FUNC("_btif_rx_dma_free failed, i_ret(%d)\n",
+				      i_ret);
+		}
+	} else {
+/*do nothing for Rx PIO mode*/
+	}
+	return i_ret;
+}
+
+int _btif_tx_pio_setup(p_mtk_btif p_btif)
+{
+	int i_ret = -1;
+	P_MTK_BTIF_INFO_STR p_btif_info = p_btif->p_btif_info;
+
+/*set Tx to PIO mode*/
+	p_btif->tx_mode = BTIF_MODE_PIO;
+/*enable Tx PIO mode*/
+	i_ret = hal_btif_tx_mode_ctrl(p_btif_info, BTIF_MODE_PIO);
+	return i_ret;
+}
+
+int _btif_rx_pio_setup(p_mtk_btif p_btif)
+{
+	int i_ret = -1;
+	P_MTK_BTIF_INFO_STR p_btif_info = p_btif->p_btif_info;
+	P_MTK_BTIF_IRQ_STR p_btif_irq = p_btif_info->p_irq;
+
+	p_btif->rx_mode = BTIF_MODE_PIO;
+/*Enable Rx IRQ*/
+	_btif_irq_ctrl(p_btif_irq, true);
+/*enable Rx PIO mode*/
+	i_ret = hal_btif_rx_mode_ctrl(p_btif_info, BTIF_MODE_PIO);
+	return i_ret;
+}
+
+int _btif_rx_dma_setup(p_mtk_btif p_btif)
+{
+	int i_ret = -1;
+	P_MTK_BTIF_INFO_STR p_btif_info = NULL;
+	P_MTK_BTIF_IRQ_STR p_btif_irq = NULL;
+	P_MTK_DMA_INFO_STR p_dma_info = p_btif->p_rx_dma->p_dma_info;
+
+	p_btif_info = p_btif->p_btif_info;
+	p_btif_irq = p_dma_info->p_irq;
+
+/*vFIFO reset*/
+	hal_btif_vfifo_reset(p_dma_info);
+
+	i_ret = hal_btif_dma_clk_ctrl(p_dma_info, CLK_OUT_ENABLE);
+	if (i_ret) {
+		BTIF_ERR_FUNC("hal_btif_dma_clk_ctrl failed, i_ret(%d),",
+			"set rx to pio mode\n", i_ret);
+/*DMA control failed set Rx to PIO mode*/
+		return _btif_rx_pio_setup(p_btif);
+	}
+/*hardware init*/
+	hal_btif_dma_hw_init(p_dma_info);
+
+	hal_btif_dma_rx_cb_reg(p_dma_info,
+			       (dma_rx_buf_write) btif_dma_rx_data_receiver);
+
+/*DMA controller enable*/
+	i_ret = hal_btif_dma_ctrl(p_dma_info, DMA_CTRL_ENABLE);
+	if (i_ret) {
+		BTIF_ERR_FUNC("hal_btif_dma_ctrl failed, i_ret(%d),",
+			"set rx to pio mode\n", i_ret);
+		hal_btif_dma_clk_ctrl(p_dma_info, CLK_OUT_DISABLE);
+/*DMA control failed set Rx to PIO mode*/
+		i_ret = _btif_rx_pio_setup(p_btif);
+	} else {
+/*enable Rx DMA mode*/
+		hal_btif_rx_mode_ctrl(p_btif_info, BTIF_MODE_DMA);
+
+/*DMA Rx IRQ register*/
+		_btif_irq_reg(p_btif_irq, btif_rx_dma_irq_handler, p_btif);
+#if 0
+/*Enable DMA Rx IRQ*/
+		_btif_irq_ctrl(p_btif_irq, true);
+#endif
+		BTIF_DBG_FUNC("succeed\n");
+	}
+	return i_ret;
+}
+
+int _btif_rx_dma_free(p_mtk_btif p_btif)
+{
+	P_MTK_DMA_INFO_STR p_dma_info = p_btif->p_rx_dma->p_dma_info;
+	P_MTK_BTIF_IRQ_STR p_irq = p_btif->p_rx_dma->p_dma_info->p_irq;
+
+	hal_btif_dma_rx_cb_reg(p_dma_info, (dma_rx_buf_write) NULL);
+	_btif_irq_free(p_irq, p_btif);
+/*disable BTIF Rx DMA channel*/
+	hal_btif_dma_ctrl(p_dma_info, DMA_CTRL_DISABLE);
+/*disable clock output*/
+	return hal_btif_dma_clk_ctrl(p_dma_info, CLK_OUT_DISABLE);
+}
+
+int _btif_tx_dma_setup(p_mtk_btif p_btif)
+{
+	int i_ret = -1;
+	P_MTK_BTIF_INFO_STR p_btif_info = p_btif->p_btif_info;
+	P_MTK_DMA_INFO_STR p_dma_info = p_btif->p_tx_dma->p_dma_info;
+	P_MTK_BTIF_IRQ_STR p_btif_irq = p_dma_info->p_irq;
+
+/*vFIFO reset*/
+	hal_btif_vfifo_reset(p_dma_info);
+
+	i_ret = hal_btif_dma_clk_ctrl(p_dma_info, CLK_OUT_ENABLE);
+	if (i_ret) {
+		BTIF_ERR_FUNC("hal_btif_dma_clk_ctrl failed, i_ret(%d)\n",
+			      i_ret);
+		return i_ret;
+	}
+/*DMA controller setup*/
+	hal_btif_dma_hw_init(p_dma_info);
+
+/*DMA HW Enable*/
+	i_ret = hal_btif_dma_ctrl(p_dma_info, DMA_CTRL_ENABLE);
+	if (i_ret) {
+		BTIF_ERR_FUNC("hal_btif_dma_ctrl failed, i_ret(%d),",
+			"set tx to pio mode\n", i_ret);
+
+#if !(MTK_BTIF_ENABLE_CLK_REF_COUNTER)
+		hal_btif_dma_clk_ctrl(p_dma_info, CLK_OUT_DISABLE);
+#endif
+
+		_btif_tx_pio_setup(p_btif);
+	} else {
+		hal_btif_tx_mode_ctrl(p_btif_info, BTIF_MODE_DMA);
+/*DMA Tx IRQ register*/
+		_btif_irq_reg(p_btif_irq, btif_tx_dma_irq_handler, p_btif);
+#if 0
+/*disable DMA Tx IRQ*/
+		_btif_irq_ctrl(p_btif_irq, false);
+#endif
+
+		BTIF_DBG_FUNC("succeed\n");
+	}
+	return i_ret;
+}
+
+int _btif_tx_dma_free(p_mtk_btif p_btif)
+{
+	P_MTK_DMA_INFO_STR p_dma_info = p_btif->p_tx_dma->p_dma_info;
+	P_MTK_BTIF_IRQ_STR p_irq = p_btif->p_tx_dma->p_dma_info->p_irq;
+
+	_btif_irq_free(p_irq, p_btif);
+/*disable BTIF Tx DMA channel*/
+	hal_btif_dma_ctrl(p_dma_info, DMA_CTRL_DISABLE);
+/*disable clock output*/
+	return hal_btif_dma_clk_ctrl(p_dma_info, CLK_OUT_DISABLE);
+}
+
+int btif_lpbk_ctrl(p_mtk_btif p_btif, bool flag)
+{
+	int i_ret = -1;
+
+/*hold state mechine lock*/
+	if (_btif_state_hold(p_btif))
+		return E_BTIF_INTR;
+#if 0
+	state = _btif_state_get(p_btif);
+	if (p_btif->enable && B_S_ON == state)
+		i_ret = _btif_lpbk_ctrl(p_btif, flag);
+	else
+		i_ret = E_BTIF_INVAL_STATE;
+#endif
+	i_ret = _btif_exit_dpidle(p_btif);
+	if (i_ret == 0)
+		i_ret = _btif_lpbk_ctrl(p_btif, flag);
+	else
+		i_ret = E_BTIF_INVAL_STATE;
+
+	BTIF_STATE_RELEASE(p_btif);
+	return i_ret;
+}
+
+int _btif_lpbk_ctrl(p_mtk_btif p_btif, bool flag)
+{
+	int i_ret = -1;
+
+	if (flag) {
+		i_ret = hal_btif_loopback_ctrl(p_btif->p_btif_info, true);
+		BTIF_DBG_FUNC("loopback function enabled\n");
+	} else {
+		i_ret = hal_btif_loopback_ctrl(p_btif->p_btif_info, false);
+		BTIF_DBG_FUNC("loopback function disabled\n");
+	}
+	if (i_ret == 0)
+		p_btif->lpbk_flag = flag;
+
+	return i_ret;
+}
+
+int btif_clock_ctrl(p_mtk_btif p_btif, int en)
+{
+	int i_ret = 0;
+	P_MTK_BTIF_INFO_STR p_btif_info = p_btif->p_btif_info;
+	ENUM_CLOCK_CTRL ctrl_flag = en == 0 ? CLK_OUT_DISABLE : CLK_OUT_ENABLE;
+
+	i_ret = hal_btif_clk_ctrl(p_btif_info, ctrl_flag);
+
+	if (p_btif->rx_mode == BTIF_MODE_DMA)
+		i_ret += hal_btif_dma_clk_ctrl(p_btif->p_rx_dma->p_dma_info, ctrl_flag);
+
+	if (p_btif->tx_mode == BTIF_MODE_DMA)
+		i_ret += hal_btif_dma_clk_ctrl(p_btif->p_tx_dma->p_dma_info, ctrl_flag);
+
+	return i_ret;
+}
+
+int _btif_controller_setup(p_mtk_btif p_btif)
+{
+	int i_ret = -1;
+	P_MTK_BTIF_INFO_STR p_btif_info = p_btif->p_btif_info;
+	P_MTK_BTIF_IRQ_STR p_btif_irq = p_btif_info->p_irq;
+
+/*BTIF rx buffer init*/
+/* memset(p_btif->rx_buf, 0, BTIF_RX_BUFFER_SIZE); */
+	BBS_INIT(&(p_btif->btif_buf));
+/************************************************/
+	hal_btif_rx_cb_reg(p_btif_info,
+			   (btif_rx_buf_write) btif_pio_rx_data_receiver);
+
+	i_ret = hal_btif_clk_ctrl(p_btif_info, CLK_OUT_ENABLE);
+	if (i_ret) {
+		BTIF_ERR_FUNC("hal_btif_clk_ctrl failed, i_ret(%d)\n", i_ret);
+		return i_ret;
+	}
+/*BTIF controller init*/
+	i_ret = hal_btif_hw_init(p_btif_info);
+	if (i_ret) {
+		hal_btif_clk_ctrl(p_btif_info, CLK_OUT_DISABLE);
+		BTIF_ERR_FUNC("hal_btif_hw_init failed, i_ret(%d)\n", i_ret);
+		return i_ret;
+	}
+	_btif_lpbk_ctrl(p_btif, p_btif->lpbk_flag);
+/*BTIF IRQ register*/
+	i_ret = _btif_irq_reg(p_btif_irq, btif_irq_handler, p_btif);
+	if (i_ret) {
+		hal_btif_clk_ctrl(p_btif_info, CLK_OUT_DISABLE);
+
+		BTIF_ERR_FUNC("_btif_irq_reg failed, i_ret(%d)\n", i_ret);
+		return i_ret;
+	}
+
+/*disable IRQ*/
+	_btif_irq_ctrl(p_btif_irq, false);
+	i_ret = 0;
+	BTIF_DBG_FUNC("succeed\n");
+	return i_ret;
+}
+
+int _btif_controller_free(p_mtk_btif p_btif)
+{
+/*No need to set BTIF to PIO mode, only enable BTIF CG*/
+	hal_btif_rx_cb_reg(p_btif->p_btif_info, (btif_rx_buf_write) NULL);
+	_btif_irq_free(p_btif->p_btif_info->p_irq, p_btif);
+	return hal_btif_clk_ctrl(p_btif->p_btif_info, CLK_OUT_DISABLE);
+}
+
+int _btif_init(p_mtk_btif p_btif)
+{
+	int i_ret = 0;
+
+	i_ret = _btif_controller_setup(p_btif);
+	if (i_ret) {
+		BTIF_ERR_FUNC("_btif_controller_init failed, i_ret(%d)\n",
+			      i_ret);
+		_btif_dpidle_notify_ctrl(p_btif, BTIF_DPIDLE_ENABLE);
+		BTIF_STATE_RELEASE(p_btif);
+		return i_ret;
+	}
+
+	i_ret = _btif_controller_tx_setup(p_btif);
+	if (i_ret) {
+		BTIF_ERR_FUNC("_btif_controller_tx_setup failed, i_ret(%d)\n",
+			      i_ret);
+		_btif_controller_free(p_btif);
+		_btif_dpidle_notify_ctrl(p_btif, BTIF_DPIDLE_ENABLE);
+		BTIF_STATE_RELEASE(p_btif);
+		return i_ret;
+	}
+
+	i_ret = _btif_controller_rx_setup(p_btif);
+	if (i_ret) {
+		BTIF_ERR_FUNC("_btif_controller_tx_setup failed, i_ret(%d)\n",
+			      i_ret);
+		_btif_controller_tx_free(p_btif);
+		_btif_controller_free(p_btif);
+		_btif_dpidle_notify_ctrl(p_btif, BTIF_DPIDLE_ENABLE);
+		BTIF_STATE_RELEASE(p_btif);
+		return i_ret;
+	}
+	return i_ret;
+}
+
+int btif_open(p_mtk_btif p_btif)
+{
+	int i_ret = -1;
+
+	if (p_btif->enable)
+		return E_BTIF_ALREADY_OPEN;
+
+/*hold state mechine lock*/
+	if (_btif_state_hold(p_btif))
+		return E_BTIF_INTR;
+/*disable deepidle*/
+	_btif_dpidle_notify_ctrl(p_btif, BTIF_DPIDLE_DISABLE);
+
+	i_ret = _btif_init(p_btif);
+	if (i_ret == 0) {
+		/*set BTIF's enable flag*/
+		p_btif->enable = true;
+		_btif_state_set(p_btif, B_S_ON);
+	} else {
+		_btif_dpidle_notify_ctrl(p_btif, BTIF_DPIDLE_ENABLE);
+	}
+	btif_log_buf_reset(&p_btif->tx_log);
+	btif_log_buf_reset(&p_btif->rx_log);
+
+	BTIF_STATE_RELEASE(p_btif);
+
+	BTIF_DBG_FUNC("BTIF's Tx Mode:%d, Rx Mode(%d)\n",
+		       p_btif->tx_mode, p_btif->rx_mode);
+	return i_ret;
+}
+
+int btif_close(p_mtk_btif p_btif)
+{
+	int i_ret = 0;
+
+	if (!(p_btif->enable))
+		return E_BTIF_NOT_OPEN;
+
+/*hold state mechine lock*/
+	if (_btif_state_hold(p_btif))
+		return E_BTIF_INTR;
+/*always set state back to B_S_ON before do close operation*/
+	_btif_exit_dpidle(p_btif);
+/*set BTIF's state to disable state*/
+	p_btif->enable = false;
+
+	_btif_controller_free(p_btif);
+	_btif_controller_tx_free(p_btif);
+	_btif_controller_rx_free(p_btif);
+
+/*reset BTIF's rx_cb function*/
+	p_btif->rx_cb = NULL;
+	p_btif->rx_notify = NULL;
+	p_btif->lpbk_flag = false;
+
+/*set state mechine to B_S_OFF*/
+	_btif_state_set(p_btif, B_S_OFF);
+
+	btif_log_buf_disable(&p_btif->tx_log);
+	btif_log_buf_disable(&p_btif->rx_log);
+
+	BTIF_STATE_RELEASE(p_btif);
+
+	return i_ret;
+}
+
+int _btif_exit_dpidle(p_mtk_btif p_btif)
+{
+	int i_ret = -1;
+	ENUM_BTIF_STATE state = B_S_MAX;
+
+	state = _btif_state_get(p_btif);
+	switch (state) {
+	case B_S_DPIDLE:
+		i_ret = _btif_exit_dpidle_from_dpidle(p_btif);
+		break;
+	case B_S_SUSPEND:
+/*in suspend state, need to do reinit of btif*/
+		i_ret = _btif_exit_dpidle_from_sus(p_btif);
+		break;
+	case B_S_OFF:
+		i_ret = _btif_init(p_btif);
+		break;
+	case B_S_ON:
+		i_ret = 0;	/* for btif_close case */
+		break;
+	default:
+		i_ret = E_BTIF_INVAL_PARAM;
+		BTIF_INFO_FUNC("invalid state change:%d->\n", state, B_S_ON);
+		break;
+	}
+
+	if (i_ret == 0)
+		i_ret = _btif_state_set(p_btif, B_S_ON);
+	return i_ret;
+}
+
+int btif_exit_dpidle(p_mtk_btif p_btif)
+{
+	int i_ret = 0;
+
+/*hold state mechine lock*/
+	if (_btif_state_hold(p_btif))
+		return E_BTIF_INTR;
+	i_ret = _btif_exit_dpidle(p_btif);
+	BTIF_STATE_RELEASE(p_btif);
+	return i_ret;
+}
+
+int _btif_enter_dpidle(p_mtk_btif p_btif)
+{
+	int i_ret = 0;
+	ENUM_BTIF_STATE state = B_S_MAX;
+
+	state = _btif_state_get(p_btif);
+	if (state == B_S_ON) {
+		i_ret = _btif_enter_dpidle_from_on(p_btif);
+	} else if (state == B_S_SUSPEND) {
+		/*do reinit and enter deepidle*/
+		i_ret = _btif_enter_dpidle_from_sus(p_btif);
+	} else if (state == B_S_DPIDLE) {
+		/*do nothing*/
+		i_ret = 0;
+	} else {
+		BTIF_WARN_FUNC("operation is not allowed, current state:%d\n",
+			       state);
+		i_ret = E_BTIF_INVAL_STATE;
+	}
+/*anyway, set to B_S_DPIDLE state*/
+	if (i_ret == 0)
+		i_ret = _btif_state_set(p_btif, B_S_DPIDLE);
+	return i_ret;
+}
+
+int btif_enter_dpidle(p_mtk_btif p_btif)
+{
+	int i_ret = 0;
+
+/*hold state mechine lock*/
+	if (_btif_state_hold(p_btif))
+		return E_BTIF_INTR;
+	i_ret = _btif_enter_dpidle(p_btif);
+	BTIF_STATE_RELEASE(p_btif);
+	return i_ret;
+}
+
+int _btif_exit_dpidle_from_dpidle(p_mtk_btif p_btif)
+{
+	int i_ret = 0;
+
+/*in dpidle state, only need to open related clock*/
+	if (p_btif->tx_mode == BTIF_MODE_DMA) {
+		/*enable BTIF Tx DMA's clock*/
+		i_ret += hal_btif_dma_clk_ctrl(p_btif->p_tx_dma->p_dma_info,
+					       CLK_OUT_ENABLE);
+	}
+	if (p_btif->rx_mode == BTIF_MODE_DMA) {
+		/*enable BTIF Rx DMA's clock*/
+		i_ret += hal_btif_dma_clk_ctrl(p_btif->p_rx_dma->p_dma_info,
+					       CLK_OUT_ENABLE);
+	}
+/*enable BTIF's clock*/
+	i_ret += hal_btif_clk_ctrl(p_btif->p_btif_info, CLK_OUT_ENABLE);
+
+	if (i_ret != 0)
+		BTIF_WARN_FUNC("failed, i_ret:%d\n", i_ret);
+	return i_ret;
+}
+
+int _btif_exit_dpidle_from_sus(p_mtk_btif p_btif)
+{
+/*in suspend state, need to do driver re-init*/
+
+	int i_ret = _btif_init(p_btif);
+
+	return i_ret;
+}
+
+int _btif_enter_dpidle_from_sus(p_mtk_btif p_btif)
+{
+/*do driiver reinit*/
+	int i_ret = _btif_init(p_btif);
+
+	if (i_ret == 0)
+		i_ret = _btif_enter_dpidle_from_on(p_btif);
+	return i_ret;
+}
+
+int _btif_enter_dpidle_from_on(p_mtk_btif p_btif)
+{
+#define MAX_WAIT_TIME_MS 5000
+/*
+ * this max wait time cannot exceed 12s,
+ * because dpm will monitor each device's
+ * resume/suspend process by start up a watch dog timer of 12s
+ * incase of one driver's suspend/resume process block other device's suspend/resume
+ */
+	int i_ret = 0;
+	unsigned int retry = 0;
+	unsigned int wait_period = 1;
+	unsigned int max_retry = MAX_WAIT_TIME_MS / wait_period;
+	struct timeval timer_start;
+	struct timeval timer_now;
+
+	do_gettimeofday(&timer_start);
+
+	while ((!_btif_is_tx_complete(p_btif)) && (retry < max_retry)) {
+		do_gettimeofday(&timer_now);
+		if ((MAX_WAIT_TIME_MS/1000) <= (timer_now.tv_sec - timer_start.tv_sec)) {
+			BTIF_WARN_FUNC("max retry timer expired, timer_start.tv_sec:%d, timer_now.tv_sec:%d,",
+				"retry:%d\n", timer_start.tv_sec, timer_now.tv_sec, retry);
+			break;
+		}
+		msleep(wait_period);
+		retry++;
+	}
+
+	if (retry < max_retry) {
+		if (p_btif->tx_mode == BTIF_MODE_DMA) {
+			/*disable BTIF Tx DMA's clock*/
+			i_ret +=
+			    hal_btif_dma_clk_ctrl(p_btif->p_tx_dma->p_dma_info,
+						  CLK_OUT_DISABLE);
+		}
+		if (p_btif->rx_mode == BTIF_MODE_DMA) {
+			/*disable BTIF Rx DMA's clock*/
+			i_ret +=
+			    hal_btif_dma_clk_ctrl(p_btif->p_rx_dma->p_dma_info,
+						  CLK_OUT_DISABLE);
+		}
+/*disable BTIF's clock*/
+		i_ret +=
+		    hal_btif_clk_ctrl(p_btif->p_btif_info, CLK_OUT_DISABLE);
+
+		if (i_ret)
+			BTIF_WARN_FUNC("failed, i_ret:%d\n", i_ret);
+	} else
+		i_ret = -1;
+
+	return i_ret;
+}
+
+int _btif_dpidle_notify_ctrl(p_mtk_btif p_btif, ENUM_BTIF_DPIDLE_CTRL en_flag)
+{
+/*call WCP's API to control deepidle's enable/disable*/
+	if (en_flag == BTIF_DPIDLE_DISABLE)
+		hal_btif_pm_ops(p_btif->p_btif_info, BTIF_PM_DPIDLE_DIS);
+	else
+		hal_btif_pm_ops(p_btif->p_btif_info, BTIF_PM_DPIDLE_EN);
+
+	return 0;
+}
+
+int btif_rx_cb_reg(p_mtk_btif p_btif, MTK_WCN_BTIF_RX_CB rx_cb)
+{
+	if (p_btif->rx_cb) {
+		BTIF_WARN_FUNC
+		    ("rx cb already exist, rewrite from (0x%p) to (0x%p)\n",
+		     p_btif->rx_cb, rx_cb);
+	}
+	p_btif->rx_cb = rx_cb;
+
+	return 0;
+}
+
+int btif_raise_wak_signal(p_mtk_btif p_btif)
+{
+	int i_ret = 0;
+	P_MTK_BTIF_INFO_STR p_btif_info = p_btif->p_btif_info;
+
+#if MTK_BTIF_ENABLE_CLK_REF_COUNTER
+	hal_btif_clk_ctrl(p_btif->p_btif_info, CLK_OUT_ENABLE);
+#endif
+
+	i_ret = hal_btif_raise_wak_sig(p_btif_info);
+
+#if MTK_BTIF_ENABLE_CLK_REF_COUNTER
+	hal_btif_clk_ctrl(p_btif_info, CLK_OUT_DISABLE);
+#endif
+	return i_ret;
+}
+
+bool _btif_is_tx_complete(p_mtk_btif p_btif)
+{
+	bool b_ret = false;
+	ENUM_BTIF_MODE tx_mode = p_btif->tx_mode;
+
+/*
+ * make sure BTIF tx finished in PIO mode
+ * make sure BTIF tx finished and DMA tx finished in DMA mode
+ */
+	if (tx_mode == BTIF_MODE_DMA) {
+		b_ret = hal_dma_is_tx_complete(p_btif->p_tx_dma->p_dma_info);
+		if (b_ret == false) {
+			BTIF_DBG_FUNC("Tx DMA is not finished\n");
+			return b_ret;
+		}
+	}
+
+	b_ret = hal_btif_is_tx_complete(p_btif->p_btif_info);
+	if (b_ret == false) {
+		BTIF_DBG_FUNC("BTIF Tx is not finished\n");
+		return b_ret;
+	}
+	b_ret = true;
+	return b_ret;
+}
+
+/*--------------------------------Functions-------------------------------------------*/
+
+#if ENABLE_BTIF_TX_DMA
+static int _btif_vfifo_init(p_mtk_btif_dma p_dma)
+{
+	P_DMA_VFIFO p_vfifo = NULL;
+	struct device *dev = NULL;
+	p_mtk_btif p_btif = NULL;
+
+	if (p_dma == NULL) {
+		BTIF_ERR_FUNC("p_dma is NULL\n");
+		return E_BTIF_INVAL_PARAM;
+	}
+
+	p_btif = (p_mtk_btif)p_dma->p_btif;
+
+	if (p_btif == NULL) {
+		BTIF_ERR_FUNC("invalid parameter: p_btif(0x%p)\n", p_btif);
+		return E_BTIF_INVAL_PARAM;
+	}
+
+	dev = (struct device *)p_btif->private_data;
+	if (dev == NULL)
+		BTIF_WARN_FUNC("Null dev pointer!!!!\n");
+
+	p_vfifo = p_dma->p_dma_info->p_vfifo;
+	if (p_vfifo->p_vir_addr != NULL) {
+		BTIF_ERR_FUNC
+		    ("BTIF vFIFO memory already allocated, do nothing\n");
+		return E_BTIF_BAD_POINTER;
+	}
+
+/*vFIFO memory allocation*/
+	p_vfifo->p_vir_addr = dma_alloc_coherent(dev,
+						  p_vfifo->vfifo_size,
+						  &p_vfifo->phy_addr, GFP_DMA | GFP_DMA32);
+	if (p_vfifo->p_vir_addr == NULL) {
+		BTIF_ERR_FUNC("alloc vFIFO memory for BTIF failed\n");
+		return E_BTIF_FAIL;
+	}
+
+	if (sizeof(dma_addr_t) == sizeof(unsigned long long))
+		BTIF_INFO_FUNC("alloc vFIFO for BTIF succeed in arch64,vir addr:0x%p,",
+		"phy addr:0x%llx\n", p_vfifo->p_vir_addr, p_vfifo->phy_addr);
+	else
+		BTIF_INFO_FUNC("alloc vFIFO for BTIF succeed in arch32,vir addr:0x%p,",
+		"phy addr:0x%08x\n",	p_vfifo->p_vir_addr, p_vfifo->phy_addr);
+
+	return 0;
+}
+#endif
+#if ENABLE_BTIF_TX_DMA
+static int _btif_vfifo_deinit(p_mtk_btif_dma p_dma)
+{
+	P_DMA_VFIFO p_vfifo = NULL;
+	struct device *dev = NULL;
+	p_mtk_btif p_btif = NULL;
+
+	if (p_dma == NULL) {
+		BTIF_ERR_FUNC("p_dma is NULL\n");
+		return E_BTIF_INVAL_PARAM;
+	}
+
+
+	p_btif = (p_mtk_btif)p_dma->p_btif;
+	if (p_btif == NULL) {
+		BTIF_ERR_FUNC("invalid parameter: p_btif(0x%p)\n", p_btif);
+		return E_BTIF_INVAL_PARAM;
+	}
+
+	dev = (struct device *)p_btif->private_data;
+	if (dev == NULL)
+		BTIF_WARN_FUNC("Null dev pointer!!!!\n");
+
+	p_vfifo = p_dma->p_dma_info->p_vfifo;
+
+/*free DMA memory if allocated successfully before*/
+	if (p_vfifo->p_vir_addr != NULL) {
+		dma_free_coherent(dev,
+				  p_vfifo->vfifo_size,
+				  p_vfifo->p_vir_addr, p_vfifo->phy_addr);
+		p_vfifo->p_vir_addr = NULL;
+	}
+
+	return 0;
+}
+#endif
+
+static int _btif_state_init(p_mtk_btif p_btif)
+{
+	if (p_btif == NULL) {
+		BTIF_ERR_FUNC("p_btif is NULL\n");
+		return E_BTIF_INVAL_PARAM;
+	}
+	p_btif->state = B_S_OFF;
+	mutex_init(&(p_btif->state_mtx));
+
+	return 0;
+}
+
+static int _btif_state_hold(p_mtk_btif p_btif)
+{
+	return mutex_lock_killable(&(p_btif->state_mtx));
+}
+
+static int _btif_state_set(p_mtk_btif p_btif, ENUM_BTIF_STATE state)
+{
+/*chaozhong: To do: need to finished state mechine here*/
+	int i_ret = 0;
+	int ori_state = p_btif->state;
+
+	if (ori_state == state) {
+		BTIF_INFO_FUNC("already in %s state\n", g_state[state]);
+		return i_ret;
+	}
+	if ((state >= B_S_OFF) && (state < B_S_MAX)) {
+		BTIF_DBG_FUNC("%s->%s request\n", g_state[ori_state],
+			      g_state[state]);
+		if (state == B_S_ON)
+			_btif_dpidle_notify_ctrl(p_btif, BTIF_DPIDLE_DISABLE);
+		switch (ori_state) {
+		case B_S_ON:
+/*B_S_ON can only be switched to B_S_OFF, B_S_SUSPEND and B_S_DPIDLE*/
+/*B_S_ON->B_S_OFF : do nothing here*/
+/*
+ * B_S_ON->B_S_DPLE : disable clock backup
+ * BTIF and DMA controller's register if necessary
+ */
+			if (state == B_S_DPIDLE) {
+				/*clock controlled id done in _btif_enter_dpidle*/
+				p_btif->state = state;
+				i_ret = 0;
+			} else if (state == B_S_OFF) {
+				/*clock controlled is done in btif_close*/
+				p_btif->state = state;
+				i_ret = 0;
+			} else if (state == B_S_SUSPEND) {
+				/*clock controlled is done in btif_close*/
+				p_btif->state = state;
+				i_ret = 0;
+			} else {
+				BTIF_ERR_FUNC("%s->%s is not allowed\n",
+					      g_state[ori_state],
+					      g_state[state]);
+				i_ret = E_BTIF_INVAL_STATE;
+			}
+			break;
+		case B_S_DPIDLE:
+/*B_S_DPIDLE can only be switched to B_S_ON and B_S_SUSPEND*/
+/*B_S_DPIDLE-> B_S_ON: do nothing for this moment*/
+/*
+ * B_S_DPIDLE-> B_S_SUSPEND:
+ * disable clock backup BTIF and DMA controller's register if necessary
+ */
+			if (state == B_S_ON) {
+				/*clock controlled id done in _btif_exit_dpidle*/
+				p_btif->state = state;
+				i_ret = 0;
+			} else if (state == B_S_SUSPEND) {
+				/*clock controlled is done in _btif_exit_dpidle*/
+				p_btif->state = state;
+				i_ret = 0;
+			} else {
+				BTIF_ERR_FUNC("%s->%s is not allowed\n",
+					      g_state[ori_state],
+					      g_state[state]);
+				i_ret = E_BTIF_INVAL_STATE;
+			}
+			break;
+
+		case B_S_SUSPEND:
+/*B_S_SUSPEND can be switched to B_S_IDLE and B_S_ON*/
+/*reinit BTIF controller and DMA controller*/
+			if (state == B_S_DPIDLE) {
+				/*
+				 * system call resume API, do resume operation,
+				 * change to deepidle state
+				 */
+				p_btif->state = state;
+				i_ret = 0;
+			} else if (state == B_S_ON) {
+				/*
+				 * when stp want to send data before
+				 * system do resume operation
+				 */
+				p_btif->state = state;
+				i_ret = 0;
+			} else {
+				BTIF_ERR_FUNC("%s->%s is not allowed\n",
+					      g_state[ori_state],
+					      g_state[state]);
+				i_ret = E_BTIF_INVAL_STATE;
+			}
+			break;
+
+		case B_S_OFF:{
+/*B_S_OFF can only be switched to B_S_ON*/
+				if (state == B_S_ON) {
+					/*clock controlled is done in btif_open*/
+					p_btif->state = state;
+					i_ret = 0;
+				} else {
+					BTIF_ERR_FUNC("%s->%s is not allowed\n",
+						      g_state[ori_state],
+						      g_state[state]);
+					i_ret = E_BTIF_INVAL_STATE;
+				}
+			}
+			break;
+		default:
+/*no this possibility*/
+			BTIF_ERR_FUNC
+			    ("state change request is not allowed, this should never happen\n");
+			break;
+		}
+
+		if (state != B_S_ON)
+			_btif_dpidle_notify_ctrl(p_btif, BTIF_DPIDLE_ENABLE);
+
+	} else {
+		i_ret = E_BTIF_INVAL_PARAM;
+		BTIF_ERR_FUNC("invalid state:%d, do nothing\n", state);
+	}
+	return i_ret;
+}
+
+static ENUM_BTIF_STATE _btif_state_get(p_mtk_btif p_btif)
+{
+	return p_btif->state;
+}
+
+static int _btif_state_release(p_mtk_btif p_btif)
+{
+	int i_ret = 0;
+
+	BTIF_MUTEX_UNLOCK(&(p_btif->state_mtx));
+	return i_ret;
+}
+
+static int _btif_state_deinit(p_mtk_btif p_btif)
+{
+	if (p_btif == NULL) {
+		BTIF_ERR_FUNC("p_btif is NULL\n");
+		return E_BTIF_INVAL_PARAM;
+	}
+	p_btif->state = B_S_OFF;
+	mutex_destroy(&(p_btif->state_mtx));
+
+	return 0;
+}
+
+static int btif_rx_data_consummer(p_mtk_btif p_btif)
+{
+	unsigned int length = 0;
+	unsigned char *p_buf = NULL;
+/*get BTIF rx buffer's information*/
+	p_btif_buf_str p_bbs = &(p_btif->btif_buf);
+/*
+ * wr_idx of btif_buf may be modified in IRQ handler,
+ * in order not to be effected by case in which irq interrupt this operation,
+ * we record wr_idx here
+ */
+	unsigned int wr_idx = p_bbs->wr_idx;
+
+	length = BBS_COUNT_CUR(p_bbs, wr_idx);
+
+/*make sure length of rx buffer data > 0*/
+	do {
+		if (length > 0) {
+			/*
+			 * check if rx_cb empty or not, if registered ,
+			 * call user's rx callback to handle these data
+			 */
+			if (p_btif->rx_cb) {
+				if (p_bbs->rd_idx <= wr_idx) {
+					p_buf = BBS_PTR(p_bbs, p_bbs->rd_idx);
+					/* p_buf = &(p_bbs->buf[p_bbs->rd_idx]); */
+					/* length = BBS_COUNT(p_bbs); */
+					length = (wr_idx >= (p_bbs)->rd_idx) ?
+					    (wr_idx - (p_bbs)->rd_idx) :
+					    BBS_SIZE(p_bbs) -
+					    ((p_bbs)->rd_idx - wr_idx);
+					if (p_btif->rx_cb)
+						(*(p_btif->rx_cb)) (p_buf, length);
+					else
+						BTIF_ERR_FUNC("p_btif->rx_cb is NULL\n");
+					/*update rx data read index*/
+					p_bbs->rd_idx = wr_idx;
+				} else {
+					unsigned int len_tail =
+					    BBS_SIZE(p_bbs) - (p_bbs)->rd_idx;
+					/*p_buf = &(p_bbs->buf[p_bbs->->rd_idx]);*/
+					p_buf = BBS_PTR(p_bbs, p_bbs->rd_idx);
+					if (p_btif->rx_cb)
+						(*(p_btif->rx_cb)) (p_buf, len_tail);
+					else
+						BTIF_ERR_FUNC("p_btif->rx_cb is NULL\n");
+					length = BBS_COUNT_CUR(p_bbs, wr_idx);
+					length -= len_tail;
+					/*p_buf = &(p_bbs->buf[0]);*/
+					p_buf = BBS_PTR(p_bbs, 0);
+					if (p_btif->rx_cb)
+						(*(p_btif->rx_cb)) (p_buf, length);
+					else
+						BTIF_ERR_FUNC("p_btif->rx_cb is NULL\n");
+					/*update rx data read index*/
+					p_bbs->rd_idx = wr_idx;
+				}
+			} else if (p_btif->rx_notify != NULL) {
+				(*p_btif->rx_notify) ();
+			} else {
+				BTIF_WARN_FUNC
+				    ("p_btif:0x%p, both rx_notify and rx_cb are NULL\n",
+				     p_btif);
+				break;
+			}
+		} else {
+			BTIF_DBG_FUNC("length:%d\n", length);
+			break;
+		}
+		wr_idx = p_bbs->wr_idx;
+		length = BBS_COUNT_CUR(p_bbs, wr_idx);
+	} while (1);
+	return length;
+}
+
+#if BTIF_RXD_BE_BLOCKED_DETECT
+static int mtk_btif_rxd_be_blocked_by_timer(void)
+{
+	int ret = 0;
+	int counter = 0;
+	unsigned int i;
+	struct timeval now;
+	int time_gap[MAX_BTIF_RXD_TIME_REC];
+
+	do_gettimeofday(&now);
+
+	for (i = 0; i < MAX_BTIF_RXD_TIME_REC; i++) {
+		BTIF_INFO_FUNC("btif_rxd_time_stamp[%d]=%d.%d\n", i,
+			btif_rxd_time_stamp[i].tv_sec, btif_rxd_time_stamp[i].tv_usec);
+		if (now.tv_sec >= btif_rxd_time_stamp[i].tv_sec) {
+			time_gap[i] = now.tv_sec - btif_rxd_time_stamp[i].tv_sec;
+			time_gap[i] *= 1000000; /*second*/
+			if (now.tv_usec >= btif_rxd_time_stamp[i].tv_usec)
+				time_gap[i] += now.tv_usec - btif_rxd_time_stamp[i].tv_usec;
+			else
+				time_gap[i] += 1000000 - now.tv_usec + btif_rxd_time_stamp[i].tv_usec;
+
+			if (time_gap[i] > 1000000)
+				counter++;
+			BTIF_INFO_FUNC("time_gap[%d]=%d,counter:%d\n", i, time_gap[i], counter);
+		} else {
+			time_gap[i] = 0;
+			BTIF_ERR_FUNC("abnormal case now:%d < time_stamp[%d]:%d\n", now.tv_sec,
+							i, btif_rxd_time_stamp[i].tv_usec);
+		}
+	}
+	if (counter > (MAX_BTIF_RXD_TIME_REC - 2))
+		ret = 1;
+	return ret;
+}
+static int mtk_btif_rxd_be_blocked_by_data(void)
+{
+	unsigned int out_index = 0;
+	unsigned int in_index = 0;
+	unsigned int dump_size = 0;
+	unsigned int len = 0;
+	unsigned long flags;
+	unsigned int sync_pkt_n = 0;
+	P_BTIF_LOG_BUF_T p_log_buf = NULL;
+	P_BTIF_LOG_QUEUE_T p_log_que = NULL;
+	p_mtk_btif p_btif = &(g_btif[0]);
+
+	p_log_que = &p_btif->rx_log;
+	spin_lock_irqsave(&p_log_que->lock, flags);
+	in_index = p_log_que->in;
+	dump_size = p_log_que->size;
+	out_index = p_log_que->size >=
+	BTIF_LOG_ENTRY_NUM ? in_index : (BTIF_LOG_ENTRY_NUM -
+					 p_log_que->size +
+					 in_index) % BTIF_LOG_ENTRY_NUM;
+	if (dump_size != 0) {
+		while (dump_size--) {
+			p_log_buf = p_log_que->p_queue[0] + out_index;
+			len = p_log_buf->len;
+			if (len > BTIF_LOG_SZ)
+				len = BTIF_LOG_SZ;
+			if ((0x7f == *(p_log_buf->buffer)) && (0x7f == *(p_log_buf->buffer + 1))) {
+				sync_pkt_n++;
+				BTIF_INFO_FUNC("tx pkt_count:%d is sync pkt\n", out_index);
+			}
+			out_index++;
+			out_index %= BTIF_LOG_ENTRY_NUM;
+		}
+	}
+	if (sync_pkt_n == 0)
+		BTIF_ERR_FUNC("there is no sync pkt in BTIF buffer\n");
+	else
+		BTIF_ERR_FUNC("there are %d sync pkt in BTIF buffer\n", sync_pkt_n);
+	spin_unlock_irqrestore(&p_log_que->lock, flags);
+	return sync_pkt_n;
+}
+
+int mtk_btif_rxd_be_blocked_flag_get(void)
+{
+	int ret = 0;
+	int condition1 = 0, condition2 = 0;
+
+	condition1 = mtk_btif_rxd_be_blocked_by_timer();
+	condition2 = mtk_btif_rxd_be_blocked_by_data();
+	if (condition1 && condition2) {
+		BTIF_ERR_FUNC("btif_rxd thread be blocked too long!\n");
+		ret = 1;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(mtk_btif_rxd_be_blocked_flag_get);
+#endif
+static int btif_rx_thread(void *p_data)
+{
+#if BTIF_RXD_BE_BLOCKED_DETECT
+	unsigned int i = 0;
+#endif
+	p_mtk_btif p_btif = (p_mtk_btif)p_data;
+
+
+	while (1) {
+		wait_for_completion_interruptible(&p_btif->rx_comp);
+
+		if (kthread_should_stop()) {
+			BTIF_WARN_FUNC("btif rx thread stoping ...\n");
+			break;
+		}
+#ifdef BTIF_RXD_BE_BLOCKED_DETECT
+		do_gettimeofday(&btif_rxd_time_stamp[i]);
+		i++;
+		if (i >= MAX_BTIF_RXD_TIME_REC)
+			i = 0;
+#endif
+		btif_rx_data_consummer(p_btif);
+	}
+	return 0;
+}
+
+static void btif_rx_worker(struct work_struct *p_work)
+{
+/*get mtk_btif's pointer*/
+	p_mtk_btif p_btif = container_of(p_work, mtk_btif, rx_work);
+
+	BTIF_DBG_FUNC("p_btif:0x%p\n", p_btif);
+/*lock rx_mutex*/
+
+	if (mutex_lock_killable(&(p_btif->rx_mtx))) {
+		BTIF_ERR_FUNC("mutex_lock_killable return failed\n");
+		return;
+	}
+	btif_rx_data_consummer(p_btif);
+	BTIF_MUTEX_UNLOCK(&(p_btif->rx_mtx));
+}
+
+static void btif_tx_worker(struct work_struct *p_work)
+{
+	int i_ret = 0;
+	int leng_sent = 0;
+/*tx fifo out*/
+	int how_much_get = 0;
+	unsigned char local_buf[384];
+
+/*get mtk_btif's pointer*/
+	p_mtk_btif p_btif = container_of(p_work, mtk_btif, tx_work);
+
+	BTIF_DBG_FUNC("p_btif:0x%p\n", p_btif);
+
+	if (mutex_lock_killable(&(p_btif->tx_mtx))) {
+		BTIF_ERR_FUNC("mutex_lock_killable return failed\n");
+		return;
+	}
+	how_much_get =
+	    kfifo_out(p_btif->p_tx_fifo, local_buf, sizeof(local_buf));
+	do {
+		while (leng_sent < how_much_get) {
+			i_ret = _btif_send_data(p_btif,
+						local_buf + leng_sent,
+						how_much_get - leng_sent);
+			if (i_ret > 0) {
+				leng_sent += i_ret;
+			} else if (i_ret == 0) {
+				BTIF_WARN_FUNC
+				    ("_btif_send_data return 0, retry\n");
+			} else {
+				BTIF_WARN_FUNC
+				    ("btif send data fail,reset tx fifo, i_ret(%d)\n",
+				     i_ret);
+				kfifo_reset(p_btif->p_tx_fifo);
+				break;
+			}
+		}
+		how_much_get =
+		    kfifo_out(p_btif->p_tx_fifo, local_buf, sizeof(local_buf));
+		leng_sent = 0;
+	} while (how_much_get > 0);
+	BTIF_MUTEX_UNLOCK(&(p_btif->tx_mtx));
+}
+
+static void btif_rx_tasklet(unsigned long func_data)
+{
+	unsigned long flags;
+/*get mtk_btif's pointer*/
+	p_mtk_btif p_btif = (p_mtk_btif) func_data;
+
+	BTIF_DBG_FUNC("p_btif:0x%p\n", p_btif);
+/*lock rx_spinlock*/
+	spin_lock_irqsave(&p_btif->rx_tasklet_spinlock, flags);
+	btif_rx_data_consummer(p_btif);
+	spin_unlock_irqrestore(&p_btif->rx_tasklet_spinlock, flags);
+}
+
+static int _btif_tx_ctx_init(p_mtk_btif p_btif)
+{
+	int i_ret = -1;
+
+	if (p_btif == NULL) {
+		BTIF_ERR_FUNC("p_btif is NULL\n");
+		return E_BTIF_INVAL_PARAM;
+	}
+
+	if (p_btif->tx_ctx == BTIF_TX_SINGLE_CTX) {
+		p_btif->p_tx_wq = create_singlethread_workqueue("btif_txd");
+
+		if (!(p_btif->p_tx_wq)) {
+			BTIF_ERR_FUNC
+			    ("create_singlethread_workqueue for tx thread fail\n");
+			i_ret = -ENOMEM;
+			goto btm_init_err;
+		}
+		mutex_init(&(p_btif->tx_mtx));
+/* init btif tx work */
+		INIT_WORK(&(p_btif->tx_work), btif_tx_worker);
+		BTIF_INFO_FUNC("btif_tx_worker init succeed\n");
+
+		p_btif->p_tx_fifo = kzalloc(sizeof(struct kfifo), GFP_ATOMIC);
+		if (p_btif->p_tx_fifo == NULL) {
+			i_ret = -ENOMEM;
+			BTIF_ERR_FUNC("kzalloc for p_btif->p_tx_fifo failed\n");
+			goto btm_init_err;
+		}
+
+		i_ret = kfifo_alloc(p_btif->p_tx_fifo,
+				    BTIF_TX_FIFO_SIZE, GFP_ATOMIC);
+		if (i_ret != 0) {
+			BTIF_ERR_FUNC("kfifo_alloc failed, errno(%d)\n", i_ret);
+			i_ret = -ENOMEM;
+			goto btm_init_err;
+		}
+	} else if (p_btif->tx_ctx == BTIF_TX_USER_CTX) {
+		BTIF_INFO_FUNC
+		    ("nothing is done when btif tx in user's thread\n");
+	} else {
+		BTIF_ERR_FUNC("unsupported tx context type:%d\n",
+			      p_btif->tx_ctx);
+		goto btm_init_err;
+	}
+
+	BTIF_INFO_FUNC("succeed\n");
+
+	i_ret = 0;
+	return i_ret;
+btm_init_err:
+	if (p_btif->tx_ctx == BTIF_TX_SINGLE_CTX) {
+		if (p_btif->p_tx_wq) {
+			destroy_workqueue(p_btif->p_tx_wq);
+			p_btif->p_tx_wq = NULL;
+			BTIF_INFO_FUNC("btif_tx_workqueue destroyed\n");
+		}
+		kfree(p_btif->p_tx_fifo);
+	}
+	return i_ret;
+}
+
+static int _btif_tx_ctx_deinit(p_mtk_btif p_btif)
+{
+	int i_ret = 0;
+
+	if (p_btif->tx_ctx == BTIF_TX_SINGLE_CTX) {
+		if (p_btif->p_tx_wq) {
+			destroy_workqueue(p_btif->p_tx_wq);
+			p_btif->p_tx_wq = NULL;
+			BTIF_INFO_FUNC("btif_tx_workqueue destroyed\n");
+		}
+		if (p_btif->p_tx_fifo) {
+			kfifo_free(p_btif->p_tx_fifo);
+			kfree(p_btif->p_tx_fifo);
+			p_btif->p_tx_fifo = NULL;
+		}
+	}
+	return i_ret;
+}
+
+static int _btif_rx_btm_init(p_mtk_btif p_btif)
+{
+	int i_ret = -1;
+
+	if (p_btif == NULL) {
+		BTIF_ERR_FUNC("p_btif is NULL\n");
+		return E_BTIF_INVAL_PARAM;
+	}
+
+	if (p_btif->btm_type == BTIF_THREAD_CTX) {
+		init_completion(&p_btif->rx_comp);
+
+		/*create kernel thread for later rx data handle*/
+		p_btif->p_task = kthread_create(btif_rx_thread, p_btif, "btif_rxd");
+		if (p_btif->p_task == NULL) {
+			BTIF_ERR_FUNC("kthread_create fail\n");
+			i_ret = -ENOMEM;
+			goto btm_init_err;
+		}
+
+#if ENABLE_BTIF_RX_THREAD_RT_SCHED
+		{
+			int i_ret = -1;
+			int policy = SCHED_FIFO;
+			struct sched_param param;
+
+			param.sched_priority = MAX_RT_PRIO - 20;
+			i_ret = sched_setscheduler(p_btif->p_task, policy, &param);
+			if (i_ret != 0)
+				BTIF_WARN_FUNC("set RT to btif_rxd workqueue failed\n");
+			else
+				BTIF_INFO_FUNC("set RT to btif_rxd workqueue succeed\n");
+		}
+#endif
+
+		wake_up_process(p_btif->p_task);
+		BTIF_INFO_FUNC("btif_rxd start to work!\n");
+	} else if (p_btif->btm_type == BTIF_WQ_CTX) {
+		p_btif->p_rx_wq = create_singlethread_workqueue("btif_rxwq");
+		if (!(p_btif->p_rx_wq)) {
+			BTIF_ERR_FUNC("create_singlethread_workqueue fail\n");
+			i_ret = -ENOMEM;
+			goto btm_init_err;
+		}
+		mutex_init(&(p_btif->rx_mtx));
+		/* init btif rx work */
+		INIT_WORK(&(p_btif->rx_work), btif_rx_worker);
+		BTIF_INFO_FUNC("btif_rx_worker init succeed\n");
+	} else if (p_btif->btm_type == BTIF_TASKLET_CTX) {
+		/*init rx tasklet*/
+		tasklet_init(&(p_btif->rx_tasklet), btif_rx_tasklet,
+			     (unsigned long)p_btif);
+		spin_lock_init(&(p_btif->rx_tasklet_spinlock));
+		BTIF_INFO_FUNC("btif_rx_tasklet init succeed\n");
+	} else {
+		BTIF_ERR_FUNC("unsupported rx context type:%d\n",
+			      p_btif->btm_type);
+	}
+
+/*spinlock init*/
+	spin_lock_init(&(p_btif->rx_irq_spinlock));
+	BTIF_INFO_FUNC("rx_spin_lock init succeed\n");
+
+	i_ret = 0;
+	return i_ret;
+btm_init_err:
+	if (p_btif->btm_type == BTIF_THREAD_CTX) {
+		/*do nothing*/
+		BTIF_INFO_FUNC("failed\n");
+	} else if (p_btif->btm_type == BTIF_WQ_CTX) {
+		if (p_btif->p_rx_wq) {
+			destroy_workqueue(p_btif->p_rx_wq);
+			p_btif->p_rx_wq = NULL;
+			BTIF_INFO_FUNC("btif_rx_workqueue destroyed\n");
+		}
+	}
+	return i_ret;
+}
+
+static int _btif_rx_btm_sched(p_mtk_btif p_btif)
+{
+	if (p_btif == NULL) {
+		BTIF_ERR_FUNC("p_btif is NULL\n");
+		return E_BTIF_INVAL_PARAM;
+	}
+
+	if (p_btif->btm_type == BTIF_THREAD_CTX) {
+		complete(&p_btif->rx_comp);
+		BTIF_DBG_FUNC("schedule btif_rx_thread\n");
+	} else if (p_btif->btm_type == BTIF_WQ_CTX) {
+		queue_work(p_btif->p_rx_wq, &(p_btif->rx_work));
+		BTIF_DBG_FUNC("schedule btif_rx_worker\n");
+	} else if (p_btif->btm_type == BTIF_TASKLET_CTX) {
+		/*schedule it!*/
+		tasklet_schedule(&(p_btif->rx_tasklet));
+		BTIF_DBG_FUNC("schedule btif_rx_tasklet\n");
+	} else {
+		BTIF_ERR_FUNC("unsupported rx context type:%d\n",
+			      p_btif->btm_type);
+	}
+
+	return 0;
+}
+
+static int _btif_rx_btm_deinit(p_mtk_btif p_btif)
+{
+	if (p_btif == NULL) {
+		BTIF_ERR_FUNC("p_btif is NULL\n");
+		return E_BTIF_INVAL_PARAM;
+	}
+	if (p_btif->btm_type == BTIF_THREAD_CTX) {
+		if (p_btif->p_task != NULL) {
+			BTIF_INFO_FUNC("signaling btif rx thread to stop ...\n");
+			kthread_stop(p_btif->p_task);
+		}
+	} else if (p_btif->btm_type == BTIF_WQ_CTX) {
+		if (p_btif->p_rx_wq) {
+			cancel_work_sync(&(p_btif->rx_work));
+			BTIF_INFO_FUNC("btif_rx_worker cancelled\n");
+			destroy_workqueue(p_btif->p_rx_wq);
+			p_btif->p_rx_wq = NULL;
+			BTIF_INFO_FUNC("btif_rx_workqueue destroyed\n");
+		}
+		mutex_destroy(&(p_btif->rx_mtx));
+	} else if (p_btif->btm_type == BTIF_TASKLET_CTX) {
+		tasklet_kill(&(p_btif->rx_tasklet));
+		BTIF_INFO_FUNC("rx_tasklet killed\n");
+	} else {
+		BTIF_ERR_FUNC("unsupported rx context type:%d\n",
+			      p_btif->btm_type);
+	}
+
+	spin_lock_init(&(p_btif->rx_irq_spinlock));
+
+	return 0;
+}
+
+
+void btif_dump_bbs_str(unsigned char *p_str, p_btif_buf_str p_bbs)
+{
+	BTIF_INFO_FUNC
+	    ("%s UBS:0x%p\n  Size:0x%p\n  read:0x%08x\n  write:0x%08x\n",
+	     p_str, p_bbs, p_bbs->size, p_bbs->rd_idx, p_bbs->wr_idx);
+}
+
+unsigned int btif_bbs_write(p_btif_buf_str p_bbs,
+			    unsigned char *p_buf, unsigned int buf_len)
+{
+/*in IRQ context, so read operation won't interrupt this operation*/
+
+	unsigned int wr_len = 0;
+
+	unsigned int emp_len = BBS_LEFT(p_bbs);
+	unsigned int ava_len = emp_len - 1;
+	p_mtk_btif p_btif = container_of(p_bbs, mtk_btif, btif_buf);
+
+	if (ava_len <= 0) {
+		BTIF_ERR_FUNC
+		    ("no empty space left for write, (%d)ava_len, (%d)to write\n",
+		     ava_len, buf_len);
+		hal_btif_dump_reg(p_btif->p_btif_info, REG_BTIF_ALL);
+		hal_dma_dump_reg(p_btif->p_rx_dma->p_dma_info, REG_RX_DMA_ALL);
+		return 0;
+	}
+
+	if (ava_len < buf_len) {
+		BTIF_ERR_FUNC("BTIF overrun, (%d)empty, (%d)needed\n",
+			      emp_len, buf_len);
+		hal_btif_dump_reg(p_btif->p_btif_info, REG_BTIF_ALL);
+		hal_dma_dump_reg(p_btif->p_rx_dma->p_dma_info, REG_RX_DMA_ALL);
+		_btif_dump_memory("<DMA Rx vFIFO>", p_buf, buf_len);
+	}
+
+	if (buf_len >= g_max_pkg_len) {
+		BTIF_WARN_FUNC("buf_len too long, (%d)ava_len, (%d)to write\n",
+			       ava_len, buf_len);
+		hal_btif_dump_reg(p_btif->p_btif_info, REG_BTIF_ALL);
+		hal_dma_dump_reg(p_btif->p_rx_dma->p_dma_info, REG_RX_DMA_ALL);
+		_btif_dump_memory("<DMA Rx vFIFO>", p_buf, buf_len);
+	}
+
+	wr_len = min(buf_len, ava_len);
+	btif_bbs_wr_direct(p_bbs, p_buf, wr_len);
+
+	if (BBS_COUNT(p_bbs) >= g_max_pding_data_size) {
+		BTIF_WARN_FUNC("Rx buf_len too long, size(%d)\n",
+			       BBS_COUNT(p_bbs));
+		btif_dump_bbs_str("Rx buffer tooo long", p_bbs);
+		hal_btif_dump_reg(p_btif->p_btif_info, REG_BTIF_ALL);
+		hal_dma_dump_reg(p_btif->p_rx_dma->p_dma_info, REG_RX_DMA_ALL);
+		_btif_dump_memory("<DMA Rx vFIFO>", p_buf, buf_len);
+		BBS_INIT(p_bbs);
+	}
+
+	return wr_len;
+}
+
+unsigned int btif_bbs_read(p_btif_buf_str p_bbs,
+			   unsigned char *p_buf, unsigned int buf_len)
+{
+	unsigned int rd_len = 0;
+	unsigned int ava_len = 0;
+	unsigned int wr_idx = p_bbs->wr_idx;
+
+	ava_len = BBS_COUNT_CUR(p_bbs, wr_idx);
+	if (ava_len >= 4096) {
+		BTIF_WARN_FUNC("ava_len too long, size(%d)\n", ava_len);
+		btif_dump_bbs_str("Rx buffer tooo long", p_bbs);
+	}
+	if (ava_len != 0) {
+		if (buf_len >= ava_len) {
+			rd_len = ava_len;
+			if (wr_idx >= (p_bbs)->rd_idx) {
+				memcpy(p_buf, BBS_PTR(p_bbs,
+						      p_bbs->rd_idx),
+				       ava_len);
+				(p_bbs)->rd_idx = wr_idx;
+			} else {
+				unsigned int tail_len = BBS_SIZE(p_bbs) -
+				    (p_bbs)->rd_idx;
+				memcpy(p_buf, BBS_PTR(p_bbs,
+						      p_bbs->rd_idx),
+				       tail_len);
+				memcpy(p_buf + tail_len, BBS_PTR(p_bbs,
+								 0), ava_len - tail_len);
+				(p_bbs)->rd_idx = wr_idx;
+			}
+		} else {
+			rd_len = buf_len;
+			if (wr_idx >= (p_bbs)->rd_idx) {
+				memcpy(p_buf, BBS_PTR(p_bbs,
+						      p_bbs->rd_idx),
+				       rd_len);
+				(p_bbs)->rd_idx = (p_bbs)->rd_idx + rd_len;
+			} else {
+				unsigned int tail_len = BBS_SIZE(p_bbs) -
+				    (p_bbs)->rd_idx;
+				if (tail_len >= rd_len) {
+					memcpy(p_buf, BBS_PTR(p_bbs, p_bbs->rd_idx),
+					       rd_len);
+					(p_bbs)->rd_idx =
+					    ((p_bbs)->rd_idx + rd_len) & (BBS_MASK(p_bbs));
+				} else {
+					memcpy(p_buf, BBS_PTR(p_bbs, p_bbs->rd_idx), tail_len);
+					memcpy(p_buf + tail_len,
+					       (p_bbs)->p_buf, rd_len - tail_len);
+					(p_bbs)->rd_idx = rd_len - tail_len;
+				}
+			}
+		}
+	}
+	mb();
+	return rd_len;
+}
+
+unsigned int btif_bbs_wr_direct(p_btif_buf_str p_bbs,
+				unsigned char *p_buf, unsigned int buf_len)
+{
+	unsigned int tail_len = 0;
+	unsigned int l = 0;
+	unsigned int tmp_wr_idx = p_bbs->wr_idx;
+
+	tail_len = BBS_SIZE(p_bbs) - (tmp_wr_idx & BBS_MASK(p_bbs));
+
+	l = min(tail_len, buf_len);
+
+	memcpy((p_bbs->p_buf) + (tmp_wr_idx & BBS_MASK(p_bbs)), p_buf, l);
+	memcpy(p_bbs->p_buf, p_buf + l, buf_len - l);
+
+	mb();
+
+	tmp_wr_idx += buf_len;
+	tmp_wr_idx &= BBS_MASK(p_bbs);
+	p_bbs->wr_idx = tmp_wr_idx;
+
+	mb();
+	return buf_len;
+}
+
+int _btif_dma_write(p_mtk_btif p_btif,
+		    const unsigned char *p_buf, unsigned int buf_len)
+{
+	unsigned int i_ret = 0;
+	unsigned int retry = 0;
+	unsigned int max_tx_retry = 10;
+
+	P_MTK_DMA_INFO_STR p_dma_info = p_btif->p_tx_dma->p_dma_info;
+
+	_btif_irq_ctrl_sync(p_dma_info->p_irq, false);
+	do {
+		/*wait until tx is allowed*/
+		while (!hal_dma_is_tx_allow(p_dma_info) &&
+		       (retry < max_tx_retry)) {
+			retry++;
+			if (retry >= max_tx_retry) {
+				BTIF_ERR_FUNC("wait for tx allowed timeout\n");
+				break;
+			}
+		}
+		if (retry >= max_tx_retry)
+			break;
+
+		if (buf_len <= hal_dma_get_ava_room(p_dma_info))
+			i_ret = hal_dma_send_data(p_dma_info, p_buf, buf_len);
+		else
+			i_ret = 0;
+	} while (0);
+	_btif_irq_ctrl_sync(p_dma_info->p_irq, true);
+	return i_ret;
+}
+
+int _btif_pio_write(p_mtk_btif p_btif,
+		    const unsigned char *p_buf, unsigned int buf_len)
+{
+	unsigned int i_ret = 0;
+	unsigned int sent_len = 0;
+	unsigned int retry = 0;
+	unsigned int max_tx_retry = 10;
+	P_MTK_BTIF_INFO_STR p_btif_info = p_btif->p_btif_info;
+
+	while ((sent_len < buf_len)) {
+		if (hal_btif_is_tx_allow(p_btif_info)) {
+			i_ret = hal_btif_send_data(p_btif_info,
+						   p_buf + sent_len,
+						   buf_len - sent_len);
+			if (i_ret > 0) {
+				sent_len += i_ret;
+				BTIF_DBG_FUNC("lent sent:%d, total sent:%d\n",
+					      i_ret, sent_len);
+				retry = 0;
+			}
+		}
+		if ((++retry > max_tx_retry) || (i_ret < 0)) {
+			BTIF_INFO_FUNC("exceed retry times limit :%d\n", retry);
+			break;
+		}
+	}
+	i_ret = sent_len;
+	return i_ret;
+}
+
+int _btif_dump_memory(char *str, unsigned char *p_buf, unsigned int buf_len)
+{
+	unsigned int idx = 0;
+
+	pr_debug("%s:, length:%d\n", str, buf_len);
+	for (idx = 0; idx < buf_len;) {
+		pr_debug("%02x ", p_buf[idx]);
+		idx++;
+		if (idx % 8 == 0)
+			pr_debug("\n");
+	}
+	return 0;
+}
+
+int btif_send_data(p_mtk_btif p_btif,
+		   const unsigned char *p_buf, unsigned int buf_len)
+{
+	int i_ret = 0;
+
+	if (p_btif->tx_ctx == BTIF_TX_USER_CTX) {
+		i_ret = _btif_send_data(p_btif, p_buf, buf_len);
+	} else if (p_btif->tx_ctx == BTIF_TX_SINGLE_CTX) {
+		int length = 0;
+/*tx fifo in*/
+		length = kfifo_in(p_btif->p_tx_fifo,
+				  (unsigned char *)p_buf, buf_len);
+		if (length == buf_len) {
+			queue_work(p_btif->p_tx_wq, &(p_btif->tx_work));
+			BTIF_DBG_FUNC("schedule btif_tx_worker\n");
+			i_ret = length;
+		} else {
+			i_ret = 0;
+			BTIF_ERR_FUNC("fifo in failed, target len(%d),in len(%d),",
+				"don't schedule btif_tx_worker\n", buf_len, length);
+		}
+	} else {
+		BTIF_ERR_FUNC("invalid btif tx context:%d\n", p_btif->tx_ctx);
+		i_ret = 0;
+	}
+
+	return i_ret;
+}
+
+int _btif_send_data(p_mtk_btif p_btif,
+		    const unsigned char *p_buf, unsigned int buf_len)
+{
+	int i_ret = 0;
+	unsigned int state = 0;
+
+/*make sure BTIF in ON state before doing tx operation*/
+	if (_btif_state_hold(p_btif))
+		return E_BTIF_INTR;
+	state = _btif_state_get(p_btif);
+
+	if (state != B_S_ON)
+		i_ret = _btif_exit_dpidle(p_btif);
+
+	if (i_ret != 0) {
+		i_ret = E_BTIF_INVAL_STATE;
+	} else if (p_btif->tx_mode == BTIF_MODE_DMA) {
+		/*_btif_dump_memory("tx data:", p_buf, buf_len);*/
+		i_ret = _btif_dma_write(p_btif, p_buf, buf_len);
+	} else if (p_btif->tx_mode == BTIF_MODE_PIO) {
+		/*_btif_dump_memory("tx data:", p_buf, buf_len);*/
+		i_ret = _btif_pio_write(p_btif, p_buf, buf_len);
+	} else {
+		BTIF_ERR_FUNC("invalid tx mode:%d\n", p_btif->tx_mode);
+		i_ret = 0;
+	}
+
+/*save Tx packet here*/
+	if (i_ret > 0)
+		btif_log_buf_dmp_in(&p_btif->tx_log, p_buf, i_ret);
+
+	BTIF_STATE_RELEASE(p_btif);
+	return i_ret;
+}
+
+int btif_dump_reg(p_mtk_btif p_btif)
+{
+	int i_ret = 0;
+	unsigned int ori_state = 0;
+
+/*make sure BTIF in ON state before doing tx operation*/
+	if (_btif_state_hold(p_btif))
+		return E_BTIF_INTR;
+	ori_state = _btif_state_get(p_btif);
+
+	if (ori_state == B_S_OFF) {
+		i_ret = E_BTIF_INVAL_STATE;
+		BTIF_ERR_FUNC
+		    ("BTIF in OFF state, ",
+		     "should no need to dump register, ",
+		     "please check wmt's operation is okay or not.\n");
+		goto dmp_reg_err;
+	}
+
+	if ((ori_state != B_S_ON) && (ori_state < B_S_MAX)) {
+		BTIF_ERR_FUNC("BTIF's original state is %s, not B_S_ON\n", g_state[ori_state]);
+		BTIF_ERR_FUNC("!!!!---<<<This should never happen in normal mode>>>---!!!");
+		i_ret = _btif_exit_dpidle(p_btif);
+	}
+
+	if (i_ret != 0) {
+		i_ret = E_BTIF_INVAL_STATE;
+		BTIF_ERR_FUNC("switch to B_S_ON failed\n");
+		goto dmp_reg_err;
+	}
+
+/*dump BTIF register*/
+	hal_btif_dump_reg(p_btif->p_btif_info, REG_BTIF_ALL);
+
+/*dump BTIF Tx DMA channel register if in DMA mode*/
+	if (p_btif->tx_mode == BTIF_MODE_DMA)
+		hal_dma_dump_reg(p_btif->p_tx_dma->p_dma_info, REG_TX_DMA_ALL);
+	else
+		BTIF_INFO_FUNC("BTIF Tx in PIO mode,no need to dump Tx DMA's register\n");
+
+/*dump BTIF Rx DMA channel register if in DMA mode*/
+	if (p_btif->rx_mode == BTIF_MODE_DMA)
+		hal_dma_dump_reg(p_btif->p_rx_dma->p_dma_info, REG_RX_DMA_ALL);
+	else
+		BTIF_INFO_FUNC("BTIF Rx in PIO mode,no need to dump Rx DMA's register\n");
+
+	switch (ori_state) {
+	case B_S_SUSPEND:
+/*return to dpidle state*/
+/* break; */
+	case B_S_DPIDLE:
+/*return to dpidle state*/
+		_btif_enter_dpidle(p_btif);
+		break;
+	case B_S_ON:
+/*nothing needs to be done*/
+		break;
+	default:
+		break;
+	}
+
+dmp_reg_err:
+
+	BTIF_STATE_RELEASE(p_btif);
+	return i_ret;
+}
+
+int btif_rx_notify_reg(p_mtk_btif p_btif, MTK_BTIF_RX_NOTIFY rx_notify)
+{
+	if (p_btif->rx_notify) {
+		BTIF_WARN_FUNC
+		    ("rx cb already exist, rewrite from (0x%p) to (0x%p)\n",
+		     p_btif->rx_notify, rx_notify);
+	}
+	p_btif->rx_notify = rx_notify;
+
+	return 0;
+}
+
+int btif_dump_data(char *p_buf, int len)
+{
+	unsigned int idx = 0;
+	unsigned char str[30];
+	unsigned char *p_str;
+
+	p_str = &str[0];
+	for (idx = 0; idx < len; idx++, p_buf++) {
+		sprintf(p_str, "%02x ", *p_buf);
+		p_str += 3;
+		if (7 == (idx % 8)) {
+			*p_str++ = '\n';
+			*p_str = '\0';
+			pr_debug("%s", str);
+			p_str = &str[0];
+		}
+	}
+	if (len % 8) {
+		*p_str++ = '\n';
+		*p_str = '\0';
+		pr_debug("%s", str);
+	}
+	return 0;
+}
+
+int btif_log_buf_dmp_in(P_BTIF_LOG_QUEUE_T p_log_que, const char *p_buf,
+			int len)
+{
+	P_BTIF_LOG_BUF_T p_log_buf = NULL;
+	char *dir = NULL;
+	struct timeval *p_timer = NULL;
+	unsigned long flags;
+	bool output_flag = false;
+
+	BTIF_DBG_FUNC("++\n");
+
+	if ((p_log_que == NULL) || (p_buf == NULL) || (len == 0)) {
+		BTIF_ERR_FUNC("invalid parameter, p_log_que(0x%x), buf(0x%x), ",
+			"len(%d)\n", p_log_que, p_buf, len);
+		return 0;
+	}
+	if (!(p_log_que->enable))
+		return 0;
+
+	dir = p_log_que->dir == BTIF_TX ? "Tx" : "Rx";
+	output_flag = p_log_que->output_flag;
+
+	spin_lock_irqsave(&(p_log_que->lock), flags);
+
+/*get next log buffer for record usage*/
+	p_log_buf = p_log_que->p_queue[0] + p_log_que->in;
+	p_timer = &p_log_buf->timer;
+
+/*log time stamp*/
+	do_gettimeofday(p_timer);
+
+/*record data information including length and content*/
+	p_log_buf->len = len;
+	memcpy(p_log_buf->buffer, p_buf, len > BTIF_LOG_SZ ? BTIF_LOG_SZ : len);
+
+/*update log queue size information*/
+	p_log_que->size++;
+	p_log_que->size = p_log_que->size >
+	    BTIF_LOG_ENTRY_NUM ? BTIF_LOG_ENTRY_NUM : p_log_que->size;
+
+/*update log queue index information*/
+	p_log_que->in++;
+	p_log_que->in %= BTIF_LOG_ENTRY_NUM;
+
+	spin_unlock_irqrestore(&p_log_que->lock, flags);
+
+/*check if log dynamic output function is enabled or not*/
+	if (output_flag) {
+		pr_debug("BTIF-DBG, dir:%s, %d.%ds len:%d\n",
+		       dir, (int)p_timer->tv_sec, (int)p_timer->tv_usec, len);
+/*output buffer content*/
+		btif_dump_data((char *)p_buf, len);
+	}
+	BTIF_DBG_FUNC("--\n");
+
+	return 0;
+}
+
+int btif_log_buf_dmp_out(P_BTIF_LOG_QUEUE_T p_log_que)
+{
+	P_BTIF_LOG_BUF_T p_log_buf = NULL;
+	unsigned int out_index = 0;
+	unsigned int in_index = 0;
+	unsigned int dump_size = 0;
+	unsigned char *p_buf = NULL;
+	unsigned int len = 0;
+	unsigned int pkt_count = 0;
+	unsigned char *p_dir = NULL;
+	struct timeval *p_timer = NULL;
+	unsigned long flags;
+
+#if 0				/* no matter enable or not, we allowed output */
+	if (!(p_log_que->enable))
+		return;
+#endif
+	BTIF_DBG_FUNC("++\n");
+
+	spin_lock_irqsave(&p_log_que->lock, flags);
+	in_index = p_log_que->in;
+	dump_size = p_log_que->size;
+	out_index = p_log_que->size >=
+	    BTIF_LOG_ENTRY_NUM ? in_index : (BTIF_LOG_ENTRY_NUM -
+					     p_log_que->size +
+					     in_index) % BTIF_LOG_ENTRY_NUM;
+	p_dir = p_log_que->dir == BTIF_TX ? "Tx" : "Rx";
+
+	BTIF_INFO_FUNC("btif %s log buffer size:%d\n", p_dir, dump_size);
+
+	if (dump_size != 0) {
+		while (dump_size--) {
+			p_log_buf = p_log_que->p_queue[0] + out_index;
+
+			len = p_log_buf->len;
+			p_buf = p_log_buf->buffer;
+			p_timer = &p_log_buf->timer;
+
+			len = len > BTIF_LOG_SZ ? BTIF_LOG_SZ : len;
+
+			BTIF_INFO_FUNC("dir:%s, pkt_count:%d, %d.%ds len:%d\n",
+			       p_dir,
+			       pkt_count++,
+			       (int)p_timer->tv_sec,
+			       (int)p_timer->tv_usec, len);
+/*output buffer content*/
+			btif_dump_data(p_log_buf->buffer, len);
+			out_index++;
+			out_index %= BTIF_LOG_ENTRY_NUM;
+		}
+	}
+	spin_unlock_irqrestore(&p_log_que->lock, flags);
+	BTIF_DBG_FUNC("--\n");
+
+	return 0;
+}
+
+int btif_log_buf_enable(P_BTIF_LOG_QUEUE_T p_log_que)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&p_log_que->lock, flags);
+	p_log_que->enable = true;
+	spin_unlock_irqrestore(&p_log_que->lock, flags);
+	BTIF_INFO_FUNC("enable %s log function\n",
+		       p_log_que->dir == BTIF_TX ? "Tx" : "Rx");
+	return 0;
+}
+
+int btif_log_buf_disable(P_BTIF_LOG_QUEUE_T p_log_que)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&p_log_que->lock, flags);
+	p_log_que->enable = false;
+	spin_unlock_irqrestore(&p_log_que->lock, flags);
+	BTIF_INFO_FUNC("disable %s log function\n",
+		       p_log_que->dir == BTIF_TX ? "Tx" : "Rx");
+	return 0;
+}
+
+int btif_log_output_enable(P_BTIF_LOG_QUEUE_T p_log_que)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&p_log_que->lock, flags);
+	p_log_que->output_flag = true;
+	spin_unlock_irqrestore(&p_log_que->lock, flags);
+	BTIF_INFO_FUNC("%s log rt output enabled\n",
+		       p_log_que->dir == BTIF_TX ? "Tx" : "Rx");
+	return 0;
+}
+
+int btif_log_output_disable(P_BTIF_LOG_QUEUE_T p_log_que)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&p_log_que->lock, flags);
+	p_log_que->output_flag = false;
+	spin_unlock_irqrestore(&p_log_que->lock, flags);
+	BTIF_INFO_FUNC("%s log rt output disabled\n",
+		       p_log_que->dir == BTIF_TX ? "Tx" : "Rx");
+	return 0;
+}
+
+int btif_log_buf_reset(P_BTIF_LOG_QUEUE_T p_log_que)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&p_log_que->lock, flags);
+
+/*tx log buffer init*/
+	p_log_que->in = 0;
+	p_log_que->out = 0;
+	p_log_que->size = 0;
+	p_log_que->enable = true;
+	memset((p_log_que->p_queue[0]), 0, sizeof(BTIF_LOG_BUF_T));
+
+	spin_unlock_irqrestore(&p_log_que->lock, flags);
+	BTIF_DBG_FUNC("reset %s log buffer\n",
+		       p_log_que->dir == BTIF_TX ? "Tx" : "Rx");
+	return 0;
+}
+
+int btif_log_buf_init(p_mtk_btif p_btif)
+{
+/*tx log buffer init*/
+	p_btif->tx_log.dir = BTIF_TX;
+	p_btif->tx_log.in = 0;
+	p_btif->tx_log.out = 0;
+	p_btif->tx_log.size = 0;
+	p_btif->tx_log.output_flag = false;
+	p_btif->tx_log.enable = true;
+	spin_lock_init(&(p_btif->tx_log.lock));
+	BTIF_DBG_FUNC("tx_log.p_queue:0x%p\n", p_btif->tx_log.p_queue[0]);
+	memset((p_btif->tx_log.p_queue[0]), 0, sizeof(BTIF_LOG_BUF_T));
+
+/*rx log buffer init*/
+	p_btif->rx_log.dir = BTIF_RX;
+	p_btif->rx_log.in = 0;
+	p_btif->rx_log.out = 0;
+	p_btif->rx_log.size = 0;
+	p_btif->rx_log.output_flag = false;
+	p_btif->rx_log.enable = true;
+	spin_lock_init(&(p_btif->rx_log.lock));
+	BTIF_DBG_FUNC("rx_log.p_queue:0x%p\n", p_btif->rx_log.p_queue[0]);
+	memset((p_btif->rx_log.p_queue[0]), 0, sizeof(BTIF_LOG_BUF_T));
+
+	return 0;
+}
+
+int btif_tx_dma_mode_set(int en)
+{
+	int index = 0;
+	ENUM_BTIF_MODE mode = (en == 1) ? BTIF_MODE_DMA : BTIF_MODE_PIO;
+
+	for (index = 0; index < BTIF_PORT_NR; index++)
+		g_btif[index].tx_mode = mode;
+
+	return 0;
+}
+
+int btif_rx_dma_mode_set(int en)
+{
+	int index = 0;
+	ENUM_BTIF_MODE mode = (en == 1) ? BTIF_MODE_DMA : BTIF_MODE_PIO;
+
+	for (index = 0; index < BTIF_PORT_NR; index++)
+		g_btif[index].rx_mode = mode;
+
+	return 0;
+}
+
+static int BTIF_init(void)
+{
+	int i_ret = -1;
+	int index = 0;
+	p_mtk_btif_dma p_tx_dma = NULL;
+	p_mtk_btif_dma p_rx_dma = NULL;
+	unsigned char *p_btif_buffer = NULL;
+	unsigned char *p_tx_queue = NULL;
+	unsigned char *p_rx_queue = NULL;
+
+	BTIF_DBG_FUNC("++\n");
+
+/*Platform Driver initialization*/
+	i_ret = platform_driver_register(&mtk_btif_dev_drv);
+	if (i_ret) {
+		BTIF_ERR_FUNC("BTIF platform driver registered failed, ret(%d)\n", i_ret);
+		goto err_exit1;
+	}
+
+	i_ret = driver_create_file(&mtk_btif_dev_drv.driver, &driver_attr_flag);
+	if (i_ret)
+		BTIF_ERR_FUNC("BTIF pdriver_create_file failed, ret(%d)\n", i_ret);
+
+/*SW init*/
+	for (index = 0; index < BTIF_PORT_NR; index++) {
+		p_btif_buffer = kmalloc(BTIF_RX_BUFFER_SIZE, GFP_ATOMIC);
+		if (!p_btif_buffer) {
+			BTIF_ERR_FUNC("p_btif_buffer kmalloc memory fail\n");
+			return -1;
+		}
+		BTIF_INFO_FUNC("p_btif_buffer get memory 0x%p\n", p_btif_buffer);
+		p_tx_queue = kmalloc_array(BTIF_LOG_ENTRY_NUM, sizeof(BTIF_LOG_BUF_T), GFP_ATOMIC);
+		if (!p_tx_queue) {
+			BTIF_ERR_FUNC("p_tx_queue kmalloc memory fail\n");
+			kfree(p_btif_buffer);
+			return -1;
+		}
+		BTIF_INFO_FUNC("p_tx_queue get memory 0x%p\n", p_tx_queue);
+		p_rx_queue = kmalloc_array(BTIF_LOG_ENTRY_NUM, sizeof(BTIF_LOG_BUF_T), GFP_ATOMIC);
+		if (!p_rx_queue) {
+			BTIF_ERR_FUNC("p_rx_queue kmalloc memory fail\n");
+			kfree(p_btif_buffer);
+			kfree(p_tx_queue);
+			return -1;
+		}
+		BTIF_INFO_FUNC("p_rx_queue get memory 0x%p\n", p_rx_queue);
+
+		INIT_LIST_HEAD(&(g_btif[index].user_list));
+		BBS_INIT(&(g_btif[index].btif_buf));
+		g_btif[index].enable = false;
+		g_btif[index].open_counter = 0;
+		g_btif[index].setting = &g_btif_setting[index];
+		g_btif[index].p_btif_info = hal_btif_info_get();
+		g_btif[index].tx_mode = g_btif_setting[index].tx_mode;
+		g_btif[index].rx_mode = g_btif_setting[index].rx_mode;
+		g_btif[index].btm_type = g_btif_setting[index].rx_type;
+		g_btif[index].tx_ctx = g_btif_setting[index].tx_type;
+		g_btif[index].lpbk_flag = false;
+		g_btif[index].rx_cb = NULL;
+		g_btif[index].rx_notify = NULL;
+		g_btif[index].btif_buf.p_buf = p_btif_buffer;
+		g_btif[index].tx_log.p_queue[0] = (P_BTIF_LOG_BUF_T) p_tx_queue;
+		g_btif[index].rx_log.p_queue[0] = (P_BTIF_LOG_BUF_T) p_rx_queue;
+		btif_log_buf_init(&g_btif[index]);
+
+#if !(MTK_BTIF_ENABLE_CLK_REF_COUNTER)
+/*enable BTIF clock gating by default*/
+		i_ret = hal_btif_clk_ctrl(g_btif[index].p_btif_info,
+					  CLK_OUT_DISABLE);
+		if (i_ret != 0) {
+			BTIF_ERR_FUNC("BTIF controller CG failed\n");
+			goto err_exit2;
+		}
+#endif
+
+/*
+ * viftual FIFO memory must be physical continious,
+ * because DMA will access it directly without MMU
+ */
+#if ENABLE_BTIF_TX_DMA
+		p_tx_dma = &g_dma[index][BTIF_TX];
+		g_btif[index].p_tx_dma = p_tx_dma;
+		p_tx_dma->dir = BTIF_TX;
+		p_tx_dma->p_btif = &(g_btif[index]);
+
+/*DMA Tx vFIFO initialization*/
+		p_tx_dma->p_dma_info = hal_btif_dma_info_get(DMA_DIR_TX);
+/*spinlock init*/
+		spin_lock_init(&(p_tx_dma->iolock));
+/*entry setup*/
+		atomic_set(&(p_tx_dma->entry), 0);
+/*vFIFO initialization*/
+		i_ret = _btif_vfifo_init(p_tx_dma);
+		if (i_ret != 0) {
+			BTIF_ERR_FUNC("BTIF Tx vFIFO allocation failed\n");
+			goto err_exit2;
+		}
+
+#if !(MTK_BTIF_ENABLE_CLK_REF_COUNTER)
+/*enable BTIF Tx DMA channel's clock gating by default*/
+		i_ret = hal_btif_dma_clk_ctrl(p_tx_dma->p_dma_info,
+					      CLK_OUT_DISABLE);
+		if (i_ret != 0) {
+			BTIF_ERR_FUNC("BTIF Tx DMA's CG failed\n");
+			goto err_exit2;
+		}
+#endif
+
+#else
+		g_btif[index].p_tx_dma = NULL;
+/*force tx mode to DMA no matter what it is in default setting*/
+		g_btif[index].tx_mode = BTIF_MODE_PIO;
+#endif
+
+#if ENABLE_BTIF_RX_DMA
+		p_rx_dma = &g_dma[index][BTIF_RX];
+		g_btif[index].p_rx_dma = p_rx_dma;
+		p_rx_dma->p_btif = &(g_btif[index]);
+		p_rx_dma->dir = BTIF_RX;
+
+/*DMA Tx vFIFO initialization*/
+		p_rx_dma->p_dma_info = hal_btif_dma_info_get(DMA_DIR_RX);
+/*spinlock init*/
+		spin_lock_init(&(p_rx_dma->iolock));
+/*entry setup*/
+		atomic_set(&(p_rx_dma->entry), 0);
+/*vFIFO initialization*/
+		i_ret = _btif_vfifo_init(p_rx_dma);
+		if (i_ret != 0) {
+			BTIF_ERR_FUNC("BTIF Rx vFIFO allocation failed\n");
+			goto err_exit2;
+		}
+
+#if !(MTK_BTIF_ENABLE_CLK_REF_COUNTER)
+/*enable BTIF Tx DMA channel's clock gating by default*/
+		i_ret = hal_btif_dma_clk_ctrl(p_rx_dma->p_dma_info,
+					      CLK_OUT_DISABLE);
+		if (i_ret != 0) {
+			BTIF_ERR_FUNC("BTIF Rx DMA's CG failed\n");
+			goto err_exit2;
+		}
+#endif
+
+#else
+		g_btif[index].p_rx_dma = NULL;
+/*force rx mode to DMA no matter what it is in default setting*/
+		g_btif[index].rx_mode = BTIF_MODE_PIO;
+
+#endif
+/*PM state mechine initialization*/
+		i_ret = _btif_state_init(&(g_btif[index]));
+		if (i_ret != 0) {
+			BTIF_ERR_FUNC("BTIF state mechanism init failed\n");
+			goto err_exit2;
+		}
+
+/*Rx bottom half initialization*/
+		i_ret = _btif_rx_btm_init(&(g_btif[index]));
+		if (i_ret != 0) {
+			BTIF_ERR_FUNC("BTIF Rx btm init failed\n");
+			goto err_exit3;
+		}
+		i_ret = _btif_tx_ctx_init(&(g_btif[index]));
+		if (i_ret != 0) {
+			BTIF_ERR_FUNC("BTIF Tx context init failed\n");
+			goto err_exit4;
+		}
+/*Character Device initialization*/
+/*Chaozhong: ToDo: to be initialized*/
+
+		mutex_init(&g_btif[index].ops_mtx);
+	}
+
+/*Debug purpose initialization*/
+
+#if BTIF_CDEV_SUPPORT
+	btif_chrdev_init();
+#endif
+
+	return 0;
+
+err_exit4:
+	for (index = 0; index < BTIF_PORT_NR; index++)
+		_btif_tx_ctx_deinit(&(g_btif[index]));
+
+err_exit3:
+	for (index = 0; index < BTIF_PORT_NR; index++) {
+		_btif_rx_btm_deinit(&(g_btif[index]));
+
+		_btif_state_deinit(&(g_btif[index]));
+	}
+
+err_exit2:
+	for (index = 0; index < BTIF_PORT_NR; index++) {
+		p_tx_dma = &g_dma[index][BTIF_TX];
+		p_rx_dma = &g_dma[index][BTIF_RX];
+#if ENABLE_BTIF_TX_DMA
+		_btif_vfifo_deinit(p_tx_dma);
+#endif
+
+#if ENABLE_BTIF_RX_DMA
+		_btif_vfifo_deinit(p_rx_dma);
+#endif
+		g_btif[index].open_counter = 0;
+		g_btif[index].enable = false;
+	}
+	driver_remove_file(&mtk_btif_dev_drv.driver, &driver_attr_flag);
+	platform_driver_unregister(&mtk_btif_dev_drv);
+
+err_exit1:
+	i_ret = -1;
+	BTIF_DBG_FUNC("--\n");
+	return i_ret;
+}
+
+static void BTIF_exit(void)
+{
+	unsigned int index = 0;
+	p_mtk_btif_dma p_tx_dma = NULL;
+	p_mtk_btif_dma p_rx_dma = NULL;
+
+	BTIF_DBG_FUNC("++\n");
+
+	for (index = 0; index < BTIF_PORT_NR; index++) {
+		g_btif[index].open_counter = 0;
+		g_btif[index].enable = false;
+		p_tx_dma = &g_dma[index][BTIF_TX];
+		p_rx_dma = &g_dma[index][BTIF_RX];
+#if ENABLE_BTIF_TX_DMA
+		_btif_vfifo_deinit(p_tx_dma);
+#endif
+
+#if ENABLE_BTIF_RX_DMA
+		_btif_vfifo_deinit(p_rx_dma);
+#endif
+		_btif_state_deinit(&(g_btif[index]));
+
+		_btif_rx_btm_deinit(&(g_btif[index]));
+
+		mutex_destroy(&g_btif[index].ops_mtx);
+	}
+
+#if !defined(CONFIG_MTK_CLKMGR)
+		hal_btif_clk_unprepare();
+#endif
+
+	driver_remove_file(&mtk_btif_dev_drv.driver, &driver_attr_flag);
+	platform_driver_unregister(&mtk_btif_dev_drv);
+	BTIF_DBG_FUNC("--\n");
+}
+
+int mtk_btif_hal_get_log_lvl(void)
+{
+	return mtk_btif_dbg_lvl;
+}
+
+void mtk_btif_read_cpu_sw_rst_debug(void)
+{
+	mtk_btif_read_cpu_sw_rst_debug_plat();
+}
+
+/*---------------------------------------------------------------------------*/
+
+module_init(BTIF_init);
+module_exit(BTIF_exit);
+
+/*---------------------------------------------------------------------------*/
+
+MODULE_AUTHOR("MBJ/WCN/SE/SS1/Chaozhong.Liang");
+MODULE_DESCRIPTION("MTK BTIF Driver$1.0$");
+MODULE_LICENSE("GPL");
+
+/*---------------------------------------------------------------------------*/
diff --git a/drivers/misc/mediatek/btif/common/mtk_btif_exp.c b/drivers/misc/mediatek/btif/common/mtk_btif_exp.c
new file mode 100644
index 00000000..b7f505d
--- /dev/null
+++ b/drivers/misc/mediatek/btif/common/mtk_btif_exp.c
@@ -0,0 +1,787 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG "MTK-BTIF-EXP"
+
+/*#include "mtk_btif_exp.h"*/
+#include "mtk_btif.h"
+
+/*---------------------------------Function----------------------------------*/
+
+p_mtk_btif btif_exp_srh_id(unsigned long u_id)
+{
+	int index = 0;
+	p_mtk_btif p_btif = NULL;
+	struct list_head *p_list = NULL;
+	struct list_head *tmp = NULL;
+	p_mtk_btif_user p_user = NULL;
+
+	for (index = 0; (index < BTIF_PORT_NR) && (p_btif == NULL); index++) {
+		p_list = &(g_btif[index].user_list);
+		list_for_each(tmp, p_list) {
+			p_user = container_of(tmp, mtk_btif_user, entry);
+			if (u_id == p_user->u_id) {
+				p_btif = p_user->p_btif;
+				BTIF_DBG_FUNC
+				    ("BTIF's user id(0x%p), p_btif(0x%p)\n",
+				     p_user->u_id, p_btif);
+				break;
+			}
+		}
+	}
+	if (p_btif == NULL) {
+		BTIF_INFO_FUNC
+		    ("no btif structure found for BTIF's user id(0x%lx)\n",
+		     u_id);
+	}
+	return p_btif;
+}
+
+/*-----Normal Mode API declearation-------*/
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_open
+* DESCRIPTION
+*  open BTIF interface, will do BTIF module HW and SW initialization
+* PARAMETERS
+*  p_owner      [IN] pointer to owner who call this API,
+*                    currently there are 2 owner ("stp" or "btif_tester")
+*                    may use this module
+*  for "stp", BTIF will call rx callback function to route rx data to STP module
+*  for "stp_tester", BTIF will save rx data and wait for native process to access
+*  p_id            [IN] BTIF's user id will be put to this address
+* RETURNS
+*  int  0 = BTIF module initialization fail; negative = BTIF module initialization success
+*       if open success, value p_id will be the only identifier
+*       for user to access BTIF's other operations
+*       including read/write/dpidle_ctrl/rx_cb_retister
+*       this user id is only an identifier used for owner identification
+*****************************************************************************/
+int mtk_wcn_btif_open(char *p_owner, unsigned long *p_id)
+{
+	int i_ret = -1;
+	unsigned int index = 0;
+	p_mtk_btif_user p_new_user = NULL;
+	p_mtk_btif p_btif = &g_btif[index];
+	struct list_head *p_user_list = &(p_btif->user_list);
+
+	BTIF_DBG_FUNC("++");
+	BTIF_DBG_FUNC("p_btif(0x%p)\n", p_btif);
+
+	if (mutex_lock_killable(&(p_btif->ops_mtx))) {
+		BTIF_ERR_FUNC("mutex_lock_killable return failed\n");
+		return E_BTIF_INTR;
+	}
+	if ((p_owner == NULL) || (p_id == NULL)) {
+		if (p_id)
+			*p_id = 0;
+		BTIF_ERR_FUNC("parameter invalid, p_owner(0x%p), p_id(0x%p)\n",
+			      p_owner, p_id);
+		BTIF_MUTEX_UNLOCK(&(p_btif->ops_mtx));
+		return E_BTIF_INVAL_PARAM;
+	}
+
+/*check if btif is already opened or not, if yes, just return fail*/
+	if (!list_empty(p_user_list)) {
+		struct list_head *pos;
+		p_mtk_btif_user p_user;
+
+		BTIF_ERR_FUNC("BTIF's user list is not empty\n");
+		list_for_each(pos, p_user_list) {
+			p_user = container_of(pos, mtk_btif_user, entry);
+			BTIF_INFO_FUNC("BTIF's user id(0x%lx), name(%s)\n",
+				       p_user->u_id, p_user->u_name);
+		}
+/*leave p_id alone*/
+		BTIF_MUTEX_UNLOCK(&(p_btif->ops_mtx));
+		return E_BTIF_ALREADY_OPEN;
+	}
+	p_new_user = vmalloc(sizeof(mtk_btif_user));
+
+	if (p_new_user != NULL) {
+		INIT_LIST_HEAD(&(p_new_user->entry));
+		p_new_user->enable = false;
+		p_new_user->p_btif = p_btif;
+		p_new_user->u_id = (unsigned long)p_new_user;
+		strncpy(p_new_user->u_name, p_owner, sizeof(p_new_user->u_name) - 1);
+		p_new_user->u_name[sizeof(p_new_user->u_name) - 1] = '\0';
+		BTIF_DBG_FUNC("owner name:%s, recorded name:%s\n",
+			       p_owner, p_new_user->u_name);
+
+		i_ret = btif_open(p_btif);
+		if (i_ret) {
+			BTIF_ERR_FUNC("btif_open failed, i_ret(%d)\n", i_ret);
+			*p_id = 0;
+/*free btif new user's structure*/
+			vfree(p_new_user);
+			p_new_user = NULL;
+		} else {
+			BTIF_INFO_FUNC("btif_open succeed\n");
+			*p_id = p_new_user->u_id;
+/*mark enable flag to true*/
+			p_new_user->enable = true;
+/*add to uer lsit*/
+			list_add_tail(&(p_new_user->entry), p_user_list);
+		}
+	} else {
+		*p_id = 0;
+		i_ret = -ENOMEM;
+		BTIF_ERR_FUNC("allocate memory for mtk_btif_user failed\n");
+	}
+	BTIF_MUTEX_UNLOCK(&(p_btif->ops_mtx));
+	BTIF_DBG_FUNC("--");
+	return i_ret;
+}
+EXPORT_SYMBOL(mtk_wcn_btif_open);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_close
+* DESCRIPTION
+*  close BTIF interface, will do BTIF module HW and SW de-initialization
+*  once this API is called, p_btif should never be used by BTIF's user again
+* PARAMETERS
+*  u_id        [IN] BTIF's user id
+* RETURNS
+*  int     0 = succeed;
+*          others = fail,
+*          for detailed information, please see ENUM_BTIF_OP_ERROR_CODE
+*****************************************************************************/
+int mtk_wcn_btif_close(unsigned long u_id)
+{
+	int i_ret = -1;
+	p_mtk_btif p_btif = NULL;
+	struct list_head *pos = NULL;
+	struct list_head *p_user_list = NULL;
+
+	BTIF_DBG_FUNC("++");
+	p_btif = btif_exp_srh_id(u_id);
+
+	if (p_btif == NULL)
+		return E_BTIF_INVAL_PARAM;
+
+	if (mutex_lock_killable(&(p_btif->ops_mtx))) {
+		BTIF_ERR_FUNC("mutex_lock_killable return failed\n");
+		return E_BTIF_INTR;
+	}
+	p_user_list = &(p_btif->user_list);
+	list_for_each(pos, p_user_list) {
+		p_mtk_btif_user p_user =
+		    container_of(pos, mtk_btif_user, entry);
+
+		if (p_user->u_id == u_id) {
+			BTIF_INFO_FUNC
+			    ("user who's id is 0x%lx deleted from user list\n",
+			     u_id);
+			list_del(pos);
+			vfree(p_user);
+			i_ret = btif_close(p_btif);
+			if (i_ret)
+				BTIF_WARN_FUNC("BTIF close failed");
+			break;
+		}
+	}
+	BTIF_MUTEX_UNLOCK(&(p_btif->ops_mtx));
+	BTIF_DBG_FUNC("--");
+	return 0;
+}
+EXPORT_SYMBOL(mtk_wcn_btif_close);
+
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_write
+* DESCRIPTION
+*  send data throuth BTIF module
+*  there's no internal buffer to cache STP data in BTIF driver,
+*  if in DMA mode
+*  btif driver will check if there's enough space in vFIFO for data to send in DMA mode
+*    if yes, put data to vFIFO and return corresponding data length to caller
+*    if no, corresponding error code will be returned to called
+* PARAMETERS
+*  p_btif      [IN] pointer returned by mtk_wcn_btif_open
+*  p_buf       [IN] pointer to target data to send
+*  len         [IN] data length (should be less than 2014 bytes per STP package)
+*
+*  if in non-DMA mode, BTIF driver will try to write to THR of BTIF controller
+*  if btif driver detected that no space is available in Tx FIFO,
+*  will return E_BTIF_NO_SPACE, mostly something is wrong with BTIF or
+*  consys when this return value is returned
+* RETURNS
+*  int  positive: data length send through BTIF;
+*       negative: please see ENUM_BTIF_OP_ERROR_CODE
+*       E_BTIF_AGAIN (0) will be returned to caller
+*       if btif does not have enough vFIFO to send data,
+*       when caller get 0, he should wait for a moment
+*       (5~10ms maybe) and try a few times (maybe 10~20)
+*        if still get E_BTIF_AGAIN,
+*        should call BTIF's debug API and dump BTIF driver
+*        and BTIF/DMA register information to kernel log for debug
+*        E_BTIF_BAD_POINTER will be returned to caller
+*        if btif is not opened successfully before call this API
+*        E_BTIF_INVAL_PARAM will be returned if parameter is not valid
+
+*****************************************************************************/
+int mtk_wcn_btif_write(unsigned long u_id,
+		       const unsigned char *p_buf, unsigned int len)
+{
+	int i_ret = -1;
+	p_mtk_btif p_btif = NULL;
+
+	BTIF_DBG_FUNC("++");
+	p_btif = btif_exp_srh_id(u_id);
+
+	if (p_btif == NULL)
+		return E_BTIF_INVAL_PARAM;
+	if (p_buf == NULL) {
+		BTIF_ERR_FUNC("invalid p_buf (0x%p)\n", p_buf);
+		return E_BTIF_INVAL_PARAM;
+	}
+	if ((len == 0) || (len > BTIF_MAX_LEN_PER_PKT)) {
+		BTIF_ERR_FUNC("invalid buffer length(%d)\n", len);
+		return E_BTIF_INVAL_PARAM;
+	}
+
+	i_ret = btif_send_data(p_btif, p_buf, len);
+	BTIF_DBG_FUNC("--, i_ret:%d\n", i_ret);
+	return i_ret;
+}
+EXPORT_SYMBOL(mtk_wcn_btif_write);
+
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_read
+* DESCRIPTION
+*  read data from BTIF module
+* PARAMETERS
+*  p_btif     [IN] pointer returned by mtk_wcn_btif_open
+*  p_buf      [IN/OUT] pointer to buffer where rx data will be put
+*  max_len    [IN] max buffer length
+* RETURNS
+*  int   positive: data length read from BTIF;
+*        negative: please see ENUM_BTIF_OP_ERROR_CODE
+*****************************************************************************/
+int mtk_wcn_btif_read(unsigned long u_id,
+		      unsigned char *p_buf, unsigned int max_len)
+{
+	return 0;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_dpidle_ctrl
+* DESCRIPTION
+*  control if BTIF module allow system enter deepidle state or not
+* PARAMETERS
+*  p_btif      [IN] pointer returned by mtk_wcn_btif_open
+*  en_flag    [IN] one of ENUM_BTIF_DPIDLE_CTRL
+* RETURNS
+*  int          always return 0
+*****************************************************************************/
+int mtk_wcn_btif_dpidle_ctrl(unsigned long u_id, ENUM_BTIF_DPIDLE_CTRL en_flag)
+{
+	int i_ret = -1;
+	p_mtk_btif p_btif = NULL;
+
+	p_btif = btif_exp_srh_id(u_id);
+
+	if (p_btif == NULL)
+		return E_BTIF_INVAL_PARAM;
+
+	if (en_flag == BTIF_DPIDLE_DISABLE)
+		i_ret = btif_exit_dpidle(p_btif);
+	else
+		i_ret = btif_enter_dpidle(p_btif);
+
+	return i_ret;
+}
+EXPORT_SYMBOL(mtk_wcn_btif_dpidle_ctrl);
+
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_rx_cb_register
+* DESCRIPTION
+*  register rx callback function to BTIF module by btif user
+* PARAMETERS
+*  p_btif  [IN] pointer returned by mtk_wcn_btif_open
+*  rx_cb  [IN] pointer to stp rx handler callback function,
+*            should be comply with MTK_WCN_BTIF_RX_CB
+* RETURNS
+*  int      0 = succeed;
+*           others = fail, for detailed information,
+*           please see ENUM_BTIF_OP_ERROR_CODE
+*****************************************************************************/
+int mtk_wcn_btif_rx_cb_register(unsigned long u_id, MTK_WCN_BTIF_RX_CB rx_cb)
+{
+	int i_ret = -1;
+	p_mtk_btif p_btif = NULL;
+
+	p_btif = btif_exp_srh_id(u_id);
+
+	if (p_btif == NULL)
+		return E_BTIF_INVAL_PARAM;
+
+	i_ret = btif_rx_cb_reg(p_btif, rx_cb);
+
+	return i_ret;
+}
+EXPORT_SYMBOL(mtk_wcn_btif_rx_cb_register);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_wakeup_consys
+* DESCRIPTION
+*  once sleep command is sent to con sys,
+*  should call this API before send wakeup command
+*  to make con sys aware host want to send data to consys
+* PARAMETERS
+*  p_btif      [IN] pointer returned by mtk_wcn_btif_open
+* RETURNS
+*  int          0 = succeed; others = fail, for detailed information, please see ENUM_BTIF_OP_ERROR_CODE
+*****************************************************************************/
+int mtk_wcn_btif_wakeup_consys(unsigned long u_id)
+{
+	int i_ret = -1;
+	p_mtk_btif p_btif = NULL;
+
+	p_btif = btif_exp_srh_id(u_id);
+
+	if (p_btif == NULL)
+		return E_BTIF_INVAL_PARAM;
+
+/*i_ret = hal_btif_raise_wak_sig(p_btif->p_btif_info);*/
+	i_ret = btif_raise_wak_signal(p_btif);
+
+	return i_ret;
+}
+EXPORT_SYMBOL(mtk_wcn_btif_wakeup_consys);
+
+
+/***************End of Normal Mode API declearation**********/
+
+/***************Debug Purpose API declearation**********/
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_loopback_ctrl
+* DESCRIPTION
+*  enable/disable BTIF internal loopback function,
+*  when this function is enabled data send to btif
+*  will be received by btif itself
+*  only for debug purpose, should never use this function in normal mode
+* PARAMETERS
+*  p_btif      [IN] pointer returned by mtk_wcn_btif_open
+*  enable     [IN] loopback mode control flag, enable or disable,
+*  shou be one of ENUM_BTIF_LPBK_MODE
+* RETURNS
+*  int          0 = succeed;
+*  others = fail, for detailed information, please see ENUM_BTIF_OP_ERROR_CODE
+*****************************************************************************/
+int mtk_wcn_btif_loopback_ctrl(unsigned long u_id, ENUM_BTIF_LPBK_MODE enable)
+{
+	int i_ret = -1;
+	p_mtk_btif p_btif = NULL;
+
+	p_btif = btif_exp_srh_id(u_id);
+
+	if (p_btif == NULL)
+		return E_BTIF_INVAL_PARAM;
+	i_ret =
+	    btif_lpbk_ctrl(p_btif, enable == BTIF_LPBK_ENABLE ? true : false);
+
+	return i_ret;
+}
+EXPORT_SYMBOL(mtk_wcn_btif_loopback_ctrl);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_btif_logger_ctrl
+* DESCRIPTION
+*  control BTIF logger function's behavior
+* PARAMETERS
+*  p_btif      [IN] pointer returned by mtk_wcn_btif_open
+*  flag         [IN] should be one of ENUM_BTIF_DBG_ID
+*                      BTIF_DISABLE_LOGGER  - disable btif logger
+*                      BTIF_ENABLE_LOGGER   - enable btif logger
+*                      BTIF_DUMP_LOG           - dump log logged by btif
+*                      BTIF_CLR_LOG             - clear btif log buffer
+*                      BTIF_DUMP_BTIF_REG   - dump btif controller's register
+*                      BTIF_DUMP_DMA_REG   - dump DMA controller's register
+* RETURNS
+*  int          0 = succeed; others = fail, for detailed information, please see ENUM_BTIF_OP_ERROR_CODE
+*****************************************************************************/
+int mtk_wcn_btif_dbg_ctrl(unsigned long u_id, ENUM_BTIF_DBG_ID flag)
+{
+	int i_ret = -1;
+	p_mtk_btif p_btif = NULL;
+
+	p_btif = btif_exp_srh_id(u_id);
+
+	if (p_btif == NULL)
+		return E_BTIF_INVAL_PARAM;
+
+	i_ret = 0;
+	switch (flag) {
+	case BTIF_DISABLE_LOGGER:{
+			BTIF_INFO_FUNC
+			    ("disable btif log function for both Tx and Rx\n");
+			btif_log_buf_disable(&p_btif->tx_log);
+			btif_log_buf_disable(&p_btif->rx_log);
+		}
+		break;
+	case BTIF_ENABLE_LOGGER:{
+			BTIF_INFO_FUNC
+			    ("enable btif log function for both Tx and Rx\n");
+			btif_log_buf_enable(&p_btif->tx_log);
+			btif_log_buf_enable(&p_btif->rx_log);
+		}
+		break;
+	case BTIF_DUMP_LOG:{
+			BTIF_INFO_FUNC("dump btif log for both Tx and Rx\n");
+			btif_log_buf_dmp_out(&p_btif->tx_log);
+			btif_log_buf_dmp_out(&p_btif->rx_log);
+		}
+		break;
+
+	case BTIF_CLR_LOG:{
+			BTIF_INFO_FUNC("clear btif log for both Tx and Rx\n");
+			btif_log_buf_reset(&p_btif->tx_log);
+			btif_log_buf_reset(&p_btif->rx_log);
+		}
+		break;
+	case BTIF_DUMP_BTIF_REG:
+		 /*TBD*/ btif_dump_reg(p_btif);
+		break;
+	case BTIF_ENABLE_RT_LOG:
+		BTIF_INFO_FUNC
+		    ("enable btif real time log for both Tx and Rx\n");
+		btif_log_output_enable(&p_btif->tx_log);
+		btif_log_output_enable(&p_btif->rx_log);
+		break;
+	case BTIF_DISABLE_RT_LOG:
+		BTIF_INFO_FUNC
+		    ("disable btif real time log for both Tx and Rx\n");
+		btif_log_output_disable(&p_btif->tx_log);
+		btif_log_output_disable(&p_btif->rx_log);
+		break;
+	default:
+		BTIF_INFO_FUNC("not supported flag:%d\n", flag);
+		i_ret = -2;
+		break;
+	}
+
+	return i_ret;
+}
+EXPORT_SYMBOL(mtk_wcn_btif_dbg_ctrl);
+
+bool mtk_wcn_btif_parser_wmt_evt(unsigned long u_id,
+	const char *sub_str, unsigned int str_len)
+{
+	bool b_ret = false;
+	p_mtk_btif p_btif = NULL;
+
+	p_btif = btif_exp_srh_id(u_id);
+
+	if (p_btif == NULL)
+		return E_BTIF_INVAL_PARAM;
+	b_ret = btif_parser_wmt_evt(p_btif, sub_str, str_len);
+	BTIF_INFO_FUNC("parser wmt evt %s\n", b_ret ? "ok" : "fail");
+
+	return b_ret;
+}
+EXPORT_SYMBOL(mtk_wcn_btif_parser_wmt_evt);
+
+/**********End of Debug Purpose API declearation**********/
+
+int btif_open_no_id(void)
+{
+	int i_ret = 0;
+	p_mtk_btif p_btif = &g_btif[0];
+
+	i_ret = btif_open(p_btif);
+
+	if (i_ret)
+		BTIF_ERR_FUNC("btif_open failed, i_ret(%d)\n", i_ret);
+	else
+		BTIF_INFO_FUNC("btif_open succeed\n");
+
+	return i_ret;
+}
+
+int btif_close_no_id(void)
+{
+	int i_ret = 0;
+	p_mtk_btif p_btif = &g_btif[0];
+
+	i_ret = btif_close(p_btif);
+
+	if (i_ret)
+		BTIF_ERR_FUNC("btif_close failed, i_ret(%d)\n", i_ret);
+	else
+		BTIF_INFO_FUNC("btif_close succeed\n");
+	return i_ret;
+}
+
+int btif_write_no_id(const unsigned char *p_buf, unsigned int len)
+{
+	int i_ret = -1;
+	p_mtk_btif p_btif = &g_btif[0];
+
+	BTIF_DBG_FUNC("++");
+
+	if (p_buf == NULL) {
+		BTIF_ERR_FUNC("invalid p_buf (0x%p)\n", p_buf);
+		return E_BTIF_INVAL_PARAM;
+	}
+	if ((len == 0) || (len > BTIF_MAX_LEN_PER_PKT)) {
+		BTIF_ERR_FUNC("invalid buffer length(%d)\n", len);
+		return E_BTIF_INVAL_PARAM;
+	}
+
+	i_ret = btif_send_data(p_btif, p_buf, len);
+	BTIF_DBG_FUNC("--, i_ret:%d\n", i_ret);
+	return i_ret;
+}
+
+int btif_dpidle_ctrl_no_id(ENUM_BTIF_DPIDLE_CTRL en_flag)
+{
+	int i_ret = -1;
+	p_mtk_btif p_btif = &g_btif[0];
+
+	if (en_flag == BTIF_DPIDLE_DISABLE)
+		i_ret = btif_exit_dpidle(p_btif);
+	else
+		i_ret = btif_enter_dpidle(p_btif);
+
+	return i_ret;
+}
+
+int btif_wakeup_consys_no_id(void)
+{
+	int i_ret = -1;
+	p_mtk_btif p_btif = &g_btif[0];
+
+/*i_ret = hal_btif_raise_wak_sig(p_btif->p_btif_info);*/
+	i_ret = btif_raise_wak_signal(p_btif);
+
+	return i_ret;
+}
+
+int btif_loopback_ctrl_no_id(ENUM_BTIF_LPBK_MODE enable)
+{
+	int i_ret = -1;
+	p_mtk_btif p_btif = &g_btif[0];
+
+	i_ret =
+	    btif_lpbk_ctrl(p_btif, enable == BTIF_LPBK_ENABLE ? true : false);
+
+	return i_ret;
+}
+
+int btif_dbg_ctrl_no_id(ENUM_BTIF_DBG_ID flag)
+{
+	int i_ret = -1;
+	p_mtk_btif p_btif = &g_btif[0];
+
+	i_ret = 0;
+	switch (flag) {
+	case BTIF_DISABLE_LOGGER:{
+			BTIF_INFO_FUNC
+			    ("disable btif log function for both Tx and Rx\n");
+			btif_log_buf_disable(&p_btif->tx_log);
+			btif_log_buf_disable(&p_btif->rx_log);
+		}
+		break;
+	case BTIF_ENABLE_LOGGER:{
+			BTIF_INFO_FUNC
+			    ("enable btif log function for both Tx and Rx\n");
+			btif_log_buf_enable(&p_btif->tx_log);
+			btif_log_buf_enable(&p_btif->rx_log);
+		}
+		break;
+	case BTIF_DUMP_LOG:{
+			BTIF_INFO_FUNC("dump btif log for both Tx and Rx\n");
+			btif_log_buf_dmp_out(&p_btif->tx_log);
+			btif_log_buf_dmp_out(&p_btif->rx_log);
+		}
+		break;
+
+	case BTIF_CLR_LOG:{
+			BTIF_INFO_FUNC("clear btif log for both Tx and Rx\n");
+			btif_log_buf_reset(&p_btif->tx_log);
+			btif_log_buf_reset(&p_btif->rx_log);
+		}
+		break;
+	case BTIF_DUMP_BTIF_REG:
+		 /*TBD*/ btif_dump_reg(p_btif);
+		break;
+	case BTIF_ENABLE_RT_LOG:
+		BTIF_INFO_FUNC
+		    ("enable btif real time log for both Tx and Rx\n");
+		btif_log_output_enable(&p_btif->tx_log);
+		btif_log_output_enable(&p_btif->rx_log);
+		break;
+	case BTIF_DISABLE_RT_LOG:
+		BTIF_INFO_FUNC
+		    ("disable btif real time log for both Tx and Rx\n");
+		btif_log_output_disable(&p_btif->tx_log);
+		btif_log_output_disable(&p_btif->rx_log);
+		break;
+	default:
+		BTIF_INFO_FUNC("not supported flag:%d\n", flag);
+		i_ret = -2;
+		break;
+	}
+
+	return i_ret;
+}
+
+int mtk_btif_exp_open_test(void)
+{
+	int i_ret = 0;
+
+	i_ret = btif_open_no_id();
+	if (i_ret < 0) {
+		BTIF_INFO_FUNC("mtk_wcn_btif_open failed\n");
+		return -1;
+	}
+
+	BTIF_INFO_FUNC("mtk_wcn_btif_open succeed\n");
+
+	return i_ret;
+}
+
+int mtk_btif_exp_close_test(void)
+{
+	int i_ret = 0;
+
+	i_ret = btif_close_no_id();
+	if (i_ret < 0) {
+		BTIF_INFO_FUNC("mtk_wcn_btif_close failed\n");
+		return -1;
+	}
+
+	BTIF_INFO_FUNC("mtk_wcn_btif_close succeed\n");
+
+	return i_ret;
+}
+
+int mtk_btif_exp_write_test(void)
+{
+	return mtk_btif_exp_write_stress_test(100, 10);
+}
+
+int mtk_btif_exp_write_stress_test(unsigned int length, unsigned int max_loop)
+{
+#define BUF_LEN 1024
+	int i_ret = 0;
+	int idx = 0;
+	int buf_len = length > BUF_LEN ? BUF_LEN : length;
+	int loop = max_loop > 1000000 ? 1000000 : max_loop;
+	unsigned char *buffer;
+
+	buffer = kmalloc(BUF_LEN, GFP_KERNEL);
+	if (!buffer) {
+		BTIF_ERR_FUNC("btif tester kmalloc failed\n");
+		return -1;
+	}
+
+	for (idx = 0; idx < buf_len; idx++)
+		/* btif_stress_test_buf[idx] = BUF_LEN -idx; */
+		*(buffer + idx) = idx % 255;
+	i_ret = btif_loopback_ctrl_no_id(BTIF_LPBK_ENABLE);
+	BTIF_INFO_FUNC("mtk_wcn_btif_loopback_ctrl returned %d\n", i_ret);
+	while (loop--) {
+		i_ret = btif_write_no_id(buffer, buf_len);
+		BTIF_INFO_FUNC("mtk_wcn_btif_write left loop:%d, i_ret:%d\n",
+				   loop, i_ret);
+		if (i_ret != buf_len) {
+			BTIF_INFO_FUNC
+				("mtk_wcn_btif_write failed, target len %d, sent len: %d\n",
+				 buf_len, i_ret);
+			break;
+		}
+		buf_len--;
+		if (buf_len <= 0)
+			buf_len = length > BUF_LEN ? BUF_LEN : length;
+	}
+	kfree(buffer);
+	return i_ret;
+}
+
+int mtk_btif_exp_suspend_test(void)
+{
+	int i_ret = 0;
+	p_mtk_btif p_btif = &g_btif[0];
+
+	i_ret = _btif_suspend(p_btif);
+	return i_ret;
+}
+
+int mtk_btif_exp_restore_noirq_test(void)
+{
+	int i_ret = 0;
+	p_mtk_btif p_btif = &g_btif[0];
+
+	i_ret = _btif_restore_noirq(p_btif);
+	return i_ret;
+}
+
+int mtk_btif_exp_clock_ctrl(int en)
+{
+	int i_ret = 0;
+	p_mtk_btif p_btif = &g_btif[0];
+
+	i_ret = btif_clock_ctrl(p_btif, en);
+	return i_ret;
+}
+
+int mtk_btif_exp_resume_test(void)
+{
+	int i_ret = 0;
+	p_mtk_btif p_btif = &g_btif[0];
+
+	i_ret = _btif_resume(p_btif);
+	return i_ret;
+}
+
+int mtk_btif_exp_enter_dpidle_test(void)
+{
+	return btif_dpidle_ctrl_no_id(BTIF_DPIDLE_ENABLE);
+}
+
+int mtk_btif_exp_exit_dpidle_test(void)
+{
+	return btif_dpidle_ctrl_no_id(BTIF_DPIDLE_DISABLE);
+}
+
+int mtk_btif_exp_log_debug_test(int flag)
+{
+	int i_ret = 0;
+
+	i_ret = btif_dbg_ctrl_no_id(flag);
+	return i_ret;
+}
+
+void mtk_btif_read_cpu_sw_rst_debug_exp(void)
+{
+	mtk_btif_read_cpu_sw_rst_debug();
+}
+
+/************End of Function**********/
diff --git a/drivers/misc/mediatek/btif/common/plat_inc/btif_dma_priv.h b/drivers/misc/mediatek/btif/common/plat_inc/btif_dma_priv.h
new file mode 100644
index 00000000..97756f6
--- /dev/null
+++ b/drivers/misc/mediatek/btif/common/plat_inc/btif_dma_priv.h
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __HAL_BTIF_DMA_H_
+#define __HAL_BTIF_DMA_H_
+
+#include <linux/io.h>
+#include "btif_dma_pub.h"
+
+#if defined(CONFIG_MTK_CLKMGR)
+#if defined(CONFIG_ARCH_MT6580)
+#define MTK_BTIF_APDMA_CLK_CG MT_CG_APDMA_SW_CG
+#elif defined(CONFIG_ARCH_MT6735) || defined(CONFIG_ARCH_MT6735M) || defined(CONFIG_ARCH_MT6753)
+#define MTK_BTIF_APDMA_CLK_CG MT_CG_PERI_APDMA
+#endif
+#else
+extern struct clk *clk_btif_apdma; /*btif apdma clock*/
+#endif /* !defined(CONFIG_MTK_CLKMGR) */
+
+#define TX_DMA_VFF_SIZE (1024 * 8)	/*Tx vFIFO Len must be 8 Byte allignment */
+#define RX_DMA_VFF_SIZE (1024 * 8)	/*Rx vFIFO Len must be 8 Byte allignment */
+
+#define DMA_TX_THRE(n) (n - 7)	/*Tx Trigger Level */
+#define DMA_RX_THRE(n) ((n) * 3 / 4)	/*Rx Trigger Level */
+
+/**********************************Hardware related defination**************************/
+#ifndef CONFIG_OF
+/*DMA channel's offset refer to AP_DMA's base address*/
+#define BTIF_TX_DMA_OFFSET 0x880
+#define BTIF_RX_DMA_OFFSET 0x900
+#endif
+
+/*Register Address Mapping*/
+#define DMA_INT_FLAG_OFFSET  0x00
+#define DMA_INT_EN_OFFSET  0x04
+#define DMA_EN_OFFSET  0x08
+#define DMA_RST_OFFSET  0x0C
+#define DMA_STOP_OFFSET  0x10
+#define DMA_FLUSH_OFFSET  0x14
+
+#define DMA_BASE_OFFSET  0x1C
+#define DMA_LEN_OFFSET  0x24
+
+#define DMA_THRE_OFFSET  0x28
+#define DMA_WPT_OFFSET  0x2C
+#define DMA_RPT_OFFSET  0x30
+#define DMA_VALID_OFFSET  0x3C
+#define DMA_LEFT_OFFSET  0x40
+#define DMA_VFF_BIT29_OFFSET  0x01
+
+#define TX_DMA_INT_FLAG(base)       (unsigned long)(base + 0x0)	/*BTIF Tx Virtual FIFO Interrupt Flag Register */
+#define TX_DMA_INT_EN(base)         (unsigned long)(base + 0x4)	/*BTIF Tx Virtual FIFO Interrupt Enable Register */
+#define TX_DMA_EN(base)             (unsigned long)(base + DMA_EN_OFFSET)/*BTIF Tx Virtual FIFO Enable Register */
+#define TX_DMA_RST(base)            (unsigned long)(base + DMA_RST_OFFSET)/*BTIF Tx Virtual FIFO  Reset Register */
+#define TX_DMA_STOP(base)           (unsigned long)(base + DMA_STOP_OFFSET)/*BTIF Tx Virtual FIFO STOP  Register */
+#define TX_DMA_FLUSH(base)          (unsigned long)(base + DMA_FLUSH_OFFSET)/*BTIF Tx Virtual FIFO Flush Register */
+#define TX_DMA_VFF_ADDR(base)       (unsigned long)(base + 0x1C) /*BTIF Tx Virtual FIFO Base Address Register */
+#define TX_DMA_VFF_LEN(base)        (unsigned long)(base + 0x24) /*BTIF Tx Virtual FIFO Length Register */
+#define TX_DMA_VFF_THRE(base)       (unsigned long)(base + 0x28) /*BTIF Tx Virtual FIFO Threshold Register */
+#define TX_DMA_VFF_WPT(base)        (unsigned long)(base + 0x2C) /*BTIF Tx Virtual FIFO Write Pointer Register */
+#define TX_DMA_VFF_RPT(base)        (unsigned long)(base + 0x30) /*BTIF Tx Virtual FIFO Read Pointer  Register */
+#define TX_DMA_W_INT_BUF_SIZE(base) (unsigned long)(base + 0x34)
+/*BTIF Tx Virtual FIFO Internal Tx Write Buffer Size Register */
+#define TX_DMA_INT_BUF_SIZE(base)   (unsigned long)(base + 0x38)
+/*BTIF Tx Virtual FIFO Internal Tx Buffer Size Register */
+
+#define TX_DMA_VFF_VALID_SIZE(base) (unsigned long)(base + 0x3C) /*BTIF Tx Virtual FIFO Valid Size Register */
+#define TX_DMA_VFF_LEFT_SIZE(base)  (unsigned long)(base + 0x40) /*BTIF Tx Virtual FIFO Left Size Register */
+#define TX_DMA_DEBUG_STATUS(base)   (unsigned long)(base + 0x50) /*BTIF Tx Virtual FIFO Debug Status Register */
+#define TX_DMA_VFF_ADDR_H(base)     (unsigned long)(base + 0x54) /*BTIF Tx Virtual FIFO Base High Address Register */
+
+/*Rx Register Address Mapping*/
+#define RX_DMA_INT_FLAG(base)       (unsigned long)(base + 0x0)	/*BTIF Rx Virtual FIFO Interrupt Flag Register */
+#define RX_DMA_INT_EN(base)         (unsigned long)(base + 0x4)	/*BTIF Rx Virtual FIFO Interrupt Enable Register */
+#define RX_DMA_EN(base)             (unsigned long)(base + DMA_EN_OFFSET) /*BTIF Rx Virtual FIFO Enable Register */
+#define RX_DMA_RST(base)            (unsigned long)(base + DMA_RST_OFFSET) /*BTIF Rx Virtual FIFO Reset Register */
+#define RX_DMA_STOP(base)           (unsigned long)(base + DMA_STOP_OFFSET) /*BTIF Rx Virtual FIFO Stop Register */
+#define RX_DMA_FLUSH(base)          (unsigned long)(base + DMA_FLUSH_OFFSET) /*BTIF Rx Virtual FIFO Flush Register */
+#define RX_DMA_VFF_ADDR(base)       (unsigned long)(base + 0x1C) /*BTIF Rx Virtual FIFO Base Address Register */
+#define RX_DMA_VFF_LEN(base)        (unsigned long)(base + 0x24) /*BTIF Rx Virtual FIFO Length Register */
+#define RX_DMA_VFF_THRE(base)       (unsigned long)(base + 0x28) /*BTIF Rx Virtual FIFO Threshold Register */
+#define RX_DMA_VFF_WPT(base)        (unsigned long)(base + 0x2C) /*BTIF Rx Virtual FIFO Write Pointer Register */
+#define RX_DMA_VFF_RPT(base)        (unsigned long)(base + 0x30) /*BTIF Rx Virtual FIFO Read Pointer Register */
+#define RX_DMA_FLOW_CTRL_THRE(base) (unsigned long)(base + 0x34) /*BTIF Rx Virtual FIFO Flow Control  Register */
+#define RX_DMA_INT_BUF_SIZE(base)   (unsigned long)(base + 0x38) /*BTIF Rx Virtual FIFO Internal Buffer Register */
+#define RX_DMA_VFF_VALID_SIZE(base) (unsigned long)(base + 0x3C) /*BTIF Rx Virtual FIFO Valid Size Register */
+#define RX_DMA_VFF_LEFT_SIZE(base)  (unsigned long)(base + 0x40) /*BTIF Rx Virtual FIFO Left Size  Register */
+#define RX_DMA_DEBUG_STATUS(base)   (unsigned long)(base + 0x50) /*BTIF Rx Virtual FIFO Debug Status Register */
+#define RX_DMA_VFF_ADDR_H(base)     (unsigned long)(base + 0x54) /*BTIF Rx Virtual FIFO Base High Address Register */
+
+#define DMA_EN_BIT (0x1)
+#define DMA_STOP_BIT (0x1)
+#define DMA_RST_BIT (0x1)
+#define DMA_FLUSH_BIT (0x1)
+
+#define DMA_WARM_RST (0x1 << 0)
+#define DMA_HARD_RST (0x1 << 1)
+
+#define DMA_WPT_MASK (0x0000FFFF)
+#define DMA_WPT_WRAP (0x00010000)
+
+#define DMA_RPT_MASK (0x0000FFFF)
+#define DMA_RPT_WRAP (0x00010000)
+
+/*APDMA BTIF Tx Reg Ctrl Bit*/
+#define TX_DMA_INT_FLAG_MASK (0x1)
+
+#define TX_DMA_INTEN_BIT (0x1)
+
+#define TX_DMA_ADDR_MASK (0xFFFFFFF8)
+#define TX_DMA_LEN_MASK (0x0000FFF8)
+
+#define TX_DMA_THRE_MASK (0x0000FFFF)
+
+#define TX_DMA_W_INT_BUF_MASK (0x000000FF)
+
+#define TX_DMA_VFF_VALID_MASK (0x0000FFFF)
+#define TX_DMA_VFF_LEFT_MASK (0x0000FFFF)
+
+/*APDMA BTIF Rx Reg Ctrl Bit*/
+#define RX_DMA_INT_THRE (0x1 << 0)
+#define RX_DMA_INT_DONE (0x1 << 1)
+
+#define RX_DMA_INT_THRE_EN (0x1 << 0)
+#define RX_DMA_INT_DONE_EN (0x1 << 1)
+
+#define RX_DMA_ADDR_MASK (0xFFFFFFF8)
+#define RX_DMA_LEN_MASK (0x0000FFF8)
+
+#define RX_DMA_THRE_MASK (0x0000FFFF)
+
+#define RX_DMA_FLOW_CTRL_THRE_MASK (0x000000FF)
+
+#define RX_DMA_INT_BUF_SIZE_MASK (0x0000001F)
+
+#define RX_DMA_VFF_VALID_MASK (0x0000001F)
+
+#define RX_DMA_VFF_LEFT_MASK (0x0000FFFF)
+
+typedef struct _MTK_BTIF_DMA_VFIFO_ {
+	DMA_VFIFO vfifo;
+	unsigned int wpt;	/*DMA's write pointer, which is maintained by SW for Tx DMA and HW for Rx DMA */
+	unsigned int last_wpt_wrap;	/*last wrap bit for wpt */
+	unsigned int rpt;	/*DMA's read pointer, which is maintained by HW for Tx DMA and SW for Rx DMA */
+	unsigned int last_rpt_wrap;	/*last wrap bit for rpt */
+} MTK_BTIF_DMA_VFIFO, *P_MTK_BTIF_DMA_VFIFO;
+
+/*for DMA debug purpose*/
+typedef struct _MTK_BTIF_DMA_REG_DMP_DBG_ {
+	unsigned long reg_addr;
+	unsigned int reg_val;
+} MTK_BTIF_DMA_REG_DMP_DBG, *P_MTK_BTIF_DMA_REG_DMP_DBG;
+
+#endif /*__HAL_BTIF_DMA_H_*/
diff --git a/drivers/misc/mediatek/btif/common/plat_inc/btif_dma_pub.h b/drivers/misc/mediatek/btif/common/plat_inc/btif_dma_pub.h
new file mode 100644
index 00000000..0773f2c
--- /dev/null
+++ b/drivers/misc/mediatek/btif/common/plat_inc/btif_dma_pub.h
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __HAL_BTIFD_DMA_PUB_H_
+#define __HAL_BTIFD_DMA_PUB_H_
+
+#include <linux/dma-mapping.h>
+
+#include "plat_common.h"
+
+typedef enum _ENUM_DMA_CTRL_ {
+	DMA_CTRL_DISABLE = 0,
+	DMA_CTRL_ENABLE = DMA_CTRL_DISABLE + 1,
+	DMA_CTRL_BOTH,
+} ENUM_DMA_CTRL;
+
+/*****************************************************************************
+* FUNCTION
+*  hal_tx_dma_info_get
+* DESCRIPTION
+*  get btif tx dma channel's information
+* PARAMETERS
+* dma_dir        [IN]         DMA's direction
+* RETURNS
+*  pointer to btif dma's information structure
+*****************************************************************************/
+P_MTK_DMA_INFO_STR hal_btif_dma_info_get(ENUM_DMA_DIR dma_dir);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_dma_hw_init
+* DESCRIPTION
+*  control clock output enable/disable of DMA module
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_dma_hw_init(P_MTK_DMA_INFO_STR p_dma_info);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_clk_ctrl
+* DESCRIPTION
+*  control clock output enable/disable of DMA module
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_dma_clk_ctrl(P_MTK_DMA_INFO_STR p_dma_info, ENUM_CLOCK_CTRL flag);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_tx_dma_ctrl
+* DESCRIPTION
+* enable/disable Tx DMA channel
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* ctrl_id          [IN]        enable/disable ID
+* dma_dir        [IN]         DMA's direction
+* RETURNS
+*  0 means success; negative means fail
+*****************************************************************************/
+int hal_btif_dma_ctrl(P_MTK_DMA_INFO_STR p_dma_info, ENUM_DMA_CTRL ctrl_id);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_dma_rx_cb_reg
+* DESCRIPTION
+* register rx callback function to dma module
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* rx_cb           [IN]        function pointer to btif
+* RETURNS
+*  0 means success; negative means fail
+*****************************************************************************/
+int hal_btif_dma_rx_cb_reg(P_MTK_DMA_INFO_STR p_dma_info,
+			   dma_rx_buf_write rx_cb);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_tx_vfifo_reset
+* DESCRIPTION
+*  reset tx virtual fifo information, except memory information
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* dma_dir  [IN]         DMA's direction
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_vfifo_reset(P_MTK_DMA_INFO_STR p_dma_info);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_tx_dma_irq_handler
+* DESCRIPTION
+*  lower level tx interrupt handler
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_tx_dma_irq_handler(P_MTK_DMA_INFO_STR p_dma_info);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_dma_send_data
+* DESCRIPTION
+*  send data through btif in DMA mode
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* p_buf     [IN]        pointer to rx data buffer
+* max_len  [IN]        tx buffer length
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_dma_send_data(P_MTK_DMA_INFO_STR p_dma_info,
+		      const unsigned char *p_buf, const unsigned int buf_len);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_dma_is_tx_complete
+* DESCRIPTION
+*  get tx complete flag
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* RETURNS
+*  true means tx complete, false means tx in process
+*****************************************************************************/
+bool hal_dma_is_tx_complete(P_MTK_DMA_INFO_STR p_dma_info);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_dma_get_ava_room
+* DESCRIPTION
+*  get tx available room
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* RETURNS
+*  available room  size
+*****************************************************************************/
+int hal_dma_get_ava_room(P_MTK_DMA_INFO_STR p_dma_info);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_dma_is_tx_allow
+* DESCRIPTION
+*  is tx operation allowed by DMA
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* RETURNS
+*  true if tx operation is allowed; false if tx is not allowed
+*****************************************************************************/
+bool hal_dma_is_tx_allow(P_MTK_DMA_INFO_STR p_dma_info);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_rx_dma_irq_handler
+* DESCRIPTION
+*  lower level rx interrupt handler
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* p_buf     [IN/OUT] pointer to rx data buffer
+* max_len  [IN]        max length of rx buffer
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_rx_dma_irq_handler(P_MTK_DMA_INFO_STR p_dma_info,
+			   unsigned char *p_buf, const unsigned int max_len);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_dma_dump_reg
+* DESCRIPTION
+*  dump BTIF module's information when needed
+* PARAMETERS
+* p_dma_info   [IN]        pointer to BTIF dma channel's information
+* flag             [IN]        register id flag
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_dma_dump_reg(P_MTK_DMA_INFO_STR p_dma_info, ENUM_BTIF_REG_ID flag);
+
+int hal_dma_pm_ops(P_MTK_DMA_INFO_STR p_dma_info, MTK_BTIF_PM_OPID opid);
+
+#endif /*__HAL_BTIFD_DMA_PUB_H_*/
diff --git a/drivers/misc/mediatek/btif/common/plat_inc/btif_priv.h b/drivers/misc/mediatek/btif/common/plat_inc/btif_priv.h
new file mode 100644
index 00000000..51fe58a
--- /dev/null
+++ b/drivers/misc/mediatek/btif/common/plat_inc/btif_priv.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __HAL_BTIF_H_
+#define __HAL_BTIF_H_
+
+#ifndef CONFIG_OF
+#define MTK_BTIF_REG_BASE BTIF_BASE
+#endif
+
+#if defined(CONFIG_MTK_CLKMGR)
+#if defined(CONFIG_ARCH_MT6580)
+#define MTK_BTIF_CG_BIT MT_CG_BTIF_SW_CG
+#elif defined(CONFIG_ARCH_MT6735) || defined(CONFIG_ARCH_MT6735M) || defined(CONFIG_ARCH_MT6753)
+#define MTK_BTIF_CG_BIT MT_CG_PERI_BTIF
+#endif
+#else
+struct clk *clk_btif_apdma; /*btif apdma clock*/
+struct clk *clk_btif; /*btif  clock*/
+#endif /* !defined(CONFIG_MTK_CLKMGR) */
+
+#define BTIF_RBR(base)         (unsigned long)(base + 0x0)	/*RX Buffer Register: read only */
+#define BTIF_THR(base)         (unsigned long)(base + 0x0) /*Rx Holding Register: write only */
+#define BTIF_IER(base)         (unsigned long)(base + 0x4) /*Interrupt Enable Register: read/write */
+#define BTIF_IIR(base)         (unsigned long)(base + 0x8)	/*Interrupt Identification Register: read only */
+#define BTIF_FIFOCTRL(base)    (unsigned long)(base + 0x8)	/*FIFO Control Register: write only */
+#define BTIF_FAKELCR(base)     (unsigned long)(base + 0xC)	/*FAKE LCR Register: read/write */
+#define BTIF_LSR(base)         (unsigned long)(base + 0x14)	/*Line Status Register: read only */
+#define BTIF_SLEEP_EN(base)    (unsigned long)(base + 0x48)	/*Sleep Enable Register: read/write */
+#define BTIF_DMA_EN(base)      (unsigned long)(base + 0x4C)	/*DMA Enable Register: read/write */
+#define BTIF_RTOCNT(base)      (unsigned long)(base + 0x54)	/*Rx Timeout Count Register: read/write */
+#define BTIF_TRI_LVL(base)     (unsigned long)(base + 0x60)	/*Tx/Rx Trigger Level Control Register: read/write */
+#define BTIF_WAK(base)         (unsigned long)(base + 0x64)	/*BTIF module wakeup Register: write only */
+#define BTIF_WAT_TIME(base)    (unsigned long)(base + 0x68)	/*BTIF ASYNC Wait Time Control Register: read/write */
+#define BTIF_HANDSHAKE(base)   (unsigned long)(base + 0x6C)	/*BTIF New Handshake Control Register: read/write */
+
+/*BTIF_IER bits*/
+#define BTIF_IER_TXEEN (0x1 << 1)	/*1: Tx holding register is empty */
+#define BTIF_IER_RXFEN (0x1 << 0)	/*1: Rx buffer contains data */
+
+/*BTIF_IIR bits*/
+#define BTIF_IIR_NINT        (0x1 << 0)	/*No INT Pending */
+#define BTIF_IIR_TX_EMPTY    (0x1 << 1)	/*Tx Holding Register empty */
+#define BTIF_IIR_RX          (0x1 << 2)	/*Rx data received */
+#define BTIF_IIR_RX_TIMEOUT  (0x11 << 2)	/*Rx data received */
+
+/*BTIF_LSR bits*/
+#define BTIF_LSR_DR_BIT (0x1 << 0)
+#define BTIF_LSR_THRE_BIT (0x1 << 5)
+#define BTIF_LSR_TEMT_BIT (0x1 << 6)
+
+/*BTIF_FIFOCTRL bits*/
+#define BTIF_FIFOCTRL_CLR_TX (0x1 << 2)	/*Clear Tx FIRO */
+#define BTIF_FIFOCTRL_CLR_RX (0x1 << 1)	/*Clear Rx FIRO */
+
+/*BTIF_FAKELCR bits*/
+#define BTIF_FAKELCR_NORMAL_MODE 0x0
+
+/*BTIF_SLEEP_EN bits*/
+#define BTIF_SLEEP_EN_BIT (0x1 << 0)	/*enable Sleep mode */
+#define BTIF_SLEEP_DIS_BIT (0x0)	/*disable sleep mode */
+
+/*BTIF_DMA_EN bits*/
+#define BTIF_DMA_EN_RX  (0x1 << 0)	/*Enable Rx DMA */
+#define BTIF_DMA_EN_TX  (0x1 << 1)	/*Enable Tx DMA */
+#define BTIF_DMA_EN_AUTORST_EN  (0x1 << 2)	/*1: timeout counter will be auto reset */
+#define BTIF_DMA_EN_AUTORST_DIS  (0x0 << 2)	/*
+						 * 0: after Rx timeout happens,
+						 * SW shall reset the interrupt by reading BTIF 0x4C
+						 */
+
+/*BTIF_TRI_LVL bits*/
+#define BTIF_TRI_LVL_TX_MASK ((0xf) << 0)
+#define BTIF_TRI_LVL_RX_MASK ((0x7) << 4)
+
+#define BTIF_TRI_LVL_TX(x) ((x & 0xf) << 0)
+#define BTIF_TRI_LVL_RX(x) ((x & 0x7) << 4)
+
+#define BTIF_TRI_LOOP_EN (0x1 << 7)
+#define BTIF_TRI_LOOP_DIS (0x0 << 7)
+
+/*BTIF_WAK bits*/
+#define BTIF_WAK_BIT (0x1 << 0)
+
+/*BTIF_HANDSHAKE bits*/
+#define BTIF_HANDSHAKE_EN_HANDSHAKE 1
+#define BTIF_HANDSHAKE_DIS_HANDSHAKE 0
+
+#define BTIF_TX_FIFO_SIZE 16
+#define BTIF_RX_FIFO_SIZE 8
+
+#define BTIF_TX_FIFO_THRE (BTIF_TX_FIFO_SIZE / 2)
+#define BTIF_RX_FIFO_THRE 0x1	/* 0x5 */
+
+#endif /*__HAL_BTIF_H_*/
diff --git a/drivers/misc/mediatek/btif/common/plat_inc/btif_pub.h b/drivers/misc/mediatek/btif/common/plat_inc/btif_pub.h
new file mode 100644
index 00000000..1555d5a
--- /dev/null
+++ b/drivers/misc/mediatek/btif/common/plat_inc/btif_pub.h
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __HAL_BTIF_PUB_H_
+#define __HAL_BTIF_PUB_H_
+
+#include "plat_common.h"
+
+/*Enum Defination*/
+/*BTIF Mode Enum */
+typedef enum _ENUM_BTIF_MODE_ {
+	BTIF_MODE_PIO = 0,
+	BTIF_MODE_DMA = BTIF_MODE_PIO + 1,
+	BTIF_MODE_MAX,
+} ENUM_BTIF_MODE;
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_info_get
+* DESCRIPTION
+*  get btif's information included base address , irq related information
+* PARAMETERS
+* RETURNS
+*  BTIF's information
+*****************************************************************************/
+P_MTK_BTIF_INFO_STR hal_btif_info_get(void);
+
+#if 0				/*included in hal_btif_info_get */
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_get_irq
+* DESCRIPTION
+*  get BTIF module's IRQ information
+* PARAMETERS
+* RETURNS
+*  pointer to BTIF's irq structure
+*****************************************************************************/
+P_MTK_BTIF_IRQ_STR hal_btif_get_irq(void);
+#endif
+
+#if !defined(CONFIG_MTK_CLKMGR)
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_clk_get_and_prepare
+* DESCRIPTION
+*  get clock from device tree and prepare for enable/disable control
+* PARAMETERS
+* pdev  device pointer
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_clk_get_and_prepare(struct platform_device *pdev);
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_clk_unprepare
+* DESCRIPTION
+*  unprepare btif clock and apdma clock
+* PARAMETERS
+* none
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_clk_unprepare(void);
+#endif
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_clk_ctrl
+* DESCRIPTION
+*  control clock output enable/disable of BTIF module
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_clk_ctrl(P_MTK_BTIF_INFO_STR p_btif, ENUM_CLOCK_CTRL flag);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_hw_init
+* DESCRIPTION
+*  BTIF module init, after this step, BTIF should enable to do tx/rx with PIO
+*  mode
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_hw_init(P_MTK_BTIF_INFO_STR p_btif);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_rx_cb_reg
+* DESCRIPTION
+*  BTIF rx callback register API
+* PARAMETERS
+* p_btif_info   [IN]        pointer to BTIF's information
+* rx_cb          [IN]        rx callback function
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_rx_cb_reg(P_MTK_BTIF_INFO_STR p_btif_info,
+		       btif_rx_buf_write rx_cb);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_loopback_ctrl
+* DESCRIPTION
+*  BTIF Tx/Rx loopback mode set, this operation can only be done
+*  after set BTIF to normal mode
+* PARAMETERS
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_loopback_ctrl(P_MTK_BTIF_INFO_STR p_btif, bool en);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_rx_handler
+* DESCRIPTION
+*  lower level interrupt handler
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* p_buf     [IN/OUT] pointer to rx data buffer
+* max_len  [IN]        max length of rx buffer
+* RETURNS
+*  0 means success; negative means fail; positive means rx data length
+*****************************************************************************/
+int hal_btif_irq_handler(P_MTK_BTIF_INFO_STR p_btif,
+			 unsigned char *p_buf, const unsigned int max_len);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_tx_mode_ctrl
+* DESCRIPTION
+*  set BTIF tx to corresponding mode (PIO/DMA)
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* mode     [IN]        rx mode <PIO/DMA>
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_tx_mode_ctrl(P_MTK_BTIF_INFO_STR p_btif, ENUM_BTIF_MODE mode);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_rx_mode_ctrl
+* DESCRIPTION
+*  set BTIF rx to corresponding mode (PIO/DMA)
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* mode     [IN]        rx mode <PIO/DMA>
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_rx_mode_ctrl(P_MTK_BTIF_INFO_STR p_btif, ENUM_BTIF_MODE mode);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_send_data
+* DESCRIPTION
+*  send data through btif in FIFO mode
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* p_buf     [IN]        pointer to rx data buffer
+* max_len  [IN]        tx buffer length
+* RETURNS
+*  positive means number of data sent;
+*  0 means no data put to FIFO;
+*  negative means error happens
+*****************************************************************************/
+int hal_btif_send_data(P_MTK_BTIF_INFO_STR p_btif,
+		       const unsigned char *p_buf, const unsigned int buf_len);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_raise_wak_sig
+* DESCRIPTION
+*  raise wakeup signal to counterpart
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_raise_wak_sig(P_MTK_BTIF_INFO_STR p_btif);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_dump_reg
+* DESCRIPTION
+*  dump BTIF module's information when needed
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* flag        [IN]        register id flag
+* RETURNS
+*  0 means success, negative means fail
+*****************************************************************************/
+int hal_btif_dump_reg(P_MTK_BTIF_INFO_STR p_btif, ENUM_BTIF_REG_ID flag);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_is_tx_complete
+* DESCRIPTION
+*  get tx complete flag
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* RETURNS
+*  true means tx complete, false means tx in process
+*****************************************************************************/
+bool hal_btif_is_tx_complete(P_MTK_BTIF_INFO_STR p_btif);
+
+/*****************************************************************************
+* FUNCTION
+*  hal_btif_is_tx_allow
+* DESCRIPTION
+*  whether tx is allowed
+* PARAMETERS
+* p_base   [IN]        BTIF module's base address
+* RETURNS
+* true if tx operation is allowed; false if tx is not allowed
+*****************************************************************************/
+bool hal_btif_is_tx_allow(P_MTK_BTIF_INFO_STR p_btif);
+
+int hal_btif_pm_ops(P_MTK_BTIF_INFO_STR p_btif, MTK_BTIF_PM_OPID opid);
+
+void mtk_btif_read_cpu_sw_rst_debug_plat(void);
+
+#endif /*__HAL_BTIF_PUB_H_*/
diff --git a/drivers/misc/mediatek/btif/common/plat_inc/plat_common.h b/drivers/misc/mediatek/btif/common/plat_inc/plat_common.h
new file mode 100644
index 00000000..2a1462c
--- /dev/null
+++ b/drivers/misc/mediatek/btif/common/plat_inc/plat_common.h
@@ -0,0 +1,307 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __HAL_PUB_H_
+#define __HAL_PUB_H_
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/sched/rt.h>
+#include <mtk_io.h>
+
+#ifdef CONFIG_OF
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/of.h>
+#else
+#include <mach/mt_reg_base.h>
+#include <mach/mt_irq.h>
+#endif
+#if defined(CONFIG_MTK_CLKMGR)
+#include <mach/mt_clkmgr.h>
+#else
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#endif /* defined(CONFIG_MTK_CLKMGR) */
+#include <sync_write.h>
+
+extern int mtk_btif_hal_get_log_lvl(void);
+
+#define MTK_BTIF_MARK_UNUSED_API
+
+typedef irq_handler_t mtk_btif_irq_handler;
+
+#define MTK_BTIF_ENABLE_CLK_CTL 1
+#define MTK_BTIF_ENABLE_CLK_REF_COUNTER 1
+
+#define DBG_LOG_STR_SIZE 256
+
+/*Log defination*/
+static int hal_log_print(const char *str, ...)
+{
+	va_list args;
+	char temp_sring[DBG_LOG_STR_SIZE];
+
+	va_start(args, str);
+	vsnprintf(temp_sring, DBG_LOG_STR_SIZE, str, args);
+	va_end(args);
+
+	pr_err("%s", temp_sring);
+
+	return 0;
+}
+
+#define BTIF_LOG_LOUD    4
+#define BTIF_LOG_DBG     3
+#define BTIF_LOG_INFO    2
+#define BTIF_LOG_WARN    1
+#define BTIF_LOG_ERR     0
+
+#ifndef DFT_TAG
+#define DFT_TAG         "[BTIF-DFT]"
+#endif
+
+#define BTIF_LOUD_FUNC(fmt, arg ...) \
+do { \
+	if (mtk_btif_hal_get_log_lvl() >= BTIF_LOG_LOUD) \
+		hal_log_print(DFT_TAG "[L]%s:"  fmt, \
+		__func__, ## arg); \
+} while (0)
+
+#define BTIF_INFO_FUNC(fmt, arg ...) \
+do { \
+	if (mtk_btif_hal_get_log_lvl() >= BTIF_LOG_INFO)\
+		hal_log_print(DFT_TAG "[I]%s:"  fmt, \
+		__func__, ## arg); \
+} while (0)
+
+#define BTIF_WARN_FUNC(fmt, arg ...) \
+do { \
+	if (mtk_btif_hal_get_log_lvl() >= BTIF_LOG_WARN)\
+		hal_log_print(DFT_TAG "[W]%s:"  fmt, \
+		__func__, ## arg); \
+} while (0)
+
+#define BTIF_ERR_FUNC(fmt, arg ...)\
+do {\
+	if (mtk_btif_hal_get_log_lvl() >= BTIF_LOG_ERR)\
+		hal_log_print(DFT_TAG "[E]%s(%d):"  fmt,\
+		__func__, __LINE__, ## arg);\
+} while (0)
+
+#define BTIF_DBG_FUNC(fmt, arg ...) \
+do { \
+	if (mtk_btif_hal_get_log_lvl() >= BTIF_LOG_DBG) \
+		hal_log_print(DFT_TAG "[D]%s:"  fmt, \
+		__func__, ## arg); \
+} while (0)
+
+#define BTIF_TRC_FUNC(f) \
+do { \
+	if (mtk_btif_hal_get_log_lvl() >= BTIF_LOG_DBG) \
+		hal_log_print(DFT_TAG "<%s> <%d>\n", \
+		__func__, __LINE__); \
+} while (0)
+
+/*-----------------------------------Enum Defination--------------------------------*/
+/*IRQ sensetive type */
+typedef enum _ENUM_IRQ_SENS_TYPE_ {
+	IRQ_SENS_EDGE = 0,
+	IRQ_SENS_LVL = IRQ_SENS_EDGE + 1,
+	IRQ_SENS_TYPE_MAX
+} ENUM_IRQ_SENS_TYPE;
+
+/*IRQ level trigger type */
+typedef enum _ENUM_IRQ_LVL_TYPE_ {
+	IRQ_LVL_LOW = 0,
+	IRQ_LVL_HIGH = IRQ_LVL_LOW + 1,
+	IRQ_LVL_MAX
+} ENUM_IRQ_LVL;
+
+/*IRQ edge trigger type */
+typedef enum _ENUM_IRQ_EDGE_TYPE_ {
+	IRQ_EDGE_FALL = 0,
+	IRQ_EDGE_RAISE = IRQ_EDGE_FALL + 1,
+	IRQ_EDGE_BOTH = IRQ_EDGE_RAISE + 1,
+	IRQ_EDGE_MAX
+} ENUM_IRQ_EDGE;
+
+typedef enum _ENUM_CLOCK_CTRL_ {
+	CLK_OUT_DISABLE = 0,
+	CLK_OUT_ENABLE = CLK_OUT_DISABLE + 1,
+	CLK_OUT_MAX
+} ENUM_CLOCK_CTRL;
+
+/*Error No. table */
+typedef enum _ENUM_ERROR_CODE_ {
+	ERR_NO_ERROR = 0,
+	ERR_INVALID_PAR = ERR_NO_ERROR - 1,
+	ERR_MAX = ERR_INVALID_PAR - 1,
+} ENUM_ERROR_CODE;
+
+typedef enum _ENUM_BTIF_DIR_ {
+	BTIF_TX = 0,
+	BTIF_RX = BTIF_TX + 1,
+	BTIF_DIR_MAX,
+} ENUM_BTIF_DIR;
+
+typedef enum _ENUM_DMA_DIR_ {
+	DMA_DIR_RX = 0,
+	DMA_DIR_TX = DMA_DIR_RX + 1,
+	DMA_DIR_BOTH,
+} ENUM_DMA_DIR;
+
+typedef enum _ENUM_BTIF_REG_ID_ {
+	REG_IIR = 0,		/*Interrupt Identification Register */
+	REG_LSR = 1,		/*Line Status Register */
+	REG_FAKE_LCR = 2,	/*Fake Lcr Regiseter */
+	REG_FIFO_CTRL = 3,	/*FIFO Control Register */
+	REG_IER = 4,		/*Interrupt Enable Register */
+	REG_SLEEP_EN = 5,	/*Sleep Enable Register */
+	REG_RTO_COUNTER = 6,	/*Rx Timeout Counter Register */
+	REG_DMA_EN = 7,		/*DMA Enalbe Register */
+	REG_TRIG_LVL = 8,	/*Tx/Rx Trigger Level Register */
+	REG_WAT_TIME = 9,	/*Async Wait Time Register */
+	REG_HANDSHAKE = 10,	/*New HandShake Mode Register */
+	REG_SLP_WAK = 11,	/*Sleep Wakeup Reigster */
+	REG_BTIF_ALL = 12,	/*all btif controller's registers */
+	REG_TX_DMA_ALL = 13,
+	REG_RX_DMA_ALL = 14,
+	REG_MAX
+} ENUM_BTIF_REG_ID;
+
+typedef enum _MTK_BTIF_PM_OPID_ {
+	BTIF_PM_DPIDLE_EN,
+	BTIF_PM_DPIDLE_DIS,
+	BTIF_PM_SUSPEND,
+	BTIF_PM_RESUME,
+	BTIF_PM_RESTORE_NOIRQ,
+} MTK_BTIF_PM_OPID;
+
+#define BTIF_HAL_TX_FIFO_SIZE (1024 * 4)
+
+/*-----------------------------------Enum Defination End--------------------------------*/
+
+/*****************************structure definition***************************/
+/*IRQ related information*/
+typedef struct _MTK_BTIF_IRQ_STR_ {
+	const char *name;
+	bool is_irq_sup;
+	unsigned int irq_id;
+#ifdef CONFIG_OF
+	unsigned int irq_flags;
+#else
+	ENUM_IRQ_SENS_TYPE sens_type;
+	union {
+		ENUM_IRQ_LVL lvl_type;
+		ENUM_IRQ_EDGE edge_type;
+	};
+#endif
+	bool reg_flag;
+	irq_handler_t p_irq_handler;
+} MTK_BTIF_IRQ_STR, *P_MTK_BTIF_IRQ_STR;
+
+typedef struct _DMA_VFIFO_ {
+	/*[Driver Access] vFIFO memory'svirtual address */
+	unsigned char *p_vir_addr;
+	/*[HW Access] dma handle , physically address, set to DMA's HW Register */
+	dma_addr_t phy_addr;
+	/*DMA's vFIFO size */
+	unsigned int vfifo_size;
+	/*DMA's threshold value */
+	unsigned int thre;
+} DMA_VFIFO, *P_DMA_VFIFO;
+
+typedef unsigned int (*dma_rx_buf_write) (void *p_dma_info,
+					  unsigned char *p_buf,
+					  unsigned int buf_len);
+typedef unsigned int (*btif_rx_buf_write) (void *p_btif_info,
+					   unsigned char *p_buf,
+					   unsigned int buf_len);
+
+/*DMA related information*/
+typedef struct _MTK_DMA_INFO_STR_ {
+	unsigned long base;
+	ENUM_DMA_DIR dir;
+	P_MTK_BTIF_IRQ_STR p_irq;
+	dma_rx_buf_write rx_cb;
+	P_DMA_VFIFO p_vfifo;
+} MTK_DMA_INFO_STR, *P_MTK_DMA_INFO_STR;
+
+/*DMA related information*/
+typedef struct _MTK_BTIF_INFO_STR_ {
+	unsigned long base;	/*base address */
+	P_MTK_BTIF_IRQ_STR p_irq;	/*irq related information */
+
+	unsigned int tx_fifo_size;	/*BTIF tx FIFO size */
+	unsigned int rx_fifo_size;	/*BTIF rx FIFO size */
+
+	unsigned int tx_tri_lvl;	/*BTIFtx trigger level in FIFO mode */
+	unsigned int rx_tri_lvl;	/*BTIFrx trigger level in FIFO mode */
+
+	unsigned int clk_gat_addr;	/*clock gating address */
+	unsigned int set_bit;	/*enable clock gating bit */
+	unsigned int clr_bit;	/*clear clock gating bit */
+
+	unsigned int rx_data_len;	/*rx data length */
+
+	btif_rx_buf_write rx_cb;
+
+	struct kfifo *p_tx_fifo;	/*tx fifo */
+	spinlock_t tx_fifo_spinlock;	/*tx fifo spinlock */
+} MTK_BTIF_INFO_STR, *P_MTK_BTIF_INFO_STR;
+
+/**********End of Structure Definition***********/
+
+/***********register operation***********/
+#ifdef __KERNEL__
+/*byte write  <1 byte> */
+#define btif_reg_sync_writeb(v, a)    mt_reg_sync_writeb(v, a)
+/*word write  <2 byte> */
+#define btif_reg_sync_writew(v, a)    mt_reg_sync_writew(v, a)
+/*long write   <4 byte> */
+#define btif_reg_sync_writel(v, a)    mt_reg_sync_writel(v, a)
+#else
+/*byte write  <1 byte> */
+#define btif_reg_sync_writeb(v, a)    mt65xx_reg_sync_writeb(v, a)
+/*word write  <2 byte> */
+#define btif_reg_sync_writew(v, a)    mt65xx_reg_sync_writew(v, a)
+/*long write   <4 byte> */
+#define btif_reg_sync_writel(v, a)    mt65xx_reg_sync_writel(v, a)
+#endif
+#define BTIF_READ8(REG)               __raw_readb((unsigned char *)(REG))
+#define BTIF_READ16(REG)              __raw_readw((unsigned short *)(REG))
+#define BTIF_READ32(REG)              __raw_readl((unsigned int *)(REG))
+
+#define BTIF_SET_BIT(REG, BITVAL)    do { \
+*((volatile unsigned int *)(REG)) |= ((unsigned int)(BITVAL)); \
+mb(); /**/ \
+} \
+while (0)
+#define BTIF_CLR_BIT(REG, BITVAL)    do { \
+(*(volatile unsigned int *)(REG)) &= ~((unsigned int)(BITVAL)); \
+mb(); /**/\
+} \
+while (0)
+
+/***********end of register operation *********/
+
+#endif /*__HAL_PUB_H_*/
