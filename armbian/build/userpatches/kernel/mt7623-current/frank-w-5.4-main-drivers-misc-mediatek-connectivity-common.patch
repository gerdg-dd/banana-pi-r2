diff --git a/drivers/misc/mediatek/connectivity/common/Makefile b/drivers/misc/mediatek/connectivity/common/Makefile
new file mode 100644
index 00000000..622b744
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/Makefile
@@ -0,0 +1,23 @@
+subdir-ccflags-y += -Werror -I$(srctree)/drivers/misc/mediatek/include/mt-plat/$(MTK_PLATFORM)/include
+subdir-ccflags-y += -Werror -I$(srctree)/drivers/misc/mediatek/include/mt-plat
+
+#ifneq ($(filter "MT6620E3",$(CONFIG_MTK_COMBO_CHIP)),)
+#	obj-y   +=  combo/
+#endif
+#ifneq ($(filter "MT6628",$(CONFIG_MTK_COMBO_CHIP)),)
+#	subdir-ccflags-y += -D MT6628
+#	subdir-ccflags-y += -D MERGE_INTERFACE_SUPPORT
+#	obj-y   +=  combo/
+#endif
+#ifneq ($(filter "MT6630",$(CONFIG_MTK_COMBO_CHIP)),)
+#	subdir-ccflags-y += -D MT6630
+#ifneq ($(CONFIG_ARCH_MT2601),y)
+#	subdir-ccflags-y += -D MERGE_INTERFACE_SUPPORT
+#endif
+#	obj-y   +=  combo/
+#endif
+ifneq ($(filter "CONSYS_%",$(CONFIG_MTK_COMBO_CHIP)),)
+	obj-y   +=  conn_soc/
+endif
+
+obj-y   +=  common_detect/
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/Makefile b/drivers/misc/mediatek/connectivity/common/common_detect/Makefile
new file mode 100644
index 00000000..4d04936
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/Makefile
@@ -0,0 +1,73 @@
+subdir-ccflags-y += -I$(srctree)/arch/arm/mach-$(MTK_PLATFORM)/$(ARCH_MTK_PROJECT)/dct/dct
+
+COMBO_CHIP_SUPPORT := false
+ifneq ($(filter "MT6620E3",$(CONFIG_MTK_COMBO_CHIP)),)
+	COMBO_CHIP_SUPPORT := true
+endif
+ifneq ($(filter "MT6628",$(CONFIG_MTK_COMBO_CHIP)),)
+	COMBO_CHIP_SUPPORT := true
+endif
+ifneq ($(filter "MT6630",$(CONFIG_MTK_COMBO_CHIP)),)
+	COMBO_CHIP_SUPPORT := true
+endif
+ifeq ($(COMBO_CHIP_SUPPORT), true)
+	subdir-ccflags-y += -D MTK_WCN_COMBO_CHIP_SUPPORT
+	ccflags-y += -I$(srctree)/$(src)/../combo/linux/include
+endif
+
+ifneq ($(filter "CONSYS_%",$(CONFIG_MTK_COMBO_CHIP)),)
+	subdir-ccflags-y += -D MTK_WCN_SOC_CHIP_SUPPORT
+	ccflags-y += -I$(srctree)/$(src)/../conn_soc/linux/include
+endif
+
+
+ifeq ($(CONFIG_MTK_COMBO),y)
+	ccflags-y += -I$(srctree)/$(src)/drv_init/inc
+	obj-y += wmt_gpio.o
+
+	obj-y += wmt_detect.o
+	obj-y += sdio_detect.o
+	obj-y += wmt_detect_pwr.o
+
+	obj-y += drv_init/
+endif
+
+ifeq ($(CONFIG_MTK_COMBO),m)
+	ccflags-y += -I$(srctree)/$(src)/drv_init/inc
+	ccflags-y += -I$(srctree)/$(src)
+
+ifneq ($(filter "MT6630",$(CONFIG_MTK_COMBO_CHIP)),)
+	ccflags-y += -D MTK_WCN_WLAN_GEN3
+endif
+ifneq ($(filter "CONSYS_6797",$(CONFIG_MTK_COMBO_CHIP)),)
+	ccflags-y += -D MTK_WCN_WLAN_GEN3
+else ifneq ($(filter "CONSYS_%",$(CONFIG_MTK_COMBO_CHIP)),)
+	ccflags-y += -D MTK_WCN_WLAN_GEN2
+endif
+
+
+	DRV_INIT_DIR := drv_init/
+
+	DRV_INIT_OBJS := \
+						$(DRV_INIT_DIR)common_drv_init.o \
+						$(DRV_INIT_DIR)bluetooth_drv_init.o \
+						$(DRV_INIT_DIR)conn_drv_init.o \
+						$(DRV_INIT_DIR)wlan_drv_init.o
+#						$(DRV_INIT_DIR)gps_drv_init.o \
+#						$(DRV_INIT_DIR)fm_drv_init.o \
+
+#	obj-($(CONFIG_MTK_COMBO_ANT)) += ant_drv_init.o
+
+	obj-$(CONFIG_MTK_COMBO) += mtk_wmt_detect.o
+
+#							wmt_stp_exp.o \
+#							mtk_wcn_stub_alps.o \
+
+	mtk_wmt_detect-objs := \
+							wmt_detect.o \
+							sdio_detect.o \
+							wmt_detect_pwr.o \
+							wmt_gpio.o
+
+	mtk_wmt_detect-objs += $(DRV_INIT_OBJS)
+endif
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/Makefile b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/Makefile
new file mode 100644
index 00000000..fda8ba1
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/Makefile
@@ -0,0 +1,22 @@
+ifneq ($(CONFIG_MTK_COMBO),)
+	ccflags-y += -I$(srctree)/$(src)/inc/
+	ccflags-y += -I$(srctree)/$(src)/../
+
+ifneq ($(filter "MT6630",$(CONFIG_MTK_COMBO_CHIP)),)
+	ccflags-y += -D MTK_WCN_WLAN_GEN3
+endif
+ifneq ($(filter "CONSYS_6797",$(CONFIG_MTK_COMBO_CHIP)),)
+	ccflags-y += -D MTK_WCN_WLAN_GEN3
+else ifneq ($(filter "CONSYS_%",$(CONFIG_MTK_COMBO_CHIP)),)
+	ccflags-y += -D MTK_WCN_WLAN_GEN2
+endif
+
+	obj-y += conn_drv_init.o
+	obj-y += common_drv_init.o
+	obj-y += bluetooth_drv_init.o
+	obj-y += gps_drv_init.o
+	obj-y += fm_drv_init.o
+	obj-y += wlan_drv_init.o
+	obj-($(CONFIG_MTK_COMBO_ANT)) += ant_drv_init.o
+
+endif
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/ant_drv_init.c b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/ant_drv_init.c
new file mode 100644
index 00000000..aa453f9
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/ant_drv_init.c
@@ -0,0 +1,38 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[ANT-MOD-INIT]"
+
+#include "wmt_detect.h"
+#include "ant_drv_init.h"
+
+int do_ant_drv_init(int chip_id)
+{
+	int i_ret = -1;
+
+	WMT_DETECT_INFO_FUNC("start to do ANT driver init\n");
+	switch (chip_id) {
+	case 0x6630:
+	case 0x6797:
+		i_ret = mtk_wcn_stpant_drv_init();
+		WMT_DETECT_INFO_FUNC("finish ANT driver init, i_ret:%d\n", i_ret);
+		break;
+	default:
+		WMT_DETECT_ERR_FUNC("chipid is not 6630,ANT is not supported!\n");
+	}
+	return i_ret;
+}
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/bluetooth_drv_init.c b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/bluetooth_drv_init.c
new file mode 100644
index 00000000..82b799f
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/bluetooth_drv_init.c
@@ -0,0 +1,36 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[BT-MOD-INIT]"
+
+#include "wmt_detect.h"
+#include "bluetooth_drv_init.h"
+
+int do_bluetooth_drv_init(int chip_id)
+{
+	int i_ret = -1;
+#if 0
+#if defined(CONFIG_MTK_COMBO_BT) || defined(CONFIG_MTK_COMBO_BT_HCI)
+	WMT_DETECT_INFO_FUNC("start to do bluetooth driver init\n");
+	i_ret = mtk_wcn_stpbt_drv_init();
+	WMT_DETECT_INFO_FUNC("finish bluetooth driver init, i_ret:%d\n", i_ret);
+#else
+	WMT_DETECT_INFO_FUNC("CONFIG_MTK_COMBO_BT is not defined\n");
+#endif
+#endif
+	return i_ret;
+}
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/common_drv_init.c b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/common_drv_init.c
new file mode 100644
index 00000000..f9c332e
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/common_drv_init.c
@@ -0,0 +1,103 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[WMT-MOD-INIT]"
+
+#include "wmt_detect.h"
+#include "common_drv_init.h"
+
+static int do_combo_common_drv_init(int chip_id)
+{
+	int i_ret = 0;
+
+#ifdef MTK_WCN_COMBO_CHIP_SUPPORT
+	int i_ret_tmp = 0;
+
+	WMT_DETECT_DBG_FUNC("start to do combo driver init, chipid:0x%08x\n", chip_id);
+
+	/* HIF-SDIO driver init */
+	i_ret_tmp = mtk_wcn_hif_sdio_drv_init();
+	i_ret += i_ret_tmp;
+	WMT_DETECT_DBG_FUNC("HIF-SDIO driver init, i_ret:%d\n", i_ret);
+
+	/* WMT driver init */
+	i_ret_tmp = mtk_wcn_combo_common_drv_init();
+	i_ret += i_ret_tmp;
+	WMT_DETECT_DBG_FUNC("COMBO COMMON driver init, i_ret:%d\n", i_ret);
+
+	/* STP-UART driver init */
+	i_ret_tmp = mtk_wcn_stp_uart_drv_init();
+	i_ret += i_ret_tmp;
+	WMT_DETECT_DBG_FUNC("STP-UART driver init, i_ret:%d\n", i_ret);
+
+	/* STP-SDIO driver init */
+	i_ret_tmp = mtk_wcn_stp_sdio_drv_init();
+	i_ret += i_ret_tmp;
+	WMT_DETECT_DBG_FUNC("STP-SDIO driver init, i_ret:%d\n", i_ret);
+
+#else
+	i_ret = -1;
+	WMT_DETECT_ERR_FUNC("COMBO chip is not supported, please check CONFIG_MTK_COMBO_CHIP in kernel config\n");
+#endif
+	WMT_DETECT_DBG_FUNC("finish combo driver init\n");
+	return i_ret;
+}
+
+static int do_soc_common_drv_init(int chip_id)
+{
+	int i_ret = 0;
+
+#ifdef MTK_WCN_SOC_CHIP_SUPPORT
+	int i_ret_tmp = 0;
+
+	WMT_DETECT_DBG_FUNC("start to do soc common driver init, chipid:0x%08x\n", chip_id);
+
+	/* WMT driver init */
+	i_ret_tmp = mtk_wcn_soc_common_drv_init();
+	i_ret += i_ret_tmp;
+	WMT_DETECT_DBG_FUNC("COMBO COMMON driver init, i_ret:%d\n", i_ret);
+
+#else
+	i_ret = -1;
+	WMT_DETECT_ERR_FUNC("SOC chip is not supported, please check CONFIG_MTK_COMBO_CHIP in kernel config\n");
+#endif
+
+	WMT_DETECT_DBG_FUNC("TBD........\n");
+	return i_ret;
+}
+
+int do_common_drv_init(int chip_id)
+{
+	int i_ret = 0;
+
+	WMT_DETECT_INFO_FUNC("start to do common driver init, chipid:0x%08x\n", chip_id);
+
+	switch (chip_id) {
+	case 0x6620:
+	case 0x6628:
+	case 0x6630:
+		i_ret = do_combo_common_drv_init(chip_id);
+		break;
+	default:
+		i_ret = do_soc_common_drv_init(chip_id);
+		break;
+	}
+
+	WMT_DETECT_INFO_FUNC("finish common driver init\n");
+
+	return i_ret;
+}
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/conn_drv_init.c b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/conn_drv_init.c
new file mode 100644
index 00000000..08e7991
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/conn_drv_init.c
@@ -0,0 +1,84 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[WCN-MOD-INIT]"
+
+#include "wmt_detect.h"
+#include "conn_drv_init.h"
+#include "common_drv_init.h"
+#include "fm_drv_init.h"
+#include "wlan_drv_init.h"
+#include "bluetooth_drv_init.h"
+#include "gps_drv_init.h"
+#include "ant_drv_init.h"
+
+int __weak do_wlan_drv_init(int chip_id)
+{
+	WMT_DETECT_ERR_FUNC("Can not find wlan module for chip: %d !\n", chip_id);
+	return 0;
+}
+
+int __weak do_ant_drv_init(int chip_id)
+{
+	WMT_DETECT_DBG_FUNC("Chip: %d can not support ANT !\n", chip_id);
+	return 0;
+}
+
+int do_connectivity_driver_init(int chip_id)
+{
+	int i_ret = 0;
+	int tmp_ret = 0;
+
+	tmp_ret = do_common_drv_init(chip_id);
+	i_ret += tmp_ret;
+	if (tmp_ret) {
+		WMT_DETECT_ERR_FUNC("do common driver init failed, ret:%d\n", tmp_ret);
+		WMT_DETECT_ERR_FUNC("abort connectivity driver init, because common part is not ready\n");
+		return i_ret;
+	}
+
+#if defined(CONFIG_MTK_COMBO_BT) || defined(CONFIG_MTK_COMBO_BT_MODULE)
+	tmp_ret = do_bluetooth_drv_init(chip_id);
+	i_ret += tmp_ret;
+	if (tmp_ret)
+		WMT_DETECT_ERR_FUNC("do common driver init failed, ret:%d\n", tmp_ret);
+#endif
+
+/*	tmp_ret = do_gps_drv_init(chip_id);
+	i_ret += tmp_ret;
+	if (tmp_ret)
+		WMT_DETECT_ERR_FUNC("do common driver init failed, ret:%d\n", tmp_ret); */
+
+/*	tmp_ret = do_fm_drv_init(chip_id);
+	i_ret += tmp_ret;
+	if (tmp_ret)
+		WMT_DETECT_ERR_FUNC("do fm module init failed, ret:%d\n", tmp_ret); */
+
+#if defined(CONFIG_MTK_COMBO_WIFI) || defined(CONFIG_MTK_COMBO_WIFI_MODULE)
+	tmp_ret = do_wlan_drv_init(chip_id);
+	i_ret += tmp_ret;
+	if (tmp_ret)
+		WMT_DETECT_ERR_FUNC("do wlan module init failed, ret:%d\n", tmp_ret);
+#endif
+
+/*	tmp_ret = do_ant_drv_init(chip_id);
+	i_ret += tmp_ret;
+	if (tmp_ret)
+		WMT_DETECT_ERR_FUNC("do ANT module init failed, ret:%d\n", tmp_ret); */
+
+	return i_ret;
+}
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/fm_drv_init.c b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/fm_drv_init.c
new file mode 100644
index 00000000..069c1cf1
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/fm_drv_init.c
@@ -0,0 +1,33 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[FM-MOD-INIT]"
+
+#include "wmt_detect.h"
+#include "fm_drv_init.h"
+
+int do_fm_drv_init(int chip_id)
+{
+	WMT_DETECT_INFO_FUNC("start to do fm module init\n");
+
+#ifdef CONFIG_MTK_FMRADIO
+	mtk_wcn_fm_init();
+#endif
+
+	WMT_DETECT_INFO_FUNC("finish fm module init\n");
+	return 0;
+}
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/gps_drv_init.c b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/gps_drv_init.c
new file mode 100644
index 00000000..6da1d70
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/gps_drv_init.c
@@ -0,0 +1,35 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[GPS-MOD-INIT]"
+
+#include "wmt_detect.h"
+#include "gps_drv_init.h"
+
+int do_gps_drv_init(int chip_id)
+{
+	int i_ret = -1;
+#ifdef CONFIG_MTK_COMBO_GPS
+	WMT_DETECT_INFO_FUNC("start to do gps driver init\n");
+	i_ret = mtk_wcn_stpgps_drv_init();
+	WMT_DETECT_INFO_FUNC("finish gps driver init, i_ret:%d\n", i_ret);
+#else
+	WMT_DETECT_INFO_FUNC("CONFIG_MTK_COMBO_GPS is not defined\n");
+#endif
+	return i_ret;
+
+}
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/ant_drv_init.h b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/ant_drv_init.h
new file mode 100644
index 00000000..4a436a2
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/ant_drv_init.h
@@ -0,0 +1,20 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _ANT_DRIVER_INIT_H_
+#define _ANT_DRIVER_INIT_H_
+
+extern int do_ant_drv_init(int chip_id);
+extern int mtk_wcn_stpant_drv_init(void);
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/bluetooth_drv_init.h b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/bluetooth_drv_init.h
new file mode 100644
index 00000000..8a847d3
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/bluetooth_drv_init.h
@@ -0,0 +1,20 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _BLUETOOTH_DRIVER_INIT_H_
+#define _BLUETOOTH_DRIVER_INIT_H_
+
+extern int do_bluetooth_drv_init(int chip_id);
+extern int mtk_wcn_stpbt_drv_init(void);
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/common_drv_init.h b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/common_drv_init.h
new file mode 100644
index 00000000..ea01bd6
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/common_drv_init.h
@@ -0,0 +1,31 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _COMMON_DRV_INIT_H_
+#define _COMMON_DRV_INIT_H_
+extern int do_common_drv_init(int chip_id);
+
+/*defined in common part driver*/
+#ifdef MTK_WCN_COMBO_CHIP_SUPPORT
+extern int mtk_wcn_combo_common_drv_init(void);
+extern int mtk_wcn_hif_sdio_drv_init(void);
+extern int mtk_wcn_stp_uart_drv_init(void);
+extern int mtk_wcn_stp_sdio_drv_init(void);
+#endif
+
+#ifdef MTK_WCN_SOC_CHIP_SUPPORT
+extern int mtk_wcn_soc_common_drv_init(void);
+#endif
+
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/conn_drv_init.h b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/conn_drv_init.h
new file mode 100644
index 00000000..971193e
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/conn_drv_init.h
@@ -0,0 +1,18 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _CONNECTIVITY_DRV_INIT_H_
+#define _CONNECTIVITY_DRV_INIT_H_
+extern int do_connectivity_driver_init(int chip_id);
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/fm_drv_init.h b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/fm_drv_init.h
new file mode 100644
index 00000000..f6ea30a
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/fm_drv_init.h
@@ -0,0 +1,20 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _FM_DRV_INIT_H_
+#define _FM_DRV_INIT_H_
+extern int do_fm_drv_init(int chip_id);
+extern int mtk_wcn_fm_init(void);
+extern void mtk_wcn_fm_exit(void);
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/gps_drv_init.h b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/gps_drv_init.h
new file mode 100644
index 00000000..006ce07
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/gps_drv_init.h
@@ -0,0 +1,19 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _GPS_DRIVER_INIT_H_
+#define _GPS_DRIVER_INIT_H_
+extern int do_gps_drv_init(int chip_id);
+extern int mtk_wcn_stpgps_drv_init(void);
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/wlan_drv_init.h b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/wlan_drv_init.h
new file mode 100644
index 00000000..cb71b50
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/inc/wlan_drv_init.h
@@ -0,0 +1,30 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _WLAN_DRV_INIT_H_
+#define _WLAN_DRV_INIT_H_
+
+
+extern int do_wlan_drv_init(int chip_id);
+
+extern int mtk_wcn_wmt_wifi_init(void);
+
+#ifdef MTK_WCN_WLAN_GEN2
+extern int mtk_wcn_wlan_gen2_init(void);
+#endif
+#ifdef MTK_WCN_WLAN_GEN3
+extern int mtk_wcn_wlan_gen3_init(void);
+#endif
+
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/wlan_drv_init.c b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/wlan_drv_init.c
new file mode 100644
index 00000000..6d7c575
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/drv_init/wlan_drv_init.c
@@ -0,0 +1,75 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[WLAN-MOD-INIT]"
+
+#include "wmt_detect.h"
+#include "wlan_drv_init.h"
+
+
+int do_wlan_drv_init(int chip_id)
+{
+	int i_ret = 0;
+
+#if defined(CONFIG_MTK_COMBO_WIFI) || defined(CONFIG_MTK_COMBO_WIFI_MODULE)
+	int ret = 0;
+
+	WMT_DETECT_INFO_FUNC("start to do wlan module init 0x%x\n", chip_id);
+
+	/* WMT-WIFI char dev init */
+	ret = mtk_wcn_wmt_wifi_init();
+	WMT_DETECT_INFO_FUNC("WMT-WIFI char dev init, ret:%d\n", ret);
+	i_ret += ret;
+
+	switch (chip_id) {
+	case 0x6630:
+	case 0x6797:
+#ifdef MTK_WCN_WLAN_GEN3
+		/* WLAN driver init */
+		ret = mtk_wcn_wlan_gen3_init();
+		WMT_DETECT_INFO_FUNC("WLAN-GEN3 driver init, ret:%d\n", ret);
+		i_ret += ret;
+#else
+		WMT_DETECT_ERR_FUNC("WLAN-GEN3 driver is not supported, please check CONFIG_MTK_COMBO_CHIP\n");
+		i_ret = -1;
+#endif
+		break;
+
+	default:
+#ifdef MTK_WCN_WLAN_GEN2
+		/* WLAN driver init */
+/* A call to mtk_wcn_wlan_gen2_init is only required if wifi support is not compiled as module */
+#if defined(CONFIG_MTK_COMBO_WIFI)
+		ret = mtk_wcn_wlan_gen2_init();
+		WMT_DETECT_INFO_FUNC("WLAN-GEN2 driver init, ret:%d\n", ret);
+		i_ret += ret;
+#endif
+#else
+		WMT_DETECT_ERR_FUNC("WLAN-GEN2 driver is not supported, please check CONFIG_MTK_COMBO_CHIP\n");
+		i_ret = -1;
+#endif
+		break;
+	}
+
+	WMT_DETECT_INFO_FUNC("finish wlan module init\n");
+
+#else
+	WMT_DETECT_INFO_FUNC("CONFIG_MTK_COMBO_WIFI is not defined\n");
+#endif
+
+	return i_ret;
+}
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/sdio_detect.c b/drivers/misc/mediatek/connectivity/common/common_detect/sdio_detect.c
new file mode 100644
index 00000000..7ac5ac7
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/sdio_detect.c
@@ -0,0 +1,269 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[SDIO-DETECT]"
+
+#include "wmt_detect.h"
+
+#if MTK_HIF_SDIO_AUTOK_ENABLED
+#include <mt_boot.h>
+#endif
+
+unsigned int gComboChipId = -1;
+struct sdio_func *g_func = NULL;
+
+MTK_WCN_HIF_SDIO_CHIP_INFO gChipInfoArray[] = {
+	/* MT6620 *//* Not an SDIO standard class device */
+	{{SDIO_DEVICE(0x037A, 0x020A)}, 0x6620},	/* SDIO1:FUNC1:WIFI */
+	{{SDIO_DEVICE(0x037A, 0x020B)}, 0x6620},	/* SDIO2:FUNC1:BT+FM+GPS */
+	{{SDIO_DEVICE(0x037A, 0x020C)}, 0x6620},	/* 2-function (SDIO2:FUNC1:BT+FM+GPS, FUNC2:WIFI) */
+
+	/* MT6628 *//* SDIO1: Wi-Fi, SDIO2: BGF */
+	{{SDIO_DEVICE(0x037A, 0x6628)}, 0x6628},
+
+	/* MT6630 *//* SDIO1: Wi-Fi, SDIO2: BGF */
+	{{SDIO_DEVICE(0x037A, 0x6630)}, 0x6630},
+
+};
+
+/* Supported SDIO device table */
+static const struct sdio_device_id mtk_sdio_id_tbl[] = {
+	/* MT6618 *//* Not an SDIO standard class device */
+	{SDIO_DEVICE(0x037A, 0x018A)},	/* SDIO1:WIFI */
+	{SDIO_DEVICE(0x037A, 0x018B)},	/* SDIO2:FUNC1:BT+FM */
+	{SDIO_DEVICE(0x037A, 0x018C)},	/* 2-function (SDIO2:FUNC1:BT+FM, FUNC2:WIFI) */
+
+	/* MT6619 *//* Not an SDIO standard class device */
+	{SDIO_DEVICE(0x037A, 0x6619)},	/* SDIO2:FUNC1:BT+FM+GPS */
+
+	/* MT6620 *//* Not an SDIO standard class device */
+	{SDIO_DEVICE(0x037A, 0x020A)},	/* SDIO1:FUNC1:WIFI */
+	{SDIO_DEVICE(0x037A, 0x020B)},	/* SDIO2:FUNC1:BT+FM+GPS */
+	{SDIO_DEVICE(0x037A, 0x020C)},	/* 2-function (SDIO2:FUNC1:BT+FM+GPS, FUNC2:WIFI) */
+
+	/* MT5921 *//* Not an SDIO standard class device */
+	{SDIO_DEVICE(0x037A, 0x5921)},
+
+	/* MT6628 *//* SDIO1: Wi-Fi, SDIO2: BGF */
+	{SDIO_DEVICE(0x037A, 0x6628)},
+
+	/* MT6630 *//* SDIO1: Wi-Fi, SDIO2: BGF */
+	{SDIO_DEVICE(0x037A, 0x6630)},
+	{ /* end: all zeroes */ },
+};
+
+static int sdio_detect_probe(struct sdio_func *func, const struct sdio_device_id *id);
+
+static void sdio_detect_remove(struct sdio_func *func);
+
+static struct sdio_driver mtk_sdio_client_drv = {
+	.name = "mtk_sdio_client",	/* MTK SDIO Client Driver */
+	.id_table = mtk_sdio_id_tbl,	/* all supported struct sdio_device_id table */
+	.probe = sdio_detect_probe,
+	.remove = sdio_detect_remove,
+};
+
+static int hif_sdio_match_chipid_by_dev_id(const struct sdio_device_id *id);
+
+int hif_sdio_is_chipid_valid(int chipId)
+{
+	int index = -1;
+
+	int left = 0;
+	int middle = 0;
+	int right = sizeof(gChipInfoArray) / sizeof(gChipInfoArray[0]) - 1;
+
+	if ((chipId < gChipInfoArray[left].chipId) || (chipId > gChipInfoArray[right].chipId))
+		return index;
+
+	middle = (left + right) / 2;
+
+	while (left <= right) {
+		if (chipId > gChipInfoArray[middle].chipId) {
+			left = middle + 1;
+		} else if (chipId < gChipInfoArray[middle].chipId) {
+			right = middle - 1;
+		} else {
+			index = middle;
+			break;
+		}
+		middle = (left + right) / 2;
+	}
+
+	if (0 > index)
+		WMT_DETECT_ERR_FUNC("no supported chipid found\n");
+	else
+		WMT_DETECT_INFO_FUNC("index:%d, chipId:0x%x\n", index, gChipInfoArray[index].chipId);
+
+	return index;
+}
+
+int hif_sdio_match_chipid_by_dev_id(const struct sdio_device_id *id)
+{
+	int maxIndex = sizeof(gChipInfoArray) / sizeof(gChipInfoArray[0]);
+	int index = 0;
+	struct sdio_device_id *localId = NULL;
+	int chipId = -1;
+
+	for (index = 0; index < maxIndex; index++) {
+		localId = &(gChipInfoArray[index].deviceId);
+		if ((localId->vendor == id->vendor) && (localId->device == id->device)) {
+			chipId = gChipInfoArray[index].chipId;
+			WMT_DETECT_INFO_FUNC
+			    ("valid chipId found, index(%d), vendor id(0x%x), device id(0x%x), chip id(0x%x)\n", index,
+			     localId->vendor, localId->device, chipId);
+			gComboChipId = chipId;
+			mtk_wcn_wmt_set_chipid(gComboChipId);
+			break;
+		}
+	}
+	if (0 > chipId) {
+		WMT_DETECT_ERR_FUNC("No valid chipId found, vendor id(0x%x), device id(0x%x)\n", id->vendor,
+				    id->device);
+	}
+
+	return chipId;
+}
+
+int sdio_detect_query_chipid(int waitFlag)
+{
+	unsigned int timeSlotMs = 200;
+	unsigned int maxTimeSlot = 15;
+	unsigned int counter = 0;
+	/* gComboChipId = 0x6628; */
+	if (0 == waitFlag)
+		return gComboChipId;
+	if (0 <= hif_sdio_is_chipid_valid(gComboChipId))
+		return gComboChipId;
+
+	while (counter < maxTimeSlot) {
+		if (0 <= hif_sdio_is_chipid_valid(gComboChipId))
+			break;
+		msleep(timeSlotMs);
+		counter++;
+	}
+
+	return gComboChipId;
+}
+
+int sdio_detect_do_autok(int chipId)
+{
+	int i_ret = 0;
+
+#if MTK_HIF_SDIO_AUTOK_ENABLED
+#if 0
+	BOOTMODE boot_mode;
+
+	boot_mode = get_boot_mode();
+
+	if (boot_mode == META_BOOT) {
+		WMT_DETECT_INFO_FUNC("omit autok in meta mode\n");
+		return 0;
+	}
+#endif
+	if (0x6630 == chipId) {
+#ifdef CONFIG_SDIOAUTOK_SUPPORT
+		if (NULL != g_func) {
+			WMT_DETECT_INFO_FUNC("wait_sdio_autok_ready++\n");
+			i_ret = wait_sdio_autok_ready(g_func->card->host);
+			WMT_DETECT_INFO_FUNC("wait_sdio_autok_ready--\n");
+			if (0 == i_ret) {
+				WMT_DETECT_INFO_FUNC("wait_sdio_autok_ready return success\n");
+			} else {
+				WMT_DETECT_INFO_FUNC("wait_sdio_autok_ready return fail, i_ret:%d\n", i_ret);
+				gComboChipId = -1;
+			}
+		} else {
+			WMT_DETECT_INFO_FUNC("g_func NULL, omit autok\n");
+		}
+#else
+		i_ret = 0;
+		WMT_DETECT_INFO_FUNC("MTK_SDIOAUTOK_SUPPORT not defined\n");
+#endif
+	} else {
+		WMT_DETECT_INFO_FUNC("MT%x does not support SDIO3.0 autoK is not needed\n", chipId);
+	}
+#else
+	i_ret = 0;
+	WMT_DETECT_INFO_FUNC("MTK_HIF_SDIO_AUTOK_ENABLED is not defined\n");
+#endif
+	return i_ret;
+}
+
+/*!
+ * \brief hif_sdio probe function
+ *
+ * hif_sdio probe function called by mmc driver when any matched SDIO function
+ * is detected by it.
+ *
+ * \param func
+ * \param id
+ *
+ * \retval 0    register successfully
+ * \retval < 0  list error code here
+ */
+static int sdio_detect_probe(struct sdio_func *func, const struct sdio_device_id *id)
+{
+	int chipId = 0;
+
+	WMT_DETECT_INFO_FUNC("vendor(0x%x) device(0x%x) num(0x%x)\n", func->vendor, func->device, func->num);
+	chipId = hif_sdio_match_chipid_by_dev_id(id);
+
+	if ((0x6630 == chipId) && (1 == func->num)) {
+		int ret = 0;
+
+		g_func = func;
+		WMT_DETECT_INFO_FUNC("autok function detected, func:0x%p\n", g_func);
+
+		sdio_claim_host(func);
+		ret = sdio_enable_func(func);
+		sdio_release_host(func);
+		if (ret)
+			WMT_DETECT_ERR_FUNC("sdio_enable_func failed!\n");
+	}
+
+	return 0;
+}
+
+static void sdio_detect_remove(struct sdio_func *func)
+{
+	if (g_func == func) {
+		sdio_claim_host(func);
+		sdio_disable_func(func);
+		sdio_release_host(func);
+		g_func = NULL;
+	}
+	WMT_DETECT_INFO_FUNC("do sdio remove\n");
+}
+
+int sdio_detect_init(void)
+{
+	int ret = -1;
+	/* register to mmc driver */
+	ret = sdio_register_driver(&mtk_sdio_client_drv);
+	WMT_DETECT_INFO_FUNC("sdio_register_driver() ret=%d\n", ret);
+	return 0;
+}
+
+int sdio_detect_exit(void)
+{
+	g_func = NULL;
+	/* register to mmc driver */
+	sdio_unregister_driver(&mtk_sdio_client_drv);
+	WMT_DETECT_INFO_FUNC("sdio_unregister_driver\n");
+	return 0;
+}
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/sdio_detect.h b/drivers/misc/mediatek/connectivity/common/common_detect/sdio_detect.h
new file mode 100644
index 00000000..3a0bff9
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/sdio_detect.h
@@ -0,0 +1,43 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _SDIO_DETECT_H_
+#define _SDIO_DETECT_H_
+
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/module.h>
+
+#ifdef CONFIG_SDIOAUTOK_SUPPORT
+#define MTK_HIF_SDIO_AUTOK_ENABLED 1
+extern int wait_sdio_autok_ready(void *);
+#else
+#define MTK_HIF_SDIO_AUTOK_ENABLED 0
+#endif
+
+typedef struct _MTK_WCN_HIF_SDIO_CHIP_INFO_ {
+	struct sdio_device_id deviceId;
+	unsigned int chipId;
+} MTK_WCN_HIF_SDIO_CHIP_INFO, *P_MTK_WCN_HIF_SDIO_CHIP_INFO;
+
+extern int sdio_detect_exit(void);
+extern int sdio_detect_init(void);
+extern int sdio_detect_query_chipid(int waitFlag);
+extern int hif_sdio_is_chipid_valid(int chipId);
+
+extern int sdio_detect_do_autok(int chipId);
+
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/wmt_detect.c b/drivers/misc/mediatek/connectivity/common/common_detect/wmt_detect.c
new file mode 100644
index 00000000..4983145
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/wmt_detect.c
@@ -0,0 +1,380 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <mtk_wcn_cmb_stub.h>
+#include <linux/platform_device.h>
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[WMT-DETECT]"
+
+#include "wmt_detect.h"
+#include "wmt_gpio.h"
+
+#if MTK_WCN_REMOVE_KO
+#include "conn_drv_init.h"
+#endif
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+
+#define WMT_DETECT_MAJOR 154
+#define WMT_DETECT_DEV_NUM 1
+#define WMT_DETECT_DRVIER_NAME "mtk_wcn_detect"
+#define WMT_DETECT_DEVICE_NAME "wmtdetect"
+
+struct class *pDetectClass = NULL;
+struct device *pDetectDev = NULL;
+static int gWmtDetectMajor = WMT_DETECT_MAJOR;
+static struct cdev gWmtDetectCdev;
+unsigned int gWmtDetectDbgLvl = WMT_DETECT_LOG_INFO;
+
+
+#ifdef MTK_WCN_COMBO_CHIP_SUPPORT
+inline unsigned int wmt_plat_get_soc_chipid(void)
+{
+	WMT_DETECT_INFO_FUNC("no soc chip supported, due to MTK_WCN_SOC_CHIP_SUPPORT is not set.\n");
+	return -1;
+}
+#endif
+
+static int wmt_detect_open(struct inode *inode, struct file *file)
+{
+	WMT_DETECT_INFO_FUNC("open major %d minor %d (pid %d)\n", imajor(inode), iminor(inode), current->pid);
+
+	return 0;
+}
+
+static int wmt_detect_close(struct inode *inode, struct file *file)
+{
+	WMT_DETECT_INFO_FUNC("close major %d minor %d (pid %d)\n", imajor(inode), iminor(inode), current->pid);
+
+	return 0;
+}
+
+static ssize_t wmt_detect_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	WMT_DETECT_INFO_FUNC(" ++\n");
+	WMT_DETECT_INFO_FUNC(" --\n");
+
+	return 0;
+}
+
+ssize_t wmt_detect_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
+{
+	WMT_DETECT_INFO_FUNC(" ++\n");
+	WMT_DETECT_INFO_FUNC(" --\n");
+
+	return 0;
+}
+
+static long wmt_detect_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+
+	WMT_DETECT_INFO_FUNC("cmd (%d),arg(%ld)\n", cmd, arg);
+
+	switch (cmd) {
+	case COMBO_IOCTL_GET_CHIP_ID:
+		/*just get chipid from sdio-detect module */
+		/*check if external combo chip exists or not */
+		/*if yes, just return combo chip id */
+		/*if no, get soc chipid */
+		retval = mtk_wcn_wmt_chipid_query();
+		break;
+
+	case COMBO_IOCTL_SET_CHIP_ID:
+		mtk_wcn_wmt_set_chipid(arg);
+
+		break;
+
+	case COMBO_IOCTL_EXT_CHIP_PWR_ON:
+		retval = wmt_detect_ext_chip_pwr_on();
+		break;
+
+	case COMBO_IOCTL_EXT_CHIP_DETECT:
+		retval = wmt_detect_ext_chip_detect();
+		break;
+
+	case COMBO_IOCTL_EXT_CHIP_PWR_OFF:
+		retval = wmt_detect_ext_chip_pwr_off();
+		break;
+
+	case COMBO_IOCTL_DO_SDIO_AUDOK:
+		retval = sdio_detect_do_autok(arg);
+		break;
+
+	case COMBO_IOCTL_GET_SOC_CHIP_ID:
+		retval = wmt_plat_get_soc_chipid();
+		/*get soc chipid by HAL interface */
+		break;
+
+	case COMBO_IOCTL_MODULE_CLEANUP:
+#if (MTK_WCN_REMOVE_KO)
+		/*deinit SDIO-DETECT module */
+		retval = sdio_detect_exit();
+#else
+		WMT_DETECT_INFO_FUNC("no MTK_WCN_REMOVE_KO defined\n");
+#endif
+		break;
+
+	case COMBO_IOCTL_DO_MODULE_INIT:
+#if (MTK_WCN_REMOVE_KO)
+		/*deinit SDIO-DETECT module */
+		retval = do_connectivity_driver_init(arg);
+#else
+		WMT_DETECT_INFO_FUNC("no MTK_WCN_REMOVE_KO defined\n");
+#endif
+		break;
+
+	default:
+		WMT_DETECT_WARN_FUNC("unknown cmd (%d)\n", cmd);
+		retval = 0;
+		break;
+	}
+	return retval;
+}
+#ifdef CONFIG_COMPAT
+static long WMT_compat_detect_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	long ret;
+
+	WMT_DETECT_INFO_FUNC("cmd (%d)\n", cmd);
+	ret = wmt_detect_unlocked_ioctl(filp, cmd, arg);
+	return ret;
+}
+#endif
+const struct file_operations gWmtDetectFops = {
+	.open = wmt_detect_open,
+	.release = wmt_detect_close,
+	.read = wmt_detect_read,
+	.write = wmt_detect_write,
+	.unlocked_ioctl = wmt_detect_unlocked_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = WMT_compat_detect_ioctl,
+#endif
+};
+
+int wmt_detect_ext_chip_pwr_on(void)
+{
+	/*pre power on external chip */
+	/* wmt_plat_pwr_ctrl(FUNC_ON); */
+#ifdef MTK_WCN_COMBO_CHIP_SUPPORT
+	WMT_DETECT_INFO_FUNC("++\n");
+	if (0 != wmt_detect_chip_pwr_ctrl(1))
+		return -1;
+	if (0 != wmt_detect_sdio_pwr_ctrl(1))
+		return -2;
+	return 0;
+#else
+	WMT_DETECT_INFO_FUNC("combo chip is not supported\n");
+	return -1;
+#endif
+}
+
+int wmt_detect_ext_chip_pwr_off(void)
+{
+	/*pre power off external chip */
+	/* wmt_plat_pwr_ctrl(FUNC_OFF); */
+#ifdef MTK_WCN_COMBO_CHIP_SUPPORT
+	WMT_DETECT_INFO_FUNC("--\n");
+	wmt_detect_sdio_pwr_ctrl(0);
+	return wmt_detect_chip_pwr_ctrl(0);
+#else
+	WMT_DETECT_INFO_FUNC("combo chip is not supported\n");
+	return 0;
+#endif
+}
+
+int wmt_detect_ext_chip_detect(void)
+{
+	int iRet = -1;
+	unsigned int chipId = -1;
+	/*if there is no external combo chip, return -1 */
+	int bgfEintStatus = -1;
+
+	WMT_DETECT_INFO_FUNC("++\n");
+	/*wait for a stable time */
+	msleep(20);
+
+	/*read BGF_EINT_PIN status */
+	bgfEintStatus = wmt_detect_read_ext_cmb_status();
+
+	if (0 == bgfEintStatus) {
+		/*external chip does not exist */
+		WMT_DETECT_INFO_FUNC("external combo chip not detected\n");
+	} else if (1 == bgfEintStatus) {
+		/*combo chip exists */
+		WMT_DETECT_INFO_FUNC("external combo chip detected\n");
+
+		/*detect chipid by sdio_detect module */
+		chipId = sdio_detect_query_chipid(1);
+		if (0 <= hif_sdio_is_chipid_valid(chipId))
+			WMT_DETECT_INFO_FUNC("valid external combo chip id (0x%x)\n", chipId);
+		else
+			WMT_DETECT_INFO_FUNC("invalid external combo chip id (0x%x)\n", chipId);
+		iRet = 0;
+	} else {
+		/*Error exists */
+		WMT_DETECT_ERR_FUNC("error happens when detecting combo chip\n");
+	}
+	WMT_DETECT_INFO_FUNC("--\n");
+	/*return 0 */
+	return iRet;
+	/*todo: if there is external combo chip, power on chip return 0 */
+}
+
+#ifdef MTK_WCN_COMBO_CHIP_SUPPORT
+static int wmt_detect_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	WMT_DETECT_ERR_FUNC("platform name: %s\n", pdev->name);
+	ret = wmt_gpio_init(pdev);
+	if (-1 == ret)
+		WMT_DETECT_ERR_FUNC("gpio init fail ret:%d\n", ret);
+	return ret;
+}
+
+static int wmt_detect_remove(struct platform_device *pdev)
+{
+	wmt_gpio_deinit();
+	return 0;
+}
+#endif
+
+#ifdef MTK_WCN_COMBO_CHIP_SUPPORT
+static struct of_device_id wmt_detect_match[] = {
+	{ .compatible = "mediatek,connectivity-combo", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, wmt_detect_match);
+
+static struct platform_driver wmt_detect_driver = {
+	.probe = wmt_detect_probe,
+	.remove = wmt_detect_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "mediatek,connectivity-combo",
+		.of_match_table = wmt_detect_match,
+	},
+};
+/*module_platform_driver(wmt_detect_driver);*/
+#endif
+
+static int __init wmt_detect_driver_init(void)
+{
+	dev_t devID = MKDEV(gWmtDetectMajor, 0);
+	int cdevErr = -1;
+	int ret = -1;
+
+	ret = register_chrdev_region(devID, WMT_DETECT_DEV_NUM, WMT_DETECT_DRVIER_NAME);
+	if (ret) {
+		WMT_DETECT_ERR_FUNC("fail to register chrdev\n");
+		return ret;
+	}
+
+	cdev_init(&gWmtDetectCdev, &gWmtDetectFops);
+	gWmtDetectCdev.owner = THIS_MODULE;
+
+	cdevErr = cdev_add(&gWmtDetectCdev, devID, WMT_DETECT_DEV_NUM);
+	if (cdevErr) {
+		WMT_DETECT_ERR_FUNC("cdev_add() fails (%d)\n", cdevErr);
+		goto err1;
+	}
+
+	pDetectClass = class_create(THIS_MODULE, WMT_DETECT_DEVICE_NAME);
+	if (IS_ERR(pDetectClass)) {
+		WMT_DETECT_ERR_FUNC("class create fail, error code(%ld)\n", PTR_ERR(pDetectClass));
+		goto err1;
+	}
+
+	pDetectDev = device_create(pDetectClass, NULL, devID, NULL, WMT_DETECT_DEVICE_NAME);
+	if (IS_ERR(pDetectDev)) {
+		WMT_DETECT_ERR_FUNC("device create fail, error code(%ld)\n", PTR_ERR(pDetectDev));
+		goto err2;
+	}
+
+	WMT_DETECT_INFO_FUNC("driver(major %d) installed success\n", gWmtDetectMajor);
+
+	/*init SDIO-DETECT module */
+	sdio_detect_init();
+
+#ifdef MTK_WCN_COMBO_CHIP_SUPPORT
+	ret = platform_driver_register(&wmt_detect_driver);
+	if (ret)
+		WMT_DETECT_ERR_FUNC("platform driver register fail ret:%d\n", ret);
+#endif
+
+	return 0;
+
+err2:
+
+	if (pDetectClass) {
+		class_destroy(pDetectClass);
+		pDetectClass = NULL;
+	}
+
+err1:
+
+	if (cdevErr == 0)
+		cdev_del(&gWmtDetectCdev);
+
+	if (ret == 0) {
+		unregister_chrdev_region(devID, WMT_DETECT_DEV_NUM);
+		gWmtDetectMajor = -1;
+	}
+
+	WMT_DETECT_ERR_FUNC("fail\n");
+
+	return -1;
+}
+
+static void __exit wmt_detect_driver_exit(void)
+{
+	dev_t dev = MKDEV(gWmtDetectMajor, 0);
+
+#ifdef MTK_WCN_COMBO_CHIP_SUPPORT
+	platform_driver_unregister(&wmt_detect_driver);
+#endif
+
+#if !(MTK_WCN_REMOVE_KO)
+/*deinit SDIO-DETECT module*/
+	sdio_detect_exit();
+#endif
+
+	if (pDetectDev) {
+		device_destroy(pDetectClass, dev);
+		pDetectDev = NULL;
+	}
+
+	if (pDetectClass) {
+		class_destroy(pDetectClass);
+		pDetectClass = NULL;
+	}
+
+	cdev_del(&gWmtDetectCdev);
+	unregister_chrdev_region(dev, WMT_DETECT_DEV_NUM);
+
+	WMT_DETECT_INFO_FUNC("done\n");
+}
+
+module_init(wmt_detect_driver_init);
+module_exit(wmt_detect_driver_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Zhiguo.Niu & Chaozhong.Liang @ MBJ/WCNSE/SS1");
+
+module_param(gWmtDetectMajor, uint, 0);
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/wmt_detect.h b/drivers/misc/mediatek/connectivity/common/common_detect/wmt_detect.h
new file mode 100644
index 00000000..7e152bf
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/wmt_detect.h
@@ -0,0 +1,114 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _WMT_DETECT_H_
+#define _WMT_DETECT_H_
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <asm/current.h>
+#include <asm/uaccess.h>
+#include <linux/proc_fs.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+#ifdef MTK_WCN_REMOVE_KERNEL_MODULE
+#define MTK_WCN_REMOVE_KO 1
+#else
+#define MTK_WCN_REMOVE_KO 0
+#endif
+
+#include "sdio_detect.h"
+#include "wmt_detect_pwr.h"
+#include <mtk_wcn_cmb_stub.h>
+
+#define WMT_DETECT_LOG_LOUD    4
+#define WMT_DETECT_LOG_DBG     3
+#define WMT_DETECT_LOG_INFO    2
+#define WMT_DETECT_LOG_WARN    1
+#define WMT_DETECT_LOG_ERR     0
+
+extern unsigned int gWmtDetectDbgLvl;
+
+#define WMT_DETECT_LOUD_FUNC(fmt, arg...) \
+do { \
+	if (gWmtDetectDbgLvl >= WMT_DETECT_LOG_LOUD) \
+		pr_debug(DFT_TAG"[L]%s:"  fmt, __func__ , ##arg); \
+} while (0)
+#define WMT_DETECT_DBG_FUNC(fmt, arg...) \
+do { \
+	if (gWmtDetectDbgLvl >= WMT_DETECT_LOG_DBG) \
+		pr_debug(DFT_TAG"[D]%s:"  fmt, __func__ , ##arg); \
+} while (0)
+#define WMT_DETECT_INFO_FUNC(fmt, arg...) \
+do { \
+	if (gWmtDetectDbgLvl >= WMT_DETECT_LOG_INFO) \
+		pr_err(DFT_TAG"[I]%s:"  fmt, __func__ , ##arg); \
+} while (0)
+#define WMT_DETECT_WARN_FUNC(fmt, arg...) \
+do { \
+	if (gWmtDetectDbgLvl >= WMT_DETECT_LOG_WARN) \
+		pr_warn(DFT_TAG"[W]%s(%d):"  fmt, __func__ , __LINE__, ##arg); \
+} while (0)
+#define WMT_DETECT_ERR_FUNC(fmt, arg...) \
+do { \
+	if (gWmtDetectDbgLvl >= WMT_DETECT_LOG_ERR) \
+		pr_err(DFT_TAG"[E]%s(%d):"  fmt, __func__ , __LINE__, ##arg); \
+} while (0)
+
+#define WMT_IOC_MAGIC			'w'
+#define COMBO_IOCTL_GET_CHIP_ID		  _IOR(WMT_IOC_MAGIC, 0, int)
+#define COMBO_IOCTL_SET_CHIP_ID		  _IOW(WMT_IOC_MAGIC, 1, int)
+#define COMBO_IOCTL_EXT_CHIP_DETECT   _IOR(WMT_IOC_MAGIC, 2, int)
+#define COMBO_IOCTL_GET_SOC_CHIP_ID   _IOR(WMT_IOC_MAGIC, 3, int)
+#define COMBO_IOCTL_DO_MODULE_INIT    _IOR(WMT_IOC_MAGIC, 4, int)
+#define COMBO_IOCTL_MODULE_CLEANUP    _IOR(WMT_IOC_MAGIC, 5, int)
+#define COMBO_IOCTL_EXT_CHIP_PWR_ON   _IOR(WMT_IOC_MAGIC, 6, int)
+#define COMBO_IOCTL_EXT_CHIP_PWR_OFF  _IOR(WMT_IOC_MAGIC, 7, int)
+#define COMBO_IOCTL_DO_SDIO_AUDOK     _IOR(WMT_IOC_MAGIC, 8, int)
+
+/*******************************************************************************
+*                   F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************/
+extern int wmt_detect_ext_chip_detect(void);
+extern int wmt_detect_ext_chip_pwr_on(void);
+extern int wmt_detect_ext_chip_pwr_off(void);
+
+#ifdef MTK_WCN_SOC_CHIP_SUPPORT
+extern unsigned int wmt_plat_get_soc_chipid(void);
+#endif
+
+#ifdef MTK_WCN_COMBO_CHIP_SUPPORT
+/* mtk_uart_pdn_enable -- request uart port enter/exit deep idle mode, this API is defined in uart driver
+ *
+ * @ port - uart port name, Eg: "ttyMT0", "ttyMT1", "ttyMT2"
+ * @ enable - "1", enable deep idle; "0", disable deep idle
+ *
+ * Return 0 if success, else -1
+ */
+extern unsigned int mtk_uart_pdn_enable(char *port, int enable);
+#endif
+
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/wmt_detect_pwr.c b/drivers/misc/mediatek/connectivity/common/common_detect/wmt_detect_pwr.c
new file mode 100644
index 00000000..1dcb7ed
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/wmt_detect_pwr.c
@@ -0,0 +1,232 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <mtk_rtc.h>
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[WMT-DETECT]"
+
+#include "wmt_detect.h"
+#include "wmt_gpio.h"
+
+#define INVALID_PIN_ID (0xFFFFFFFF)
+
+/*copied form WMT module*/
+static int wmt_detect_dump_pin_conf(void)
+{
+	WMT_DETECT_DBG_FUNC("[WMT-DETECT]=>dump wmt pin configuration start<=\n");
+
+	WMT_DETECT_INFO_FUNC("LDO(GPIO%d), PMU(GPIO%d), PMUV28(GPIO%d)\n",
+			gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_LDO_EN_PIN].gpio_num,
+			gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_num,
+			gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMUV28_EN_PIN].gpio_num);
+
+	WMT_DETECT_INFO_FUNC("RST(GPIO%d), BGF_EINT(GPIO%d), BGF_EINT_NUM(%d)\n",
+			gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_num,
+			gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_BGF_EINT_PIN].gpio_num,
+			gpio_to_irq(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_BGF_EINT_PIN].gpio_num));
+
+	WMT_DETECT_INFO_FUNC("WIFI_EINT(GPIO%d), WIFI_EINT_NUM(%d)\n",
+			gpio_ctrl_info.gpio_ctrl_state[GPIO_WIFI_EINT_PIN].gpio_num,
+			gpio_to_irq(gpio_ctrl_info.gpio_ctrl_state[GPIO_WIFI_EINT_PIN].gpio_num));
+
+	WMT_DETECT_DBG_FUNC("[WMT-PLAT]=>dump wmt pin configuration ends<=\n");
+
+	return 0;
+}
+
+int _wmt_detect_output_low(unsigned int id)
+{
+	if (INVALID_PIN_ID != gpio_ctrl_info.gpio_ctrl_state[id].gpio_num) {
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[id].gpio_num, 0);
+		WMT_DETECT_DBG_FUNC("WMT-DETECT: set GPIO%d to output %d\n",
+				gpio_ctrl_info.gpio_ctrl_state[id].gpio_num,
+				gpio_get_value(gpio_ctrl_info.gpio_ctrl_state[id].gpio_num));
+	}
+
+	return 0;
+}
+
+int _wmt_detect_output_high(unsigned int id)
+{
+	if (INVALID_PIN_ID != gpio_ctrl_info.gpio_ctrl_state[id].gpio_num) {
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[id].gpio_num, 1);
+		WMT_DETECT_DBG_FUNC("WMT-DETECT: set GPIO%d to output %d\n",
+				gpio_ctrl_info.gpio_ctrl_state[id].gpio_num,
+				gpio_get_value(gpio_ctrl_info.gpio_ctrl_state[id].gpio_num));
+	}
+
+	return 0;
+}
+
+int _wmt_detect_read_gpio_input(unsigned int id)
+{
+	int retval = 0;
+
+	if (INVALID_PIN_ID != gpio_ctrl_info.gpio_ctrl_state[id].gpio_num) {
+		retval = gpio_get_value(gpio_ctrl_info.gpio_ctrl_state[id].gpio_num);
+		WMT_DETECT_DBG_FUNC("WMT-DETECT: get GPIO%d val%d\n",
+				gpio_ctrl_info.gpio_ctrl_state[id].gpio_num, retval);
+	}
+
+	return retval;
+}
+
+/*This power on sequence must support all combo chip's basic power on sequence
+ * 1. LDO control is a must, if external LDO exist
+ * 2. PMU control is a must
+ * 3. RST control is a must
+ * 4. WIFI_EINT pin control is a must, used for GPIO mode for EINT status checkup
+ * 5. RTC32k clock control is a must
+ * */
+static int wmt_detect_chip_pwr_on(void)
+{
+	int retval = -1;
+	/*setting validiation check*/
+	if ((INVALID_PIN_ID == gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_num) ||
+		(INVALID_PIN_ID == gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_num) ||
+		(INVALID_PIN_ID == gpio_ctrl_info.gpio_ctrl_state[GPIO_WIFI_EINT_PIN].gpio_num)) {
+		WMT_DETECT_ERR_FUNC("WMT-DETECT: either PMU(%d) or RST(%d) or WIFI_EINT(%d) is not set\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_num,
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_num,
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_WIFI_EINT_PIN].gpio_num);
+
+		return retval;
+	}
+	/*set LDO/PMU/RST to output 0, no pull*/
+	if (INVALID_PIN_ID != gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_LDO_EN_PIN].gpio_num)
+		_wmt_detect_output_low(GPIO_COMBO_LDO_EN_PIN);
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_state[GPIO_PULL_DIS]) {
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_state[GPIO_PULL_DIS]);
+		WMT_DETECT_INFO_FUNC("wmt_gpio:set GPIO_COMBO_PMU_EN_PIN to GPIO_PULL_DIS done!\n");
+	} else
+		WMT_DETECT_ERR_FUNC("wmt_gpio:set GPIO_COMBO_PMU_EN_PIN to GPIO_PULL_DIS fail, is NULL!\n");
+	_wmt_detect_output_low(GPIO_COMBO_PMU_EN_PIN);
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_state[GPIO_PULL_DIS]) {
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_state[GPIO_PULL_DIS]);
+		WMT_DETECT_INFO_FUNC("wmt_gpio:set GPIO_COMBO_RST_PIN to GPIO_PULL_DIS done!\n");
+	} else
+		WMT_DETECT_ERR_FUNC("wmt_gpio:set GPIO_COMBO_RST_PIN to GPIO_PULL_DIS fail, is NULL!\n");
+	_wmt_detect_output_low(GPIO_COMBO_RST_PIN);
+
+#if 0
+	_wmt_detect_output_high(GPIO_WIFI_EINT_PIN);
+#endif
+
+	/*pull high LDO*/
+	if (INVALID_PIN_ID != gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_LDO_EN_PIN].gpio_num)
+		_wmt_detect_output_high(GPIO_COMBO_LDO_EN_PIN);
+	/*sleep for LDO stable time*/
+	msleep(MAX_LDO_STABLE_TIME);
+
+	/*export RTC clock, sleep for RTC stable time*/
+	rtc_gpio_enable_32k(RTC_GPIO_USER_GPS);
+	msleep(MAX_RTC_STABLE_TIME);
+	/*PMU output low, RST output low, to make chip power off completely*/
+	/*always done*/
+	/*sleep for power off stable time*/
+	msleep(MAX_OFF_STABLE_TIME);
+	/*PMU output high, and sleep for reset stable time*/
+	_wmt_detect_output_high(GPIO_COMBO_PMU_EN_PIN);
+#ifdef CONFIG_MTK_COMBO_COMM_NPWR
+	if ((gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_I2S_DAT_PIN].gpio_num != INVALID_PIN_ID) &&
+		(gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAISYNC_PIN].gpio_num != INVALID_PIN_ID)) {
+		msleep(20);
+		_wmt_detect_output_high(GPIO_PCM_DAISYNC_PIN);
+
+		msleep(20);
+		_wmt_detect_output_high(GPIO_COMBO_I2S_DAT_PIN);
+
+		msleep(20);
+		_wmt_detect_output_low(GPIO_COMBO_I2S_DAT_PIN);
+
+		msleep(20);
+		_wmt_detect_output_low(GPIO_PCM_DAISYNC_PIN);
+
+		msleep(20);
+	}
+#endif
+	msleep(MAX_RST_STABLE_TIME);
+	/*RST output high, and sleep for power on stable time */
+	_wmt_detect_output_high(GPIO_COMBO_RST_PIN);
+	msleep(MAX_ON_STABLE_TIME);
+
+	retval = 0;
+	return retval;
+}
+
+static int wmt_detect_chip_pwr_off(void)
+{
+
+	/*set RST pin to input low status*/
+	if (INVALID_PIN_ID != gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_LDO_EN_PIN].gpio_num)
+		_wmt_detect_output_low(GPIO_COMBO_LDO_EN_PIN);
+	/*set RST pin to input low status*/
+	if (INVALID_PIN_ID != gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_num)
+		_wmt_detect_output_low(GPIO_COMBO_RST_PIN);
+	/*set PMU pin to input low status*/
+	if (INVALID_PIN_ID != gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_num)
+		_wmt_detect_output_low(GPIO_COMBO_PMU_EN_PIN);
+	return 0;
+}
+
+int wmt_detect_read_ext_cmb_status(void)
+{
+	int retval = 0;
+	/*read WIFI_EINT pin status*/
+	if (INVALID_PIN_ID == gpio_ctrl_info.gpio_ctrl_state[GPIO_WIFI_EINT_PIN].gpio_num) {
+		retval = 0;
+		WMT_DETECT_ERR_FUNC("WMT-DETECT: no WIFI_EINT pin set\n");
+	} else {
+		retval = _wmt_detect_read_gpio_input(GPIO_WIFI_EINT_PIN);
+		WMT_DETECT_ERR_FUNC("WMT-DETECT: WIFI_EINT input status:%d\n", retval);
+	}
+	return retval;
+}
+
+int wmt_detect_chip_pwr_ctrl(int on)
+{
+	int retval = -1;
+
+	if (0 == on) {
+		/*power off combo chip */
+		retval = wmt_detect_chip_pwr_off();
+	} else {
+		wmt_detect_dump_pin_conf();
+		/*power on combo chip */
+		retval = wmt_detect_chip_pwr_on();
+	}
+	return retval;
+}
+
+int wmt_detect_sdio_pwr_ctrl(int on)
+{
+	int retval = -1;
+#ifdef MTK_WCN_COMBO_CHIP_SUPPORT
+	if (0 == on) {
+		/*power off SDIO slot */
+		retval = board_sdio_ctrl(1, 0);
+	} else {
+		/*power on SDIO slot */
+		retval = board_sdio_ctrl(1, 1);
+	}
+#else
+	WMT_DETECT_WARN_FUNC("WMT-DETECT: MTK_WCN_COMBO_CHIP_SUPPORT is not set\n");
+#endif
+	return retval;
+}
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/wmt_detect_pwr.h b/drivers/misc/mediatek/connectivity/common/common_detect/wmt_detect_pwr.h
new file mode 100644
index 00000000..32e6615
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/wmt_detect_pwr.h
@@ -0,0 +1,29 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __WMT_DETECT_PWR_H_
+#define __WMT_DETECT_PWR_H_
+
+#define MAX_RTC_STABLE_TIME 100
+#define MAX_LDO_STABLE_TIME 100
+#define MAX_RST_STABLE_TIME 30
+#define MAX_OFF_STABLE_TIME 10
+#define MAX_ON_STABLE_TIME 30
+
+extern int board_sdio_ctrl(unsigned int sdio_port_num, unsigned int on);
+extern int wmt_detect_chip_pwr_ctrl(int on);
+extern int wmt_detect_sdio_pwr_ctrl(int on);
+extern int wmt_detect_read_ext_cmb_status(void);
+
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/wmt_gpio.c b/drivers/misc/mediatek/connectivity/common/common_detect/wmt_gpio.c
new file mode 100644
index 00000000..3a79e1e
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/wmt_gpio.c
@@ -0,0 +1,371 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "wmt_gpio.h"
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+const PUINT8 gpio_state_name[GPIO_PIN_ID_MAX][GPIO_STATE_MAX] = {{"gpio_ldo_en_pull_dis",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"gpio_ldo_en_in_pulldown",
+		""},
+	{"gpio_pmuv28_pull_dis",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"gpio_pmuv28_in_pulldown",
+		""},
+	{"gpio_pmu_en_pull_dis",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"gpio_pmu_en_in_pulldown",
+		""},
+	{"gpio_rst_pull_dis",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		""},
+	{"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"gpio_bgf_eint_in_pulldown",
+		"gpio_bgf_eint_in_pullup"},
+	{"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"gpio_wifi_eint_in_pull_dis",
+		"",
+		"gpio_wifi_eint_in_pullup"},
+	{"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"gpio_all_eint_in_pulldown",
+		"gpio_all_eint_in_pullup"},
+	{"gpio_urxd_uart_pull_dis",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"gpio_urxd_gpio_in_pull_dis",
+		"",
+		"gpio_urxd_gpio_in_pullup"},
+	{"gpio_utxd_uart_pull_dis",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		""},
+	{"gpio_pcm_daiclk_pull_dis",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		""},
+	{"gpio_pcm_daipcmin_pull_dis",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		""},
+	{"gpio_pcm_daipcmout_pull_dis",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		""},
+	{"gpio_pcm_daisync_pull_dis",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		""},
+	{"gpio_i2s_ck_pull_dis",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		""},
+	{"gpio_i2s_ws_pull_dis",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		""},
+	{"gpio_i2s_dat_pull_dis",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		""},
+	{"gpio_gps_sync_pull_dis",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		""},
+	{"gpio_gps_lna_pull_dis",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		""}
+};
+
+const PUINT8 gpio_pin_name[GPIO_PIN_ID_MAX] = {"gpio_combo_ldo_en_pin",
+					"gpio_combo_pmuv28_en_pin",
+					"gpio_combo_pmu_en_pin",
+					"gpio_combo_rst_pin",
+					"gpio_combo_bgf_eint_pin",
+					"gpio_wifi_eint_pin",
+					"gpio_all_eint_pin",
+					"gpio_combo_urxd_pin",
+					"gpio_combo_utxd_pin",
+					"gpio_pcm_daiclk_pin",
+					"gpio_pcm_daipcmin_pin",
+					"gpio_pcm_daipcmout_pin",
+					"gpio_pcm_daisync_pin",
+					"gpio_combo_i2s_ck_pin",
+					"gpio_combo_i2s_ws_pin",
+					"gpio_combo_i2s_dat_pin",
+					"gpio_gps_sync_pin",
+					"gpio_gps_lna_pin"};
+
+GPIO_CTRL_INFO gpio_ctrl_info;
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+INT32 wmt_gpio_init(struct platform_device *pdev)
+{
+	INT32 iret = 0;
+	UINT32 i, j;
+	struct device_node *node;
+
+	node = of_find_compatible_node(NULL, NULL, "mediatek,connectivity-combo");
+	if (!node) {
+		for (i = 0; i < GPIO_PIN_ID_MAX; i++)
+			gpio_ctrl_info.gpio_ctrl_state[i].gpio_num = DEFAULT_PIN_ID;
+		pr_err("wmt_gpio:can't find device tree node!\n");
+		iret = -1;
+		goto err;
+	}
+
+	gpio_ctrl_info.pinctrl_info = devm_pinctrl_get(&pdev->dev);
+	if (gpio_ctrl_info.pinctrl_info) {
+		for (i = 0; i < GPIO_PIN_ID_MAX; i++) {
+			gpio_ctrl_info.gpio_ctrl_state[i].gpio_num = of_get_named_gpio(node,
+					gpio_pin_name[i], 0);
+			if (gpio_ctrl_info.gpio_ctrl_state[i].gpio_num < 0)
+				gpio_ctrl_info.gpio_ctrl_state[i].gpio_num = DEFAULT_PIN_ID;
+			if (DEFAULT_PIN_ID != gpio_ctrl_info.gpio_ctrl_state[i].gpio_num) {
+				for (j = 0; j < GPIO_STATE_MAX; j++) {
+					if (0 != strlen(gpio_state_name[i][j])) {
+						gpio_ctrl_info.gpio_ctrl_state[i].gpio_state[j] =
+							pinctrl_lookup_state(gpio_ctrl_info.pinctrl_info,
+									gpio_state_name[i][j]);
+					} else
+						gpio_ctrl_info.gpio_ctrl_state[i].gpio_state[j] = NULL;
+				}
+			}
+		}
+
+		pr_err("wmt_gpio: gpio init start!\n");
+
+		if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_state[GPIO_PULL_DIS]) {
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+					gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].
+					gpio_state[GPIO_PULL_DIS]);
+			pr_err("wmt_gpio:set GPIO_COMBO_PMU_EN_PIN to GPIO_PULL_DIS done!\n");
+		} else
+			pr_err("wmt_gpio:set GPIO_COMBO_PMU_EN_PIN to GPIO_PULL_DIS fail, is NULL!\n");
+
+		if (DEFAULT_PIN_ID != gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_num) {
+			gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_num,
+					0);
+			pr_err("wmt_gpio:set GPIO_COMBO_PMU_EN_PIN out to 0: %d!\n",
+					gpio_get_value(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_num));
+		}
+
+		if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_state[GPIO_PULL_DIS]) {
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+					gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_state[GPIO_PULL_DIS]);
+			pr_err("wmt_gpio:set GPIO_COMBO_RST_PIN to GPIO_PULL_DIS done!\n");
+		} else
+			pr_err("wmt_gpio:set GPIO_COMBO_RST_PIN to GPIO_PULL_DIS fail, is NULL!\n");
+
+		if (DEFAULT_PIN_ID != gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_num) {
+			gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_num,
+					0);
+			pr_err("wmt_gpio:set GPIO_COMBO_RST_PIN out to 0: %d!\n",
+					gpio_get_value(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_num));
+		}
+
+		if (gpio_ctrl_info.gpio_ctrl_state[GPIO_WIFI_EINT_PIN].gpio_state[GPIO_IN_PULLUP]) {
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+					gpio_ctrl_info.gpio_ctrl_state[GPIO_WIFI_EINT_PIN].gpio_state[GPIO_IN_PULLUP]);
+			pr_err("wmt_gpio:set GPIO_WIFI_EINT_PIN to GPIO_IN_PULLUP done!\n");
+		} else
+			pr_err("wmt_gpio:set GPIO_WIFI_EINT_PIN to GPIO_IN_PULLUP fail, is NULL!\n");
+
+		if (gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAICLK_PIN].gpio_state[GPIO_PULL_DIS]) {
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+					gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAICLK_PIN].gpio_state[GPIO_PULL_DIS]);
+			pr_err("wmt_gpio:set GPIO_PCM_DAICLK_PIN to GPIO_PULL_DIS done!\n");
+		} else
+			pr_err("wmt_gpio:set GPIO_PCM_DAICLK_PIN to GPIO_PULL_DIS fail, is NULL!\n");
+
+		if (gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAIPCMIN_PIN].gpio_state[GPIO_PULL_DIS]) {
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+					gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAIPCMIN_PIN].
+					gpio_state[GPIO_PULL_DIS]);
+			pr_err("wmt_gpio:set GPIO_PCM_DAIPCMIN_PIN to GPIO_PULL_DIS done!\n");
+		} else
+			pr_err("wmt_gpio:set GPIO_PCM_DAIPCMIN_PIN to GPIO_PULL_DIS fail, is NULL!\n");
+
+		if (gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAIPCMOUT_PIN].gpio_state[GPIO_PULL_DIS]) {
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+					gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAIPCMOUT_PIN].
+					gpio_state[GPIO_PULL_DIS]);
+			pr_err("wmt_gpio:set GPIO_PCM_DAIPCMOUT_PIN to GPIO_PULL_DIS done!\n");
+		} else
+			pr_err("wmt_gpio:set GPIO_PCM_DAIPCMOUT_PIN to GPIO_PULL_DIS fail, is NULL!\n");
+
+		if (gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAISYNC_PIN].gpio_state[GPIO_PULL_DIS]) {
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+					gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAISYNC_PIN].
+					gpio_state[GPIO_PULL_DIS]);
+			pr_err("wmt_gpio:set GPIO_PCM_DAISYNC_PIN to GPIO_PULL_DIS done!\n");
+		} else
+			pr_err("wmt_gpio:set GPIO_PCM_DAISYNC_PIN to GPIO_PULL_DIS fail, is NULL!\n");
+
+		pr_err("wmt_gpio: gpio init done!\n");
+	} else {
+		pr_err("wmt_gpio:can't find pinctrl dev!\n");
+		iret = -1;
+	}
+err:
+	return iret;
+}
+
+INT32 wmt_gpio_deinit(VOID)
+{
+	INT32 iret = 0;
+	UINT32 i;
+	UINT32 j;
+
+	for (i = 0; i < GPIO_PIN_ID_MAX; i++) {
+		gpio_ctrl_info.gpio_ctrl_state[i].gpio_num = DEFAULT_PIN_ID;
+		if (DEFAULT_PIN_ID != gpio_ctrl_info.gpio_ctrl_state[i].gpio_num) {
+			for (j = 0; j < GPIO_STATE_MAX; j++) {
+				if (0 != strlen(gpio_state_name[i][j]))
+					gpio_ctrl_info.gpio_ctrl_state[i].gpio_state[j] = NULL;
+			}
+		}
+	}
+	if (gpio_ctrl_info.pinctrl_info) {
+		devm_pinctrl_put(gpio_ctrl_info.pinctrl_info);
+		gpio_ctrl_info.pinctrl_info = NULL;
+	}
+
+	return iret;
+}
diff --git a/drivers/misc/mediatek/connectivity/common/common_detect/wmt_gpio.h b/drivers/misc/mediatek/connectivity/common/common_detect/wmt_gpio.h
new file mode 100644
index 00000000..cd935bf
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/common_detect/wmt_gpio.h
@@ -0,0 +1,103 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _WMT_GPIO_H_
+#define _WMT_GPIO_H_
+
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include "osal.h"
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+#define DEFAULT_PIN_ID (0xffffffff)
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+typedef enum _ENUM_GPIO_PIN_ID {
+	GPIO_COMBO_LDO_EN_PIN = 0,
+	GPIO_COMBO_PMUV28_EN_PIN,
+	GPIO_COMBO_PMU_EN_PIN,
+	GPIO_COMBO_RST_PIN,
+	GPIO_COMBO_BGF_EINT_PIN,
+	GPIO_WIFI_EINT_PIN,
+	GPIO_COMBO_ALL_EINT_PIN,
+	GPIO_COMBO_URXD_PIN,
+	GPIO_COMBO_UTXD_PIN,
+	GPIO_PCM_DAICLK_PIN,
+	GPIO_PCM_DAIPCMIN_PIN,
+	GPIO_PCM_DAIPCMOUT_PIN,
+	GPIO_PCM_DAISYNC_PIN,
+	GPIO_COMBO_I2S_CK_PIN,
+	GPIO_COMBO_I2S_WS_PIN,
+	GPIO_COMBO_I2S_DAT_PIN,
+	GPIO_GPS_SYNC_PIN,
+	GPIO_GPS_LNA_PIN,
+	GPIO_PIN_ID_MAX
+} ENUM_GPIO_PIN_ID, *P_ENUM_GPIO_PIN_ID;
+
+typedef enum _ENUM_GPIO_STATE_ID {
+	GPIO_PULL_DIS = 0,
+	GPIO_PULL_DOWN,
+	GPIO_PULL_UP,
+	GPIO_OUT_LOW,
+	GPIO_OUT_HIGH,
+	GPIO_IN_DIS,
+	GPIO_IN_EN,
+	GPIO_IN_PULL_DIS,
+	GPIO_IN_PULLDOWN,
+	GPIO_IN_PULLUP,
+	GPIO_STATE_MAX,
+} ENUM_GPIO_STATE_ID, *P_ENUM_GPIO_STATE_ID;
+
+typedef struct _GPIO_CTRL_STATE {
+	INT32 gpio_num;
+	struct pinctrl_state *gpio_state[GPIO_STATE_MAX];
+} GPIO_CTRL_STATE, *P_GPIO_CTRL_STATE;
+
+typedef struct _GPIO_CTRL_INFO {
+	struct pinctrl *pinctrl_info;
+	GPIO_CTRL_STATE gpio_ctrl_state[GPIO_PIN_ID_MAX];
+} GPIO_CTRL_INFO, *P_GPIO_CTRL_INFO;
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+extern const PUINT8 gpio_state_name[GPIO_PIN_ID_MAX][GPIO_STATE_MAX];
+extern const PUINT8 gpio_pin_name[GPIO_PIN_ID_MAX];
+extern GPIO_CTRL_INFO gpio_ctrl_info;
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+INT32 wmt_gpio_init(struct platform_device *pdev);
+
+INT32 wmt_gpio_deinit(VOID);
+
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/Makefile b/drivers/misc/mediatek/connectivity/common/conn_soc/Makefile
new file mode 100644
index 00000000..d9caa4d
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/Makefile
@@ -0,0 +1,94 @@
+subdir-ccflags-y += \
+	-I$(srctree)/$(src)/linux/include \
+	-I$(srctree)/$(src)/linux/pri/include \
+	-I$(srctree)/$(src)/core/include \
+	-I$(srctree)/$(src)/include \
+	-I$(srctree)/drivers/misc/mediatek/btif/common/inc \
+	-I$(srctree)/$(src)/$(subst ",,$(CONFIG_MTK_PLATFORM))/include
+
+EXT_FLAG=_soc
+COMMON_SRC_PATH := $(src)
+COMMON_OBJ_PATH := $(src)
+
+ifeq ($(CONFIG_ARCH_MT6580), y)
+subdir-ccflags-y += -D CFG_WMT_READ_EFUSE_VCN33
+endif
+
+ifeq ($(CONFIG_MTK_COMBO), m)
+
+# ---------------------------------------------------
+# Directory List
+# ---------------------------------------------------
+CORE_DIR      := core/
+LINUX_PRI_DIR := linux/pri/
+LINUX_PUB_DIR := linux/pub/
+
+# ---------------------------------------------------
+# Objects List
+# ---------------------------------------------------
+CORE_OBJS := 	$(CORE_DIR)wmt_core.o \
+				$(CORE_DIR)wmt_ctrl.o \
+				$(CORE_DIR)wmt_func.o \
+				$(CORE_DIR)wmt_ic_soc.o \
+				$(CORE_DIR)wmt_lib.o \
+				$(CORE_DIR)wmt_conf.o \
+				$(CORE_DIR)btm_core.o \
+				$(CORE_DIR)dbg_core.o \
+				$(CORE_DIR)psm_core.o \
+				$(CORE_DIR)stp_core.o \
+				$(CORE_DIR)wmt_stp_exp.o \
+				$(CORE_DIR)mtk_wcn_stub_alps.o
+
+
+LINUX_PRI_OBJS := 	$(LINUX_PRI_DIR)stp_btif.o \
+					$(LINUX_PRI_DIR)stp_dbg.o \
+					$(LINUX_PRI_DIR)stp_exp.o \
+					$(LINUX_PRI_DIR)wmt_dev.o \
+					$(LINUX_PRI_DIR)wmt_exp.o
+
+
+LINUX_PUB_OBJS :=	$(LINUX_PUB_DIR)osal.o \
+					$(LINUX_PUB_DIR)bgw_desense.o \
+					$(LINUX_PUB_DIR)wmt_idc.o
+
+
+ccflags-y += -DWMT_CREATE_NODE_DYNAMIC=1
+ccflags-y += -DMTK_BT_HCI=1
+ccflags-y += -DMTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+ifeq ($(CONFIG_MTK_TC1_FEATURE), y)
+    ccflags-y += -DCFG_TC1_FEATURE=1
+else
+    ccflags-y += -DCFG_TC1_FEATURE=0
+endif
+ifeq ($(CONFIG_MTK_CONN_LTE_IDC_SUPPORT),y)
+    ccflags-y += -DWMT_IDC_SUPPORT=1
+else
+    ccflags-y += -DWMT_IDC_SUPPORT=0
+endif
+
+# WMT LIBRARY DRIVER
+obj-$(CONFIG_MTK_COMBO) += mtk_stp_wmt$(EXT_FLAG).o
+
+mtk_stp_wmt$(EXT_FLAG)-objs	:= 	$(CORE_OBJS) \
+								$(LINUX_PRI_OBJS) \
+								$(LINUX_PUB_OBJS)
+
+mtk_stp_wmt$(EXT_FLAG)-objs += $(subst ",,$(CONFIG_MTK_PLATFORM))/wmt_plat_alps.o
+mtk_stp_wmt$(EXT_FLAG)-objs += $(subst ",,$(CONFIG_MTK_PLATFORM))/mtk_wcn_consys_hw.o
+
+# WMT LIBRARY BT CONTROL DRIVER
+obj-$(CONFIG_MTK_COMBO_BT) 	+= mtk_stp_bt$(EXT_FLAG).o
+mtk_stp_bt$(EXT_FLAG)-objs	:= $(LINUX_PUB_DIR)stp_chrdev_bt.o
+
+# WMT LIBRARY WIFI CONTROL DRIVER
+obj-$(CONFIG_MTK_COMBO_WIFI) += mtk_wmt_wifi$(EXT_FLAG).o
+mtk_wmt_wifi$(EXT_FLAG)-objs := $(LINUX_PUB_DIR)wmt_chrdev_wifi.o
+
+endif
+
+ifeq ($(CONFIG_MTK_COMBO), y)
+subdir-ccflags-y += -DMTK_WCN_BUILT_IN_DRIVER
+obj-y += core/
+obj-y += linux/
+obj-y += $(subst ",,$(CONFIG_MTK_PLATFORM))/
+endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/Makefile b/drivers/misc/mediatek/connectivity/common/conn_soc/core/Makefile
new file mode 100644
index 00000000..153a243
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/Makefile
@@ -0,0 +1,24 @@
+ifeq ($(CONFIG_MTK_COMBO), y)
+
+ccflags-y += \
+	-I$(srctree)/$(src)/../linux/include \
+	-I$(srctree)/$(src)/../linux/pri/include \
+	-I$(srctree)/$(src)/../core/include \
+	-I$(srctree)/$(src)/../include \
+	-I$(srctree)/$(src)/../../common_detect \
+	-I$(srctree)/drivers/misc/mediatek/btif/common/inc
+
+obj-y += wmt_core.o \
+         wmt_ctrl.o \
+         wmt_func.o \
+         wmt_ic_soc.o \
+         wmt_lib.o \
+         wmt_conf.o \
+         btm_core.o \
+         dbg_core.o \
+         psm_core.o \
+         stp_core.o \
+         mtk_wcn_stub_alps.o \
+         wmt_stp_exp.o
+
+endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/btm_core.c b/drivers/misc/mediatek/connectivity/common/conn_soc/core/btm_core.c
new file mode 100644
index 00000000..4946b68
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/btm_core.c
@@ -0,0 +1,1376 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+#include <asm/atomic.h>
+
+#include "osal_typedef.h"
+#include "osal.h"
+#include "stp_dbg.h"
+#include "stp_core.h"
+#include "btm_core.h"
+#include "wmt_plat.h"
+
+#define PFX_BTM                         "[STP-BTM] "
+#define STP_BTM_LOG_LOUD                 4
+#define STP_BTM_LOG_DBG                  3
+#define STP_BTM_LOG_INFO                 2
+#define STP_BTM_LOG_WARN                 1
+#define STP_BTM_LOG_ERR                  0
+
+INT32 gBtmDbgLevel = STP_BTM_LOG_INFO;
+
+#define STP_BTM_LOUD_FUNC(fmt, arg...) \
+do { \
+	if (gBtmDbgLevel >= STP_BTM_LOG_LOUD) \
+		pr_debug(PFX_BTM "%s: "  fmt, __func__ , ##arg); \
+} while (0)
+#define STP_BTM_DBG_FUNC(fmt, arg...) \
+do { \
+	if (gBtmDbgLevel >= STP_BTM_LOG_DBG) \
+		pr_debug(PFX_BTM "%s: "  fmt, __func__ , ##arg); \
+} while (0)
+#define STP_BTM_INFO_FUNC(fmt, arg...) \
+do { \
+	if (gBtmDbgLevel >= STP_BTM_LOG_INFO) \
+		pr_debug(PFX_BTM "[I]%s: "  fmt, __func__ , ##arg); \
+} while (0)
+#define STP_BTM_WARN_FUNC(fmt, arg...) \
+do { \
+	if (gBtmDbgLevel >= STP_BTM_LOG_WARN) \
+		pr_warn(PFX_BTM "[W]%s: "  fmt, __func__ , ##arg); \
+} while (0)
+#define STP_BTM_ERR_FUNC(fmt, arg...) \
+do { \
+	if (gBtmDbgLevel >= STP_BTM_LOG_ERR) \
+		pr_err(PFX_BTM "[E]%s(%d):ERROR! "   fmt, __func__ , __LINE__, ##arg); \
+} while (0)
+#define STP_BTM_TRC_FUNC(f) \
+do { \
+	if (gBtmDbgLevel >= STP_BTM_LOG_DBG) \
+		pr_debug(PFX_BTM "<%s> <%d>\n", __func__, __LINE__); \
+} while (0)
+
+#define ASSERT(expr)
+
+MTKSTP_BTM_T stp_btm_i;
+MTKSTP_BTM_T *stp_btm = &stp_btm_i;
+
+const char *g_btm_op_name[] = {
+	"STP_OPID_BTM_RETRY",
+	"STP_OPID_BTM_RST",
+	"STP_OPID_BTM_DBG_DUMP",
+	"STP_OPID_BTM_DUMP_TIMEOUT",
+	"STP_OPID_BTM_POLL_CPUPCR",
+	"STP_OPID_BTM_PAGED_DUMP",
+	"STP_OPID_BTM_FULL_DUMP",
+	"STP_OPID_BTM_PAGED_TRACE",
+	"STP_OPID_BTM_FORCE_FW_ASSERT",
+#if CFG_WMT_LTE_COEX_HANDLING
+	"STP_OPID_BTM_WMT_LTE_COEX",
+#endif
+	"STP_OPID_BTM_EXIT"
+};
+
+#if 0
+static char *_stp_pkt_type(int type)
+{
+
+	static char s[10];
+
+	switch (type) {
+	case WMT_TASK_INDX:
+		osal_memcpy(s, "WMT", strlen("WMT") + 1);
+		break;
+	case BT_TASK_INDX:
+		osal_memcpy(s, "BT", strlen("BT") + 1);
+		break;
+	case GPS_TASK_INDX:
+		osal_memcpy(s, "GPS", strlen("GPS") + 1);
+		break;
+	case FM_TASK_INDX:
+		osal_memcpy(s, "FM", strlen("FM") + 1);
+		break;
+	default:
+		osal_memcpy(s, "UNKNOWN", strlen("UNKNOWN") + 1);
+		break;
+	}
+
+	return s;
+}
+#endif
+
+static INT32 _stp_btm_put_dump_to_nl(void)
+{
+#define NUM_FETCH_ENTRY 8
+
+	static UINT8 buf[2048];
+	static UINT8 tmp[2048];
+
+	UINT32 buf_len;
+	STP_PACKET_T *pkt;
+	STP_DBG_HDR_T *hdr;
+	INT32 len;
+	INT32 remain = 0, index = 0;
+	INT32 retry = 0, rc = 0, nl_retry = 0;
+
+	STP_BTM_INFO_FUNC("Enter..\n");
+
+	index = 0;
+	tmp[index++] = '[';
+	tmp[index++] = 'M';
+	tmp[index++] = ']';
+
+	do {
+		index = 3;
+		remain = stp_dbg_dmp_out_ex(&buf[0], &buf_len);
+		if (buf_len > 0) {
+			pkt = (STP_PACKET_T *) buf;
+			hdr = &pkt->hdr;
+			len = pkt->hdr.len;
+			osal_memcpy(&tmp[index], &len, 2);
+			index += 2;
+			if (hdr->dbg_type == STP_DBG_FW_DMP) {
+					osal_memcpy(&tmp[index], pkt->raw, len);
+
+				if (len <= 1500) {
+					/* pr_warn("\n%s\n+++\n", tmp); */
+					/* pr_warn("send coredump len:%d\n", len); */
+					/* pr_warn("send coredump:%s\n", tmp); */
+					rc = stp_dbg_nl_send((PINT8)&tmp, 2, len+5);
+
+					while (rc) {
+						nl_retry++;
+					if (nl_retry > 1000)
+							break;
+						STP_BTM_WARN_FUNC
+							("**dump send fails, and retry again.**\n");
+						osal_sleep_ms(3);
+						rc = stp_dbg_nl_send((PINT8)&tmp, 2, len+5);
+					if (!rc)
+							STP_BTM_WARN_FUNC("****retry again ok!**\n");
+						}
+					/* schedule(); */
+				} else {
+						STP_BTM_INFO_FUNC("dump entry length is over long\n");
+						BUG_ON(0);
+				}
+				retry = 0;
+			}
+		} else {
+			retry++;
+			osal_sleep_ms(100);
+		}
+	} while ((remain > 0) || (retry < 2));
+
+	STP_BTM_INFO_FUNC("Exit..\n");
+	return 0;
+}
+
+#define SUB_PKT_SIZE 1024
+#define SUB_PKT_HEADER 5	/*'[M]',3Bytes; len,2Bytes*/
+
+INT32 _stp_btm_put_emi_dump_to_nl(PUINT8 data_buf, INT32 dump_len)
+{
+	static UINT8  tmp[SUB_PKT_SIZE + SUB_PKT_HEADER];
+
+	INT32 remain = dump_len, index = 0;
+	INT32 rc = 0, nl_retry = 0;
+	INT32 len;
+	INT32 offset = 0;
+
+	STP_BTM_INFO_FUNC("Enter..\n");
+
+	if (dump_len > 0) {
+		index = 0;
+		tmp[index++] = '[';
+		tmp[index++] = 'M';
+		tmp[index++] = ']';
+
+		do {
+			index = 3;
+			if (remain >= SUB_PKT_SIZE)
+				len = SUB_PKT_SIZE;
+			else
+				len = remain;
+			remain -= len;
+
+			osal_memcpy(&tmp[index], &len, 2);
+			index += 2;
+			osal_memcpy(&tmp[index], data_buf + offset, len);
+			offset += len;
+			STP_BTM_DBG_FUNC
+				("send %d remain %d\n", len, remain);
+
+			rc = stp_dbg_nl_send((PINT8)&tmp, 2, len + SUB_PKT_HEADER);
+			while (rc) {
+				nl_retry++;
+				if (nl_retry > 1000)
+					break;
+				STP_BTM_WARN_FUNC
+								("**dump send fails, and retry again.**\n");
+					osal_sleep_ms(3);
+					rc = stp_dbg_nl_send((PINT8)&tmp, 2, len + SUB_PKT_HEADER);
+					if (!rc) {
+						STP_BTM_WARN_FUNC
+							("****retry again ok!**\n");
+					}
+				}
+			/* schedule(); */
+		} while (remain > 0);
+	} else
+		STP_BTM_INFO_FUNC("dump entry length is 0\n");
+
+	STP_BTM_INFO_FUNC("Exit..\n");
+	return 0;
+}
+
+static INT32 _stp_btm_put_dump_to_aee(void)
+{
+	static UINT8 buf[2048];
+	static UINT8 tmp[2048];
+
+	UINT32 buf_len;
+	STP_PACKET_T *pkt;
+	STP_DBG_HDR_T *hdr;
+	INT32 remain = 0;
+	INT32 retry = 0;
+	INT32 ret = 0;
+
+	STP_BTM_INFO_FUNC("Enter..\n");
+
+	do {
+		remain = stp_dbg_dmp_out_ex(&buf[0], &buf_len);
+		if (buf_len > 0) {
+			pkt = (STP_PACKET_T *) buf;
+			hdr = &pkt->hdr;
+			if (hdr->dbg_type == STP_DBG_FW_DMP) {
+				memcpy(&tmp[0], pkt->raw, pkt->hdr.len);
+
+				if (pkt->hdr.len <= 1500) {
+					tmp[pkt->hdr.len] = '\n';
+					tmp[pkt->hdr.len + 1] = '\0';
+
+					ret = stp_dbg_aee_send(tmp, pkt->hdr.len, 0);
+				} else {
+					STP_BTM_INFO_FUNC("dump entry length is over long\n");
+					BUG_ON(0);
+				}
+				retry = 0;
+			}
+		} else {
+			retry++;
+			msleep(100);
+		}
+	} while ((remain > 0) || (retry < 2));
+
+	STP_BTM_INFO_FUNC("Exit..\n");
+	return ret;
+}
+
+#if 0
+INT32 _stp_trigger_firmware_assert_via_emi(VOID)
+{
+	PUINT8 p_virtual_addr = NULL;
+	INT32 status = -1;
+	INT32 i = 0, j = 0;
+
+	do {
+		STP_BTM_INFO_FUNC("[Force Assert] stp_trigger_firmware_assert_via_emi -->\n");
+		p_virtual_addr = wmt_plat_get_emi_virt_add(EXP_APMEM_CTRL_HOST_OUTBAND_ASSERT_W1);
+		if (!p_virtual_addr) {
+			STP_BTM_ERR_FUNC("get virtual address fail\n");
+			return -1;
+		}
+
+		CONSYS_REG_WRITE(p_virtual_addr, EXP_APMEM_HOST_OUTBAND_ASSERT_MAGIC_W1);
+		STP_BTM_INFO_FUNC("[Force Assert] stp_trigger_firmware_assert_via_emi <--\n");
+#if 1
+		/* wait for firmware assert */
+		osal_sleep_ms(50);
+		/* if firmware is not assert self, host driver helps it. */
+		do {
+			if (0 != mtk_wcn_stp_coredump_start_get()) {
+				status = 0;
+				break;
+			}
+
+			mtk_wcn_stp_wakeup_consys();
+			STP_BTM_INFO_FUNC("[Force Assert] wakeup consys (%d)\n", i);
+			stp_dbg_poll_cpupcr(5, 1, 1);
+			osal_sleep_ms(5);
+
+			i++;
+			if (i > 20) {
+				i = 0;
+				break;
+			}
+		} while (1);
+#endif
+
+		if (0 != mtk_wcn_stp_coredump_start_get()) {
+			status = 0;
+			break;
+		}
+
+		j++;
+		if (j > 8) {
+			j = 0;
+			break;
+		}
+	} while (1);
+
+	return status;
+}
+#else
+INT32 _stp_trigger_firmware_assert_via_emi(VOID)
+{
+	INT32 status = -1;
+	INT32 j = 0;
+
+	wmt_plat_force_trigger_assert(STP_FORCE_TRG_ASSERT_DEBUG_PIN);
+
+	do {
+		if (0 != mtk_wcn_stp_coredump_start_get()) {
+			status = 0;
+			break;
+		}
+
+		stp_dbg_poll_cpupcr(5, 1, 1);
+		stp_dbg_poll_dmaregs(5, 1);
+		j++;
+		STP_BTM_INFO_FUNC("Wait for assert message (%d)\n", j);
+		osal_sleep_ms(20);
+		if (j > 49) {	/* wait for 1 second */
+			stp_dbg_set_fw_info("host trigger fw assert timeout",
+					    osal_strlen("host trigger fw assert timeout"),
+					    STP_HOST_TRIGGER_ASSERT_TIMEOUT);
+			wcn_core_dump_timeout();	/* trigger collect SYS_FTRACE */
+			break;
+		}
+	} while (1);
+
+	return status;
+}
+#endif
+
+#define COMBO_DUMP2AEE
+#if 1
+#define STP_DBG_PAGED_DUMP_BUFFER_SIZE (32*1024*sizeof(char))
+UINT8 g_paged_dump_buffer[STP_DBG_PAGED_DUMP_BUFFER_SIZE] = { 0 };
+
+#define STP_DBG_PAGED_TRACE_SIZE (2048*sizeof(char))
+UINT8 g_paged_trace_buffer[STP_DBG_PAGED_TRACE_SIZE] = { 0 };
+
+UINT32 g_paged_dump_len = 0;
+UINT32 g_paged_trace_len = 0;
+VOID _stp_dump_emi_dump_buffer(UINT8 *buffer, UINT32 len)
+{
+	UINT32 i = 0;
+
+	if (len > 16)
+		len = 16;
+	for (i = 0; i < len; i++) {
+		if (i % 16 == 0 && i != 0)
+			pr_cont("\n    ");
+
+		if (buffer[i] == ']' || buffer[i] == '[' || buffer[i] == ',')
+			pr_cont("%c", buffer[i]);
+		else
+			pr_cont("0x%02x ", buffer[i]);
+	}
+}
+#endif
+static INT32 _stp_btm_handler(MTKSTP_BTM_T *stp_btm, P_STP_BTM_OP pStpOp)
+{
+	INT32 ret = -1;
+	INT32 dump_sink = 1;	/* core dump target, 0: aee; 1: netlink */
+	INT32 Ret = 0;
+	static UINT32 counter;
+	UINT32 full_dump_left = STP_FULL_DUMP_TIME;
+	UINT32 page_counter = 0;
+	UINT32 packet_num = STP_PAGED_DUMP_TIME_LIMIT/100;
+	UINT32 dump_num = 0;
+	ENUM_STP_FW_ISSUE_TYPE issue_type;
+	P_CONSYS_EMI_ADDR_INFO p_ecsi;
+
+	p_ecsi = wmt_plat_get_emi_phy_add();
+	osal_assert(p_ecsi);
+	if (NULL == pStpOp)
+		return -1;
+
+	switch (pStpOp->opId) {
+	case STP_OPID_BTM_EXIT:
+		/* TODO: clean all up? */
+		ret = 0;
+		break;
+
+		/*tx timeout retry */
+	case STP_OPID_BTM_RETRY:
+		stp_do_tx_timeout();
+		ret = 0;
+
+		break;
+
+		/*whole chip reset */
+	case STP_OPID_BTM_RST:
+		STP_BTM_INFO_FUNC("whole chip reset start!\n");
+		STP_BTM_INFO_FUNC("....+\n");
+		if (stp_btm->wmt_notify) {
+			stp_btm->wmt_notify(BTM_RST_OP);
+			ret = 0;
+		} else {
+			STP_BTM_ERR_FUNC("stp_btm->wmt_notify is NULL.");
+			ret = -1;
+		}
+
+		STP_BTM_INFO_FUNC("whole chip reset end!\n");
+
+		break;
+
+	case STP_OPID_BTM_DBG_DUMP:
+		/*Notify the wmt to get dump data */
+		STP_BTM_DBG_FUNC("wmt dmp notification\n");
+		dump_sink = ((stp_btm->wmt_notify(BTM_GET_AEE_SUPPORT_FLAG) == MTK_WCN_BOOL_TRUE) ? 0 : 1);
+
+		if (dump_sink == 0)
+			_stp_btm_put_dump_to_aee();
+		else if (dump_sink == 1)
+			_stp_btm_put_dump_to_nl();
+		else
+			STP_BTM_ERR_FUNC("unknown sink %d\n", dump_sink);
+
+		break;
+
+	case STP_OPID_BTM_DUMP_TIMEOUT:
+		/* Flush dump data, and reset compressor */
+		STP_BTM_INFO_FUNC("Flush dump data\n");
+		wcn_core_dump_flush(0, MTK_WCN_BOOL_TRUE);
+		break;
+
+	case STP_OPID_BTM_POLL_CPUPCR:
+		do {
+			UINT32 times;
+			UINT32 sleep;
+
+			times = pStpOp->au4OpData[0];
+			sleep = pStpOp->au4OpData[1];
+
+			ret = stp_dbg_poll_cpupcr(times, sleep, 0);
+			ret += stp_dbg_poll_dmaregs(times, sleep);
+		} while (0);
+		break;
+
+	case STP_OPID_BTM_PAGED_DUMP:
+		g_paged_dump_len = 0;
+		issue_type = STP_FW_ASSERT_ISSUE;
+		/*packet number depend on dump_num get from register:0xf0080044 ,support jade*/
+		wcn_core_dump_deinit_gcoredump();
+		dump_num = wmt_plat_get_dump_info(p_ecsi->p_ecso->emi_apmem_ctrl_chip_page_dump_num);
+		if (dump_num != 0) {
+				packet_num = dump_num;
+				STP_BTM_WARN_FUNC("get consys dump num packet_num(%d)\n", packet_num);
+		} else {
+			STP_BTM_ERR_FUNC("can not get consys dump num and default num is 35\n");
+		}
+		Ret = wcn_core_dump_init_gcoredump(packet_num, STP_CORE_DUMP_TIMEOUT);
+		if (Ret) {
+			STP_BTM_ERR_FUNC("core dump init fail\n");
+			break;
+		}
+		wmt_plat_set_host_dump_state(STP_HOST_DUMP_NOT_START);
+		page_counter = 0;
+		do {
+			UINT32 loop_cnt1 = 0;
+			UINT32 loop_cnt2 = 0;
+			ENUM_HOST_DUMP_STATE host_state;
+			ENUM_CHIP_DUMP_STATE chip_state;
+			UINT32 dump_phy_addr = 0;
+			UINT8 *dump_vir_addr = NULL;
+			UINT32 dump_len = 0;
+			UINT32 isEnd = 0;
+
+			host_state = (ENUM_HOST_DUMP_STATE)wmt_plat_get_dump_info(
+				p_ecsi->p_ecso->emi_apmem_ctrl_host_sync_state);
+			if (STP_HOST_DUMP_NOT_START == host_state) {
+				counter++;
+				STP_BTM_INFO_FUNC("counter(%d)\n", counter);
+				osal_sleep_ms(100);
+			} else {
+				counter = 0;
+			}
+			while (1) {
+				chip_state = (ENUM_CHIP_DUMP_STATE)wmt_plat_get_dump_info(
+					p_ecsi->p_ecso->emi_apmem_ctrl_chip_sync_state);
+				if (STP_CHIP_DUMP_PUT_DONE == chip_state) {
+					STP_BTM_INFO_FUNC("chip put done\n");
+					break;
+				}
+				STP_BTM_INFO_FUNC("waiting chip put done\n");
+				STP_BTM_INFO_FUNC("chip_state: %d\n", chip_state);
+				loop_cnt1++;
+				osal_sleep_ms(5);
+
+				if (loop_cnt1 > 10)
+					goto paged_dump_end;
+
+			}
+
+			wmt_plat_set_host_dump_state(STP_HOST_DUMP_GET);
+
+			dump_phy_addr = wmt_plat_get_dump_info(
+				p_ecsi->p_ecso->emi_apmem_ctrl_chip_sync_addr);
+
+			if (!dump_phy_addr) {
+				STP_BTM_ERR_FUNC("get paged dump phy address fail\n");
+				ret = -1;
+				break;
+			}
+
+			dump_vir_addr = wmt_plat_get_emi_virt_add(dump_phy_addr - p_ecsi->emi_phy_addr);
+			if (!dump_vir_addr) {
+				STP_BTM_ERR_FUNC("get paged dump phy address fail\n");
+				ret = -2;
+				break;
+			}
+			dump_len = wmt_plat_get_dump_info(
+				p_ecsi->p_ecso->emi_apmem_ctrl_chip_sync_len);
+			STP_BTM_INFO_FUNC("dump_phy_ddr(%08x),dump_vir_add(0x%p),dump_len(%d)\n",
+				dump_phy_addr, dump_vir_addr, dump_len);
+
+			/*move dump info according to dump_addr & dump_len */
+#if 1
+			osal_memcpy(&g_paged_dump_buffer[0], dump_vir_addr, dump_len);
+			_stp_dump_emi_dump_buffer(&g_paged_dump_buffer[0], dump_len);
+
+			if (0 == page_counter) {	/* do fw assert infor paser in first paged dump */
+				if (1 == stp_dbg_get_host_trigger_assert())
+					issue_type = STP_HOST_TRIGGER_FW_ASSERT;
+
+				ret = stp_dbg_set_fw_info(&g_paged_dump_buffer[0], 512, issue_type);
+				if (ret) {
+					STP_BTM_ERR_FUNC("set fw issue infor fail(%d),maybe fw warm reset...\n", ret);
+					stp_dbg_set_fw_info("Fw Warm reset", osal_strlen("Fw Warm reset"),
+							    STP_FW_WARM_RST_ISSUE);
+				}
+			}
+
+			if (dump_len <= 32 * 1024) {
+				pr_err("g_coredump_mode: %d!\n", g_coredump_mode);
+				if (1 == g_coredump_mode)
+					ret = stp_dbg_aee_send(&g_paged_dump_buffer[0], dump_len, 0);
+				else if	(2 == g_coredump_mode)
+					ret = _stp_btm_put_emi_dump_to_nl(&g_paged_dump_buffer[0], dump_len);
+				else{
+					STP_BTM_INFO_FUNC("coredump is disabled!\n");
+					return 0;
+				}
+				if (ret == 0)
+					STP_BTM_INFO_FUNC("aee send ok!\n");
+				else if (ret == 1)
+					STP_BTM_INFO_FUNC("aee send fisish!\n");
+				else
+					STP_BTM_ERR_FUNC("aee send error!\n");
+			} else
+				STP_BTM_ERR_FUNC("dump len is over than 32K(%d)\n", dump_len);
+
+			g_paged_dump_len += dump_len;
+			STP_BTM_INFO_FUNC("dump len update(%d)\n", g_paged_dump_len);
+#endif
+			wmt_plat_update_host_sync_num();
+			wmt_plat_set_host_dump_state(STP_HOST_DUMP_GET_DONE);
+
+			STP_BTM_INFO_FUNC("host sync num(%d),chip sync num(%d)\n",
+					  wmt_plat_get_dump_info(
+						p_ecsi->p_ecso->emi_apmem_ctrl_host_sync_num),
+					  wmt_plat_get_dump_info(
+						p_ecsi->p_ecso->emi_apmem_ctrl_chip_sync_num));
+
+			page_counter++;
+			STP_BTM_INFO_FUNC("\n\n++ paged dump counter(%d) ++\n\n\n", page_counter);
+
+			while (1) {
+				chip_state = (ENUM_CHIP_DUMP_STATE)wmt_plat_get_dump_info(
+					p_ecsi->p_ecso->emi_apmem_ctrl_chip_sync_state);
+				if (STP_CHIP_DUMP_END == chip_state) {
+					STP_BTM_INFO_FUNC("chip put end\n");
+					wmt_plat_set_host_dump_state(STP_HOST_DUMP_END);
+					break;
+				}
+				STP_BTM_INFO_FUNC("waiting chip put end\n");
+
+				loop_cnt2++;
+				osal_sleep_ms(10);
+
+				if (loop_cnt2 > 10)
+					goto paged_dump_end;
+			}
+
+paged_dump_end:
+			wmt_plat_set_host_dump_state(STP_HOST_DUMP_NOT_START);
+
+			if (counter > packet_num) {
+				isEnd = wmt_plat_get_dump_info(
+					p_ecsi->p_ecso->emi_apmem_ctrl_chip_paded_dump_end);
+
+				if (isEnd) {
+					STP_BTM_INFO_FUNC("paged dump end\n");
+
+					STP_BTM_INFO_FUNC("\n\n paged dump print  ++\n\n");
+					_stp_dump_emi_dump_buffer(&g_paged_dump_buffer[0], g_paged_dump_len);
+					STP_BTM_INFO_FUNC("\n\n paged dump print  --\n\n");
+					STP_BTM_INFO_FUNC("\n\n paged dump size = %d, paged dump page number = %d\n\n",
+							  g_paged_dump_len, page_counter);
+					counter = 0;
+					ret = 0;
+				} else {
+					STP_BTM_ERR_FUNC("paged dump fail\n");
+					wmt_plat_set_host_dump_state(STP_HOST_DUMP_NOT_START);
+					stp_dbg_poll_cpupcr(5, 5, 0);
+					stp_dbg_poll_dmaregs(5, 1);
+					counter = 0;
+					ret = -1;
+				}
+				break;
+			}
+
+		} while (1);
+
+		break;
+
+	case STP_OPID_BTM_FULL_DUMP:
+
+		wmt_plat_set_host_dump_state(STP_HOST_DUMP_NOT_START);
+		do {
+			UINT32 loop_cnt1 = 0;
+			UINT32 loop_cnt2 = 0;
+			ENUM_CHIP_DUMP_STATE chip_state;
+			UINT32 dump_phy_addr = 0;
+			UINT8 *dump_vir_addr = NULL;
+			UINT32 dump_len = 0;
+			UINT32 isFail = 0;
+
+			while (1) {
+				chip_state = (ENUM_CHIP_DUMP_STATE)wmt_plat_get_dump_info(
+						p_ecsi->p_ecso->emi_apmem_ctrl_chip_sync_state);
+				if (STP_CHIP_DUMP_PUT_DONE == chip_state)
+					break;
+
+				loop_cnt1++;
+				osal_sleep_ms(10);
+
+				if (loop_cnt1 > 10) {
+					isFail = 1;
+					goto full_dump_end;
+				}
+			}
+
+			wmt_plat_set_host_dump_state(STP_HOST_DUMP_GET);
+
+			dump_phy_addr = wmt_plat_get_dump_info(p_ecsi->p_ecso->emi_apmem_ctrl_chip_sync_addr);
+			if (!dump_phy_addr) {
+				STP_BTM_ERR_FUNC("get phy dump address fail\n");
+				ret = -1;
+				break;
+			}
+
+			dump_vir_addr = wmt_plat_get_emi_virt_add(dump_phy_addr - p_ecsi->emi_phy_addr);
+			if (!dump_vir_addr) {
+				STP_BTM_ERR_FUNC("get vir dump address fail\n");
+				ret = -2;
+				break;
+			}
+			dump_len = wmt_plat_get_dump_info(p_ecsi->p_ecso->emi_apmem_ctrl_chip_sync_len);
+			/*move dump info according to dump_addr & dump_len */
+			wmt_plat_update_host_sync_num();
+			wmt_plat_set_host_dump_state(STP_HOST_DUMP_GET_DONE);
+
+			STP_BTM_INFO_FUNC("host sync num(%d),chip sync num(%d)\n",
+					  wmt_plat_get_dump_info(
+						p_ecsi->p_ecso->emi_apmem_ctrl_host_sync_num),
+					  wmt_plat_get_dump_info(
+						p_ecsi->p_ecso->emi_apmem_ctrl_chip_sync_num));
+
+			while (1) {
+				chip_state = (ENUM_CHIP_DUMP_STATE)wmt_plat_get_dump_info(
+							p_ecsi->p_ecso->emi_apmem_ctrl_chip_sync_state);
+				if (STP_CHIP_DUMP_END == chip_state) {
+					wmt_plat_set_host_dump_state(STP_HOST_DUMP_END);
+					break;
+				}
+				loop_cnt2++;
+				osal_sleep_ms(10);
+
+				if (loop_cnt2 > 10) {
+					isFail = 1;
+					goto full_dump_end;
+				}
+			}
+			wmt_plat_set_host_dump_state(STP_HOST_DUMP_NOT_START);
+full_dump_end:
+			if (isFail) {
+				STP_BTM_ERR_FUNC("full dump fail\n");
+				wmt_plat_set_host_dump_state(STP_HOST_DUMP_NOT_START);
+				ret = -1;
+				break;
+			}
+		} while (--full_dump_left > 0);
+		if (0 == full_dump_left) {
+			STP_BTM_INFO_FUNC("full dump end\n");
+			ret = 0;
+		}
+		break;
+	case STP_OPID_BTM_PAGED_TRACE:
+		g_paged_trace_len = 0;
+		do {
+			UINT32 ctrl_val = 0;
+			UINT32 loop_cnt1 = 0;
+			UINT32 buffer_start = 0;
+			UINT32 buffer_idx = 0;
+			UINT8 *dump_vir_addr = NULL;
+
+			while (loop_cnt1 < 10) {
+				ctrl_val = wmt_plat_get_dump_info(p_ecsi->p_ecso->emi_apmem_ctrl_state);
+				if (0x8 == ctrl_val)
+					break;
+				osal_sleep_ms(10);
+				loop_cnt1++;
+			}
+
+			if (loop_cnt1 >= 10) {
+				STP_BTM_ERR_FUNC("polling CTRL STATE fail\n");
+				ret = -1;
+				break;
+			}
+
+			buffer_start = wmt_plat_get_dump_info(
+							p_ecsi->p_ecso->emi_apmem_ctrl_chip_print_buff_start);
+			buffer_idx = wmt_plat_get_dump_info(
+							p_ecsi->p_ecso->emi_apmem_ctrl_chip_print_buff_idx);
+			/* buffer_len = buffer_idx - buffer_start; */
+			g_paged_trace_len = buffer_idx;
+			STP_BTM_INFO_FUNC("paged trace buffer addr(%08x),buffer_len(%d)\n", buffer_start, buffer_idx);
+			dump_vir_addr = wmt_plat_get_emi_virt_add(buffer_start - p_ecsi->emi_phy_addr);
+			if (!dump_vir_addr) {
+				STP_BTM_ERR_FUNC("get vir dump address fail\n");
+				ret = -2;
+				break;
+			}
+			osal_memcpy(&g_paged_trace_buffer[0], dump_vir_addr,
+				    buffer_idx < STP_DBG_PAGED_TRACE_SIZE ? buffer_idx : STP_DBG_PAGED_TRACE_SIZE);
+			/*moving paged trace according to buffer_start & buffer_len */
+			do {
+				int i = 0;
+				int dump_len = 0;
+
+				dump_len =
+				    buffer_idx < STP_DBG_PAGED_TRACE_SIZE ? buffer_idx : STP_DBG_PAGED_TRACE_SIZE;
+				pr_warn("\n\n -- paged trace hex output --\n\n");
+				for (i = 0; i < dump_len; i++) {
+					if (i % 16 == 0)
+						pr_cont("\n");
+
+					pr_cont("%02x ", g_paged_trace_buffer[i]);
+				}
+				pr_warn("\n\n -- paged trace ascii output --\n\n");
+				for (i = 0; i < dump_len; i++) {
+					if (i % 64 == 0)
+						pr_cont("\n");
+					pr_cont("%c", g_paged_trace_buffer[i]);
+				}
+			} while (0);
+			/*move parser fw assert infor to paged dump in the one paged dump */
+			/* ret = stp_dbg_set_fw_info(&g_paged_trace_buffer[0],g_paged_trace_len,issue_type); */
+			ret = 0;
+
+		} while (0);
+		mtk_wcn_stp_ctx_restore();
+		break;
+
+#if CFG_WMT_LTE_COEX_HANDLING
+	case STP_OPID_BTM_WMT_LTE_COEX:
+		ret = wmt_idc_msg_to_lte_handing();
+		break;
+#endif
+	default:
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+
+static P_OSAL_OP _stp_btm_get_op(MTKSTP_BTM_T *stp_btm, P_OSAL_OP_Q pOpQ)
+{
+	P_OSAL_OP pOp;
+	/* INT32 ret = 0; */
+
+	if (!pOpQ) {
+		STP_BTM_WARN_FUNC("!pOpQ\n");
+		return NULL;
+	}
+
+	osal_lock_unsleepable_lock(&(stp_btm->wq_spinlock));
+	/* acquire lock success */
+	RB_GET(pOpQ, pOp);
+	osal_unlock_unsleepable_lock(&(stp_btm->wq_spinlock));
+
+	if (!pOp)
+		STP_BTM_WARN_FUNC("RB_GET fail\n");
+
+	return pOp;
+}
+
+static INT32 _stp_btm_put_op(MTKSTP_BTM_T *stp_btm, P_OSAL_OP_Q pOpQ, P_OSAL_OP pOp)
+{
+	INT32 ret;
+
+	if (!pOpQ || !pOp) {
+		STP_BTM_WARN_FUNC("invalid input param: 0x%p, 0x%p\n", pOpQ, pOp);
+		return 0;	/* ;MTK_WCN_BOOL_FALSE; */
+	}
+
+	ret = 0;
+
+	osal_lock_unsleepable_lock(&(stp_btm->wq_spinlock));
+	/* acquire lock success */
+	if (!RB_FULL(pOpQ))
+		RB_PUT(pOpQ, pOp);
+	else
+		ret = -1;
+
+	osal_unlock_unsleepable_lock(&(stp_btm->wq_spinlock));
+
+	if (ret) {
+		STP_BTM_WARN_FUNC("RB_FULL(0x%p) %d ,rFreeOpQ = %p, rActiveOpQ = %p\n",
+			pOpQ,
+			RB_COUNT(pOpQ),
+			&stp_btm->rFreeOpQ,
+			&stp_btm->rActiveOpQ);
+		return 0;
+	}
+	/* STP_BTM_WARN_FUNC("RB_COUNT = %d\n",RB_COUNT(pOpQ)); */
+	return 1;
+
+}
+
+P_OSAL_OP _stp_btm_get_free_op(MTKSTP_BTM_T *stp_btm)
+{
+	P_OSAL_OP pOp;
+
+	if (stp_btm) {
+		pOp = _stp_btm_get_op(stp_btm, &stp_btm->rFreeOpQ);
+		if (pOp)
+			osal_memset(&pOp->op, 0, sizeof(pOp->op));
+
+		return pOp;
+	} else
+		return NULL;
+}
+
+INT32 _stp_btm_put_act_op(MTKSTP_BTM_T *stp_btm, P_OSAL_OP pOp)
+{
+	INT32 bRet = 0;
+	INT32 bCleanup = 0;
+	long wait_ret = -1;
+
+	P_OSAL_SIGNAL pSignal = NULL;
+
+	if (!stp_btm || !pOp) {
+		STP_BTM_ERR_FUNC("Input NULL pointer\n");
+		return bRet;
+	}
+	do {
+		pSignal = &pOp->signal;
+
+		if (pSignal->timeoutValue) {
+			pOp->result = -9;
+			osal_signal_init(&pOp->signal);
+		}
+
+		/* put to active Q */
+		bRet = _stp_btm_put_op(stp_btm, &stp_btm->rActiveOpQ, pOp);
+		if (0 == bRet) {
+			STP_BTM_WARN_FUNC("put active queue fail\n");
+			bCleanup = 1;	/* MTK_WCN_BOOL_TRUE; */
+			break;
+		}
+
+		/* wake up wmtd */
+		osal_trigger_event(&stp_btm->STPd_event);
+
+		if (pSignal->timeoutValue == 0) {
+			bRet = 1;	/* MTK_WCN_BOOL_TRUE; */
+			/* clean it in wmtd */
+			break;
+		}
+
+		/* wait result, clean it here */
+		bCleanup = 1;	/* MTK_WCN_BOOL_TRUE; */
+
+		/* check result */
+		wait_ret = osal_wait_for_signal_timeout(&pOp->signal);
+
+		STP_BTM_DBG_FUNC("wait completion:%ld\n", wait_ret);
+		if (!wait_ret) {
+			STP_BTM_ERR_FUNC("wait completion timeout\n");
+			/* TODO: how to handle it? retry? */
+		} else {
+			if (pOp->result)
+				STP_BTM_WARN_FUNC("op(%d) result:%d\n", pOp->op.opId, pOp->result);
+
+			bRet = (pOp->result) ? 0 : 1;
+		}
+	} while (0);
+
+	if (bCleanup) {
+		/* put Op back to freeQ */
+		_stp_btm_put_op(stp_btm, &stp_btm->rFreeOpQ, pOp);
+	}
+	bRet = (pOp->result) ? 0 : 1;
+	return bRet;
+}
+
+static INT32 _stp_btm_wait_for_msg(void *pvData)
+{
+	MTKSTP_BTM_T *stp_btm = (MTKSTP_BTM_T *) pvData;
+
+	return (!RB_EMPTY(&stp_btm->rActiveOpQ)) || osal_thread_should_stop(&stp_btm->BTMd);
+}
+
+static INT32 _stp_btm_proc(void *pvData)
+{
+	MTKSTP_BTM_T *stp_btm = (MTKSTP_BTM_T *) pvData;
+	P_OSAL_OP pOp;
+	INT32 id;
+	INT32 result;
+
+	if (!stp_btm) {
+		STP_BTM_WARN_FUNC("!stp_btm\n");
+		return -1;
+	}
+
+	for (;;) {
+		pOp = NULL;
+
+		osal_wait_for_event(&stp_btm->STPd_event, _stp_btm_wait_for_msg, (void *)stp_btm);
+
+		if (osal_thread_should_stop(&stp_btm->BTMd)) {
+			STP_BTM_INFO_FUNC("should stop now...\n");
+			/* TODO: clean up active opQ */
+			break;
+		}
+
+		/* get Op from activeQ */
+		pOp = _stp_btm_get_op(stp_btm, &stp_btm->rActiveOpQ);
+
+		if (!pOp) {
+			STP_BTM_WARN_FUNC("get_lxop activeQ fail\n");
+			continue;
+		}
+
+		id = osal_op_get_id(pOp);
+
+		STP_BTM_DBG_FUNC("======> lxop_get_opid = %d, %s, remaining count = *%d*\n",
+				 id, (id >= osal_array_size(g_btm_op_name)) ? ("???") : (g_btm_op_name[id]),
+				 RB_COUNT(&stp_btm->rActiveOpQ));
+
+		if (id >= STP_OPID_BTM_NUM) {
+			STP_BTM_WARN_FUNC("abnormal opid id: 0x%x\n", id);
+			result = -1;
+			goto handler_done;
+		}
+
+		result = _stp_btm_handler(stp_btm, &pOp->op);
+
+handler_done:
+
+		if (result) {
+			STP_BTM_WARN_FUNC("opid id(0x%x)(%s) error(%d)\n", id,
+					  (id >= osal_array_size(g_btm_op_name)) ? ("???") : (g_btm_op_name[id]),
+					  result);
+		}
+
+		if (osal_op_is_wait_for_signal(pOp)) {
+			osal_op_raise_signal(pOp, result);
+		} else {
+			/* put Op back to freeQ */
+			_stp_btm_put_op(stp_btm, &stp_btm->rFreeOpQ, pOp);
+		}
+
+		if (STP_OPID_BTM_EXIT == id) {
+			break;
+		} else if (STP_OPID_BTM_RST == id) {
+			/* prevent multi reset case */
+			stp_btm_reset_btm_wq(stp_btm);
+			mtk_wcn_stp_coredump_start_ctrl(0);
+		}
+	}
+
+	STP_BTM_INFO_FUNC("exits\n");
+
+	return 0;
+};
+
+static inline INT32 _stp_btm_notify_wmt_rst_wq(MTKSTP_BTM_T *stp_btm)
+{
+
+	P_OSAL_OP pOp;
+	INT32 bRet;
+	INT32 retval;
+
+	if (stp_btm == NULL)
+		return STP_BTM_OPERATION_FAIL;
+
+	pOp = _stp_btm_get_free_op(stp_btm);
+	if (!pOp) {
+		STP_BTM_WARN_FUNC("get_free_lxop fail\n");
+		return -1;	/* break; */
+	}
+	pOp->op.opId = STP_OPID_BTM_RST;
+	pOp->signal.timeoutValue = 0;
+	bRet = _stp_btm_put_act_op(stp_btm, pOp);
+	STP_BTM_DBG_FUNC("OPID(%d) type(%zd) bRet(%d)\n\n", pOp->op.opId, pOp->op.au4OpData[0], bRet);
+	retval = (0 == bRet) ? STP_BTM_OPERATION_FAIL : STP_BTM_OPERATION_SUCCESS;
+
+	return retval;
+}
+
+static inline INT32 _stp_btm_notify_stp_retry_wq(MTKSTP_BTM_T *stp_btm)
+{
+
+	P_OSAL_OP pOp;
+	INT32 bRet;
+	INT32 retval;
+
+	if (stp_btm == NULL)
+		return STP_BTM_OPERATION_FAIL;
+
+	pOp = _stp_btm_get_free_op(stp_btm);
+	if (!pOp) {
+		STP_BTM_WARN_FUNC("get_free_lxop fail\n");
+		return -1;	/* break; */
+	}
+	pOp->op.opId = STP_OPID_BTM_RETRY;
+	pOp->signal.timeoutValue = 0;
+	bRet = _stp_btm_put_act_op(stp_btm, pOp);
+	STP_BTM_DBG_FUNC("OPID(%d) type(%zd) bRet(%d)\n\n", pOp->op.opId, pOp->op.au4OpData[0], bRet);
+	retval = (0 == bRet) ? STP_BTM_OPERATION_FAIL : STP_BTM_OPERATION_SUCCESS;
+
+	return retval;
+}
+
+static inline INT32 _stp_btm_notify_coredump_timeout_wq(MTKSTP_BTM_T *stp_btm)
+{
+
+	P_OSAL_OP pOp;
+	INT32 bRet;
+	INT32 retval;
+
+	if (!stp_btm)
+		return STP_BTM_OPERATION_FAIL;
+
+	pOp = _stp_btm_get_free_op(stp_btm);
+	if (!pOp) {
+		STP_BTM_WARN_FUNC("get_free_lxop fail\n");
+		return -1;	/* break; */
+	}
+	pOp->op.opId = STP_OPID_BTM_DUMP_TIMEOUT;
+	pOp->signal.timeoutValue = 0;
+	bRet = _stp_btm_put_act_op(stp_btm, pOp);
+	STP_BTM_DBG_FUNC("OPID(%d) type(%zd) bRet(%d)\n\n", pOp->op.opId, pOp->op.au4OpData[0], bRet);
+	retval = (0 == bRet) ? STP_BTM_OPERATION_FAIL : STP_BTM_OPERATION_SUCCESS;
+
+	return retval;
+}
+
+static inline INT32 _stp_btm_dump_type(MTKSTP_BTM_T *stp_btm, ENUM_STP_BTM_OPID_T opid)
+{
+	P_OSAL_OP pOp;
+	INT32 bRet;
+	INT32 retval;
+
+	pOp = _stp_btm_get_free_op(stp_btm);
+	if (!pOp) {
+		STP_BTM_WARN_FUNC("get_free_lxop fail\n");
+		return -1;	/* break; */
+	}
+
+	pOp->op.opId = opid;
+	pOp->signal.timeoutValue = 0;
+	bRet = _stp_btm_put_act_op(stp_btm, pOp);
+	STP_BTM_DBG_FUNC("OPID(%d) type(%zd) bRet(%d)\n\n", pOp->op.opId, pOp->op.au4OpData[0], bRet);
+	retval = (0 == bRet) ? STP_BTM_OPERATION_FAIL : STP_BTM_OPERATION_SUCCESS;
+
+	return retval;
+}
+
+static inline INT32 _stp_btm_notify_wmt_dmp_wq(MTKSTP_BTM_T *stp_btm)
+{
+
+	INT32 retval;
+#if 0
+	UINT32 dump_type;
+	UINT8 *virtual_addr = NULL;
+#endif
+	if (stp_btm == NULL)
+		return STP_BTM_OPERATION_FAIL;
+
+#if 1				/* Paged dump */
+	STP_BTM_INFO_FUNC("paged dump start++\n");
+	retval = _stp_btm_dump_type(stp_btm, STP_OPID_BTM_PAGED_DUMP);
+	if (retval)
+		STP_BTM_ERR_FUNC("paged dump fail\n");
+#else
+	virtual_addr = wmt_plat_get_emi_virt_add(EXP_APMEM_CTRL_CHIP_SYNC_ADDR);
+	if (!virtual_addr) {
+		STP_BTM_ERR_FUNC("get dump type virtual addr fail\n");
+		return -1;
+	}
+	dump_type = CONSYS_REG_READ(virtual_addr);
+	STP_BTM_INFO_FUNC("dump type:%08x\n", dump_type);
+
+	if ((dump_type & 0xfffff) == (CONSYS_PAGED_DUMP_START_ADDR & 0xfffff)) {
+		STP_BTM_INFO_FUNC("do paged dump\n");
+		retval = _stp_btm_dump_type(stp_btm, STP_OPID_BTM_PAGED_DUMP);
+		if (retval) {
+			STP_BTM_ERR_FUNC("paged dump fail,do full dump\n");
+			_stp_btm_dump_type(stp_btm, STP_OPID_BTM_FULL_DUMP);
+		}
+	} else if ((dump_type & 0xfffff) == (CONSYS_FULL_DUMP_START_ADDR & 0xfffff)) {
+		STP_BTM_INFO_FUNC("do full dump\n");
+		retval = _stp_btm_dump_type(stp_btm, STP_OPID_BTM_FULL_DUMP);
+	} else {
+		STP_BTM_INFO_FUNC("do normal dump\n");
+		retval = _stp_btm_dump_type(stp_btm, STP_OPID_BTM_DBG_DUMP);
+	}
+#endif
+
+	return retval;
+}
+
+static inline INT32 _stp_notify_btm_poll_cpupcr(MTKSTP_BTM_T *stp_btm, UINT32 times, UINT32 sleep)
+{
+
+	P_OSAL_OP pOp;
+	INT32 bRet;
+	INT32 retval;
+
+	if (stp_btm == NULL)
+		return STP_BTM_OPERATION_FAIL;
+
+	pOp = _stp_btm_get_free_op(stp_btm);
+	if (!pOp) {
+		/* STP_BTM_WARN_FUNC("get_free_lxop fail\n"); */
+		return -1;	/* break; */
+	}
+	pOp->op.opId = STP_OPID_BTM_POLL_CPUPCR;
+	pOp->signal.timeoutValue = 0;
+	pOp->op.au4OpData[0] = times;
+	pOp->op.au4OpData[1] = sleep;
+	bRet = _stp_btm_put_act_op(stp_btm, pOp);
+	STP_BTM_DBG_FUNC("OPID(%d) type(%zd) bRet(%d)\n\n", pOp->op.opId, pOp->op.au4OpData[0], bRet);
+	retval = (0 == bRet) ? STP_BTM_OPERATION_FAIL : STP_BTM_OPERATION_SUCCESS;
+
+	return retval;
+}
+
+static inline INT32 _stp_btm_notify_wmt_trace_wq(MTKSTP_BTM_T *stp_btm)
+{
+	P_OSAL_OP pOp;
+	INT32 bRet;
+	INT32 retval;
+
+	if (stp_btm == NULL)
+		return STP_BTM_OPERATION_FAIL;
+
+	pOp = _stp_btm_get_free_op(stp_btm);
+	if (!pOp) {
+		/* STP_BTM_WARN_FUNC("get_free_lxop fail\n"); */
+		return -1;	/* break; */
+	}
+	pOp->op.opId = STP_OPID_BTM_PAGED_TRACE;
+	pOp->signal.timeoutValue = 0;
+	bRet = _stp_btm_put_act_op(stp_btm, pOp);
+	STP_BTM_DBG_FUNC("OPID(%d) type(%zd) bRet(%d)\n\n", pOp->op.opId, pOp->op.au4OpData[0], bRet);
+	retval = (0 == bRet) ? STP_BTM_OPERATION_FAIL : STP_BTM_OPERATION_SUCCESS;
+
+	return retval;
+}
+
+static inline INT32 _stp_btm_do_fw_assert_via_emi(MTKSTP_BTM_T *stp_btm)
+{
+	INT32 ret = -1;
+
+	ret = _stp_trigger_firmware_assert_via_emi();
+
+	return ret;
+
+}
+
+INT32 stp_btm_notify_wmt_rst_wq(MTKSTP_BTM_T *stp_btm)
+{
+	return _stp_btm_notify_wmt_rst_wq(stp_btm);
+}
+
+INT32 stp_btm_notify_stp_retry_wq(MTKSTP_BTM_T *stp_btm)
+{
+	return _stp_btm_notify_stp_retry_wq(stp_btm);
+}
+
+INT32 stp_btm_notify_coredump_timeout_wq(MTKSTP_BTM_T *stp_btm)
+{
+	return _stp_btm_notify_coredump_timeout_wq(stp_btm);
+}
+
+INT32 stp_btm_notify_wmt_dmp_wq(MTKSTP_BTM_T *stp_btm)
+{
+	return _stp_btm_notify_wmt_dmp_wq(stp_btm);
+}
+
+INT32 stp_btm_notify_wmt_trace_wq(MTKSTP_BTM_T *stp_btm)
+{
+	return _stp_btm_notify_wmt_trace_wq(stp_btm);
+}
+
+INT32 stp_notify_btm_poll_cpupcr(MTKSTP_BTM_T *stp_btm, UINT32 times, UINT32 sleep)
+{
+	return _stp_notify_btm_poll_cpupcr(stp_btm, times, sleep);
+}
+
+INT32 stp_notify_btm_poll_cpupcr_ctrl(UINT32 en)
+{
+	return stp_dbg_poll_cuppcr_ctrl(en);
+}
+
+INT32 stp_notify_btm_do_fw_assert_via_emi(MTKSTP_BTM_T *stp_btm)
+{
+	INT32 ret = -1;
+#if BTIF_RXD_BE_BLOCKED_DETECT
+	if (is_btif_rxd_be_blocked())
+		ret = wcn_btif_rxd_blocked_collect_ftrace();	/* trigger collect SYS_FTRACE */
+	else
+#endif
+		ret = _stp_btm_do_fw_assert_via_emi(stp_btm);
+	return ret;
+}
+
+#if CFG_WMT_LTE_COEX_HANDLING
+
+static inline INT32 _stp_notify_btm_handle_wmt_lte_coex(MTKSTP_BTM_T *stp_btm)
+{
+	P_OSAL_OP pOp;
+	INT32 bRet;
+	INT32 retval;
+
+	if (stp_btm == NULL)
+		return STP_BTM_OPERATION_FAIL;
+
+	pOp = _stp_btm_get_free_op(stp_btm);
+	if (!pOp) {
+		/* STP_BTM_WARN_FUNC("get_free_lxop fail\n"); */
+		return -1;	/* break; */
+	}
+	pOp->op.opId = STP_OPID_BTM_WMT_LTE_COEX;
+	pOp->signal.timeoutValue = 0;
+	bRet = _stp_btm_put_act_op(stp_btm, pOp);
+	STP_BTM_DBG_FUNC("OPID(%d) type(%zd) bRet(%d)\n\n", pOp->op.opId, pOp->op.au4OpData[0], bRet);
+	retval = (0 == bRet) ? STP_BTM_OPERATION_FAIL : STP_BTM_OPERATION_SUCCESS;
+
+	return retval;
+}
+
+INT32 stp_notify_btm_handle_wmt_lte_coex(MTKSTP_BTM_T *stp_btm)
+{
+	return _stp_notify_btm_handle_wmt_lte_coex(stp_btm);
+}
+
+#endif
+MTKSTP_BTM_T *stp_btm_init(void)
+{
+	INT32 i = 0x0;
+	INT32 ret = -1;
+
+	osal_unsleepable_lock_init(&stp_btm->wq_spinlock);
+	osal_event_init(&stp_btm->STPd_event);
+	stp_btm->wmt_notify = wmt_lib_btm_cb;
+
+	RB_INIT(&stp_btm->rFreeOpQ, STP_BTM_OP_BUF_SIZE);
+	RB_INIT(&stp_btm->rActiveOpQ, STP_BTM_OP_BUF_SIZE);
+
+	/* Put all to free Q */
+	for (i = 0; i < STP_BTM_OP_BUF_SIZE; i++) {
+		osal_signal_init(&(stp_btm->arQue[i].signal));
+		_stp_btm_put_op(stp_btm, &stp_btm->rFreeOpQ, &(stp_btm->arQue[i]));
+	}
+
+	/*Generate PSM thread, to servie STP-CORE for packet retrying and core dump receiving */
+	stp_btm->BTMd.pThreadData = (VOID *) stp_btm;
+	stp_btm->BTMd.pThreadFunc = (VOID *) _stp_btm_proc;
+	osal_memcpy(stp_btm->BTMd.threadName, BTM_THREAD_NAME, osal_strlen(BTM_THREAD_NAME));
+
+	ret = osal_thread_create(&stp_btm->BTMd);
+	if (ret < 0) {
+		STP_BTM_ERR_FUNC("osal_thread_create fail...\n");
+		goto ERR_EXIT1;
+	}
+
+	/* Start STPd thread */
+	ret = osal_thread_run(&stp_btm->BTMd);
+	if (ret < 0) {
+		STP_BTM_ERR_FUNC("osal_thread_run FAILS\n");
+		goto ERR_EXIT1;
+	}
+
+	return stp_btm;
+
+ERR_EXIT1:
+
+	return NULL;
+
+}
+
+INT32 stp_btm_deinit(MTKSTP_BTM_T *stp_btm)
+{
+
+	INT32 ret = -1;
+
+	STP_BTM_INFO_FUNC("btm deinit\n");
+
+	if (!stp_btm)
+		return STP_BTM_OPERATION_FAIL;
+
+	ret = osal_thread_destroy(&stp_btm->BTMd);
+	if (ret < 0) {
+		STP_BTM_ERR_FUNC("osal_thread_destroy FAILS\n");
+		return STP_BTM_OPERATION_FAIL;
+	}
+
+	return STP_BTM_OPERATION_SUCCESS;
+}
+
+INT32 stp_btm_reset_btm_wq(MTKSTP_BTM_T *stp_btm)
+{
+	UINT32 i = 0;
+
+	osal_lock_unsleepable_lock(&(stp_btm->wq_spinlock));
+	RB_INIT(&stp_btm->rFreeOpQ, STP_BTM_OP_BUF_SIZE);
+	RB_INIT(&stp_btm->rActiveOpQ, STP_BTM_OP_BUF_SIZE);
+	osal_unlock_unsleepable_lock(&(stp_btm->wq_spinlock));
+	/* Put all to free Q */
+	for (i = 0; i < STP_BTM_OP_BUF_SIZE; i++) {
+		osal_signal_init(&(stp_btm->arQue[i].signal));
+		_stp_btm_put_op(stp_btm, &stp_btm->rFreeOpQ, &(stp_btm->arQue[i]));
+	}
+
+	return 0;
+}
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/dbg_core.c b/drivers/misc/mediatek/connectivity/common/conn_soc/core/dbg_core.c
new file mode 100644
index 00000000..246448b
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/dbg_core.c
@@ -0,0 +1,13 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/btm_core.h b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/btm_core.h
new file mode 100644
index 00000000..9a429b4
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/btm_core.h
@@ -0,0 +1,133 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _BTM_CORE_H
+#define _BTM_CORE_H
+
+#include "osal_typedef.h"
+#include "osal.h"
+#include "stp_wmt.h"
+#include "wmt_plat.h"
+#include "wmt_idc.h"
+#include "mtk_btif_exp.h"
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+#define STP_BTM_OPERATION_FAIL    (-1)
+#define STP_BTM_OPERATION_SUCCESS (0)
+
+#define STP_BTM_OP_BUF_SIZE (64)
+
+#define BTM_THREAD_NAME "mtk_stp_btm"
+
+#define STP_PAGED_DUMP_TIME_LIMIT 3500
+#define STP_FULL_DUMP_TIME 3
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+typedef enum _ENUM_STP_BTM_OPID_T {
+	STP_OPID_BTM_RETRY = 0x0,
+	STP_OPID_BTM_RST = 0x1,
+	STP_OPID_BTM_DBG_DUMP = 0x2,
+	STP_OPID_BTM_DUMP_TIMEOUT = 0x3,
+	STP_OPID_BTM_POLL_CPUPCR = 0x4,
+	STP_OPID_BTM_PAGED_DUMP = 0x5,
+	STP_OPID_BTM_FULL_DUMP = 0x6,
+	STP_OPID_BTM_PAGED_TRACE = 0x7,
+	STP_OPID_BTM_FORCE_FW_ASSERT = 0x8,
+#if CFG_WMT_LTE_COEX_HANDLING
+	STP_OPID_BTM_WMT_LTE_COEX = 0x9,
+#endif
+	STP_OPID_BTM_EXIT,
+	STP_OPID_BTM_NUM
+} ENUM_STP_BTM_OPID_T, *P_ENUM_STP_BTM_OPID_T;
+
+typedef OSAL_OP_DAT STP_BTM_OP;
+typedef P_OSAL_OP_DAT P_STP_BTM_OP;
+
+typedef struct mtk_stp_btm {
+	OSAL_THREAD BTMd;	/* main thread (wmtd) handle */
+	OSAL_EVENT STPd_event;
+	OSAL_UNSLEEPABLE_LOCK wq_spinlock;
+
+	OSAL_OP_Q rFreeOpQ;	/* free op queue */
+	OSAL_OP_Q rActiveOpQ;	/* active op queue */
+	OSAL_OP arQue[STP_BTM_OP_BUF_SIZE];	/* real op instances */
+
+	/*wmt_notify */
+	INT32 (*wmt_notify)(MTKSTP_BTM_WMT_OP_T);
+} MTKSTP_BTM_T;
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+INT32 stp_btm_notify_wmt_rst_wq(MTKSTP_BTM_T *stp_btm);
+INT32 stp_btm_notify_stp_retry_wq(MTKSTP_BTM_T *stp_btm);
+INT32 stp_btm_notify_coredump_timeout_wq(MTKSTP_BTM_T *stp_btm);
+INT32 stp_btm_notify_wmt_dmp_wq(MTKSTP_BTM_T *stp_btm);
+INT32 stp_btm_deinit(MTKSTP_BTM_T *stp_btm);
+INT32 stp_btm_reset_btm_wq(MTKSTP_BTM_T *stp_btm);
+INT32 stp_notify_btm_poll_cpupcr(MTKSTP_BTM_T *stp_btm, UINT32 times, UINT32 sleep);
+INT32 stp_notify_btm_poll_cpupcr_ctrl(UINT32 en);
+INT32 stp_btm_notify_wmt_trace_wq(MTKSTP_BTM_T *stp_btm);
+INT32 stp_notify_btm_do_fw_assert_via_emi(MTKSTP_BTM_T *stp_btm);
+INT32 stp_notify_btm_handle_wmt_lte_coex(MTKSTP_BTM_T *stp_btm);
+INT32 wcn_psm_flag_trigger_collect_ftrace(void);
+#if BTIF_RXD_BE_BLOCKED_DETECT
+INT32 wcn_btif_rxd_blocked_collect_ftrace(void);
+MTK_WCN_BOOL is_btif_rxd_be_blocked(void);
+#endif
+MTKSTP_BTM_T *stp_btm_init(void);
+extern unsigned int g_coredump_mode;
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/dbg_core.h b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/dbg_core.h
new file mode 100644
index 00000000..d8c6ebe
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/dbg_core.h
@@ -0,0 +1,69 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _DBG_CORE_H
+#define _DBG_CORE_H
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/psm_core.h b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/psm_core.h
new file mode 100644
index 00000000..fe92f25
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/psm_core.h
@@ -0,0 +1,251 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _PSM_CORE_H
+#define _PSM_CORE_H
+
+#include "osal_typedef.h"
+#include "osal.h"
+#include "stp_wmt.h"
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+#define PFX_PSM                         "[STP-PSM] "
+#define STP_PSM_LOG_LOUD                 4
+#define STP_PSM_LOG_DBG                  3
+#define STP_PSM_LOG_INFO                 2
+#define STP_PSM_LOG_WARN                 1
+#define STP_PSM_LOG_ERR                  0
+
+#define ASSERT(expr)
+#define STP_PSM_FIFO_SIZE  0x2000	/* 8kbytes */
+#define STP_PSM_TX_SIZE    0x800	/* 2kbytes */
+
+#define STP_PSM_OPERATION_FAIL    (-1)
+#define STP_PSM_OPERATION_SUCCESS (0)
+
+#define STP_PSM_PACKET_SIZE_MAX (2000)
+
+#define PSM_HANDLING 127
+
+#define STP_PSM_WMT_PS_TASK_HANDLING_TIME  30	/* 20 milli-seconds */
+#define STP_PSM_IDLE_TIME_SLEEP           30	/* temporary for stress testing */
+#define STP_PSM_IDLE_TIME_SLEEP_1000           1000	/* for high speed transmission e.g. BT OPP*/
+#define STP_PSM_SDIO_IDLE_TIME_SLEEP           100	/* temporary for SDIO stress testing */
+#define STP_PSM_WAIT_EVENT_TIMEOUT        6000
+#if 0
+#define STP_PSM_WMT_EVENT_SLEEP_EN                    (0x1UL << 0)
+#define STP_PSM_WMT_EVENT_WAKEUP_EN                   (0x1UL << 1)
+#define STP_PSM_BLOCK_DATA_EN                         (0x1UL << 2)
+#define STP_PSM_WMT_EVENT_DISABLE_MONITOR             (0x1UL << 3)
+#define STP_PSM_WMT_EVENT_ROLL_BACK_EN                (0x1UL << 4)
+#define STP_PSM_RESET_EN                              (0x1UL << 5)
+#define STP_PSM_WMT_EVENT_HOST_WAKEUP_EN                    (0x1UL << 6)
+#define STP_PSM_WMT_EVENT_DISABLE_MONITOR_TX_HIGH_DENSITY   (0x1UL << 7)
+#define STP_PSM_WMT_EVENT_DISABLE_MONITOR_RX_HIGH_DENSITY   (0x1UL << 8)
+#endif
+
+#define STP_PSM_WMT_EVENT_SLEEP_EN                    (0)
+#define STP_PSM_WMT_EVENT_WAKEUP_EN                   (1)
+#define STP_PSM_BLOCK_DATA_EN                         (2)
+#define STP_PSM_WMT_EVENT_DISABLE_MONITOR             (3)
+#define STP_PSM_WMT_EVENT_ROLL_BACK_EN                (4)
+#define STP_PSM_RESET_EN                              (5)
+#define STP_PSM_WMT_EVENT_HOST_WAKEUP_EN                    (6)
+#define STP_PSM_WMT_EVENT_DISABLE_MONITOR_TX_HIGH_DENSITY   (7)
+#define STP_PSM_WMT_EVENT_DISABLE_MONITOR_RX_HIGH_DENSITY   (8)
+
+#define STP_PSM_DBG_SIZE (16)
+
+/* OP command ring buffer : must be power of 2 */
+#define STP_OP_BUF_SIZE (16)
+
+#define PSM_THREAD_NAME "mtk_stp_psm"
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+typedef enum {
+	ACT = 0,
+	ACT_INACT,
+	INACT,
+	INACT_ACT,
+	STP_PSM_MAX_STATE,
+} MTKSTP_PSM_STATE_T;
+
+typedef enum _ENUM_STP_OPID_T {
+	STP_OPID_PSM_SLEEP = 0,
+	STP_OPID_PSM_WAKEUP,
+	STP_OPID_PSM_HOST_AWAKE,
+	STP_OPID_PSM_EXIT,
+	STP_OPID_PSM_NUM,
+	STP_OPID_PSM_INALID = STP_OPID_PSM_NUM,
+} ENUM_STP_OPID_T, *P_ENUM_STP_OPID_T;
+
+typedef enum {
+	MON = 0,
+	UNMON,
+} MTKSTP_PSM_MONSTATE_T;
+
+typedef INT32(*wmt_notify_t) (MTKSTP_PSM_ACTION_T action);
+typedef INT32(*stp_tx_cb_t) (unsigned char *buffer, UINT32 length, UINT8 type);
+
+typedef OSAL_OP_DAT STP_OP;
+typedef P_OSAL_OP_DAT P_STP_OP;
+
+typedef struct mtk_stp_psm {
+	OSAL_THREAD PSMd;	/* main thread (wmtd) handle */
+	OSAL_EVENT STPd_event;
+
+	OSAL_OP_Q rFreeOpQ;	/* free op queue */
+	OSAL_OP_Q rActiveOpQ;	/* active op queue */
+	OSAL_OP arQue[STP_OP_BUF_SIZE];	/* real op instances */
+
+	/* OSAL_OP                 current_active_op; */
+	/* P_OSAL_OP               current_active_op; */
+	UINT32 last_active_opId;
+	MTKSTP_PSM_STATE_T work_state;	/*working state */
+	OSAL_BIT_OP_VAR flag;
+
+	/* in normal cases, sleep op is always enabled;
+	* but in error cases, we can't execute sleep cmd,
+	* Eg: FW assert, core dump
+	*/
+	INT32 sleep_en;
+
+/* OSAL_UNSLEEPABLE_LOCK   flagSpinlock; */
+	INT32 idle_time_to_sleep;
+	OSAL_WAKE_LOCK wake_lock;
+	OSAL_TIMER psm_timer;	/*monitor if active */
+	OSAL_EVENT wait_wmt_q;
+	OSAL_FIFO hold_fifo;
+	OSAL_SLEEPABLE_LOCK hold_fifo_spinlock_global;
+	OSAL_UNSLEEPABLE_LOCK wq_spinlock;
+	OSAL_SLEEPABLE_LOCK stp_psm_lock;
+	INT32 (*wmt_notify)(MTKSTP_PSM_ACTION_T action);
+	INT32 (*stp_tx_cb)(unsigned char *buffer, UINT32 length, UINT8 type);
+
+	MTK_WCN_BOOL (*is_wmt_quick_ps_support)(VOID);
+	UINT8 out_buf[STP_PSM_TX_SIZE];
+} MTKSTP_PSM_T;
+
+typedef struct {
+	UINT32 prev_flag;
+	UINT32 cur_flag;
+	UINT32 line_num;
+	UINT32 package_no;
+	UINT32 sec;
+	UINT32 usec;
+	UINT32 pid;
+} STP_PSM_ENTRY_T;
+
+typedef struct stp_psm_record {
+	STP_PSM_ENTRY_T queue[STP_PSM_DBG_SIZE];
+	UINT32 in;
+	UINT32 out;
+	UINT32 size;
+	OSAL_UNSLEEPABLE_LOCK lock;
+} STP_PSM_RECORD_T;
+
+typedef struct stp_psm_opid_record {
+	STP_PSM_ENTRY_T queue[STP_PSM_DBG_SIZE];
+	UINT32 in;
+	UINT32 out;
+	UINT32 size;
+	OSAL_UNSLEEPABLE_LOCK lock;
+} STP_PSM_OPID_RECORD, *P_STP_PSM_OPID_RECORD;
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+#define PSM_USE_COUNT_PACKAGE 0
+
+#if PSM_USE_COUNT_PACKAGE
+#define MTK_COMBO_PSM_RX_TH_DEFAULT (1600)
+#define MTK_COMBO_PSM_TX_TH_DEFAULT (300)
+INT32 stp_psm_disable_by_tx_rx_density(MTKSTP_PSM_T *stp_psm, INT32 dir);
+#else
+#define SAMPLE_DURATION 1	/*1 second */
+#define RTX_SPEED_THRESHOLD     50000	/*50KB/s */
+INT32 stp_psm_disable_by_tx_rx_density(MTKSTP_PSM_T *stp_psm, INT32 dir, INT32 length);
+#endif
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+/*stp-psm external function*/
+INT32 stp_psm_notify_stp(MTKSTP_PSM_T *stp_psm, const MTKSTP_PSM_ACTION_T action);
+INT32 stp_psm_notify_wmt_wakeup(MTKSTP_PSM_T *stp_psm);
+INT32 stp_psm_notify_wmt_sleep(MTKSTP_PSM_T *stp_psm);
+
+INT32 stp_psm_start_monitor(MTKSTP_PSM_T *stp_psm);
+INT32 stp_psm_is_to_block_traffic(MTKSTP_PSM_T *stp_psm);
+INT32 stp_psm_is_disable(MTKSTP_PSM_T *stp_psm);
+INT32 stp_psm_has_pending_data(MTKSTP_PSM_T *stp_psm);
+INT32 stp_psm_release_data(MTKSTP_PSM_T *stp_psm);
+INT32 stp_psm_hold_data(MTKSTP_PSM_T *stp_psm, const UINT8 *buffer, const UINT32 len, const UINT8 type);
+INT32 stp_psm_do_wakeup(MTKSTP_PSM_T *stp_psm);
+INT32 stp_psm_reset(MTKSTP_PSM_T *stp_psm);
+INT32 stp_psm_disable(MTKSTP_PSM_T *stp_psm);
+INT32 stp_psm_enable(MTKSTP_PSM_T *stp_psm, INT32 idle_time_to_sleep);
+struct mtk_stp_psm *stp_psm_init(void);
+INT32 stp_psm_deinit(MTKSTP_PSM_T *stp_psm);
+MTK_WCN_BOOL mtk_wcn_stp_psm_dbg_level(UINT32 dbglevel);
+INT32 stp_psm_sleep_for_thermal(MTKSTP_PSM_T *stp_psm);
+INT32 stp_psm_thread_lock_aquire(MTKSTP_PSM_T *stp_psm);
+INT32 stp_psm_thread_lock_release(MTKSTP_PSM_T *stp_psm);
+INT32 stp_psm_set_state(MTKSTP_PSM_T *stp_psm, MTKSTP_PSM_STATE_T state);
+MTK_WCN_BOOL stp_psm_is_quick_ps_support(VOID);
+
+INT32 stp_psm_set_sleep_enable(MTKSTP_PSM_T *stp_psm);
+INT32 stp_psm_set_sleep_disable(MTKSTP_PSM_T *stp_psm);
+INT32 stp_psm_check_sleep_enable(MTKSTP_PSM_T *stp_psm);
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/stp_core.h b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/stp_core.h
new file mode 100644
index 00000000..eaa5ce7
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/stp_core.h
@@ -0,0 +1,629 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _STP_CORE_H
+#define _STP_CORE_H
+
+#include "osal_typedef.h"
+#include "osal.h"
+#include "stp_exp.h"
+#include "psm_core.h"
+#include "btm_core.h"
+#include "stp_btif.h"
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+#define CFG_STP_CORE_CTX_SPIN_LOCK (0)
+
+#define WMT_LTE_COEX_FLAG (0x16)
+
+/*configure using SPINLOCK or just mutex for STP-CORE tx*/
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+#define CONFIG_POWER_SAVING_SUPPORT
+
+#ifdef PFX
+#undef PFX
+#endif
+#define PFX                         "[STP] "
+
+#define STP_LOG_DBG                  4
+#define STP_LOG_PKHEAD               3
+#define STP_LOG_INFO                 2
+#define STP_LOG_WARN                 1
+#define STP_LOG_ERR                  0
+
+extern unsigned int gStpDbgLvl;
+
+#define STP_DBG_FUNC(fmt, arg...)\
+do { \
+	if (gStpDbgLvl >= STP_LOG_DBG) \
+		osal_dbg_print(PFX "%s: "  fmt, __func__ , ##arg); \
+} while (0)
+#define STP_INFO_FUNC(fmt, arg...) \
+do { \
+	if (gStpDbgLvl >= STP_LOG_INFO) \
+		osal_dbg_print(PFX "%s:[I] "  fmt, __func__ , ##arg); \
+} while (0)
+#define STP_WARN_FUNC(fmt, arg...) \
+do { \
+	if (gStpDbgLvl >= STP_LOG_WARN) \
+		osal_warn_print(PFX "%s:[W] "  fmt, __func__ , ##arg); \
+} while (0)
+#define STP_ERR_FUNC(fmt, arg...) \
+do { \
+	if (gStpDbgLvl >= STP_LOG_ERR) \
+		osal_err_print(PFX "%s:[E] "   fmt, __func__ , ##arg); \
+} while (0)
+#define STP_TRC_FUNC(f) \
+do { \
+	if (gStpDbgLvl >= STP_LOG_DBG) \
+		osal_dbg_print(PFX "<%s> <%d>\n", __func__, __LINE__); \
+} while (0)
+
+#define STP_DUMP_PACKET_HEAD(a, b, c) \
+do { \
+	if (gStpDbgLvl >= STP_LOG_PKHEAD) \
+		stp_dump_data(a, b, c); \
+} while (0)
+#define STP_TRACE_FUNC(fmt, arg...) \
+do { \
+	if (gStpDbgLvl >= STP_LOG_DBG) \
+		osal_dbg_print(PFX "%s: "  fmt, __func__ , ##arg); \
+} while (0)
+
+#define STP_MODE_BIT(x) (0x1UL << x)
+#define MTKSTP_UART_FULL_MODE	  STP_MODE_BIT(0)
+#define MTKSTP_UART_MAND_MODE	  STP_MODE_BIT(1)
+#define MTKSTP_BTIF_FULL_MODE	  STP_MODE_BIT(2)
+#define MTKSTP_BTIF_MAND_MODE	  STP_MODE_BIT(3)
+#define MTKSTP_SDIO_MODE          STP_MODE_BIT(4)
+
+#define MTKSTP_BUFFER_SIZE  (16384)
+
+/*To check function driver's status by the the interface*/
+/*Operation definition*/
+#define OP_FUNCTION_ACTIVE         0
+
+/*Driver's status*/
+#define STATUS_OP_INVALID          0
+#define STATUS_FUNCTION_INVALID    1
+
+#define STATUS_FUNCTION_ACTIVE     31
+#define STATUS_FUNCTION_INACTIVE   32
+
+#define MTKSTP_CRC_SIZE     (2)
+#define MTKSTP_HEADER_SIZE  (4)
+#define MTKSTP_SEQ_SIZE     (8)
+
+/*#define MTKSTP_WINSIZE      (4)*/
+#define MTKSTP_WINSIZE      (7)
+#define MTKSTP_TX_TIMEOUT   (180)	/*TODO: Baudrate to decide this */
+#define MTKSTP_RETRY_LIMIT  (10)
+
+#define INDEX_INC(idx)  \
+{                       \
+	idx++;              \
+	idx &= 0x7;         \
+}
+
+#define INDEX_DEC(idx)  \
+{                       \
+	idx--;              \
+	idx &= 0x7;         \
+}
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+typedef INT32(*IF_TX) (const PUINT8 data, const UINT32 size, PUINT32 written_size);
+/* event/signal */
+typedef INT32(*EVENT_SET) (UINT8 function_type);
+typedef INT32(*EVENT_TX_RESUME) (UINT8 winspace);
+typedef INT32(*FUNCTION_STATUS) (UINT8 type, UINT8 op);
+typedef INT32(*WMT_NOTIFY_FUNC_T) (UINT32 action);
+typedef INT32(*BTM_NOTIFY_WMT_FUNC_T) (INT32);
+
+#if CFG_STP_CORE_CTX_SPIN_LOCK
+typedef OSAL_UNSLEEPABLE_LOCK STP_CTX_LOCK, *PSTP_CTX_LOCK;
+#else
+typedef OSAL_SLEEPABLE_LOCK STP_CTX_LOCK, *PSTP_CTX_LOCK;
+#endif
+
+typedef struct {
+	/* common interface */
+	IF_TX cb_if_tx;
+	/* event/signal */
+	EVENT_SET cb_event_set;
+	EVENT_TX_RESUME cb_event_tx_resume;
+	FUNCTION_STATUS cb_check_funciton_status;
+} mtkstp_callback;
+
+typedef enum {
+	MTKSTP_SYNC = 0,
+	MTKSTP_SEQ,
+	MTKSTP_ACK,
+	MTKSTP_NAK,
+	MTKSTP_TYPE,
+	MTKSTP_LENGTH,
+	MTKSTP_CHECKSUM,
+	MTKSTP_DATA,
+	MTKSTP_CRC1,
+	MTKSTP_CRC2,
+	MTKSTP_RESYNC1,
+	MTKSTP_RESYNC2,
+	MTKSTP_RESYNC3,
+	MTKSTP_RESYNC4,
+	MTKSTP_FW_MSG,
+} mtkstp_parser_state;
+
+typedef struct {
+	mtkstp_parser_state state;
+	UINT8 seq;
+	UINT8 ack;
+	UINT8 nak;
+	UINT8 type;
+	UINT16 length;
+	UINT8 checksum;
+	UINT16 crc;
+#if 1
+	UINT8 wmtsubtype;
+#endif
+} mtkstp_parser_context_struct;
+
+typedef struct {
+	UINT8 txseq;		/* last tx pkt's seq + 1 */
+	UINT8 txack;		/* last tx pkt's ack */
+	UINT8 rxack;		/* last rx pkt's ack */
+	UINT8 winspace;		/* current sliding window size */
+	UINT8 expected_rxseq;	/* last rx pkt's seq + 1 */
+	UINT8 retry_times;
+} mtkstp_sequence_context_struct;
+
+typedef struct {
+	/* MTK_WCN_MUTEX           mtx; */
+	OSAL_UNSLEEPABLE_LOCK mtx;
+	UINT8 buffer[MTKSTP_BUFFER_SIZE];
+	UINT32 read_p;
+	UINT32 write_p;
+} mtkstp_ring_buffer_struct;
+
+typedef struct {
+	UINT8 inband_rst_set;
+	UINT32 rx_counter;	/* size of current processing pkt in rx_buf[] */
+	UINT8 rx_buf[MTKSTP_BUFFER_SIZE];	/* input buffer of STP, room for current processing pkt */
+	UINT32 tx_read;		/* read ptr of tx_buf[] */
+	UINT32 tx_write;	/* write ptr of tx_buf[] */
+	UINT8 tx_buf[MTKSTP_BUFFER_SIZE];	/* output buffer of STP */
+	UINT32 tx_start_addr[MTKSTP_SEQ_SIZE];	/* ptr of each pkt in tx_buf[] */
+	UINT32 tx_length[MTKSTP_SEQ_SIZE];	/* length of each pkt in tx_buf[] */
+	mtkstp_ring_buffer_struct ring[MTKSTP_MAX_TASK_NUM];	/* ring buffers for each function driver */
+	mtkstp_parser_context_struct parser;	/* current rx pkt's content */
+	mtkstp_sequence_context_struct sequence;	/* state machine's current status */
+	/* MTK_WCN_MUTEX stp_mutex; */
+	/* OSAL_UNSLEEPABLE_LOCK stp_mutex; */
+	STP_CTX_LOCK stp_mutex;
+	/* MTK_WCN_TIMER tx_timer; // timer for tx timeout handling */
+	OSAL_TIMER tx_timer;
+
+	MTKSTP_PSM_T *psm;
+	MTKSTP_BTM_T *btm;
+	UINT8 f_enable;		/* default disabled */
+	UINT8 f_ready;		/* default non-ready */
+	UINT8 f_pending_type;
+	UINT8 f_coredump;	/*block tx flag, for now, only when f/w assert happens, we will set this bit on */
+	UINT8 en_coredump;
+	/* Flag to identify Blueztooth is Bluez/or MTK Stack */
+	MTK_WCN_BOOL f_bluez;
+	MTK_WCN_BOOL f_dbg_en;
+	MTK_WCN_BOOL f_autorst_en;
+
+	/* Flag to identify STP by SDIO or UART */
+	UINT32 f_mode;
+
+	/* Flag to indicate the last WMT CLOSE */
+	UINT32 f_wmt_last_close;
+
+	/* Flag to indicate evt err has triggered assert or not */
+	UINT32 f_evt_err_assert;
+} mtkstp_context_struct;
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+INT32 stp_send_data_no_ps(UINT8 *buffer, UINT32 length, UINT8 type);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_init
+* DESCRIPTION
+*  init STP kernel
+* PARAMETERS
+*  cb_func      [IN] function pointers of system APIs
+* RETURNS
+*  INT32    0 = success, others = failure
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_init(const mtkstp_callback * const cb_func);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_deinit
+* DESCRIPTION
+*  deinit STP kernel
+* PARAMETERS
+*  void
+* RETURNS
+*  INT32    0 = success, others = failure
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_deinit(void);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_enable
+* DESCRIPTION
+*  enable/disable STP
+* PARAMETERS
+*  value        [IN]        0 = disable, others = enable
+* RETURNS
+*  INT32    0 = success, others = error
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_enable(INT32 value);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_ready
+* DESCRIPTION
+*  ready/non-ready STP
+* PARAMETERS
+*  value        [IN]        0 = non-ready, others = ready
+* RETURNS
+*  INT32    0 = success, others = error
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_ready(INT32 value);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_coredump_start_ctrl
+* DESCRIPTION
+*  set f/w assert flag in STP context
+* PARAMETERS
+*  value        [IN]        0=assert end, others=assert begins
+* RETURNS
+*  INT32    0=success, others=error
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_coredump_start_ctrl(UINT32 value);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_coredump_start_get
+* DESCRIPTION
+*  get f/w assert flag in STP context
+* PARAMETERS
+*  VOID
+* RETURNS
+*  INT32    0= f/w assert flag is not set, others=f/w assert flag is set
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_coredump_start_get(VOID);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_send_data_raw
+* DESCRIPTION
+*  send raw data to common interface, bypass STP
+* PARAMETERS
+*  buffer      [IN]        data buffer
+*  length      [IN]        data buffer length
+*  type        [IN]        subfunction type
+* RETURNS
+*  INT32    length transmitted
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_send_data_raw(const PUINT8 buffer, const UINT32 length, const UINT8 type);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_set_sdio_mode
+* DESCRIPTION
+*  Set stp for SDIO mode
+* PARAMETERS
+*  sdio_flag  [IN]        sdio mode flag (TRUE:SDIO mode, FALSE:UART mode)
+* RETURNS
+*  void
+*****************************************************************************/
+extern void mtk_wcn_stp_set_mode(UINT32 sdio_flag);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_is_uart_fullset_mode
+* DESCRIPTION
+*  Is stp use UART Fullset  mode?
+* PARAMETERS
+*  none.
+* RETURNS
+*  MTK_WCN_BOOL    TRUE:UART Fullset, FALSE:UART Fullset
+*****************************************************************************/
+extern MTK_WCN_BOOL mtk_wcn_stp_is_uart_fullset_mode(void);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_is_uart_mand_mode
+* DESCRIPTION
+*  Is stp use UART Mandatory  mode?
+* PARAMETERS
+*  none.
+* RETURNS
+*  MTK_WCN_BOOL    TRUE:UART Mandatory, FALSE:UART Mandatory
+*****************************************************************************/
+extern MTK_WCN_BOOL mtk_wcn_stp_is_uart_mand_mode(void);
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_is_btif_fullset_mode
+* DESCRIPTION
+*  Is stp use BTIF Fullset  mode?
+* PARAMETERS
+*  none.
+* RETURNS
+*  MTK_WCN_BOOL    TRUE:BTIF Fullset, FALSE:BTIF Fullset
+*****************************************************************************/
+extern MTK_WCN_BOOL mtk_wcn_stp_is_btif_fullset_mode(void);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_is_btif_mand_mode
+* DESCRIPTION
+*  Is stp use BTIF Mandatory  mode?
+* PARAMETERS
+*  none.
+* RETURNS
+*  MTK_WCN_BOOL    TRUE:BTIF Mandatory, FALSE:BTIF Mandatory
+*****************************************************************************/
+extern MTK_WCN_BOOL mtk_wcn_stp_is_btif_mand_mode(void);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_is_sdio_mode
+* DESCRIPTION
+*  Is stp use SDIO mode?
+* PARAMETERS
+*  none.
+* RETURNS
+*  MTK_WCN_BOOL    TRUE:SDIO mode, FALSE:UART mode
+*****************************************************************************/
+extern MTK_WCN_BOOL mtk_wcn_stp_is_sdio_mode(void);
+
+/*****************************************************************************
+* FUNCTION
+*  stp_send_inband_reset
+* DESCRIPTION
+*  To sync to oringnal stp state with f/w stp
+* PARAMETERS
+*  none.
+* RETURNS
+*  none
+*****************************************************************************/
+extern void mtk_wcn_stp_inband_reset(void);
+
+/*****************************************************************************
+* FUNCTION
+*  stp_send_inband_reset
+* DESCRIPTION
+*  To send testing command to chip
+* PARAMETERS
+*  none.
+* RETURNS
+*  none
+*****************************************************************************/
+extern void mtk_wcn_stp_test_cmd(INT32 no);
+
+/*****************************************************************************
+* FUNCTION
+*  stp_send_inband_reset
+* DESCRIPTION
+* To control STP debugging mechanism
+* PARAMETERS
+*  func_no: function control, func_op: dumpping filer, func_param: dumpping parameter
+* RETURNS
+*  none
+*****************************************************************************/
+extern void mtk_wcn_stp_debug_ctrl(INT32 func_no, INT32 func_op, INT32 func_param);
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_flush
+* DESCRIPTION
+*  flush all stp context
+* PARAMETERS
+*  none.
+* RETURNS
+*  none
+*****************************************************************************/
+extern void mtk_wcn_stp_flush_context(void);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_rx_queue
+* DESCRIPTION
+*  flush all stp rx queue
+* PARAMETERS
+*  none.
+* RETURNS
+*  none
+*****************************************************************************/
+extern void mtk_wcn_stp_flush_rx_queue(UINT32 type);
+
+/*****************************************************************************
+* FUNCTION
+*  set stp debugging mdoe
+* DESCRIPTION
+*  set stp debugging mdoe
+* PARAMETERS
+* dbg_mode: switch to dbg mode ?
+* RETURNS
+*  void
+*****************************************************************************/
+extern void mtk_wcn_stp_set_dbg_mode(MTK_WCN_BOOL dbg_mode);
+
+/*****************************************************************************
+* FUNCTION
+*  set stp auto reset mdoe
+* DESCRIPTION
+*  set stp auto reset mdoe
+* PARAMETERS
+* auto_rst: switch to auto reset mode ?
+* RETURNS
+*  void
+*****************************************************************************/
+extern void mtk_wcn_stp_set_auto_rst(MTK_WCN_BOOL auto_rst);
+
+/*stp_psm support*/
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_psm_notify_stp
+* DESCRIPTION
+*  WMT notification to STP that power saving job is done or not
+* PARAMETERS
+*
+* RETURNS
+*  0: Sccuess  Negative value: Fail
+*****************************************************************************/
+extern int mtk_wcn_stp_psm_notify_stp(const UINT32 action);
+
+extern int mtk_wcn_stp_set_psm_state(MTKSTP_PSM_STATE_T state);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_psm_enabla
+* DESCRIPTION
+*  enable STP PSM
+* PARAMETERS
+*  int idle_time_to_sleep: IDLE time to sleep
+* RETURNS
+*  0: Sccuess  Negative value: Fail
+*****************************************************************************/
+extern int mtk_wcn_stp_psm_enable(int idle_time_to_sleep);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_psm_disable
+* DESCRIPTION
+*  disable STP PSM
+* PARAMETERS
+*  void
+* RETURNS
+*  0: Sccuess  Negative value: Fail
+*****************************************************************************/
+extern int mtk_wcn_stp_psm_disable(void);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_psm_reset
+* DESCRIPTION
+*  reset STP PSM (used on whole chip reset)
+* PARAMETERS
+*  void
+* RETURNS
+*  0: Sccuess  Negative value: Fail
+*****************************************************************************/
+extern int mtk_wcn_stp_psm_reset(void);
+extern void stp_do_tx_timeout(void);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_btm_get_dmp
+* DESCRIPTION
+*  get stp dump related information
+* PARAMETERS
+*  buffer: dump placement, len: dump size
+* RETURNS
+*   0: Success Negative Value: Fail
+*****************************************************************************/
+extern int mtk_wcn_stp_btm_get_dmp(char *buf, int *len);
+
+extern int mtk_wcn_stp_dbg_enable(void);
+
+extern int mtk_wcn_stp_dbg_disable(void);
+
+extern void mtk_wcn_stp_set_if_tx_type(ENUM_STP_TX_IF_TYPE stp_if_type);
+
+extern int mtk_wcn_sys_if_rx(UINT8 *data, INT32 size);
+
+extern MTK_WCN_BOOL mtk_wcn_stp_dbg_level(UINT32 dbglevel);
+
+extern INT32 mtk_wcn_stp_dbg_dump_package(VOID);
+
+extern int stp_drv_init(void);
+
+extern void stp_drv_exit(void);
+
+extern INT32 mtk_wcn_stp_dbg_log_ctrl(UINT32 on);
+
+extern INT32 mtk_wcn_stp_coredump_flag_ctrl(UINT32 on);
+
+extern INT32 mtk_wcn_stp_coredump_flag_get(VOID);
+extern INT32 mtk_wcn_stp_notify_sleep_for_thermal(void);
+
+extern INT32 mtk_wcn_stp_set_wmt_last_close(UINT32 value);
+
+/*stp btif API declared*/
+extern INT32 mtk_wcn_stp_open_btif(VOID);
+extern INT32 mtk_wcn_stp_close_btif(VOID);
+extern INT32 mtk_wcn_stp_rxcb_register(MTK_WCN_BTIF_RX_CB rx_cb);
+extern INT32 mtk_wcn_stp_tx(UINT8 *pBuf, UINT32 len, UINT32 *written_len);
+extern INT32 mtk_wcn_stp_wakeup_consys(VOID);
+extern INT32 mtk_wcn_stp_dpidle_ctrl(ENUM_BTIF_DPIDLE_CTRL en_flag);
+extern INT32 mtk_wcn_stp_lpbk_ctrl(ENUM_BTIF_LPBK_MODE mode);
+extern INT32 mtk_wcn_stp_logger_ctrl(ENUM_BTIF_DBG_ID flag);
+extern VOID mtk_wcn_stp_ctx_save(VOID);
+extern VOID mtk_wcn_stp_ctx_restore(VOID);
+extern INT32 mtk_wcn_stp_wmt_evt_err_trg_assert(VOID);
+extern VOID mtk_wcn_stp_set_wmt_evt_err_trg_assert(UINT32 value);
+extern UINT32 mtk_wcn_stp_get_wmt_evt_err_trg_assert(VOID);
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+#endif /* _STP_CORE_H_ */
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/stp_wmt.h b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/stp_wmt.h
new file mode 100644
index 00000000..94b3d8a
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/stp_wmt.h
@@ -0,0 +1,89 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _STP_WMT_H
+#define _STP_WMT_H
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+typedef enum {
+	BTM_RST_OP = 0,
+	BTM_DMP_OP = 1,
+	BTM_GET_AEE_SUPPORT_FLAG = 2,
+	BTM_MAX_OP,
+} MTKSTP_BTM_WMT_OP_T;
+
+typedef enum {
+	SLEEP = 0,
+	HOST_AWAKE,
+	WAKEUP,
+	EIRQ,
+	ROLL_BACK,
+	STP_PSM_MAX_ACTION
+} MTKSTP_PSM_ACTION_T;
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+extern MTK_WCN_BOOL wmt_lib_btm_cb(MTKSTP_BTM_WMT_OP_T op);
+
+extern INT32 wmt_lib_ps_stp_cb(MTKSTP_PSM_ACTION_T action);
+extern MTK_WCN_BOOL wmt_lib_is_quick_ps_support(VOID);
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+#endif /* _STP_WMT_H_ */
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_conf.h b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_conf.h
new file mode 100644
index 00000000..4c64b6b
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_conf.h
@@ -0,0 +1,74 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _WMT_CONF_H_
+#define _WMT_CONF_H_
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+#define CUST_CFG_WMT "WMT_SOC.cfg"
+#define CUST_CFG_WMT_PREFIX "/system/etc/firmware/"
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+INT32 wmt_conf_read_file(VOID);
+P_WMT_GEN_CONF wmt_conf_get_cfg(VOID);
+INT32 wmt_conf_set_cfg_file(const char *name);
+
+#endif /* _WMT_CONF_H_ */
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_core.h b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_core.h
new file mode 100644
index 00000000..cca52a1
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_core.h
@@ -0,0 +1,428 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _WMT_CORE_H_
+#define _WMT_CORE_H_
+
+#include "osal.h"
+#include "wmt_ctrl.h"
+#include "wmt_exp.h"
+#include "wmt_plat.h"
+/* TODO: [GeorgeKuo][FixMe] remove temporarily */
+/* for AIF state definition */
+/* #include "mtk_wcn_cmb_stub.h" */
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+#define CFG_CORE_MT6620_SUPPORT 0	/* whether MT6620 is supported or not */
+
+#define CFG_CORE_MT6628_SUPPORT 0	/* whether MT6628 is supported or not */
+
+#define CFG_CORE_SOC_SUPPORT 1
+
+/* TODO:[ChangeFeature][George] move this definition outside so that wmt_dev can remove wmt_core.h inclusion. */
+#define defaultPatchName "mt66xx_patch_hdr.bin"
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+#define BCNT_PATCH_BUF_HEADROOM (8)
+
+#define DWCNT_HIF_CONF    (4)
+#define DWCNT_STRAP_CONF  (4)
+#define DWCNT_RESERVED    (8)
+#define DWCNT_CTRL_DATA  (16)
+
+#if 0				/* TODO: [obsolete][GeorgeKuo]: remove ubsolete definitions */
+#define WMT_SET (1)
+#define WMT_QUERY (0)
+#define WMT_PKT_FMT_RAW (1)
+#define WMT_PKT_FMT_STP (0)
+#endif
+
+#define WMT_FUNC_CTRL_ON  (MTK_WCN_BOOL_TRUE)
+#define WMT_FUNC_CTRL_OFF (MTK_WCN_BOOL_FALSE)
+
+#define WMT_HDR_LEN             (4)	/* header length */
+#define WMT_STS_LEN             (1)	/* status length */
+#define WMT_FLAG_LEN            (1)
+#define WMT_HIF_UART_INFO_LEN   (4)
+#define WMT_FUNC_CTRL_PARAM_LEN (1)
+
+#define WMT_DEFAULT_BAUD_RATE   (115200)
+
+#define INIT_CMD(c, e, s) {.cmd = c, .cmdSz = sizeof(c), .evt = e, .evtSz = sizeof(e), .str = s}
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+typedef enum _ENUM_WMT_FM_T {
+	WMT_FM_INVALID = 0,
+	WMT_FM_I2C = 1,
+	WMT_FM_COMM = 2,
+	WMT_FM_MAX
+} ENUM_WMT_FM_T, *P_ENUM_WMT_FM_T;
+
+typedef enum _ENUM_WMT_HIF_T {
+	WMT_HIF_UART = 0,
+	WMT_HIF_SDIO = 1,
+	WMT_HIF_BTIF = 2,
+	WMT_HIF_MAX
+} ENUM_WMT_HIF_T, *P_ENUM_WMT_HIF_T;
+
+#if 0				/* [George] moved to wmt_exp.h for hif_sdio's use */
+typedef enum {
+	WMT_SDIO_SLOT_INVALID = 0,
+	WMT_SDIO_SLOT_SDIO1 = 1,	/* Wi-Fi dedicated SDIO1 */
+	WMT_SDIO_SLOT_SDIO2 = 2,
+	WMT_SDIO_SLOT_MAX
+} WMT_SDIO_SLOT_NUM;
+
+typedef enum {
+	WMT_SDIO_FUNC_STP = 0,
+	WMT_SDIO_FUNC_WIFI = 1,
+	WMT_SDIO_FUNC_MAX
+} WMT_SDIO_FUNC_TYPE;
+#endif
+
+typedef enum _ENUM_WMT_OPID_T {
+	WMT_OPID_HIF_CONF = 0,
+	WMT_OPID_PWR_ON = 1,
+	WMT_OPID_PWR_OFF = 2,
+	WMT_OPID_FUNC_ON = 3,
+	WMT_OPID_FUNC_OFF = 4,
+	WMT_OPID_REG_RW = 5,	/* TODO:[ChangeFeature][George] is this OP obsoleted? */
+	WMT_OPID_EXIT = 6,
+	WMT_OPID_PWR_SV = 7,
+	WMT_OPID_DSNS = 8,
+	WMT_OPID_LPBK = 9,
+	WMT_OPID_CMD_TEST = 10,
+	WMT_OPID_HW_RST = 11,
+	WMT_OPID_SW_RST = 12,
+	WMT_OPID_BAUD_RST = 13,
+	WMT_OPID_STP_RST = 14,
+	WMT_OPID_THERM_CTRL = 15,
+	WMT_OPID_EFUSE_RW = 16,
+	WMT_OPID_GPIO_CTRL = 17,
+	WMT_OPID_FW_COREDMP = 18,
+	WMT_OPID_GPIO_STATE = 19,
+	WMT_OPID_BGW_DS = 20,
+	WMT_OPID_SET_MCU_CLK = 21,
+	WMT_OPID_ADIE_LPBK_TEST = 22,
+#if CFG_WMT_LTE_COEX_HANDLING
+	WMT_OPID_IDC_MSG_HANDLING = 23,
+#endif
+#ifdef CONFIG_MTK_COMBO_ANT
+	WMT_OPID_ANT_RAM_DOWN = 24,
+	WMT_OPID_ANT_RAM_STA_GET = 25,
+#endif
+	WMT_OPID_MAX
+} ENUM_WMT_OPID_T, *P_ENUM_WMT_OPID_T;
+
+typedef OSAL_OP_DAT WMT_OP;
+typedef P_OSAL_OP_DAT P_WMT_OP;
+
+typedef struct _WMT_HIF_CONF {
+	UINT32 hifType;		/* HIF Type */
+	UINT32 au4HifConf[DWCNT_HIF_CONF];	/* HIF Config */
+	UINT32 au4StrapConf[DWCNT_STRAP_CONF];	/* Strap Config */
+} WMT_HIF_CONF, *P_WMT_HIF_CONF;
+
+typedef INT32(*WMT_OPID_FUNC) (P_WMT_OP);
+
+typedef struct _WMT_GEN_CONF {
+	UINT8 cfgExist;
+
+	UINT8 coex_wmt_ant_mode;
+	UINT8 coex_wmt_ext_component;
+	UINT8 coex_wmt_wifi_time_ctl;
+	UINT8 coex_wmt_ext_pta_dev_on;
+	/*mt6592 and LTE coex filter mode setting */
+	UINT8 coex_wmt_filter_mode;
+
+	UINT8 coex_bt_rssi_upper_limit;
+	UINT8 coex_bt_rssi_mid_limit;
+	UINT8 coex_bt_rssi_lower_limit;
+	UINT8 coex_bt_pwr_high;
+	UINT8 coex_bt_pwr_mid;
+	UINT8 coex_bt_pwr_low;
+
+	UINT8 coex_wifi_rssi_upper_limit;
+	UINT8 coex_wifi_rssi_mid_limit;
+	UINT8 coex_wifi_rssi_lower_limit;
+	UINT8 coex_wifi_pwr_high;
+	UINT8 coex_wifi_pwr_mid;
+	UINT8 coex_wifi_pwr_low;
+
+	UINT8 coex_ext_pta_hi_tx_tag;
+	UINT8 coex_ext_pta_hi_rx_tag;
+	UINT8 coex_ext_pta_lo_tx_tag;
+	UINT8 coex_ext_pta_lo_rx_tag;
+	UINT16 coex_ext_pta_sample_t1;
+	UINT16 coex_ext_pta_sample_t2;
+	UINT8 coex_ext_pta_wifi_bt_con_trx;
+
+	UINT32 coex_misc_ext_pta_on;
+	UINT32 coex_misc_ext_feature_set;
+	/*GPS LNA setting */
+	UINT8 wmt_gps_lna_pin;
+	UINT8 wmt_gps_lna_enable;
+	/*Power on sequence */
+	UINT8 pwr_on_rtc_slot;
+	UINT8 pwr_on_ldo_slot;
+	UINT8 pwr_on_rst_slot;
+	UINT8 pwr_on_off_slot;
+	UINT8 pwr_on_on_slot;
+	UINT8 co_clock_flag;
+
+	/* Combo chip side SDIO driving setting */
+	UINT32 sdio_driving_cfg;
+
+} WMT_GEN_CONF, *P_WMT_GEN_CONF;
+
+typedef enum _ENUM_DRV_STS_ {
+#if 0
+	DRV_STS_INVALID = 0,
+	DRV_STS_UNREG = 1,	/* Initial State */
+#endif
+	DRV_STS_POWER_OFF = 0,	/* initial state */
+	DRV_STS_POWER_ON = 1,	/* powered on, only WMT */
+	DRV_STS_FUNC_ON = 2,	/* FUNC ON */
+	DRV_STS_MAX
+} ENUM_DRV_STS, *P_ENUM_DRV_STS;
+
+typedef enum _WMT_IC_PIN_ID_ {
+	WMT_IC_PIN_AUDIO = 0,
+	WMT_IC_PIN_EEDI = 1,
+	WMT_IC_PIN_EEDO = 2,
+	WMT_IC_PIN_GSYNC = 3,
+	WMT_IC_PIN_MAX
+} WMT_IC_PIN_ID, *P_WMT_IC_PIN_ID;
+
+typedef enum _WMT_IC_PIN_STATE_ {
+	WMT_IC_PIN_EN = 0,
+	WMT_IC_PIN_DIS = 1,
+	WMT_IC_AIF_0 = 2,	/* = CMB_STUB_AIF_0, */
+	WMT_IC_AIF_1 = 3,	/* = CMB_STUB_AIF_1, */
+	WMT_IC_AIF_2 = 4,	/* = CMB_STUB_AIF_2, */
+	WMT_IC_AIF_3 = 5,	/* = CMB_STUB_AIF_3, */
+	WMT_IC_PIN_MUX = 6,
+	WMT_IC_PIN_GPIO = 7,
+	WMT_IC_PIN_GPIO_HIGH = 8,
+	WMT_IC_PIN_GPIO_LOW = 9,
+	WMT_IC_PIN_STATE_MAX
+} WMT_IC_PIN_STATE, *P_WMT_IC_PIN_STATE;
+
+typedef enum _WMT_CO_CLOCK_ {
+	WMT_CO_CLOCK_DIS = 0,
+	WMT_CO_CLOCK_EN = 1,
+	WMT_CO_CLOCK_MAX
+} WMT_CO_CLOCK, *P_WMT_CO_CLOCK;
+
+typedef INT32(*SW_INIT) (P_WMT_HIF_CONF pWmtHifConf);
+typedef INT32(*SW_DEINIT) (P_WMT_HIF_CONF pWmtHifConf);
+typedef INT32(*IC_PIN_CTRL) (WMT_IC_PIN_ID id, WMT_IC_PIN_STATE state, UINT32 flag);
+typedef INT32(*IC_VER_CHECK) (VOID);
+typedef INT32(*CO_CLOCK_CTRL) (WMT_CO_CLOCK on);
+typedef MTK_WCN_BOOL(*IS_QUICK_SLEEP_SUPPORT) (VOID);
+typedef MTK_WCN_BOOL(*IS_AEE_DUMP_SUPPORT) (VOID);
+
+typedef struct _WMT_IC_OPS_ {
+	UINT32 icId;
+	SW_INIT sw_init;
+	SW_DEINIT sw_deinit;
+	IC_PIN_CTRL ic_pin_ctrl;
+	IC_VER_CHECK ic_ver_check;
+	CO_CLOCK_CTRL co_clock_ctrl;
+	IS_QUICK_SLEEP_SUPPORT is_quick_sleep;
+	IS_AEE_DUMP_SUPPORT is_aee_dump_support;
+} WMT_IC_OPS, *P_WMT_IC_OPS;
+
+typedef struct _WMT_CTX_ {
+	ENUM_DRV_STS eDrvStatus[WMTDRV_TYPE_MAX];	/* Controlled driver status */
+	UINT32 wmtInfoBit;	/* valid info bit */
+	WMT_HIF_CONF wmtHifConf;	/* HIF information */
+
+	/* Pointer to WMT_IC_OPS. Shall be assigned to a correct table in stp_init
+	 * if and only if getting chip id successfully. hwver and fwver are kept in
+	 * WMT-IC module only.
+	 */
+	P_WMT_IC_OPS p_ic_ops;
+} WMT_CTX, *P_WMT_CTX;
+
+/* TODO:[ChangeFeature][George] remove WMT_PKT. replace it with hardcoded arrays. */
+/* Using this struct relies on compiler's implementation and pack() settings */
+typedef struct _WMT_PKT_ {
+	UINT8 eType;		/* PKT_TYPE_* */
+	UINT8 eOpCode;		/* OPCODE_* */
+	UINT16 u2SduLen;	/* 2 bytes length, little endian */
+	UINT8 aucParam[32];
+} WMT_PKT, *P_WMT_PKT;
+
+/* WMT Packet Format */
+typedef enum _ENUM_PKT_TYPE {
+	PKT_TYPE_INVALID = 0,
+	PKT_TYPE_CMD = 1,
+	PKT_TYPE_EVENT = 2,
+	_PKT_TYPE_MAX
+} ENUM_PKT_TYPE, *P_ENUM_PKT_TYPE;
+
+typedef enum _ENUM_OPCODE {
+	OPCODE_INVALID = 0,
+	OPCODE_PATCH = 1,
+	OPCODE_TEST = 2,
+	OPCODE_WAKEUP = 3,
+	OPCODE_HIF = 4,
+	OPCODE_STRAP_CONF = 5,
+	OPCODE_FUNC_CTRL = 6,
+	OPCODE_RESET = 7,
+	OPCODE_INT = 8,
+	OPCODE_MAX
+} ENUM_OPCODE, *P_ENUM_OPCODE;
+
+typedef enum {
+	WMT_STP_CONF_EN = 0,
+	WMT_STP_CONF_RDY = 1,
+	WMT_STP_CONF_MODE = 2,
+	WMT_STP_CONF_MAX
+} WMT_STP_CONF_TYPE;
+
+struct init_script {
+	UINT8 *cmd;
+	UINT32 cmdSz;
+	UINT8 *evt;
+	UINT32 evtSz;
+	UINT8 *str;
+};
+
+typedef struct _WMT_PATCH {
+	UINT8 ucDateTime[16];
+	UINT8 ucPLat[4];
+	UINT16 u2HwVer;
+	UINT16 u2SwVer;
+	UINT32 u4PatchVer;
+} WMT_PATCH, *P_WMT_PATCH;
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+#if CFG_CORE_MT6620_SUPPORT
+extern WMT_IC_OPS wmt_ic_ops_mt6620;
+#endif
+
+#if CFG_CORE_MT6628_SUPPORT
+extern WMT_IC_OPS wmt_ic_ops_mt6628;
+#endif
+
+#if CFG_CORE_SOC_SUPPORT
+extern WMT_IC_OPS wmt_ic_ops_soc;
+#endif
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+extern INT32 wmt_core_init(VOID);
+extern INT32 wmt_core_deinit(VOID);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_wmtd
+* DESCRIPTION
+*  deinit STP kernel
+* PARAMETERS
+*  void
+* RETURNS
+*  INT32    0 = success, others = failure
+*****************************************************************************/
+extern INT32 wmt_core_opid(P_WMT_OP pWmtOp);
+
+extern INT32 wmt_core_ctrl(ENUM_WMT_CTRL_T ctrId, unsigned long *pPa1, unsigned long *pPa2);
+
+extern INT32 wmt_core_func_ctrl_cmd(ENUM_WMTDRV_TYPE_T type, MTK_WCN_BOOL fgEn);
+
+extern INT32 wmt_core_reg_rw_raw(UINT32 isWrite, UINT32 offset, PUINT32 pVal, UINT32 mask);
+
+extern VOID wmt_core_dump_data(PUINT8 pData, PUINT8 pTitle, UINT32 len);
+
+extern MTK_WCN_BOOL wmt_core_patch_check(UINT32 u4PatchVer, UINT32 u4HwVer);
+
+extern INT32 wmt_core_init_script(struct init_script *script, INT32 count);
+
+extern INT32 wmt_core_rx(PUINT8 pBuf, UINT32 bufLen, UINT32 *readSize);
+
+extern INT32 wmt_core_tx(const PUINT8 pData, UINT32 size, PUINT32 writtenSize, MTK_WCN_BOOL bRawFlag);
+extern MTK_WCN_BOOL wmt_core_is_quick_ps_support(void);
+
+extern MTK_WCN_BOOL wmt_core_get_aee_dump_flag(void);
+
+#if CFG_CORE_INTERNAL_TXRX
+extern INT32 wmt_core_lpbk_do_stp_init(void);
+extern INT32 wmt_core_lpbk_do_stp_deinit(void);
+#endif
+
+extern VOID wmt_core_set_coredump_state(ENUM_DRV_STS state);
+#if CFG_WMT_LTE_COEX_HANDLING
+extern VOID wmt_core_set_flag_for_test(UINT32 enable);
+extern UINT32 wmt_core_get_flag_for_test(VOID);
+#endif
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+static _osal_inline_ MTK_WCN_BOOL wmt_core_ic_ops_check(P_WMT_IC_OPS p_ops)
+{
+	if (!p_ops)
+		return MTK_WCN_BOOL_FALSE;
+
+	if ((NULL == p_ops->sw_init)
+	    || (NULL == p_ops->sw_deinit)
+	    || (NULL == p_ops->ic_ver_check)
+	    || (NULL == p_ops->ic_pin_ctrl))
+		return MTK_WCN_BOOL_FALSE;
+	else
+		return MTK_WCN_BOOL_TRUE;
+}
+
+#endif /* _WMT_CORE_H_ */
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_ctrl.h b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_ctrl.h
new file mode 100644
index 00000000..0ff3d60
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_ctrl.h
@@ -0,0 +1,120 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _WMT_CTRL_H_
+#define _WMT_CTRL_H_
+
+#include "osal.h"
+#include "wmt_stp_exp.h"
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+#define DWCNT_CTRL_DATA  (16)
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+typedef struct _WMT_CTRL_DATA_ {
+	SIZE_T ctrlId;
+	SIZE_T au4CtrlData[DWCNT_CTRL_DATA];
+} WMT_CTRL_DATA, *P_WMT_CTRL_DATA;
+
+typedef enum _ENUM_WMT_CTRL_T {
+	WMT_CTRL_HW_PWR_OFF = 0,	/* whole chip power off */
+	WMT_CTRL_HW_PWR_ON = 1,	/* whole chip power on */
+	WMT_CTRL_HW_RST = 2,	/* whole chip rst */
+	WMT_CTRL_STP_CLOSE = 3,
+	WMT_CTRL_STP_OPEN = 4,
+	WMT_CTRL_STP_CONF = 5,
+	WMT_CTRL_FREE_PATCH = 6,
+	WMT_CTRL_GET_PATCH = 7,
+	WMT_CTRL_GET_PATCH_NAME = 8,
+	WMT_CTRL_HWIDVER_SET = 9,	/* TODO: rename this and add chip id information in addition to chip version */
+	WMT_CTRL_STP_RST = 10,
+	WMT_CTRL_GET_WMT_CONF = 11,
+	WMT_CTRL_TX = 12,	/* [FixMe][GeorgeKuo]: to be removed by Sean's stp integration */
+	WMT_CTRL_RX = 13,	/* [FixMe][GeorgeKuo]: to be removed by Sean's stp integration */
+	WMT_CTRL_RX_FLUSH = 14,	/* [FixMe][SeanWang]: to be removed by Sean's stp integration */
+	WMT_CTRL_GPS_SYNC_SET = 15,
+	WMT_CTRL_GPS_LNA_SET = 16,
+	WMT_CTRL_PATCH_SEARCH = 17,
+	WMT_CTRL_CRYSTAL_TRIMING_GET = 18,
+	WMT_CTRL_CRYSTAL_TRIMING_PUT = 19,
+	WMT_CTRL_HW_STATE_DUMP = 20,
+	WMT_CTRL_GET_PATCH_NUM = 21,
+	WMT_CTRL_GET_PATCH_INFO = 22,
+	WMT_CTRL_SOC_PALDO_CTRL = 23,
+	WMT_CTRL_SOC_WAKEUP_CONSYS = 24,
+	WMT_CTRL_SET_STP_DBG_INFO = 25,
+	WMT_CTRL_BGW_DESENSE_CTRL = 26,
+	WMT_CTRL_EVT_ERR_TRG_ASSERT = 27,
+#if CFG_WMT_LTE_COEX_HANDLING
+	WMT_CTRL_GET_TDM_REQ_ANTSEL = 28,
+#endif
+	WMT_CTRL_EVT_PARSER = 29,
+	WMT_CTRL_MAX
+} ENUM_WMT_CTRL_T, *P_ENUM_WMT_CTRL_T;
+
+typedef INT32(*WMT_CTRL_FUNC) (P_WMT_CTRL_DATA);
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+extern INT32 wmt_ctrl(P_WMT_CTRL_DATA pWmtCtrlData);
+
+extern INT32 wmt_ctrl_tx_ex(const PUINT8 pData, const UINT32 size, PUINT32 writtenSize, const MTK_WCN_BOOL bRawFlag);
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+#endif /* _WMT_CTRL_H_ */
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_func.h b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_func.h
new file mode 100644
index 00000000..d586f44
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_func.h
@@ -0,0 +1,140 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _WMT_FUNC_H_
+#define _WMT_FUNC_H_
+
+#include "osal_typedef.h"
+#include "osal.h"
+#include "wmt_core.h"
+#include "wmt_plat.h"
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+#if 1	/* defined(CONFIG_MTK_COMBO_HCI_DRIVER) || defined(CONFIG_MTK_COMBO_BT) */
+#define CFG_FUNC_BT_SUPPORT 1
+#else
+#define CFG_FUNC_BT_SUPPORT 0
+#endif
+
+#if 1	/* defined(CONFIG_MTK_COMBO_FM) */
+#define CFG_FUNC_FM_SUPPORT 1
+#else
+#define CFG_FUNC_FM_SUPPORT 0
+#endif
+
+#if 1	/* defined(CONFIG_MTK_COMBO_GPS) */
+#define CFG_FUNC_GPS_SUPPORT 1
+#else
+#define CFG_FUNC_GPS_SUPPORT 0
+#endif
+
+#if 1	/* defined(CONFIG_MTK_COMBO_WIFI) */
+#define CFG_FUNC_WIFI_SUPPORT 1
+#else
+#define CFG_FUNC_WIFI_SUPPORT 0
+#endif
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+typedef INT32(*SUBSYS_FUNC_ON) (P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf);
+typedef INT32(*SUBSYS_FUNC_OFF) (P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf);
+
+typedef struct _WMT_FUNC_OPS_ {
+	SUBSYS_FUNC_ON func_on;
+	SUBSYS_FUNC_OFF func_off;
+} WMT_FUNC_OPS, *P_WMT_FUNC_OPS;
+
+typedef struct _CMB_PIN_CTRL_REG_ {
+	UINT32 regAddr;
+	UINT32 regValue;
+	UINT32 regMask;
+
+} CMB_PIN_CTRL_REG, *P_CMB_PIN_CTRL_REG;
+
+typedef struct _CMB_PIN_CTRL_ {
+	UINT32 pinId;
+	UINT32 regNum;
+	P_CMB_PIN_CTRL_REG pFuncOnArray;
+	P_CMB_PIN_CTRL_REG pFuncOffArray;
+
+} CMB_PIN_CTRL, *P_CMB_PIN_CTRL;
+
+typedef enum _ENUM_CMP_PIN_ID_ {
+	CMB_PIN_EEDI_ID = 0,
+	CMB_PIN_EEDO_ID = 1,
+	CMB_PIN_GSYNC_ID = 2,
+} ENUM_CMP_PIN_ID, *P_ENUM_CMP_PIN_ID;
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+#if CFG_FUNC_BT_SUPPORT
+extern WMT_FUNC_OPS wmt_func_bt_ops;
+#endif
+
+#if CFG_FUNC_FM_SUPPORT
+extern WMT_FUNC_OPS wmt_func_fm_ops;
+#endif
+
+#if CFG_FUNC_GPS_SUPPORT
+extern WMT_FUNC_OPS wmt_func_gps_ops;
+#endif
+
+#if CFG_FUNC_WIFI_SUPPORT
+extern WMT_FUNC_OPS wmt_func_wifi_ops;
+#endif
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+#endif /* _WMT_FUNC_H_ */
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_ic.h b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_ic.h
new file mode 100644
index 00000000..901becf
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_ic.h
@@ -0,0 +1,122 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _WMT_IC_H_
+#define _WMT_IC_H_
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+#include "wmt_core.h"
+#include "wmt_exp.h"
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+#define WMT_IC_NAME_MT6620 "MT6620"
+#define WMT_IC_NAME_MT6628 "MT6628"
+#define WMT_IC_NAME_DEFAULT "SOC_CONSYS"
+
+#define WMT_IC_VER_E1 "E1"
+#define WMT_IC_VER_E2 "E2"
+#define WMT_IC_VER_E3 "E3"
+#define WMT_IC_VER_E4 "E4"
+#define WMT_IC_VER_E5 "E5"
+#define WMT_IC_VER_E6 "E6"
+
+#define WMT_IC_PATCH_DUMMY_EXT "_ex"
+#define WMT_IC_PATCH_NO_EXT ""
+#define WMT_IC_PATCH_E1_EXT "_e1"
+#define WMT_IC_PATCH_E2_EXT "_e2"
+#define WMT_IC_PATCH_E3_EXT "_e3"
+#define WMT_IC_PATCH_E4_EXT "_e4"
+#define WMT_IC_PATCH_E5_EXT "_e5"
+#define WMT_IC_PATCH_E6_EXT "_e6"
+
+#define WMT_IC_PATCH_TAIL    "_hdr.bin"
+
+#define WMT_IC_INVALID_CHIP_ID 0xFFFF
+
+#define MAJORNUM(x) (x & 0x00F0)
+#define MINORNUM(x) (x & 0x000F)
+
+/*******************************************************************************
+*                             R E G I S T E R   M A P
+********************************************************************************
+*/
+/* General definition used for ALL/UNKNOWN CHIPS */
+/* Now MT6620 uses these definitions */
+#define GEN_CONFG_BASE (0x80000000UL)
+#define GEN_HVR (GEN_CONFG_BASE + 0x0UL)	/* HW_VER */
+#define GEN_FVR (GEN_CONFG_BASE + 0x4UL)	/* FW_VER */
+#define GEN_VER_MASK (0x0000FFFFUL)	/* HW_VER and FW_VER valid bits mask */
+#define GEN_HCR (GEN_CONFG_BASE + 0x8UL)	/* HW_CODE, chip id */
+#define GEN_HCR_MASK (0x0000FFFFUL)	/* HW_CODE valid bits mask */
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+typedef struct _WMT_IC_INFO_S {
+	UINT32 u4HwVer;		/* u4HwId */
+	PUINT8 cChipName;
+	PUINT8 cChipVersion;
+	PUINT8 cPatchNameExt;
+	MTK_WCN_BOOL bPsmSupport;
+	MTK_WCN_BOOL bWorkWithoutPatch;
+	ENUM_WMTHWVER_TYPE_T eWmtHwVer;
+} WMT_IC_INFO_S, *P_WMT_IC_INFO_S;
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+#endif /* _WMT_IC_H_ */
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_lib.h b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_lib.h
new file mode 100644
index 00000000..b0c05cf
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/include/wmt_lib.h
@@ -0,0 +1,300 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _WMT_LIB_H_
+#define _WMT_LIB_H_
+
+#include "osal.h"
+#include "wmt_core.h"
+#include "wmt_exp.h"
+#include <mtk_wcn_cmb_stub.h>
+#include "stp_wmt.h"
+#include "wmt_plat.h"
+#include "wmt_idc.h"
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+#define WMT_OP_BUF_SIZE (16)
+
+typedef enum _ENUM_WMTRSTRET_TYPE_T {
+	WMTRSTRET_SUCCESS = 0x0,
+	WMTRSTRET_FAIL = 0x1,
+	WMTRSTRET_ONGOING = 0x2,
+	WMTRSTRET_MAX
+} ENUM_WMTRSTRET_TYPE_T, *P_ENUM_WMTRSTRET_TYPE_T;
+
+/*
+3(retry times) * 180 (STP retry time out)
++ 10 (firmware process time) +
+10 (transmit time) +
+10 (uart process -> WMT response pool) +
+230 (others)
+*/
+#define WMT_LIB_RX_TIMEOUT 20000	/*800-->cover v1.2phone BT function on time (~830ms) */
+/*
+open wifi during wifi power on procedure
+(because wlan is insert to system after mtk_hif_sdio module,
+so wifi card is not registered to hif module
+when mtk_wcn_wmt_func_on is called by wifi through rfkill)
+*/
+#define MAX_WIFI_ON_TIME 55000
+
+#define WMT_PWRON_RTY_DFT 2
+#define MAX_RETRY_TIME_DUE_TO_RX_TIMEOUT (WMT_PWRON_RTY_DFT * WMT_LIB_RX_TIMEOUT)
+#define MAX_EACH_FUNC_ON_WHEN_CHIP_POWER_ON_ALREADY WMT_LIB_RX_TIMEOUT	/*each WMT command */
+#define MAX_FUNC_ON_TIME \
+	(MAX_WIFI_ON_TIME + MAX_RETRY_TIME_DUE_TO_RX_TIMEOUT + MAX_EACH_FUNC_ON_WHEN_CHIP_POWER_ON_ALREADY * 3)
+
+#define MAX_EACH_FUNC_OFF (WMT_LIB_RX_TIMEOUT + 1000)	/*1000->WMT_LIB_RX_TIMEOUT + 1000, logical judgement */
+#define MAX_FUNC_OFF_TIME (MAX_EACH_FUNC_OFF * 4)
+
+#define MAX_EACH_WMT_CMD (WMT_LIB_RX_TIMEOUT + 1000)	/*1000->WMT_LIB_RX_TIMEOUT + 1000, logical judgement */
+
+#define MAX_GPIO_CTRL_TIME (2000)	/* [FixMe][GeorgeKuo] a temp value */
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/* AIF FLAG definition */
+/* bit(0): share pin or not */
+#define WMT_LIB_AIF_FLAG_MASK (0x1UL)
+#define WMT_LIB_AIF_FLAG_SHARE (0x1UL << 0)
+#define WMT_LIB_AIF_FLAG_SEPARATE (0x0UL << 0)
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+/* bit field offset definition */
+typedef enum {
+	WMT_STAT_PWR = 0,	/* is powered on */
+	WMT_STAT_STP_REG = 1,	/* is STP driver registered: */
+	WMT_STAT_STP_OPEN = 2,	/* is STP opened: default FALSE */
+	WMT_STAT_STP_EN = 3,	/* is STP enabled: default FALSE */
+	WMT_STAT_STP_RDY = 4,	/* is STP ready for client: default FALSE */
+	WMT_STAT_RX = 5,	/* is rx data available */
+	WMT_STAT_CMD = 6,	/* is cmd string to be read */
+	WMT_STAT_RST_ON = 7,
+	WMT_STAT_MAX
+} WMT_STAT;
+
+typedef enum _ENUM_WMTRSTSRC_TYPE_T {
+	WMTRSTSRC_RESET_BT = 0x0,
+	WMTRSTSRC_RESET_FM = 0x1,
+	WMTRSTSRC_RESET_GPS = 0x2,
+	WMTRSTSRC_RESET_WIFI = 0x3,
+	WMTRSTSRC_RESET_STP = 0x4,
+	WMTRSTSRC_RESET_TEST = 0x5,
+	WMTRSTSRC_RESET_MAX
+} ENUM_WMTRSTSRC_TYPE_T, *P_ENUM_WMTRSTSRC_TYPE_T;
+
+typedef struct {
+	PF_WMT_CB fDrvRst[4];
+} WMT_FDRV_CB, *P_WMT_FDRV_CB;
+
+typedef struct {
+	UINT32 dowloadSeq;
+	UINT8 addRess[4];
+	UINT8 patchName[256];
+} WMT_PATCH_INFO, *P_WMT_PATCH_INFO;
+
+/* OS independent wrapper for WMT_OP */
+typedef struct _DEV_WMT_ {
+
+	OSAL_SLEEPABLE_LOCK psm_lock;
+	OSAL_SLEEPABLE_LOCK idc_lock;
+	/* WMTd thread information */
+	/* struct task_struct *pWmtd; */
+	OSAL_THREAD thread;		/* main thread (wmtd) handle */
+	/* wait_queue_head_t rWmtdWq;   */
+	OSAL_EVENT rWmtdWq;		/*WMTd command wait queue */
+	/* ULONG state; */
+	OSAL_BIT_OP_VAR state;	/* bit field of WMT_STAT */
+
+	/* STP context information */
+	/* wait_queue_head_t rWmtRxWq; */
+	OSAL_EVENT rWmtRxWq;	/* STP Rx wait queue */
+	/* WMT_STP_FUNC rStpFunc; */
+	WMT_FDRV_CB rFdrvCb;	/* STP functions */
+
+	/* WMT Configurations */
+	WMT_HIF_CONF rWmtHifConf;
+	WMT_GEN_CONF rWmtGenConf;
+
+	/* Patch information */
+	UINT8 cPatchName[NAME_MAX + 1];
+	UINT8 cFullPatchName[NAME_MAX + 1];
+	UINT32 patchNum;
+
+	const osal_firmware *pPatch;
+
+	UINT8 cWmtcfgName[NAME_MAX + 1];
+	const osal_firmware *pWmtCfg;
+
+	const osal_firmware *pNvram;
+
+	/* Current used UART port description */
+	INT8 cUartName[NAME_MAX + 1];
+
+	OSAL_OP_Q rFreeOpQ;	/* free op queue */
+	OSAL_OP_Q rActiveOpQ;	/* active op queue */
+	OSAL_OP arQue[WMT_OP_BUF_SIZE];	/* real op instances */
+	P_OSAL_OP pCurOP;	/* current op */
+
+	/* cmd str buffer */
+	UINT8 cCmd[NAME_MAX + 1];
+	INT32 cmdResult;
+	/* struct completion cmd_comp; */
+	/* wait_queue_head_t cmd_wq; */
+	OSAL_SIGNAL cmdResp;	/* read command queues */
+	OSAL_EVENT cmdReq;
+
+	/* WMT loopback Thread Information */
+	/* WMT_CMB_VER combo_ver; */
+	/* P_WMT_CMB_CHIP_INFO_S pChipInfo; */
+	UINT32 chip_id;
+	UINT32 hw_ver;
+	UINT32 fw_ver;
+	/* TODO:  [FixMe][GeorgeKuo] remove this translated version code in the */
+	/* future. Just return the above 3 info to querist */
+	ENUM_WMTHWVER_TYPE_T eWmtHwVer;
+
+	P_WMT_PATCH_INFO pWmtPatchInfo;
+} DEV_WMT, *P_DEV_WMT;
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+extern DEV_WMT gDevWmt;
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+extern INT32 wmt_lib_init(VOID);
+extern INT32 wmt_lib_deinit(VOID);
+extern INT32 wmt_lib_tx(PUINT8 data, UINT32 size, PUINT32 writtenSize);
+extern INT32 wmt_lib_tx_raw(PUINT8 data, UINT32 size, PUINT32 writtenSize);
+extern INT32 wmt_lib_rx(PUINT8 buff, UINT32 buffLen, PUINT32 readSize);
+extern VOID wmt_lib_flush_rx(VOID);
+
+#if CFG_WMT_PS_SUPPORT
+extern INT32 wmt_lib_ps_set_idle_time(UINT32 psIdleTime);
+extern INT32 wmt_lib_ps_init(VOID);
+extern INT32 wmt_lib_ps_deinit(VOID);
+extern INT32 wmt_lib_ps_enable(VOID);
+extern INT32 wmt_lib_ps_ctrl(UINT32 state);
+
+extern INT32 wmt_lib_ps_disable(VOID);
+extern VOID wmt_lib_ps_irq_cb(VOID);
+#endif
+extern VOID wmt_lib_ps_set_sdio_psop(PF_WMT_SDIO_PSOP own_cb);
+
+/* LXOP functions: */
+extern P_OSAL_OP wmt_lib_get_free_op(VOID);
+extern INT32 wmt_lib_put_op_to_free_queue(P_OSAL_OP pOp);
+extern MTK_WCN_BOOL wmt_lib_put_act_op(P_OSAL_OP pOp);
+
+/* extern ENUM_WMTHWVER_TYPE_T wmt_lib_get_hwver (VOID); */
+extern UINT32 wmt_lib_get_icinfo(ENUM_WMT_CHIPINFO_TYPE_T type);
+
+extern MTK_WCN_BOOL wmt_lib_is_therm_ctrl_support(VOID);
+extern MTK_WCN_BOOL wmt_lib_is_dsns_ctrl_support(VOID);
+extern INT32 wmt_lib_trigger_cmd_signal(INT32 result);
+extern PUINT8 wmt_lib_get_cmd(VOID);
+extern P_OSAL_EVENT wmt_lib_get_cmd_event(VOID);
+extern INT32 wmt_lib_set_patch_name(PUINT8 cPatchName);
+extern INT32 wmt_lib_set_hif(unsigned long hifconf);
+extern P_WMT_HIF_CONF wmt_lib_get_hif(VOID);
+extern MTK_WCN_BOOL wmt_lib_get_cmd_status(VOID);
+
+/* GeorgeKuo: replace set_chip_gpio() with more specific ones */
+#if 0				/* moved to wmt_exp.h */
+extern INT32 wmt_lib_set_aif(CMB_STUB_AIF_X aif, MTK_WCN_BOOL share);	/* set AUDIO interface options */
+#endif
+extern INT32 wmt_lib_host_awake_get(VOID);
+extern INT32 wmt_lib_host_awake_put(VOID);
+extern UINT32 wmt_lib_dbg_level_set(UINT32 level);
+
+extern INT32 wmt_lib_msgcb_reg(ENUM_WMTDRV_TYPE_T eType, PF_WMT_CB pCb);
+
+extern INT32 wmt_lib_msgcb_unreg(ENUM_WMTDRV_TYPE_T eType);
+ENUM_WMTRSTRET_TYPE_T wmt_lib_cmb_rst(ENUM_WMTRSTSRC_TYPE_T src);
+MTK_WCN_BOOL wmt_lib_sw_rst(INT32 baudRst);
+MTK_WCN_BOOL wmt_lib_hw_rst(VOID);
+INT32 wmt_lib_reg_rw(UINT32 isWrite, UINT32 offset, PUINT32 pvalue, UINT32 mask);
+INT32 wmt_lib_efuse_rw(UINT32 isWrite, UINT32 offset, PUINT32 pvalue, UINT32 mask);
+
+extern INT32 DISABLE_PSM_MONITOR(void);
+extern VOID ENABLE_PSM_MONITOR(void);
+extern INT32 wmt_lib_notify_stp_sleep(void);
+extern void wmt_lib_psm_lock_release(void);
+extern INT32 wmt_lib_psm_lock_aquire(void);
+extern VOID wmt_lib_idc_lock_release(VOID);
+extern INT32 wmt_lib_idc_lock_aquire(VOID);
+extern INT32 wmt_lib_set_stp_wmt_last_close(UINT32 value);
+
+extern VOID wmt_lib_set_patch_num(UINT32 num);
+extern VOID wmt_lib_set_patch_info(P_WMT_PATCH_INFO pPatchinfo);
+extern INT32 wmt_lib_set_current_op(P_DEV_WMT pWmtDev, P_OSAL_OP pOp);
+extern P_OSAL_OP wmt_lib_get_current_op(P_DEV_WMT pWmtDev);
+extern PUINT8 wmt_lib_get_fwinfor_from_emi(UINT8 section, UINT32 offset, PUINT8 buff, UINT32 len);
+extern INT32 wmt_lib_poll_cpupcr(UINT32 count, UINT16 sleep, UINT16 toAee);
+extern PUINT8 wmt_lib_get_cpupcr_xml_format(PUINT32 len);
+extern INT32 wmt_lib_register_thermal_ctrl_cb(thermal_query_ctrl_cb thermal_ctrl);
+extern UINT32 wmt_lib_set_host_assert_info(UINT32 type, UINT32 reason, UINT32 en);
+extern INT8 wmt_lib_co_clock_get(VOID);
+extern UINT32 wmt_lib_soc_set_wifiver(UINT32 wifiver);
+
+#if CFG_WMT_LTE_COEX_HANDLING
+extern MTK_WCN_BOOL wmt_lib_handle_idc_msg(ipc_ilm_t *idc_infor);
+#endif
+#if CFG_WMT_PS_SUPPORT
+extern UINT32 wmt_lib_quick_sleep_ctrl(UINT32 en);
+#endif
+#if CONSYS_ENALBE_SET_JTAG
+extern UINT32 wmt_lib_jtag_flag_set(UINT32 en);
+#endif
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+#endif /* _WMT_LIB_H_ */
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/mtk_wcn_stub_alps.c b/drivers/misc/mediatek/connectivity/common/conn_soc/core/mtk_wcn_stub_alps.c
new file mode 100644
index 00000000..dee7a62
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/mtk_wcn_stub_alps.c
@@ -0,0 +1,605 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+#define CMB_STUB_DBG_LOG                  3
+#define CMB_STUB_INFO_LOG                 2
+#define CMB_STUB_WARN_LOG                 1
+
+int gCmbStubLogLevel = CMB_STUB_INFO_LOG;
+
+#define CMB_STUB_LOG_INFO(fmt, arg...) \
+do { \
+	if (gCmbStubLogLevel >= CMB_STUB_INFO_LOG) \
+		pr_warn(fmt, ##arg); \
+} while (0)
+#define CMB_STUB_LOG_WARN(fmt, arg...) \
+do { \
+	if (gCmbStubLogLevel >= CMB_STUB_WARN_LOG) \
+		pr_warn(fmt, ##arg); \
+} while (0)
+#define CMB_STUB_LOG_DBG(fmt, arg...) \
+do { \
+	if (gCmbStubLogLevel >= CMB_STUB_DBG_LOG) \
+		pr_debug(fmt, ##arg); \
+} while (0)
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/vmalloc.h>
+#include <linux/workqueue.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <mtk_wcn_cmb_stub.h>
+/* #include "wmt_detect.h" */
+
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+#ifndef MTK_WCN_CMB_FOR_SDIO_1V_AUTOK
+#define MTK_WCN_CMB_FOR_SDIO_1V_AUTOK 0
+#endif
+
+#if MTK_WCN_CMB_FOR_SDIO_1V_AUTOK
+struct work_struct *g_sdio_1v_autok_wk = NULL;
+#endif
+int gConnectivityChipId = -1;
+
+#ifdef MTK_WCN_COMBO_CHIP_SUPPORT
+/*
+* current used uart port name, default is "ttyMT2",
+* will be changed when wmt driver init
+*/
+char *wmt_uart_port_desc = "ttyMT2";
+EXPORT_SYMBOL(wmt_uart_port_desc);
+#endif
+
+static void mtk_wcn_cmb_sdio_request_eirq(msdc_sdio_irq_handler_t irq_handler, void *data);
+static void mtk_wcn_cmb_sdio_enable_eirq(void);
+static void mtk_wcn_cmb_sdio_disable_eirq(void);
+static void mtk_wcn_cmb_sdio_register_pm(pm_callback_t pm_cb, void *data);
+
+struct sdio_ops mt_sdio_ops[4] = {
+	{NULL, NULL, NULL, NULL},
+	{NULL, NULL, NULL, NULL},
+	{mtk_wcn_cmb_sdio_request_eirq, mtk_wcn_cmb_sdio_enable_eirq,
+		mtk_wcn_cmb_sdio_disable_eirq, mtk_wcn_cmb_sdio_register_pm},
+	{mtk_wcn_cmb_sdio_request_eirq, mtk_wcn_cmb_sdio_enable_eirq,
+		mtk_wcn_cmb_sdio_disable_eirq, mtk_wcn_cmb_sdio_register_pm}
+};
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+static wmt_aif_ctrl_cb cmb_stub_aif_ctrl_cb;
+static wmt_func_ctrl_cb cmb_stub_func_ctrl_cb;
+static wmt_thermal_query_cb cmb_stub_thermal_ctrl_cb;
+static CMB_STUB_AIF_X cmb_stub_aif_stat = CMB_STUB_AIF_0;
+static wmt_deep_idle_ctrl_cb cmb_stub_deep_idle_ctrl_cb;
+#if MTK_WCN_CMB_FOR_SDIO_1V_AUTOK
+static wmt_get_drv_status cmb_stub_drv_status_ctrl_cb;
+#endif
+static wmt_func_do_reset cmb_stub_do_reset_cb;
+/* A temp translation table between COMBO_AUDIO_STATE_X and CMB_STUB_AIF_X.
+ * This is used for ALPS backward compatible ONLY!!! Remove this table, related
+ * functions, and type definition after modifying other kernel built-in modules,
+ * such as AUDIO. [FixMe][GeorgeKuo]
+ */
+#if 0
+static CMB_STUB_AIF_X audio2aif[] = {
+	[COMBO_AUDIO_STATE_0] = CMB_STUB_AIF_0,
+	[COMBO_AUDIO_STATE_1] = CMB_STUB_AIF_1,
+	[COMBO_AUDIO_STATE_2] = CMB_STUB_AIF_2,
+	[COMBO_AUDIO_STATE_3] = CMB_STUB_AIF_3,
+};
+#endif
+static msdc_sdio_irq_handler_t mtk_wcn_cmb_sdio_eirq_handler;
+static atomic_t sdio_claim_irq_enable_flag;
+static atomic_t irq_enable_flag;
+static pm_callback_t mtk_wcn_cmb_sdio_pm_cb;
+static void *mtk_wcn_cmb_sdio_pm_data;
+static void *mtk_wcn_cmb_sdio_eirq_data;
+
+static u32 wifi_irq = 0xffffffff;
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+#if MTK_WCN_CMB_FOR_SDIO_1V_AUTOK
+static void mtk_wcn_cmb_stub_1v_autok_work(struct work_struct *work)
+{
+	CMB_STUB_LOG_WARN("++enter++\n");
+	mtk_wcn_cmb_stub_func_ctrl(11, 1);
+	mtk_wcn_cmb_stub_func_ctrl(11, 0);
+	CMB_STUB_LOG_WARN("--exit--\n");
+}
+
+/*!
+ * \brief A function for Getting current driver status:on/off
+ *
+ * \param driver type:0/bt,1/fm,2/gps,3/wifi,11/autok->run wmt turn on/off wifi flow
+ *
+ * \retval 0/off,2/on,-1/null pointer
+ */
+static int mtk_wcn_cmb_stub_drv_status(unsigned int type)
+{
+	int ret = -1;
+
+	if (cmb_stub_drv_status_ctrl_cb)
+		ret = (*cmb_stub_drv_status_ctrl_cb) (type);
+	else
+		CMB_STUB_LOG_WARN("cmb_stub_drv_status_ctrl_cb is NULL\n");
+	return ret;
+}
+
+/*!
+ * \brief A 1v AutoK function for kernel DVFS driver calling when screen off
+ *
+ * \param void
+ *
+ * \retval int,mt6630 state:0/off,1/power on,2/func on, -1/null
+ */
+int mtk_wcn_cmb_stub_1vautok_for_dvfs(void)
+{
+	int wmt_status;
+
+	CMB_STUB_LOG_WARN("DVFS driver call sdio 1v autok\n");
+
+	wmt_status = mtk_wcn_cmb_stub_drv_status(4);
+	CMB_STUB_LOG_WARN("current mt6630 status is %d\n", wmt_status);
+	if (0 == wmt_status) {
+		if (g_sdio_1v_autok_wk)
+			schedule_work(g_sdio_1v_autok_wk);
+		else
+			CMB_STUB_LOG_WARN("g_sdio_1v_autok_wk is NULL\n");
+	} else if ((2 == wmt_status) || (1 == wmt_status)) {
+		CMB_STUB_LOG_WARN("mt6630 is on state,skip AUTOK\n");
+	} else {
+		CMB_STUB_LOG_WARN("mt6630 is unknown state(%d)\n", wmt_status);
+	}
+
+	return wmt_status;
+
+}
+#endif
+/*!
+ * \brief A registration function for WMT-PLAT to register itself to CMB-STUB.
+ *
+ * An MTK-WCN-CMB-STUB registration function provided to WMT-PLAT to register
+ * itself and related callback functions when driver being loaded into kernel.
+ *
+ * \param p_stub_cb a pointer carrying CMB_STUB_CB information
+ *
+ * \retval 0 operation success
+ * \retval -1 invalid parameters
+ */
+int mtk_wcn_cmb_stub_reg(P_CMB_STUB_CB p_stub_cb)
+{
+	if ((!p_stub_cb)
+	    || (p_stub_cb->size != sizeof(CMB_STUB_CB))) {
+		CMB_STUB_LOG_WARN("[cmb_stub] invalid p_stub_cb:0x%p size(%d)\n",
+				  p_stub_cb, (p_stub_cb) ? p_stub_cb->size : 0);
+		return -1;
+	}
+
+	CMB_STUB_LOG_DBG("[cmb_stub] registered, p_stub_cb:0x%p size(%d)\n", p_stub_cb, p_stub_cb->size);
+
+	cmb_stub_aif_ctrl_cb = p_stub_cb->aif_ctrl_cb;
+	cmb_stub_func_ctrl_cb = p_stub_cb->func_ctrl_cb;
+	cmb_stub_thermal_ctrl_cb = p_stub_cb->thermal_query_cb;
+	cmb_stub_deep_idle_ctrl_cb = p_stub_cb->deep_idle_ctrl_cb;
+	cmb_stub_do_reset_cb = p_stub_cb->wmt_do_reset_cb;
+#if MTK_WCN_CMB_FOR_SDIO_1V_AUTOK
+	cmb_stub_drv_status_ctrl_cb = p_stub_cb->get_drv_status_cb;
+	g_sdio_1v_autok_wk = vmalloc(sizeof(struct work_struct));
+	if (!g_sdio_1v_autok_wk)
+		CMB_STUB_LOG_WARN("vmalloc work_struct(%zd) fail\n", sizeof(struct work_struct));
+	else
+		INIT_WORK(g_sdio_1v_autok_wk, mtk_wcn_cmb_stub_1v_autok_work);
+
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL(mtk_wcn_cmb_stub_reg);
+/*!
+ * \brief A unregistration function for WMT-PLAT to unregister from CMB-STUB.
+ *
+ * An MTK-WCN-CMB-STUB unregistration function provided to WMT-PLAT to
+ * unregister itself and clear callback function references.
+ *
+ * \retval 0 operation success
+ */
+int mtk_wcn_cmb_stub_unreg(void)
+{
+	cmb_stub_aif_ctrl_cb = NULL;
+	cmb_stub_func_ctrl_cb = NULL;
+	cmb_stub_thermal_ctrl_cb = NULL;
+	cmb_stub_deep_idle_ctrl_cb = NULL;
+	cmb_stub_do_reset_cb = NULL;
+	CMB_STUB_LOG_INFO("[cmb_stub] unregistered\n");	/* KERN_DEBUG */
+
+#if MTK_WCN_CMB_FOR_SDIO_1V_AUTOK
+	if (g_sdio_1v_autok_wk) {
+		vfree(g_sdio_1v_autok_wk);
+		g_sdio_1v_autok_wk = NULL;
+	}
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL(mtk_wcn_cmb_stub_unreg);
+
+/* stub functions for kernel to control audio path pin mux */
+int mtk_wcn_cmb_stub_aif_ctrl(CMB_STUB_AIF_X state, CMB_STUB_AIF_CTRL ctrl)
+{
+	int ret;
+
+	if ((CMB_STUB_AIF_MAX <= state)
+	    || (CMB_STUB_AIF_CTRL_MAX <= ctrl)) {
+
+		CMB_STUB_LOG_WARN("[cmb_stub] aif_ctrl invalid (%d, %d)\n", state, ctrl);
+		return -1;
+	}
+
+	/* avoid the early interrupt before we register the eirq_handler */
+	if (cmb_stub_aif_ctrl_cb) {
+		ret = (*cmb_stub_aif_ctrl_cb) (state, ctrl);
+		CMB_STUB_LOG_INFO("[cmb_stub] aif_ctrl_cb state(%d->%d) ctrl(%d) ret(%d)\n",
+		cmb_stub_aif_stat, state, ctrl, ret);	/* KERN_DEBUG */
+
+		cmb_stub_aif_stat = state;
+	} else {
+		CMB_STUB_LOG_WARN("[cmb_stub] aif_ctrl_cb null\n");
+		ret = -2;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_cmb_stub_aif_ctrl);
+
+/* Use a temp translation table between COMBO_AUDIO_STATE_X and CMB_STUB_AIF_X
+ * for ALPS backward compatible ONLY!!! Remove this table, related functions,
+ * and type definition after modifying other kernel built-in modules, such as
+ * AUDIO. [FixMe][GeorgeKuo]
+ */
+
+void mtk_wcn_cmb_stub_func_ctrl(unsigned int type, unsigned int on)
+{
+	if (cmb_stub_func_ctrl_cb)
+		(*cmb_stub_func_ctrl_cb) (type, on);
+	else
+		CMB_STUB_LOG_WARN("[cmb_stub] func_ctrl_cb null\n");
+}
+EXPORT_SYMBOL(mtk_wcn_cmb_stub_func_ctrl);
+
+int mtk_wcn_cmb_stub_query_ctrl(void)
+{
+	signed long temp = 0;
+
+	if (cmb_stub_thermal_ctrl_cb)
+		temp = (*cmb_stub_thermal_ctrl_cb) ();
+	else
+		CMB_STUB_LOG_WARN("[cmb_stub] thermal_ctrl_cb null\n");
+
+	return temp;
+}
+
+/*platform-related APIs*/
+/* void clr_device_working_ability(UINT32 clockId, MT6573_STATE state); */
+/* void set_device_working_ability(UINT32 clockId, MT6573_STATE state); */
+
+static int _mt_combo_plt_do_deep_idle(COMBO_IF src, int enter)
+{
+	int ret = -1;
+
+#if 0
+	if (src != COMBO_IF_UART && src != COMBO_IF_MSDC && src != COMBO_IF_BTIF) {
+		CMB_STUB_LOG_WARN("src = %d is error\n", src);
+		return ret;
+	}
+	if (src >= 0 && src < COMBO_IF_MAX)
+		CMB_STUB_LOG_INFO("src = %s, to enter deep idle? %d\n", combo_if_name[src], enter);
+#endif
+	/*TODO: For Common SDIO configuration, we need to do some judgement between STP and WIFI
+	   to decide if the msdc will enter deep idle safely */
+
+	switch (src) {
+	case COMBO_IF_UART:
+		if (enter == 0) {
+			/* clr_device_working_ability(MT65XX_PDN_PERI_UART3, DEEP_IDLE_STATE); */
+			/* disable_dpidle_by_bit(MT65XX_PDN_PERI_UART2); */
+#ifdef MTK_WCN_COMBO_CHIP_SUPPORT
+#if 0
+			ret = mtk_uart_pdn_enable(wmt_uart_port_desc, 0);
+			if (ret < 0)
+				CMB_STUB_LOG_WARN("[CMB] %s exit deep idle failed\n", wmt_uart_port_desc);
+#endif
+#endif
+		} else {
+			/* set_device_working_ability(MT65XX_PDN_PERI_UART3, DEEP_IDLE_STATE); */
+			/* enable_dpidle_by_bit(MT65XX_PDN_PERI_UART2); */
+#ifdef MTK_WCN_COMBO_CHIP_SUPPORT
+#if 0
+			ret = mtk_uart_pdn_enable(wmt_uart_port_desc, 1);
+			if (ret < 0)
+				CMB_STUB_LOG_WARN("[CMB] %s enter deep idle failed\n", wmt_uart_port_desc);
+#endif
+#endif
+		}
+		ret = 0;
+		break;
+
+	case COMBO_IF_MSDC:
+		if (enter == 0) {
+			/* for common sdio hif */
+			/* clr_device_working_ability(MT65XX_PDN_PERI_MSDC2, DEEP_IDLE_STATE); */
+		} else {
+			/* for common sdio hif */
+			/* set_device_working_ability(MT65XX_PDN_PERI_MSDC2, DEEP_IDLE_STATE); */
+		}
+		ret = 0;
+		break;
+
+	case COMBO_IF_BTIF:
+		if (cmb_stub_deep_idle_ctrl_cb)
+			ret = (*cmb_stub_deep_idle_ctrl_cb) (enter);
+		else
+			CMB_STUB_LOG_WARN("NULL function pointer\n");
+
+		if (ret)
+			CMB_STUB_LOG_WARN("%s deep idle fail(%d)\n", enter == 1 ? "enter" : "exit", ret);
+		else
+			CMB_STUB_LOG_DBG("%s deep idle ok(%d)\n", enter == 1 ? "enter" : "exit", ret);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+int mt_combo_plt_enter_deep_idle(COMBO_IF src)
+{
+	/* return 0; */
+	/* TODO: [FixMe][GeorgeKuo] handling this depends on common UART or common SDIO */
+	return _mt_combo_plt_do_deep_idle(src, 1);
+}
+EXPORT_SYMBOL(mt_combo_plt_enter_deep_idle);
+
+int mt_combo_plt_exit_deep_idle(COMBO_IF src)
+{
+	/* return 0; */
+	/* TODO: [FixMe][GeorgeKuo] handling this depends on common UART or common SDIO */
+	return _mt_combo_plt_do_deep_idle(src, 0);
+}
+EXPORT_SYMBOL(mt_combo_plt_exit_deep_idle);
+
+int mtk_wcn_wmt_chipid_query(void)
+{
+	return gConnectivityChipId;
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_chipid_query);
+
+void mtk_wcn_wmt_set_chipid(int chipid)
+{
+	CMB_STUB_LOG_INFO("set current consys chipid (0x%x)\n", chipid);
+	gConnectivityChipId = chipid;
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_set_chipid);
+
+int mtk_wcn_cmb_stub_do_reset(unsigned int type)
+{
+	if (cmb_stub_do_reset_cb)
+		return (*cmb_stub_do_reset_cb) (type);
+	else
+		return -1;
+}
+EXPORT_SYMBOL(mtk_wcn_cmb_stub_do_reset);
+
+static void mtk_wcn_cmb_sdio_enable_eirq(void)
+{
+	if (atomic_read(&irq_enable_flag))
+		CMB_STUB_LOG_DBG("wifi eint has been enabled\n");
+	else {
+		atomic_set(&irq_enable_flag, 1);
+		if (wifi_irq != 0xfffffff) {
+			enable_irq(wifi_irq);
+			CMB_STUB_LOG_DBG(" enable WIFI EINT irq %d !!\n", wifi_irq);
+		}
+	}
+}
+
+static void mtk_wcn_cmb_sdio_disable_eirq(void)
+{
+	if (!atomic_read(&irq_enable_flag))
+		CMB_STUB_LOG_DBG("wifi eint has been disabled!\n");
+	else {
+		if (wifi_irq != 0xfffffff) {
+			disable_irq_nosync(wifi_irq);
+			CMB_STUB_LOG_DBG("disable WIFI EINT irq %d !!\n", wifi_irq);
+		}
+		atomic_set(&irq_enable_flag, 0);
+	}
+}
+
+irqreturn_t mtk_wcn_cmb_sdio_eirq_handler_stub(int irq, void *data)
+{
+	if ((NULL != mtk_wcn_cmb_sdio_eirq_handler)&&(0 != atomic_read(&sdio_claim_irq_enable_flag)))
+		mtk_wcn_cmb_sdio_eirq_handler(mtk_wcn_cmb_sdio_eirq_data);
+	return IRQ_HANDLED;
+}
+
+static void mtk_wcn_cmb_sdio_request_eirq(msdc_sdio_irq_handler_t irq_handler, void *data)
+{
+	struct device_node *node;
+	int ret = -EINVAL;
+#if 0
+	unsigned int gpio_wifi_eint_pin;
+#endif
+
+	CMB_STUB_LOG_INFO("enter %s\n", __func__);
+	mtk_wcn_sdio_irq_flag_set(0);
+	atomic_set(&irq_enable_flag, 0);
+	mtk_wcn_cmb_sdio_eirq_data = data;
+	mtk_wcn_cmb_sdio_eirq_handler = irq_handler;
+
+	node = (struct device_node *)of_find_compatible_node(NULL, NULL, "mediatek,connectivity-combo");
+	if (node) {
+#if 0
+		gpio_wifi_eint_pin = of_get_gpio(node, 5);
+		CMB_STUB_LOG_INFO("WIFI EINT pin %d !!\n", gpio_wifi_eint_pin);
+		wifi_irq = gpio_to_irq(gpio_wifi_eint_pin);
+#else
+		wifi_irq = irq_of_parse_and_map(node, 0);/* get wifi eint num */
+#endif
+#if 1
+		ret = request_irq(wifi_irq, mtk_wcn_cmb_sdio_eirq_handler_stub, IRQF_TRIGGER_LOW,
+				"WIFI-eint", NULL);
+		CMB_STUB_LOG_DBG("WIFI EINT irq %d !!\n", wifi_irq);
+#endif
+
+		if (ret)
+			CMB_STUB_LOG_WARN("WIFI EINT IRQ LINE NOT AVAILABLE!!\n");
+		else
+			mtk_wcn_cmb_sdio_disable_eirq();/*not ,chip state is power off*/
+	} else
+		CMB_STUB_LOG_WARN("[%s] can't find connectivity compatible node\n", __func__);
+
+	CMB_STUB_LOG_INFO("exit %s\n", __func__);
+}
+
+static void mtk_wcn_cmb_sdio_register_pm(pm_callback_t pm_cb, void *data)
+{
+	CMB_STUB_LOG_DBG("mtk_wcn_cmb_sdio_register_pm (0x%p, 0x%p)\n", pm_cb, data);
+	/* register pm change callback */
+	mtk_wcn_cmb_sdio_pm_cb = pm_cb;
+	mtk_wcn_cmb_sdio_pm_data = data;
+}
+
+static void mtk_wcn_cmb_sdio_on(int sdio_port_num)
+{
+	pm_message_t state = {.event = PM_EVENT_USER_RESUME };
+
+	CMB_STUB_LOG_INFO("mtk_wcn_cmb_sdio_on (%d)\n", sdio_port_num);
+
+	/* 1. disable sdio eirq */
+	mtk_wcn_cmb_sdio_disable_eirq();
+
+	/* 2. call sd callback */
+	if (mtk_wcn_cmb_sdio_pm_cb) {
+		/* pr_warn("mtk_wcn_cmb_sdio_pm_cb(PM_EVENT_USER_RESUME, 0x%p, 0x%p)\n",
+		 * mtk_wcn_cmb_sdio_pm_cb, mtk_wcn_cmb_sdio_pm_data); */
+		mtk_wcn_cmb_sdio_pm_cb(state, mtk_wcn_cmb_sdio_pm_data);
+	} else
+		CMB_STUB_LOG_WARN("mtk_wcn_cmb_sdio_on no sd callback!!\n");
+}
+
+static void mtk_wcn_cmb_sdio_off(int sdio_port_num)
+{
+	pm_message_t state = {.event = PM_EVENT_USER_SUSPEND };
+
+	CMB_STUB_LOG_INFO("mtk_wcn_cmb_sdio_off (%d)\n", sdio_port_num);
+
+	/* 1. call sd callback */
+	if (mtk_wcn_cmb_sdio_pm_cb) {
+		/* pr_warn("mtk_wcn_cmb_sdio_off(PM_EVENT_USER_SUSPEND, 0x%p, 0x%p)\n",
+		 * mtk_wcn_cmb_sdio_pm_cb, mtk_wcn_cmb_sdio_pm_data); */
+		mtk_wcn_cmb_sdio_pm_cb(state, mtk_wcn_cmb_sdio_pm_data);
+	} else
+		CMB_STUB_LOG_WARN("mtk_wcn_cmb_sdio_off no sd callback!!\n");
+
+	/* 2. disable sdio eirq */
+	mtk_wcn_cmb_sdio_disable_eirq();
+}
+
+int board_sdio_ctrl(unsigned int sdio_port_num, unsigned int on)
+{
+	CMB_STUB_LOG_DBG("mt_mtk_wcn_cmb_sdio_ctrl (%d, %d)\n", sdio_port_num, on);
+	if (on) {
+#if 1
+		CMB_STUB_LOG_DBG("board_sdio_ctrl force off before on\n");
+		mtk_wcn_cmb_sdio_off(sdio_port_num);
+#else
+		CMB_STUB_LOG_WARN("skip sdio off before on\n");
+#endif
+		/* off -> on */
+		mtk_wcn_cmb_sdio_on(sdio_port_num);
+		if (wifi_irq != 0xfffffff)
+			irq_set_irq_wake(wifi_irq, 1);
+		else
+			CMB_STUB_LOG_WARN("wifi_irq is not available\n");
+	} else {
+			if (wifi_irq != 0xfffffff)
+				irq_set_irq_wake(wifi_irq, 0);
+			else
+				CMB_STUB_LOG_WARN("wifi_irq is not available\n");
+			/* on -> off */
+			mtk_wcn_cmb_sdio_off(sdio_port_num);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(board_sdio_ctrl);
+
+int mtk_wcn_sdio_irq_flag_set(int flag)
+{
+	if (0 != flag)
+		atomic_set(&sdio_claim_irq_enable_flag, 1);
+	else
+		atomic_set(&sdio_claim_irq_enable_flag, 0);
+
+	CMB_STUB_LOG_DBG("sdio_claim_irq_enable_flag:%d\n", atomic_read(&sdio_claim_irq_enable_flag));
+
+	return atomic_read(&sdio_claim_irq_enable_flag);
+}
+EXPORT_SYMBOL(mtk_wcn_sdio_irq_flag_set);
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/psm_core.c b/drivers/misc/mediatek/connectivity/common/conn_soc/core/psm_core.c
new file mode 100644
index 00000000..c826c51
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/psm_core.c
@@ -0,0 +1,1890 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "osal_typedef.h"
+#include "osal.h"
+#include "psm_core.h"
+#include "stp_core.h"
+#include <mtk_wcn_cmb_stub.h>
+
+INT32 gPsmDbgLevel = STP_PSM_LOG_INFO;
+MTKSTP_PSM_T stp_psm_i;
+MTKSTP_PSM_T *stp_psm = &stp_psm_i;
+
+STP_PSM_RECORD_T *g_stp_psm_dbg = NULL;
+static UINT32 g_record_num;
+
+P_STP_PSM_OPID_RECORD g_stp_psm_opid_dbg = NULL;
+static UINT32 g_opid_record_num;
+
+#define STP_PSM_LOUD_FUNC(fmt, arg...) \
+do { \
+	if (gPsmDbgLevel >= STP_PSM_LOG_LOUD) \
+		pr_debug(PFX_PSM "%s: "  fmt, __func__ , ##arg); \
+} while (0)
+#define STP_PSM_DBG_FUNC(fmt, arg...) \
+do { \
+	if (gPsmDbgLevel >= STP_PSM_LOG_DBG) \
+		pr_debug(PFX_PSM "%s: "  fmt, __func__ , ##arg); \
+} while (0)
+#define STP_PSM_INFO_FUNC(fmt, arg...) \
+do { \
+	if (gPsmDbgLevel >= STP_PSM_LOG_INFO) \
+		pr_debug(PFX_PSM "[I]%s: "  fmt, __func__ , ##arg); \
+} while (0)
+#define STP_PSM_WARN_FUNC(fmt, arg...) \
+do { \
+	if (gPsmDbgLevel >= STP_PSM_LOG_WARN) \
+		pr_warn(PFX_PSM "[W]%s: "  fmt, __func__ , ##arg); \
+} while (0)
+#define STP_PSM_ERR_FUNC(fmt, arg...) \
+do { \
+	if (gPsmDbgLevel >= STP_PSM_LOG_ERR) \
+		pr_err(PFX_PSM "[E]%s(%d):ERROR! "   fmt, __func__ , __LINE__, ##arg); \
+} while (0)
+#define STP_PSM_TRC_FUNC(f) \
+do { \
+	if (gPsmDbgLevel >= STP_PSM_LOG_DBG) \
+		pr_debug(PFX_PSM "<%s> <%d>\n", __func__, __LINE__); \
+} while (0)
+
+static inline INT32 _stp_psm_notify_wmt(MTKSTP_PSM_T *stp_psm, const MTKSTP_PSM_ACTION_T action);
+static INT32 _stp_psm_thread_lock_aquire(MTKSTP_PSM_T *stp_psm);
+static INT32 _stp_psm_thread_lock_release(MTKSTP_PSM_T *stp_psm);
+static INT32 _stp_psm_dbg_dmp_in(STP_PSM_RECORD_T *stp_psm_dbg, UINT32 flag, UINT32 line_num);
+static INT32 _stp_psm_dbg_out_printk(STP_PSM_RECORD_T *stp_psm_dbg);
+
+static INT32 _stp_psm_opid_dbg_dmp_in(P_STP_PSM_OPID_RECORD p_opid_dbg, UINT32 opid, UINT32 line_num);
+static INT32 _stp_psm_opid_dbg_out_printk(P_STP_PSM_OPID_RECORD p_opid_dbg);
+
+static const char *g_psm_state[STP_PSM_MAX_STATE] = {
+	"ACT",
+	"ACT_INACT",
+	"INACT",
+	"INACT_ACT"
+};
+
+static const char *g_psm_action[STP_PSM_MAX_ACTION] = {
+	"SLEEP",
+	"HOST_AWAKE",
+	"WAKEUP",
+	"EIRQ",
+	"ROLL_BACK"
+};
+
+static const char *g_psm_op_name[STP_OPID_PSM_NUM] = {
+	"STP_OPID_PSM_SLEEP",
+	"STP_OPID_PSM_WAKEUP",
+	"STP_OPID_PSM_HOST_AWAKE",
+	"STP_OPID_PSM_EXIT"
+};
+
+static int _stp_psm_release_data(MTKSTP_PSM_T *stp_psm);
+
+static inline int _stp_psm_get_state(MTKSTP_PSM_T *stp_psm);
+
+static int _stp_psm_is_redundant_active_op(P_OSAL_OP pOp, P_OSAL_OP_Q pOpQ);
+
+static int _stp_psm_clean_up_redundant_active_op(P_OSAL_OP_Q pOpQ);
+static MTK_WCN_BOOL _stp_psm_is_quick_ps_support(VOID);
+
+MTK_WCN_BOOL mtk_wcn_stp_psm_dbg_level(UINT32 dbglevel)
+{
+	if (dbglevel <= 4) {
+		gPsmDbgLevel = dbglevel;
+		STP_PSM_INFO_FUNC("gPsmDbgLevel = %d\n", gPsmDbgLevel);
+		return true;
+	}
+	STP_PSM_INFO_FUNC("invalid psm debug level. gPsmDbgLevel = %d\n", gPsmDbgLevel);
+
+	return false;
+}
+
+static INT32 _stp_psm_handler(MTKSTP_PSM_T *stp_psm, P_STP_OP pStpOp)
+{
+	INT32 ret = -1;
+
+	/* if (NULL == pStpOp) */
+	/* { */
+	/* return -1; */
+	/* } */
+	ret = _stp_psm_thread_lock_aquire(stp_psm);
+	if (ret) {
+		STP_PSM_ERR_FUNC("--->lock psm_thread_lock failed ret=%d\n", ret);
+		return ret;
+	}
+
+	switch (pStpOp->opId) {
+	case STP_OPID_PSM_EXIT:
+		/* TODO: clean all up? */
+		ret = 0;
+		break;
+
+	case STP_OPID_PSM_SLEEP:
+		if (stp_psm_check_sleep_enable(stp_psm) > 0)
+			ret = _stp_psm_notify_wmt(stp_psm, SLEEP);
+		else
+			STP_PSM_INFO_FUNC("cancel sleep request\n");
+
+		break;
+
+	case STP_OPID_PSM_WAKEUP:
+		ret = _stp_psm_notify_wmt(stp_psm, WAKEUP);
+		break;
+
+	case STP_OPID_PSM_HOST_AWAKE:
+		ret = _stp_psm_notify_wmt(stp_psm, HOST_AWAKE);
+		break;
+
+	default:
+		STP_PSM_ERR_FUNC("invalid operation id (%d)\n", pStpOp->opId);
+		ret = -1;
+		break;
+	}
+	_stp_psm_thread_lock_release(stp_psm);
+	return ret;
+}
+
+static P_OSAL_OP _stp_psm_get_op(MTKSTP_PSM_T *stp_psm, P_OSAL_OP_Q pOpQ)
+{
+	P_OSAL_OP pOp;
+
+	if (!pOpQ) {
+		STP_PSM_WARN_FUNC("pOpQ == NULL\n");
+		return NULL;
+	}
+
+	osal_lock_unsleepable_lock(&(stp_psm->wq_spinlock));
+	/* acquire lock success */
+	RB_GET(pOpQ, pOp);
+
+	if ((pOpQ == &stp_psm->rActiveOpQ) && (NULL != pOp)) {
+		/* stp_psm->current_active_op = pOp; */
+		stp_psm->last_active_opId = pOp->op.opId;
+	}
+	osal_unlock_unsleepable_lock(&(stp_psm->wq_spinlock));
+
+	if ((pOpQ == &stp_psm->rActiveOpQ) && (NULL != pOp))
+		STP_PSM_DBG_FUNC("last_active_opId(%d)\n", stp_psm->last_active_opId);
+
+	if (!pOp)
+		STP_PSM_WARN_FUNC("RB_GET fail\n");
+
+	return pOp;
+}
+
+static INT32 _stp_psm_dump_active_q(P_OSAL_OP_Q pOpQ)
+{
+	UINT32 read_idx;
+	UINT32 write_idx;
+	UINT32 opId;
+
+	if (pOpQ == &stp_psm->rActiveOpQ) {
+		read_idx = stp_psm->rActiveOpQ.read;
+		write_idx = stp_psm->rActiveOpQ.write;
+
+		STP_PSM_DBG_FUNC("Active op list:++\n");
+		while ((read_idx & RB_MASK(pOpQ)) != (write_idx & RB_MASK(pOpQ))) {
+			opId = pOpQ->queue[read_idx & RB_MASK(pOpQ)]->op.opId;
+			if (opId < STP_OPID_PSM_NUM)
+				STP_PSM_DBG_FUNC("%s\n", g_psm_op_name[opId]);
+			else
+				STP_PSM_WARN_FUNC("Unknown OP Id\n");
+
+			++read_idx;
+		}
+		STP_PSM_DBG_FUNC("Active op list:--\n");
+	} else {
+		STP_PSM_DBG_FUNC("%s: not active queue, dont dump\n", __func__);
+	}
+
+	return 0;
+}
+
+static int _stp_psm_is_redundant_active_op(P_OSAL_OP pOp, P_OSAL_OP_Q pOpQ)
+{
+	unsigned int opId = 0;
+	unsigned int prev_opId = 0;
+
+	/* if((pOpQ == &stp_psm->rActiveOpQ) && (NULL != stp_psm->current_active_op)) */
+	if ((pOpQ == &stp_psm->rActiveOpQ) && (STP_OPID_PSM_INALID != stp_psm->last_active_opId)) {
+		opId = pOp->op.opId;
+
+		if (opId == STP_OPID_PSM_SLEEP) {
+			if (RB_EMPTY(pOpQ)) {
+				/* prev_opId = stp_psm->current_active_op->op.opId; */
+				prev_opId = stp_psm->last_active_opId;
+			} else {
+				prev_opId = pOpQ->queue[(pOpQ->write - 1) & RB_MASK(pOpQ)]->op.opId;
+			}
+
+			if (prev_opId == STP_OPID_PSM_SLEEP) {
+				STP_PSM_DBG_FUNC("redundant sleep opId found\n");
+				return 1;
+			} else {
+				return 0;
+			}
+		} else {
+			if (RB_EMPTY(pOpQ)) {
+				/* prev_opId = stp_psm->current_active_op->op.opId; */
+				prev_opId = stp_psm->last_active_opId;
+			} else {
+				prev_opId = pOpQ->queue[(pOpQ->write - 1) & RB_MASK(pOpQ)]->op.opId;
+			}
+
+			if (((opId == STP_OPID_PSM_WAKEUP) && (prev_opId == STP_OPID_PSM_WAKEUP)) ||
+			    ((opId == STP_OPID_PSM_HOST_AWAKE) && (prev_opId == STP_OPID_PSM_WAKEUP)) ||
+			    ((opId == STP_OPID_PSM_HOST_AWAKE) && (prev_opId == STP_OPID_PSM_HOST_AWAKE)) ||
+			    ((opId == STP_OPID_PSM_WAKEUP) && (prev_opId == STP_OPID_PSM_HOST_AWAKE))
+			    ) {
+				STP_PSM_DBG_FUNC("redundant opId found, opId(%d), preOpid(%d)\n", opId, prev_opId);
+				return 1;
+			} else {
+				return 0;
+			}
+		}
+	} else {
+		return 0;
+	}
+
+}
+
+static int _stp_psm_clean_up_redundant_active_op(P_OSAL_OP_Q pOpQ)
+{
+	unsigned int prev_opId = 0;
+	unsigned int prev_prev_opId = 0;
+
+	P_OSAL_OP pOp;
+	P_OSAL_OP_Q pFreeOpQ = &stp_psm->rFreeOpQ;
+
+	if (pOpQ == &stp_psm->rActiveOpQ) {
+		/* sleep , wakeup | sleep, --> null | sleep (x) */
+		/* wakeup , sleep , wakeup | sleep --> wakeup | sleep (v) */
+		/* sleep , wakeup , sleep | wakeup --> sleep | wakeup (v) */
+		/* xxx, sleep | sleep --> xxx, sleep  (v) */
+		/* xxx, wakeup | wakeup --> xxx, wakeup  (v) */
+		/* xxx, awake | awake --> xxx, awake  (v) --> should never happen */
+		while (RB_COUNT(pOpQ) > 2) {
+			prev_opId = pOpQ->queue[(pOpQ->write - 1) & RB_MASK(pOpQ)]->op.opId;
+			prev_prev_opId = pOpQ->queue[(pOpQ->write - 2) & RB_MASK(pOpQ)]->op.opId;
+
+			if ((prev_opId == STP_OPID_PSM_SLEEP && prev_prev_opId == STP_OPID_PSM_WAKEUP) ||
+			    (prev_opId == STP_OPID_PSM_SLEEP && prev_prev_opId == STP_OPID_PSM_HOST_AWAKE) ||
+			    (prev_opId == STP_OPID_PSM_WAKEUP && prev_prev_opId == STP_OPID_PSM_SLEEP) ||
+			    (prev_opId == STP_OPID_PSM_HOST_AWAKE && prev_prev_opId == STP_OPID_PSM_SLEEP)
+			    ) {
+				RB_GET(pOpQ, pOp);
+				RB_PUT(pFreeOpQ, pOp);
+				RB_GET(pOpQ, pOp);
+				RB_PUT(pFreeOpQ, pOp);
+			} else if (prev_opId == prev_prev_opId) {
+				RB_GET(pOpQ, pOp);
+				STP_PSM_DBG_FUNC("redundant opId(%d) found, remove it\n", pOp->op.opId);
+				RB_PUT(pFreeOpQ, pOp);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static INT32 _stp_psm_put_op(MTKSTP_PSM_T *stp_psm, P_OSAL_OP_Q pOpQ, P_OSAL_OP pOp)
+{
+	INT32 ret;
+
+	/* if (!pOpQ || !pOp) */
+	/* { */
+	/* STP_PSM_WARN_FUNC("pOpQ = 0x%p, pLxOp = 0x%p\n", pOpQ, pOp); */
+	/* return 0; */
+	/* } */
+	ret = 0;
+
+	osal_lock_unsleepable_lock(&(stp_psm->wq_spinlock));
+	/* acquire lock success */
+	if (pOpQ == &stp_psm->rActiveOpQ) {
+		if (!_stp_psm_is_redundant_active_op(pOp, pOpQ)) {
+			/* acquire lock success */
+			if (!RB_FULL(pOpQ)) {
+				RB_PUT(pOpQ, pOp);
+				STP_PSM_DBG_FUNC("opId(%d) enqueue\n", pOp->op.opId);
+			} else {
+				STP_PSM_INFO_FUNC("************ Active Queue Full ************\n");
+				ret = -1;
+			}
+
+			_stp_psm_clean_up_redundant_active_op(pOpQ);
+		} else {
+			/*redundant opId, mark ret as success */
+			P_OSAL_OP_Q pFreeOpQ = &stp_psm->rFreeOpQ;
+
+			if (!RB_FULL(pFreeOpQ))
+				RB_PUT(pFreeOpQ, pOp);
+			else
+				osal_assert(!RB_FULL(pFreeOpQ));
+
+			ret = 0;
+		}
+	} else {
+		if (!RB_FULL(pOpQ))
+			RB_PUT(pOpQ, pOp);
+		else
+			ret = -1;
+
+	}
+
+	if (pOpQ == &stp_psm->rActiveOpQ)
+		_stp_psm_dump_active_q(&stp_psm->rActiveOpQ);
+
+
+	osal_unlock_unsleepable_lock(&(stp_psm->wq_spinlock));
+	STP_PSM_DBG_FUNC("stp_psm do unlock,active queue? (%s)\n", (pOpQ == &stp_psm->rActiveOpQ) ? "y" : "n");
+
+	if (ret) {
+		STP_PSM_WARN_FUNC("RB_FULL, RB_COUNT=%d , RB_SIZE=%d\n", RB_COUNT(pOpQ), RB_SIZE(pOpQ));
+		return 0;
+	} else
+		return 1;
+
+}
+
+P_OSAL_OP _stp_psm_get_free_op(MTKSTP_PSM_T *stp_psm)
+{
+	P_OSAL_OP pOp;
+
+	if (stp_psm) {
+		pOp = _stp_psm_get_op(stp_psm, &stp_psm->rFreeOpQ);
+		if (pOp)
+			osal_memset(&pOp->op, 0, sizeof(pOp->op));
+
+		return pOp;
+	} else
+		return NULL;
+
+}
+
+INT32 _stp_psm_put_act_op(MTKSTP_PSM_T *stp_psm, P_OSAL_OP pOp)
+{
+	INT32 bRet = 0;		/* MTK_WCN_BOOL_FALSE; */
+	INT32 bCleanup = 0;	/* MTK_WCN_BOOL_FALSE; */
+	INT32 wait_ret = -1;
+	P_OSAL_SIGNAL pSignal = NULL;
+
+	do {
+		if (!stp_psm || !pOp) {
+			STP_PSM_ERR_FUNC("stp_psm = %p, pOp = %p\n", stp_psm, pOp);
+			break;
+		}
+
+		pSignal = &pOp->signal;
+
+		if (pSignal->timeoutValue) {
+			pOp->result = -9;
+			osal_signal_init(&pOp->signal);
+		}
+
+		/* put to active Q */
+		bRet = _stp_psm_put_op(stp_psm, &stp_psm->rActiveOpQ, pOp);
+
+		if (0 == bRet) {
+			STP_PSM_WARN_FUNC("+++++++++++ Put op Active queue Fail\n");
+			bCleanup = 1;	/* MTK_WCN_BOOL_TRUE; */
+			break;
+		}
+		_stp_psm_opid_dbg_dmp_in(g_stp_psm_opid_dbg, pOp->op.opId, __LINE__);
+
+		/* wake up wmtd */
+		osal_trigger_event(&stp_psm->STPd_event);
+
+		if (pSignal->timeoutValue == 0) {
+			bRet = 1;	/* MTK_WCN_BOOL_TRUE; */
+			/* clean it in wmtd */
+			break;
+		}
+
+		/* wait result, clean it here */
+		bCleanup = 1;	/* MTK_WCN_BOOL_TRUE; */
+
+		/* check result */
+		wait_ret = osal_wait_for_signal_timeout(&pOp->signal);
+		STP_PSM_DBG_FUNC("wait completion:%d\n", wait_ret);
+		if (!wait_ret) {
+			STP_PSM_ERR_FUNC("wait completion timeout\n");
+			/* TODO: how to handle it? retry? */
+		} else {
+			if (pOp->result)
+				STP_PSM_WARN_FUNC("op(%d) result:%d\n", pOp->op.opId, pOp->result);
+			/* op completes, check result */
+			bRet = (pOp->result) ? 0 : 1;
+		}
+	} while (0);
+
+	if (bCleanup) {
+		/* put Op back to freeQ */
+		bRet = _stp_psm_put_op(stp_psm, &stp_psm->rFreeOpQ, pOp);
+		if (bRet == 0)
+			STP_PSM_WARN_FUNC("+++++++++++ Put op active free fail, maybe disable/enable psm\n");
+	}
+
+	return bRet;
+}
+
+static INT32 _stp_psm_wait_for_msg(void *pvData)
+{
+	MTKSTP_PSM_T *stp_psm = (MTKSTP_PSM_T *) pvData;
+
+	STP_PSM_DBG_FUNC("%s: stp_psm->rActiveOpQ = %d\n", __func__, RB_COUNT(&stp_psm->rActiveOpQ));
+
+	return (!RB_EMPTY(&stp_psm->rActiveOpQ)) || osal_thread_should_stop(&stp_psm->PSMd);
+}
+
+static INT32 _stp_psm_proc(void *pvData)
+{
+	MTKSTP_PSM_T *stp_psm = (MTKSTP_PSM_T *) pvData;
+	P_OSAL_OP pOp;
+	UINT32 id;
+	INT32 result;
+
+	if (!stp_psm) {
+		STP_PSM_WARN_FUNC("!stp_psm\n");
+		return -1;
+	}
+/* STP_PSM_INFO_FUNC("wmtd starts running: pWmtDev(0x%p) [pol, rt_pri, n_pri, pri]=[%d, %d, %d, %d]\n", */
+/* stp_psm, current->policy, current->rt_priority, current->normal_prio, current->prio); */
+
+	for (;;) {
+
+		pOp = NULL;
+
+		osal_wait_for_event(&stp_psm->STPd_event, _stp_psm_wait_for_msg, (void *)stp_psm);
+
+		/* we set reset flag when calling stp_reset after cleanup all op. */
+		if (osal_test_bit(STP_PSM_RESET_EN, &stp_psm->flag)) {
+			osal_clear_bit(STP_PSM_RESET_EN, &stp_psm->flag);
+			_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+		}
+		if (osal_thread_should_stop(&stp_psm->PSMd)) {
+			STP_PSM_INFO_FUNC("should stop now...\n");
+			/* TODO: clean up active opQ */
+			break;
+		}
+
+		/* get Op from activeQ */
+		pOp = _stp_psm_get_op(stp_psm, &stp_psm->rActiveOpQ);
+		if (!pOp) {
+			STP_PSM_WARN_FUNC("+++++++++++ Get op from activeQ fail, maybe disable/enable psm\n");
+			continue;
+		}
+
+		id = osal_op_get_id(pOp);
+
+		if (id >= STP_OPID_PSM_NUM) {
+			STP_PSM_WARN_FUNC("abnormal opid id: 0x%x\n", id);
+			result = -1;
+			goto handler_done;
+		}
+
+		result = _stp_psm_handler(stp_psm, &pOp->op);
+
+handler_done:
+
+		if (result) {
+			STP_PSM_WARN_FUNC("opid id(0x%x)(%s) error(%d)\n", id,
+					  (id >= 4) ? ("???") : (g_psm_op_name[id]), result);
+		}
+
+		if (osal_op_is_wait_for_signal(pOp))
+			osal_op_raise_signal(pOp, result);
+		else {
+			/* put Op back to freeQ */
+			if (_stp_psm_put_op(stp_psm, &stp_psm->rFreeOpQ, pOp) == 0)
+				STP_PSM_WARN_FUNC("+++++++++++ Put op to FreeOpQ fail, maybe disable/enable psm\n");
+		}
+
+		if (STP_OPID_PSM_EXIT == id)
+			break;
+	}
+	STP_PSM_INFO_FUNC("exits\n");
+
+	return 0;
+};
+
+static inline INT32 _stp_psm_get_time(void)
+{
+	if (gPsmDbgLevel >= STP_PSM_LOG_LOUD)
+		osal_printtimeofday("<psm time>>>>");
+
+	return 0;
+}
+
+static inline INT32 _stp_psm_get_state(MTKSTP_PSM_T *stp_psm)
+{
+
+	if (stp_psm == NULL)
+		return STP_PSM_OPERATION_FAIL;
+
+	if (stp_psm->work_state < STP_PSM_MAX_STATE)
+		return stp_psm->work_state;
+	STP_PSM_ERR_FUNC("work_state = %d, invalid\n", stp_psm->work_state);
+
+			return STP_PSM_OPERATION_FAIL;
+}
+
+static inline INT32 _stp_psm_set_state(MTKSTP_PSM_T *stp_psm, const MTKSTP_PSM_STATE_T state)
+{
+	if (stp_psm == NULL)
+		return STP_PSM_OPERATION_FAIL;
+
+	if (stp_psm->work_state < STP_PSM_MAX_STATE) {
+		_stp_psm_get_time();
+		/* STP_PSM_INFO_FUNC("work_state = %s --> %s\n",
+		*	g_psm_state[stp_psm->work_state], g_psm_state[state]);
+		*/
+
+		stp_psm->work_state = state;
+		if (stp_psm->work_state != ACT) {
+			/* osal_lock_unsleepable_lock(&stp_psm->flagSpinlock); */
+			osal_set_bit(STP_PSM_BLOCK_DATA_EN, &stp_psm->flag);
+			_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+			/* osal_unlock_unsleepable_lock(&stp_psm->flagSpinlock); */
+		}
+	} else
+		STP_PSM_ERR_FUNC("work_state = %d, invalid\n", stp_psm->work_state);
+
+
+	return STP_PSM_OPERATION_SUCCESS;
+}
+
+static inline INT32 _stp_psm_start_monitor(MTKSTP_PSM_T *stp_psm)
+{
+
+	if (!stp_psm)
+		return STP_PSM_OPERATION_FAIL;
+
+	if (osal_test_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR, &stp_psm->flag)) {
+		STP_PSM_DBG_FUNC("STP-PSM DISABLE, DONT restart monitor!\n\r");
+		return STP_PSM_OPERATION_SUCCESS;
+	}
+
+	STP_PSM_LOUD_FUNC("start monitor\n");
+	osal_timer_modify(&stp_psm->psm_timer, stp_psm->idle_time_to_sleep);
+
+	return STP_PSM_OPERATION_SUCCESS;
+}
+
+static inline INT32 _stp_psm_stop_monitor(MTKSTP_PSM_T *stp_psm)
+{
+
+	if (!stp_psm)
+		return STP_PSM_OPERATION_FAIL;
+
+	STP_PSM_DBG_FUNC("stop monitor\n");
+	osal_timer_stop_sync(&stp_psm->psm_timer);
+
+	return STP_PSM_OPERATION_SUCCESS;
+}
+
+INT32 _stp_psm_hold_data(MTKSTP_PSM_T *stp_psm, const UINT8 *buffer, const UINT32 len, const UINT8 type)
+{
+	INT32 available_space = 0;
+	INT32 needed_space = 0;
+	UINT8 delimiter[] = { 0xbb, 0xbb };
+
+	if (!stp_psm)
+		return STP_PSM_OPERATION_FAIL;
+
+	osal_lock_sleepable_lock(&stp_psm->hold_fifo_spinlock_global);
+
+	available_space = STP_PSM_FIFO_SIZE - osal_fifo_len(&stp_psm->hold_fifo);
+	needed_space = len + sizeof(UINT8) + sizeof(UINT32) + 2;
+
+	/* STP_PSM_INFO_FUNC("*******FIFO Available(%d), Need(%d)\n", available_space, needed_space); */
+
+	if (available_space < needed_space) {
+		STP_PSM_ERR_FUNC("FIFO Available!! Reset FIFO\n");
+		osal_fifo_reset(&stp_psm->hold_fifo);
+	}
+	/* type */
+	osal_fifo_in(&stp_psm->hold_fifo, (PUINT8) &type, sizeof(UINT8));
+	/* length */
+	osal_fifo_in(&stp_psm->hold_fifo, (PUINT8) &len, sizeof(UINT32));
+	/* buffer */
+	osal_fifo_in(&stp_psm->hold_fifo, (PUINT8) buffer, len);
+	/* delimiter */
+	osal_fifo_in(&stp_psm->hold_fifo, (PUINT8) delimiter, 2);
+
+	osal_unlock_sleepable_lock(&stp_psm->hold_fifo_spinlock_global);
+
+	return len;
+
+}
+
+INT32 _stp_psm_has_pending_data(MTKSTP_PSM_T *stp_psm)
+{
+	return osal_fifo_len(&stp_psm->hold_fifo);
+}
+
+INT32 _stp_psm_release_data(MTKSTP_PSM_T *stp_psm)
+{
+
+	INT32 i = 20;		/*Max buffered packet number */
+	INT32 ret = 0;
+	UINT8 type = 0;
+	UINT32 len = 0;
+	UINT8 delimiter[2];
+
+	/* STP_PSM_ERR_FUNC("++++++++++release data++len=%d\n", osal_fifo_len(&stp_psm->hold_fifo)); */
+	while (osal_fifo_len(&stp_psm->hold_fifo) && i > 0) {
+		/* acquire spinlock */
+		osal_lock_sleepable_lock(&stp_psm->hold_fifo_spinlock_global);
+
+		ret = osal_fifo_out(&stp_psm->hold_fifo, (PUINT8) &type, sizeof(UINT8));
+		ret = osal_fifo_out(&stp_psm->hold_fifo, (PUINT8) &len, sizeof(UINT32));
+
+		if (len > STP_PSM_PACKET_SIZE_MAX) {
+			STP_PSM_ERR_FUNC("***psm packet's length too Long!****\n");
+			STP_PSM_INFO_FUNC("***reset psm's fifo***\n");
+		} else {
+			osal_memset(stp_psm->out_buf, 0, STP_PSM_TX_SIZE);
+			ret = osal_fifo_out(&stp_psm->hold_fifo, (PUINT8) stp_psm->out_buf, len);
+		}
+
+		ret = osal_fifo_out(&stp_psm->hold_fifo, (PUINT8) delimiter, 2);
+
+		if (delimiter[0] == 0xbb && delimiter[1] == 0xbb) {
+			/* osal_buffer_dump(stp_psm->out_buf, "psm->out_buf", len, 32); */
+			stp_send_data_no_ps(stp_psm->out_buf, len, type);
+		} else {
+			STP_PSM_ERR_FUNC("***psm packet fifo parsing fail****\n");
+			STP_PSM_INFO_FUNC("***reset psm's fifo***\n");
+
+			osal_fifo_reset(&stp_psm->hold_fifo);
+		}
+		i--;
+		osal_unlock_sleepable_lock(&stp_psm->hold_fifo_spinlock_global);
+	}
+	return STP_PSM_OPERATION_SUCCESS;
+}
+
+static inline INT32 _stp_psm_notify_wmt_host_awake_wq(MTKSTP_PSM_T *stp_psm)
+{
+
+	P_OSAL_OP pOp;
+	INT32 bRet;
+	INT32 retval;
+
+	if (stp_psm == NULL)
+		return STP_PSM_OPERATION_FAIL;
+
+	pOp = _stp_psm_get_free_op(stp_psm);
+	if (!pOp) {
+		STP_PSM_WARN_FUNC("get_free_lxop fail\n");
+		return -1;	/* break; */
+	}
+
+	pOp->op.opId = STP_OPID_PSM_HOST_AWAKE;
+	pOp->signal.timeoutValue = 0;
+	bRet = _stp_psm_put_act_op(stp_psm, pOp);
+
+	STP_PSM_DBG_FUNC("OPID(%d) type(%zd) bRet(%d)\n\n", pOp->op.opId, pOp->op.au4OpData[0], bRet);
+
+	retval = (0 == bRet) ? (STP_PSM_OPERATION_FAIL) : 0;
+
+	return retval;
+}
+
+static inline INT32 _stp_psm_notify_wmt_wakeup_wq(MTKSTP_PSM_T *stp_psm)
+{
+	P_OSAL_OP pOp;
+	INT32 bRet;
+	INT32 retval;
+
+	if (stp_psm == NULL)
+		return STP_PSM_OPERATION_FAIL;
+
+	pOp = _stp_psm_get_free_op(stp_psm);
+	if (!pOp) {
+		STP_PSM_WARN_FUNC("get_free_lxop fail\n");
+		return -1;	/* break; */
+	}
+
+	pOp->op.opId = STP_OPID_PSM_WAKEUP;
+	pOp->signal.timeoutValue = 0;
+	bRet = _stp_psm_put_act_op(stp_psm, pOp);
+	if (0 == bRet) {
+		STP_PSM_WARN_FUNC("OPID(%d) type(%zd) bRet(%s)\n\n",
+				  pOp->op.opId, pOp->op.au4OpData[0], "fail");
+	}
+	retval = (0 == bRet) ? (STP_PSM_OPERATION_FAIL) : (STP_PSM_OPERATION_SUCCESS);
+
+	return retval;
+}
+
+static inline INT32 _stp_psm_notify_wmt_sleep_wq(MTKSTP_PSM_T *stp_psm)
+{
+	P_OSAL_OP pOp;
+	INT32 bRet;
+	INT32 retval;
+
+	if (stp_psm == NULL)
+		return STP_PSM_OPERATION_FAIL;
+
+	if (osal_test_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR_TX_HIGH_DENSITY, &stp_psm->flag))
+		return 0;
+#if PSM_USE_COUNT_PACKAGE
+	if (osal_test_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR_RX_HIGH_DENSITY, &stp_psm->flag))
+		return 0;
+#endif
+	if (osal_test_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR, &stp_psm->flag))
+		return 0;
+
+	pOp = _stp_psm_get_free_op(stp_psm);
+	if (!pOp) {
+		STP_PSM_WARN_FUNC("get_free_lxop fail\n");
+		return -1;	/* break; */
+	}
+
+	pOp->op.opId = STP_OPID_PSM_SLEEP;
+	pOp->signal.timeoutValue = 0;
+	bRet = _stp_psm_put_act_op(stp_psm, pOp);
+
+	STP_PSM_DBG_FUNC("OPID(%d) type(%zd) bRet(%d)\n\n", pOp->op.opId, pOp->op.au4OpData[0], bRet);
+
+	retval = (0 == bRet) ? (STP_PSM_OPERATION_FAIL) : 1;
+
+	return retval;
+}
+
+/*internal function*/
+
+static inline INT32 _stp_psm_reset(MTKSTP_PSM_T *stp_psm)
+{
+	INT32 i = 0;
+	P_OSAL_OP_Q pOpQ;
+	P_OSAL_OP pOp;
+
+	STP_PSM_DBG_FUNC("PSM MODE RESET=============================>\n\r");
+
+	STP_PSM_DBG_FUNC("_stp_psm_reset\n");
+	STP_PSM_DBG_FUNC("reset-wake_lock(%d)\n", osal_wake_lock_count(&stp_psm->wake_lock));
+	osal_wake_unlock(&stp_psm->wake_lock);
+	STP_PSM_DBG_FUNC("reset-wake_lock(%d)\n", osal_wake_lock_count(&stp_psm->wake_lock));
+
+	/* --> disable psm <--// */
+	stp_psm->flag.data = 0;
+	osal_set_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR, &stp_psm->flag);
+	_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+	_stp_psm_stop_monitor(stp_psm);
+
+	/* --> prepare the op list <--// */
+	osal_lock_unsleepable_lock(&(stp_psm->wq_spinlock));
+	RB_INIT(&stp_psm->rFreeOpQ, STP_OP_BUF_SIZE);
+	RB_INIT(&stp_psm->rActiveOpQ, STP_OP_BUF_SIZE);
+
+	/* stp_psm->current_active_op = NULL; */
+	stp_psm->last_active_opId = STP_OPID_PSM_INALID;
+
+	pOpQ = &stp_psm->rFreeOpQ;
+	for (i = 0; i < STP_OP_BUF_SIZE; i++) {
+		if (!RB_FULL(pOpQ)) {
+			pOp = &stp_psm->arQue[i];
+			RB_PUT(pOpQ, pOp);
+		}
+	}
+	osal_unlock_unsleepable_lock(&(stp_psm->wq_spinlock));
+
+	/* --> clean up interal data structure<--// */
+	_stp_psm_set_state(stp_psm, ACT);
+
+	osal_lock_sleepable_lock(&stp_psm->hold_fifo_spinlock_global);
+	osal_fifo_reset(&stp_psm->hold_fifo);
+	osal_unlock_sleepable_lock(&stp_psm->hold_fifo_spinlock_global);
+
+	/* --> stop psm thread wait <--// */
+	osal_set_bit(STP_PSM_RESET_EN, &stp_psm->flag);
+	_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+	osal_trigger_event(&stp_psm->wait_wmt_q);
+
+	STP_PSM_DBG_FUNC("PSM MODE RESET<============================\n\r");
+
+	return STP_PSM_OPERATION_SUCCESS;
+}
+
+static INT32 _stp_psm_wait_wmt_event(void *pvData)
+{
+	MTKSTP_PSM_T *stp_psm = (MTKSTP_PSM_T *) pvData;
+
+	STP_PSM_DBG_FUNC("%s, stp_psm->flag= %ld\n", __func__, stp_psm->flag.data);
+
+	return (osal_test_bit(STP_PSM_WMT_EVENT_SLEEP_EN, &stp_psm->flag)) ||
+		(osal_test_bit(STP_PSM_WMT_EVENT_WAKEUP_EN, &stp_psm->flag)) ||
+		(osal_test_bit(STP_PSM_WMT_EVENT_ROLL_BACK_EN, &stp_psm->flag)) ||
+		(osal_test_bit(STP_PSM_RESET_EN, &stp_psm->flag));
+}
+
+static inline INT32 _stp_psm_wait_wmt_event_wq(MTKSTP_PSM_T *stp_psm)
+{
+
+	INT32 retval = 0;
+
+	if (stp_psm == NULL)
+		return STP_PSM_OPERATION_FAIL;
+
+	osal_wait_for_event_timeout(&stp_psm->wait_wmt_q, _stp_psm_wait_wmt_event, (void *)stp_psm);
+
+	if (osal_test_bit(STP_PSM_WMT_EVENT_WAKEUP_EN, &stp_psm->flag)) {
+		osal_clear_bit(STP_PSM_WMT_EVENT_WAKEUP_EN, &stp_psm->flag);
+		_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+/* osal_lock_unsleepable_lock(&stp_psm->flagSpinlock); */
+		/* STP send data here: STP enqueue data to psm buffer. */
+		_stp_psm_release_data(stp_psm);
+		/* STP send data here: STP enqueue data to psm buffer. We release packet by the next one. */
+		osal_clear_bit(STP_PSM_BLOCK_DATA_EN, &stp_psm->flag);
+		_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+		/* STP send data here: STP sends data directly without PSM. */
+		_stp_psm_set_state(stp_psm, ACT);
+/* osal_unlock_unsleepable_lock(&stp_psm->flagSpinlock); */
+
+		if (stp_psm_is_quick_ps_support())
+			stp_psm_notify_wmt_sleep(stp_psm);
+		else
+			_stp_psm_start_monitor(stp_psm);
+	} else if (osal_test_bit(STP_PSM_WMT_EVENT_SLEEP_EN, &stp_psm->flag)) {
+		osal_clear_bit(STP_PSM_WMT_EVENT_SLEEP_EN, &stp_psm->flag);
+		_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+		_stp_psm_set_state(stp_psm, INACT);
+
+		STP_PSM_DBG_FUNC("mt_combo_plt_enter_deep_idle++\n");
+		mt_combo_plt_enter_deep_idle(COMBO_IF_BTIF);
+		STP_PSM_DBG_FUNC("mt_combo_plt_enter_deep_idle--\n");
+
+		STP_PSM_DBG_FUNC("sleep-wake_lock(%d)\n", osal_wake_lock_count(&stp_psm->wake_lock));
+		osal_wake_unlock(&stp_psm->wake_lock);
+		STP_PSM_DBG_FUNC("sleep-wake_lock#(%d)\n", osal_wake_lock_count(&stp_psm->wake_lock));
+	} else if (osal_test_bit(STP_PSM_WMT_EVENT_ROLL_BACK_EN, &stp_psm->flag)) {
+		osal_clear_bit(STP_PSM_WMT_EVENT_ROLL_BACK_EN, &stp_psm->flag);
+		_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+		if (_stp_psm_get_state(stp_psm) == ACT_INACT) {
+			/* osal_lock_unsleepable_lock(&stp_psm->flagSpinlock); */
+			_stp_psm_release_data(stp_psm);
+			osal_clear_bit(STP_PSM_BLOCK_DATA_EN, &stp_psm->flag);
+			_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+			_stp_psm_set_state(stp_psm, ACT);
+			/* osal_unlock_unsleepable_lock(&stp_psm->flagSpinlock); */
+		} else if (_stp_psm_get_state(stp_psm) == INACT_ACT) {
+			_stp_psm_set_state(stp_psm, INACT);
+			STP_PSM_INFO_FUNC("[WARNING]PSM state rollback due too wakeup fail\n");
+		}
+	} else if (osal_test_bit(STP_PSM_RESET_EN, &stp_psm->flag)) {
+		osal_clear_bit(STP_PSM_WMT_EVENT_ROLL_BACK_EN, &stp_psm->flag);
+		_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+	} else {
+		STP_PSM_ERR_FUNC("flag = %ld<== Abnormal flag be set!!\n\r", stp_psm->flag.data);
+		STP_PSM_ERR_FUNC("state = %d, flag = %ld\n", stp_psm->work_state, stp_psm->flag.data);
+		wcn_psm_flag_trigger_collect_ftrace();	/* trigger collect SYS_FTRACE */
+		_stp_psm_dbg_out_printk(g_stp_psm_dbg);
+	}
+	retval = STP_PSM_OPERATION_SUCCESS;
+
+	return retval;
+}
+
+static inline INT32 _stp_psm_notify_stp(MTKSTP_PSM_T *stp_psm, const MTKSTP_PSM_ACTION_T action)
+{
+
+	INT32 retval = 0;
+
+	if (action == EIRQ) {
+		STP_PSM_DBG_FUNC("Call _stp_psm_notify_wmt_host_awake_wq\n\r");
+
+		_stp_psm_notify_wmt_host_awake_wq(stp_psm);
+
+		return STP_PSM_OPERATION_FAIL;
+	}
+
+	if ((_stp_psm_get_state(stp_psm) < STP_PSM_MAX_STATE) && (_stp_psm_get_state(stp_psm) >= 0)) {
+		STP_PSM_DBG_FUNC("state = %s, action=%s\n\r", g_psm_state[_stp_psm_get_state(stp_psm)],
+				 g_psm_action[action]);
+	}
+	/* If STP trigger WAKEUP and SLEEP, to do the job below */
+	switch (_stp_psm_get_state(stp_psm)) {
+		/* stp trigger */
+	case ACT_INACT:
+
+		if (action == SLEEP) {
+			STP_PSM_LOUD_FUNC("Action = %s, ACT_INACT state, ready to INACT\n\r", g_psm_action[action]);
+			osal_clear_bit(STP_PSM_WMT_EVENT_WAKEUP_EN, &stp_psm->flag);
+			_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+			osal_set_bit(STP_PSM_WMT_EVENT_SLEEP_EN, &stp_psm->flag);
+			_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+			/* wake_up(&stp_psm->wait_wmt_q); */
+			osal_trigger_event(&stp_psm->wait_wmt_q);
+		} else if (action == ROLL_BACK) {
+			STP_PSM_LOUD_FUNC("Action = %s, ACT_INACT state, back to ACT\n\r", g_psm_action[action]);
+			/* stp_psm->flag &= ~STP_PSM_WMT_EVENT_ROLL_BACK_EN; */
+			osal_set_bit(STP_PSM_WMT_EVENT_ROLL_BACK_EN, &stp_psm->flag);
+			_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+			/* wake_up(&stp_psm->wait_wmt_q); */
+			osal_trigger_event(&stp_psm->wait_wmt_q);
+		} else {
+			if (action < STP_PSM_MAX_ACTION) {
+				STP_PSM_ERR_FUNC("Action = %s, ACT_INACT state, the case should not happens\n\r",
+						 g_psm_action[action]);
+				STP_PSM_ERR_FUNC("state = %d, flag = %ld\n", stp_psm->work_state, stp_psm->flag.data);
+			} else {
+				STP_PSM_ERR_FUNC("Invalid Action!!\n\r");
+			}
+			_stp_psm_dbg_out_printk(g_stp_psm_dbg);
+			retval = STP_PSM_OPERATION_FAIL;
+		}
+		break;
+		/* stp trigger */
+
+	case INACT_ACT:
+
+		if (action == WAKEUP) {
+			STP_PSM_LOUD_FUNC("Action = %s, INACT_ACT state, ready to ACT\n\r", g_psm_action[action]);
+			osal_clear_bit(STP_PSM_WMT_EVENT_SLEEP_EN, &stp_psm->flag);
+			_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+			osal_set_bit(STP_PSM_WMT_EVENT_WAKEUP_EN, &stp_psm->flag);
+			_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+			/* wake_up(&stp_psm->wait_wmt_q); */
+			osal_trigger_event(&stp_psm->wait_wmt_q);
+		} else if (action == HOST_AWAKE) {
+			STP_PSM_LOUD_FUNC("Action = %s, INACT_ACT state, ready to ACT\n\r", g_psm_action[action]);
+			osal_clear_bit(STP_PSM_WMT_EVENT_SLEEP_EN, &stp_psm->flag);
+			_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+			osal_set_bit(STP_PSM_WMT_EVENT_WAKEUP_EN, &stp_psm->flag);
+			_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+			/* wake_up(&stp_psm->wait_wmt_q); */
+			osal_trigger_event(&stp_psm->wait_wmt_q);
+		} else if (action == ROLL_BACK) {
+			STP_PSM_LOUD_FUNC("Action = %s, INACT_ACT state, back to INACT\n\r", g_psm_action[action]);
+			osal_set_bit(STP_PSM_WMT_EVENT_ROLL_BACK_EN, &stp_psm->flag);
+			_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+			/* wake_up(&stp_psm->wait_wmt_q); */
+			osal_trigger_event(&stp_psm->wait_wmt_q);
+		} else {
+			if (action < STP_PSM_MAX_ACTION) {
+				STP_PSM_ERR_FUNC("Action = %s, INACT_ACT state, the case should not happens\n\r",
+						 g_psm_action[action]);
+				STP_PSM_ERR_FUNC("state = %d, flag = %ld\n", stp_psm->work_state, stp_psm->flag.data);
+			} else {
+				STP_PSM_ERR_FUNC("Invalid Action!!\n\r");
+			}
+			_stp_psm_dbg_out_printk(g_stp_psm_dbg);
+			retval = STP_PSM_OPERATION_FAIL;
+		}
+		break;
+
+	case INACT:
+
+		if (action < STP_PSM_MAX_ACTION) {
+			STP_PSM_ERR_FUNC("Action = %s, INACT state, the case should not happens\n\r",
+					 g_psm_action[action]);
+			STP_PSM_ERR_FUNC("state = %d, flag = %ld\n", stp_psm->work_state, stp_psm->flag.data);
+		} else {
+			STP_PSM_ERR_FUNC("Invalid Action!!\n\r");
+		}
+		_stp_psm_dbg_out_printk(g_stp_psm_dbg);
+		retval = -1;
+
+		break;
+
+	case ACT:
+
+		if (action < STP_PSM_MAX_ACTION) {
+			STP_PSM_ERR_FUNC("Action = %s, ACT state, the case should not happens\n\r",
+					 g_psm_action[action]);
+			STP_PSM_ERR_FUNC("state = %d, flag = %ld\n", stp_psm->work_state, stp_psm->flag.data);
+		} else {
+			STP_PSM_ERR_FUNC("Invalid Action!!\n\r");
+		}
+		_stp_psm_dbg_out_printk(g_stp_psm_dbg);
+		retval = STP_PSM_OPERATION_FAIL;
+
+		break;
+
+	default:
+
+		/*invalid */
+		if (action < STP_PSM_MAX_ACTION) {
+			STP_PSM_ERR_FUNC("Action = %s, Invalid state, the case should not happens\n\r",
+					 g_psm_action[action]);
+			STP_PSM_ERR_FUNC("state = %d, flag = %ld\n", stp_psm->work_state, stp_psm->flag.data);
+		} else {
+			STP_PSM_ERR_FUNC("Invalid Action!!\n\r");
+		}
+		_stp_psm_dbg_out_printk(g_stp_psm_dbg);
+		retval = STP_PSM_OPERATION_FAIL;
+
+		break;
+	}
+
+	return retval;
+
+}
+
+static inline INT32 _stp_psm_notify_wmt(MTKSTP_PSM_T *stp_psm, const MTKSTP_PSM_ACTION_T action)
+{
+	INT32 ret = 0;
+
+	if (stp_psm == NULL)
+		return STP_PSM_OPERATION_FAIL;
+
+	switch (_stp_psm_get_state(stp_psm)) {
+	case ACT:
+
+		if (action == SLEEP) {
+			if (osal_test_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR, &stp_psm->flag)) {
+				STP_PSM_ERR_FUNC("psm monitor disabled, can't do sleep op\n");
+				return STP_PSM_OPERATION_FAIL;
+			}
+
+			_stp_psm_set_state(stp_psm, ACT_INACT);
+
+			_stp_psm_release_data(stp_psm);
+
+			if (stp_psm->wmt_notify) {
+				stp_psm->wmt_notify(SLEEP);
+				_stp_psm_wait_wmt_event_wq(stp_psm);
+			} else {
+				STP_PSM_ERR_FUNC("stp_psm->wmt_notify = NULL\n");
+				ret = STP_PSM_OPERATION_FAIL;
+			}
+		} else if (action == WAKEUP || action == HOST_AWAKE) {
+			STP_PSM_INFO_FUNC("In ACT state, dont do WAKEUP/HOST_AWAKE again\n");
+			_stp_psm_release_data(stp_psm);
+		} else {
+			STP_PSM_ERR_FUNC("invalid operation, the case should not happen\n");
+			STP_PSM_ERR_FUNC("state = %d, flag = %ld\n", stp_psm->work_state, stp_psm->flag.data);
+			_stp_psm_dbg_out_printk(g_stp_psm_dbg);
+			ret = STP_PSM_OPERATION_FAIL;
+
+		}
+
+		break;
+
+	case INACT:
+
+		if (action == WAKEUP) {
+			_stp_psm_set_state(stp_psm, INACT_ACT);
+
+			if (stp_psm->wmt_notify) {
+				STP_PSM_DBG_FUNC("wakeup +wake_lock(%d)\n", osal_wake_lock_count(&stp_psm->wake_lock));
+				osal_wake_lock(&stp_psm->wake_lock);
+				STP_PSM_DBG_FUNC("wakeup +wake_lock(%d)#\n", osal_wake_lock_count(&stp_psm->wake_lock));
+
+				STP_PSM_DBG_FUNC("mt_combo_plt_exit_deep_idle++\n");
+				mt_combo_plt_exit_deep_idle(COMBO_IF_BTIF);
+				STP_PSM_DBG_FUNC("mt_combo_plt_exit_deep_idle--\n");
+
+				stp_psm->wmt_notify(WAKEUP);
+				_stp_psm_wait_wmt_event_wq(stp_psm);
+			} else {
+				STP_PSM_ERR_FUNC("stp_psm->wmt_notify = NULL\n");
+				ret = STP_PSM_OPERATION_FAIL;
+			}
+		} else if (action == HOST_AWAKE) {
+			_stp_psm_set_state(stp_psm, INACT_ACT);
+
+			if (stp_psm->wmt_notify) {
+				STP_PSM_DBG_FUNC("host awake +wake_lock(%d)\n",
+						 osal_wake_lock_count(&stp_psm->wake_lock));
+				osal_wake_lock(&stp_psm->wake_lock);
+				STP_PSM_DBG_FUNC("host awake +wake_lock(%d)#\n",
+						 osal_wake_lock_count(&stp_psm->wake_lock));
+
+				STP_PSM_DBG_FUNC("mt_combo_plt_exit_deep_idle++\n");
+				mt_combo_plt_exit_deep_idle(COMBO_IF_BTIF);
+				STP_PSM_DBG_FUNC("mt_combo_plt_exit_deep_idle--\n");
+
+				stp_psm->wmt_notify(HOST_AWAKE);
+				_stp_psm_wait_wmt_event_wq(stp_psm);
+			} else {
+				STP_PSM_ERR_FUNC("stp_psm->wmt_notify = NULL\n");
+				ret = STP_PSM_OPERATION_FAIL;
+			}
+		} else if (action == SLEEP) {
+			STP_PSM_INFO_FUNC("In INACT state, dont do SLEEP again\n");
+		} else {
+			STP_PSM_ERR_FUNC("invalid operation, the case should not happen\n");
+			STP_PSM_ERR_FUNC("state = %d, flag = %ld\n", stp_psm->work_state, stp_psm->flag.data);
+			_stp_psm_dbg_out_printk(g_stp_psm_dbg);
+			ret = STP_PSM_OPERATION_FAIL;
+		}
+
+		break;
+
+	default:
+
+		/*invalid */
+		STP_PSM_ERR_FUNC("invalid state, the case should not happen\n");
+		STP_PSM_ERR_FUNC("state = %d, flag = %ld\n", stp_psm->work_state, stp_psm->flag.data);
+		_stp_psm_dbg_out_printk(g_stp_psm_dbg);
+		ret = STP_PSM_OPERATION_FAIL;
+
+		break;
+	}
+	return ret;
+}
+
+static inline void _stp_psm_stp_is_idle(/*unsigned long data*/struct timer_list *t)
+{
+	//MTKSTP_PSM_T *stp_psm = (MTKSTP_PSM_T *) data;
+	MTKSTP_PSM_T *stp_psm = from_timer(stp_psm,t,psm_timer.timer);
+
+	osal_clear_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR_RX_HIGH_DENSITY, &stp_psm->flag);
+	_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+	osal_clear_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR_TX_HIGH_DENSITY, &stp_psm->flag);
+	_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+	if (osal_test_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR, &stp_psm->flag)) {
+		STP_PSM_DBG_FUNC("STP-PSM DISABLE!\n");
+		return;
+	}
+
+	if (1 == _stp_psm_notify_wmt_sleep_wq(stp_psm))
+		STP_PSM_INFO_FUNC("**IDLE is over %d msec, go to sleep!!!**\n", stp_psm->idle_time_to_sleep);
+}
+
+static inline INT32 _stp_psm_init_monitor(MTKSTP_PSM_T *stp_psm)
+{
+	if (!stp_psm)
+		return STP_PSM_OPERATION_FAIL;
+
+	STP_PSM_INFO_FUNC("init monitor\n");
+
+	stp_psm->psm_timer.timeoutHandler = _stp_psm_stp_is_idle;
+	stp_psm->psm_timer.timeroutHandlerData = (unsigned long)stp_psm;
+	osal_timer_create(&stp_psm->psm_timer);
+
+	return STP_PSM_OPERATION_SUCCESS;
+}
+
+static inline INT32 _stp_psm_deinit_monitor(MTKSTP_PSM_T *stp_psm)
+{
+
+	if (!stp_psm)
+		return STP_PSM_OPERATION_FAIL;
+
+	STP_PSM_INFO_FUNC("deinit monitor\n");
+
+	osal_timer_stop_sync(&stp_psm->psm_timer);
+
+	return 0;
+}
+
+static inline INT32 _stp_psm_is_to_block_traffic(MTKSTP_PSM_T *stp_psm)
+{
+	INT32 iRet = -1;
+
+/* osal_lock_unsleepable_lock(&stp_psm->flagSpinlock); */
+
+	if (osal_test_bit(STP_PSM_BLOCK_DATA_EN, &stp_psm->flag))
+		iRet = 1;
+	else
+		iRet = 0;
+
+/* osal_unlock_unsleepable_lock(&stp_psm->flagSpinlock); */
+	return iRet;
+}
+
+static inline INT32 _stp_psm_is_disable(MTKSTP_PSM_T *stp_psm)
+{
+	if (osal_test_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR, &stp_psm->flag))
+		return 1;
+	else
+		return 0;
+}
+
+static inline INT32 _stp_psm_do_wait(MTKSTP_PSM_T *stp_psm, MTKSTP_PSM_STATE_T state)
+{
+
+#define POLL_WAIT 20		/* 200 */
+#define POLL_WAIT_TIME 2000
+
+	INT32 i = 0;
+	INT32 limit = POLL_WAIT_TIME / POLL_WAIT;
+
+	while (_stp_psm_get_state(stp_psm) != state && i < limit) {
+		osal_sleep_ms(POLL_WAIT);
+		i++;
+		STP_PSM_INFO_FUNC("STP is waiting state for %s, i=%d, state = %d\n", g_psm_state[state], i,
+				  _stp_psm_get_state(stp_psm));
+	}
+
+	if (i == limit) {
+		STP_PSM_WARN_FUNC("-Wait for %s takes %d msec\n", g_psm_state[state], i * POLL_WAIT);
+		_stp_psm_opid_dbg_out_printk(g_stp_psm_opid_dbg);
+		return STP_PSM_OPERATION_FAIL;
+	}
+	STP_PSM_DBG_FUNC("+Total waits for %s takes %d msec\n", g_psm_state[state], i * POLL_WAIT);
+	/* _stp_psm_dbg_out_printk(g_stp_psm_opid_dbg); */
+	return STP_PSM_OPERATION_SUCCESS;
+}
+
+static inline INT32 _stp_psm_do_wakeup(MTKSTP_PSM_T *stp_psm)
+{
+
+	INT32 ret = 0;
+	INT32 retry = 10;
+	P_OSAL_OP_Q pOpQ;
+	P_OSAL_OP pOp;
+
+	STP_PSM_LOUD_FUNC("*** Do Force Wakeup!***\n\r");
+
+	/* <1>If timer is active, we will stop it. */
+	_stp_psm_stop_monitor(stp_psm);
+
+	osal_lock_unsleepable_lock(&(stp_psm->wq_spinlock));
+
+	pOpQ = &stp_psm->rFreeOpQ;
+
+	while (!RB_EMPTY(&stp_psm->rActiveOpQ)) {
+		RB_GET(&stp_psm->rActiveOpQ, pOp);
+		if (NULL != pOp && !RB_FULL(pOpQ)) {
+			STP_PSM_DBG_FUNC("opid = %d\n", pOp->op.opId);
+			RB_PUT(pOpQ, pOp);
+		} else {
+			STP_PSM_ERR_FUNC("clear up active queue fail, freeQ full\n");
+		}
+	}
+	osal_unlock_unsleepable_lock(&(stp_psm->wq_spinlock));
+	/* <5>We issue wakeup request into op queue. and wait for active. */
+	do {
+		ret = _stp_psm_notify_wmt_wakeup_wq(stp_psm);
+
+		if (ret == STP_PSM_OPERATION_SUCCESS) {
+			ret = _stp_psm_do_wait(stp_psm, ACT);
+
+			/* STP_PSM_INFO_FUNC("<< wait ret = %d, num of activeQ = %d\n",
+			*	ret,  RB_COUNT(&stp_psm->rActiveOpQ));
+			*/
+			if (ret == STP_PSM_OPERATION_SUCCESS)
+				break;
+		} else
+			STP_PSM_ERR_FUNC("_stp_psm_notify_wmt_wakeup_wq fail!!\n");
+
+		/* STP_PSM_INFO_FUNC("retry = %d\n", retry); */
+		retry--;
+
+		if (retry == 0)
+			break;
+	} while (1);
+
+	if (retry == 0)
+		return STP_PSM_OPERATION_FAIL;
+	else
+		return STP_PSM_OPERATION_SUCCESS;
+}
+
+static inline INT32 _stp_psm_disable(MTKSTP_PSM_T *stp_psm)
+{
+	INT32 ret = STP_PSM_OPERATION_FAIL;
+
+	STP_PSM_DBG_FUNC("PSM Disable start\n\r");
+
+	osal_set_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR, &stp_psm->flag);
+	_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+	ret = _stp_psm_do_wakeup(stp_psm);
+	if (ret == STP_PSM_OPERATION_SUCCESS)
+		STP_PSM_DBG_FUNC("PSM Disable Success\n");
+	else
+		STP_PSM_ERR_FUNC("***PSM Disable Fail***\n");
+
+	return ret;
+}
+
+static inline INT32 _stp_psm_enable(MTKSTP_PSM_T *stp_psm, INT32 idle_time_to_sleep)
+{
+	INT32 ret = STP_PSM_OPERATION_FAIL;
+
+	STP_PSM_LOUD_FUNC("PSM Enable start\n\r");
+
+	osal_set_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR, &stp_psm->flag);
+	_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+
+	ret = _stp_psm_do_wakeup(stp_psm);
+	if (ret == STP_PSM_OPERATION_SUCCESS) {
+		osal_clear_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR, &stp_psm->flag);
+		_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+		stp_psm->idle_time_to_sleep = idle_time_to_sleep;
+
+		if (osal_wake_lock_count(&stp_psm->wake_lock) == 0) {
+			STP_PSM_DBG_FUNC("psm_en+wake_lock(%d)\n", osal_wake_lock_count(&stp_psm->wake_lock));
+			osal_wake_lock(&stp_psm->wake_lock);
+			STP_PSM_DBG_FUNC("psm_en+wake_lock(%d)#\n", osal_wake_lock_count(&stp_psm->wake_lock));
+		}
+
+		_stp_psm_start_monitor(stp_psm);
+
+		STP_PSM_DBG_FUNC("PSM Enable succeed\n\r");
+	} else
+		STP_PSM_ERR_FUNC("***PSM Enable Fail***\n");
+
+	return ret;
+}
+
+INT32 _stp_psm_thread_lock_aquire(MTKSTP_PSM_T *stp_psm)
+{
+	return osal_lock_sleepable_lock(&stp_psm->stp_psm_lock);
+}
+
+INT32 _stp_psm_thread_lock_release(MTKSTP_PSM_T *stp_psm)
+{
+	osal_unlock_sleepable_lock(&stp_psm->stp_psm_lock);
+	return 0;
+}
+
+MTK_WCN_BOOL _stp_psm_is_quick_ps_support(VOID)
+{
+	if (stp_psm->is_wmt_quick_ps_support)
+		return (*(stp_psm->is_wmt_quick_ps_support)) ();
+
+	STP_PSM_DBG_FUNC("stp_psm->is_wmt_quick_ps_support is NULL, return false\n\r");
+	return MTK_WCN_BOOL_FALSE;
+}
+
+MTK_WCN_BOOL stp_psm_is_quick_ps_support(VOID)
+{
+	return _stp_psm_is_quick_ps_support();
+}
+
+#if PSM_USE_COUNT_PACKAGE
+int stp_psm_disable_by_tx_rx_density(MTKSTP_PSM_T *stp_psm, int dir)
+{
+
+	/* easy the variable maintain beween stp tx, rx thread. */
+	/* so we create variable for tx, rx respectively. */
+
+	static int tx_cnt;
+	static int rx_cnt;
+	static int is_tx_first = 1;
+	static int is_rx_first = 1;
+	static unsigned long tx_end_time;
+	static unsigned long rx_end_time;
+
+	/*  */
+	/* BT A2DP                  TX CNT = 220, RX CNT = 843 */
+	/* BT FTP Transferring  TX CNT = 574, RX CNT = 2233 (1228~1588) */
+	/* BT FTP Receiving      TX CNT = 204, RX CNT = 3301 (2072~2515) */
+	/* BT OPP  Tx               TX_CNT= 330, RX CNT = 1300~1800 */
+	/* BT OPP  Rx               TX_CNT= (109~157), RX CNT = 1681~2436 */
+	if (dir == 0) {		/* tx */
+
+		tx_cnt++;
+
+		if (((long)jiffies - (long)tx_end_time >= 0) || (is_tx_first)) {
+			tx_end_time = jiffies + (3 * HZ);
+			STP_PSM_INFO_FUNC("tx cnt = %d in the previous 3 sec\n", tx_cnt);
+			/* if(tx_cnt > 400)//for high traffic , not to do sleep. */
+			if (tx_cnt > 300) {
+				osal_set_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR_TX_HIGH_DENSITY, &stp_psm->flag);
+				_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+				stp_psm_start_monitor(stp_psm);
+			} else {
+				osal_clear_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR_TX_HIGH_DENSITY, &stp_psm->flag);
+				_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+			}
+			tx_cnt = 0;
+			if (is_tx_first)
+				is_tx_first = 0;
+		}
+	} else {
+		rx_cnt++;
+
+		if (((long)jiffies - (long)rx_end_time >= 0) || (is_rx_first)) {
+			rx_end_time = jiffies + (3 * HZ);
+			STP_PSM_INFO_FUNC("rx cnt = %d in the previous 3 sec\n", rx_cnt);
+
+			/* if(rx_cnt > 2000)//for high traffic , not to do sleep. */
+			if (rx_cnt > 1200) {	/* for high traffic , not to do sleep. */
+				osal_set_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR_RX_HIGH_DENSITY, &stp_psm->flag);
+				_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+				stp_psm_start_monitor(stp_psm);
+			} else {
+				osal_clear_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR_RX_HIGH_DENSITY, &stp_psm->flag);
+				_stp_psm_dbg_dmp_in(g_stp_psm_dbg, stp_psm->flag.data, __LINE__);
+			}
+			rx_cnt = 0;
+			if (is_rx_first)
+				is_rx_first = 0;
+		}
+	}
+
+	return 0;
+}
+
+#else
+static struct timeval tv_now, tv_end;
+static INT32 sample_start;
+static INT32 tx_sum_len;
+static INT32 rx_sum_len;
+
+INT32 stp_psm_disable_by_tx_rx_density(MTKSTP_PSM_T *stp_psm, INT32 dir, INT32 length)
+{
+	if (sample_start) {
+		if (dir)
+			rx_sum_len += length;
+		else
+			tx_sum_len += length;
+
+		do_gettimeofday(&tv_now);
+		/* STP_PSM_INFO_FUNC("tv_now:%d.%d tv_end:%d.%d\n",
+		*	tv_now.tv_sec,tv_now.tv_usec,tv_end.tv_sec,tv_end.tv_usec);
+		*/
+		if (((tv_now.tv_sec == tv_end.tv_sec) && (tv_now.tv_usec > tv_end.tv_usec)) ||
+		    (tv_now.tv_sec > tv_end.tv_sec)) {
+			STP_PSM_INFO_FUNC("STP speed rx:%d tx:%d\n", rx_sum_len, tx_sum_len);
+			if ((rx_sum_len + tx_sum_len) > RTX_SPEED_THRESHOLD) {
+				/* STP_PSM_INFO_FUNC("High speed,Disable monitor\n"); */
+				osal_set_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR_TX_HIGH_DENSITY, &stp_psm->flag);
+				stp_psm->idle_time_to_sleep = STP_PSM_IDLE_TIME_SLEEP_1000;
+				stp_psm_start_monitor(stp_psm);
+			} else {
+				/* STP_PSM_INFO_FUNC("Low speed,Enable monitor\n"); */
+				stp_psm->idle_time_to_sleep = STP_PSM_IDLE_TIME_SLEEP;
+				osal_clear_bit(STP_PSM_WMT_EVENT_DISABLE_MONITOR_TX_HIGH_DENSITY, &stp_psm->flag);
+			}
+			sample_start = 0;
+			rx_sum_len = 0;
+			tx_sum_len = 0;
+		}
+	} else {
+		sample_start = 1;
+		do_gettimeofday(&tv_now);
+		tv_end = tv_now;
+		tv_end.tv_sec += SAMPLE_DURATION;
+	}
+
+	return 0;
+}
+#endif
+
+/*external function for WMT module to do sleep/wakeup*/
+INT32 stp_psm_set_state(MTKSTP_PSM_T *stp_psm, MTKSTP_PSM_STATE_T state)
+{
+	return _stp_psm_set_state(stp_psm, state);
+}
+
+INT32 stp_psm_thread_lock_aquire(MTKSTP_PSM_T *stp_psm)
+{
+	return _stp_psm_thread_lock_aquire(stp_psm);
+}
+
+INT32 stp_psm_thread_lock_release(MTKSTP_PSM_T *stp_psm)
+{
+	return _stp_psm_thread_lock_release(stp_psm);
+}
+
+INT32 stp_psm_do_wakeup(MTKSTP_PSM_T *stp_psm)
+{
+	return _stp_psm_do_wakeup(stp_psm);
+}
+
+INT32 stp_psm_notify_stp(MTKSTP_PSM_T *stp_psm, const MTKSTP_PSM_ACTION_T action)
+{
+
+	return _stp_psm_notify_stp(stp_psm, action);
+}
+
+INT32 stp_psm_notify_wmt_wakeup(MTKSTP_PSM_T *stp_psm)
+{
+	return _stp_psm_notify_wmt_wakeup_wq(stp_psm);
+}
+
+int stp_psm_notify_wmt_sleep(MTKSTP_PSM_T *stp_psm)
+{
+
+	return _stp_psm_notify_wmt_sleep_wq(stp_psm);
+}
+
+INT32 stp_psm_start_monitor(MTKSTP_PSM_T *stp_psm)
+{
+	return _stp_psm_start_monitor(stp_psm);
+}
+
+INT32 stp_psm_is_to_block_traffic(MTKSTP_PSM_T *stp_psm)
+{
+	return _stp_psm_is_to_block_traffic(stp_psm);
+}
+
+INT32 stp_psm_is_disable(MTKSTP_PSM_T *stp_psm)
+{
+	return _stp_psm_is_disable(stp_psm);
+}
+
+INT32 stp_psm_has_pending_data(MTKSTP_PSM_T *stp_psm)
+{
+	return _stp_psm_has_pending_data(stp_psm);
+}
+
+INT32 stp_psm_release_data(MTKSTP_PSM_T *stp_psm)
+{
+	return _stp_psm_release_data(stp_psm);
+}
+
+INT32 stp_psm_hold_data(MTKSTP_PSM_T *stp_psm, const UINT8 *buffer, const UINT32 len, const UINT8 type)
+{
+	return _stp_psm_hold_data(stp_psm, buffer, len, type);
+}
+
+INT32 stp_psm_disable(MTKSTP_PSM_T *stp_psm)
+{
+	return _stp_psm_disable(stp_psm);
+}
+
+INT32 stp_psm_enable(MTKSTP_PSM_T *stp_psm, INT32 idle_time_to_sleep)
+{
+	return _stp_psm_enable(stp_psm, idle_time_to_sleep);
+}
+
+INT32 stp_psm_reset(MTKSTP_PSM_T *stp_psm)
+{
+	stp_psm_set_sleep_enable(stp_psm);
+
+	return _stp_psm_reset(stp_psm);
+}
+
+INT32 stp_psm_sleep_for_thermal(MTKSTP_PSM_T *stp_psm)
+{
+	return _stp_psm_notify_wmt_sleep_wq(stp_psm);
+}
+
+INT32 stp_psm_set_sleep_enable(MTKSTP_PSM_T *stp_psm)
+{
+	INT32 ret = 0;
+
+	if (stp_psm) {
+		stp_psm->sleep_en = 1;
+		STP_PSM_DBG_FUNC("\n");
+		ret = 0;
+	} else {
+		STP_PSM_INFO_FUNC("Null pointer\n");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+INT32 stp_psm_set_sleep_disable(MTKSTP_PSM_T *stp_psm)
+{
+	INT32 ret = 0;
+
+	if (stp_psm) {
+		stp_psm->sleep_en = 0;
+		STP_PSM_DBG_FUNC("\n");
+		ret = 0;
+	} else {
+		STP_PSM_INFO_FUNC("Null pointer\n");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+/* stp_psm_check_sleep_enable  - to check if sleep cmd is enabled or not
+ * @ stp_psm - pointer of psm
+ *
+ * return 1 if sleep is enabled; else return 0 if disabled; else error code
+ */
+INT32 stp_psm_check_sleep_enable(MTKSTP_PSM_T *stp_psm)
+{
+	INT32 ret = 0;
+
+	if (stp_psm) {
+		ret = stp_psm->sleep_en;
+		STP_PSM_DBG_FUNC("%s\n", ret ? "enabled" : "disabled");
+	} else {
+		STP_PSM_INFO_FUNC("Null pointer\n");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static INT32 _stp_psm_dbg_dmp_in(STP_PSM_RECORD_T *stp_psm_dbg, UINT32 flag, UINT32 line_num)
+{
+	INT32 index = 0;
+	struct timeval now;
+
+	if (stp_psm_dbg) {
+		osal_lock_unsleepable_lock(&stp_psm_dbg->lock);
+		do_gettimeofday(&now);
+		index = stp_psm_dbg->in - 1;
+		index = (index + STP_PSM_DBG_SIZE) % STP_PSM_DBG_SIZE;
+		STP_PSM_DBG_FUNC("index(%d)\n", index);
+		stp_psm_dbg->queue[stp_psm_dbg->in].prev_flag = stp_psm_dbg->queue[index].cur_flag;
+		stp_psm_dbg->queue[stp_psm_dbg->in].cur_flag = flag;
+		stp_psm_dbg->queue[stp_psm_dbg->in].line_num = line_num;
+		stp_psm_dbg->queue[stp_psm_dbg->in].package_no = g_record_num++;
+		stp_psm_dbg->queue[stp_psm_dbg->in].sec = now.tv_sec;
+		stp_psm_dbg->queue[stp_psm_dbg->in].usec = now.tv_usec;
+		stp_psm_dbg->size++;
+		STP_PSM_DBG_FUNC("pre_Flag = %d, cur_flag = %d\n", stp_psm_dbg->queue[stp_psm_dbg->in].prev_flag,
+				 stp_psm_dbg->queue[stp_psm_dbg->in].cur_flag);
+		stp_psm_dbg->size = (stp_psm_dbg->size > STP_PSM_DBG_SIZE) ? STP_PSM_DBG_SIZE : stp_psm_dbg->size;
+		stp_psm_dbg->in = (stp_psm_dbg->in >= (STP_PSM_DBG_SIZE - 1)) ? (0) : (stp_psm_dbg->in + 1);
+		STP_PSM_DBG_FUNC("record size = %d, in = %d num = %d\n", stp_psm_dbg->size, stp_psm_dbg->in, line_num);
+
+		osal_unlock_unsleepable_lock(&stp_psm_dbg->lock);
+	}
+	return 0;
+}
+
+static INT32 _stp_psm_dbg_out_printk(STP_PSM_RECORD_T *stp_psm_dbg)
+{
+
+	UINT32 dumpSize = 0;
+	UINT32 inIndex = 0;
+	UINT32 outIndex = 0;
+
+	if (!stp_psm_dbg) {
+		STP_PSM_ERR_FUNC("NULL g_stp_psm_dbg reference\n");
+		return -1;
+	}
+	osal_lock_unsleepable_lock(&stp_psm_dbg->lock);
+
+	inIndex = stp_psm_dbg->in;
+	dumpSize = stp_psm_dbg->size;
+	if (STP_PSM_DBG_SIZE == dumpSize)
+		outIndex = inIndex;
+	else
+		outIndex = ((inIndex + STP_PSM_DBG_SIZE) - dumpSize) % STP_PSM_DBG_SIZE;
+
+	STP_PSM_INFO_FUNC("loged record size = %d, in(%d), out(%d)\n", dumpSize, inIndex, outIndex);
+	while (dumpSize > 0) {
+
+		pr_debug("STP-PSM:%d.%ds, n(%d)pre_flag(%d)cur_flag(%d)line_no(%d)\n",
+		       stp_psm_dbg->queue[outIndex].sec,
+		       stp_psm_dbg->queue[outIndex].usec,
+		       stp_psm_dbg->queue[outIndex].package_no,
+		       stp_psm_dbg->queue[outIndex].prev_flag,
+		       stp_psm_dbg->queue[outIndex].cur_flag, stp_psm_dbg->queue[outIndex].line_num);
+
+		outIndex = (outIndex >= (STP_PSM_DBG_SIZE - 1)) ? (0) : (outIndex + 1);
+		dumpSize--;
+
+	}
+
+	osal_unlock_unsleepable_lock(&stp_psm_dbg->lock);
+
+	return 0;
+}
+
+static INT32 _stp_psm_opid_dbg_dmp_in(P_STP_PSM_OPID_RECORD p_opid_dbg, UINT32 opid, UINT32 line_num)
+{
+	INT32 index = 0;
+	struct timeval now;
+
+	if (p_opid_dbg) {
+		osal_lock_unsleepable_lock(&p_opid_dbg->lock);
+		do_gettimeofday(&now);
+		index = p_opid_dbg->in - 1;
+		index = (index + STP_PSM_DBG_SIZE) % STP_PSM_DBG_SIZE;
+		STP_PSM_DBG_FUNC("index(%d)\n", index);
+		p_opid_dbg->queue[p_opid_dbg->in].prev_flag = p_opid_dbg->queue[index].cur_flag;
+		p_opid_dbg->queue[p_opid_dbg->in].cur_flag = opid;
+		p_opid_dbg->queue[p_opid_dbg->in].line_num = line_num;
+		p_opid_dbg->queue[p_opid_dbg->in].package_no = g_opid_record_num++;
+		p_opid_dbg->queue[p_opid_dbg->in].sec = now.tv_sec;
+		p_opid_dbg->queue[p_opid_dbg->in].usec = now.tv_usec;
+		p_opid_dbg->queue[p_opid_dbg->in].pid = current->pid;
+		p_opid_dbg->size++;
+		STP_PSM_DBG_FUNC("pre_opid = %d, cur_opid = %d\n", p_opid_dbg->queue[p_opid_dbg->in].prev_flag,
+				 p_opid_dbg->queue[p_opid_dbg->in].cur_flag);
+		p_opid_dbg->size = (p_opid_dbg->size > STP_PSM_DBG_SIZE) ? STP_PSM_DBG_SIZE : p_opid_dbg->size;
+		p_opid_dbg->in = (p_opid_dbg->in >= (STP_PSM_DBG_SIZE - 1)) ? (0) : (p_opid_dbg->in + 1);
+		STP_PSM_DBG_FUNC("opid record size = %d, in = %d num = %d\n", p_opid_dbg->size, p_opid_dbg->in,
+				 line_num);
+
+		osal_unlock_unsleepable_lock(&p_opid_dbg->lock);
+	}
+	return 0;
+
+}
+
+static INT32 _stp_psm_opid_dbg_out_printk(P_STP_PSM_OPID_RECORD p_opid_dbg)
+{
+	UINT32 dumpSize = 0;
+	UINT32 inIndex = 0;
+	UINT32 outIndex = 0;
+
+	if (!p_opid_dbg) {
+		STP_PSM_ERR_FUNC("NULL p_opid_dbg reference\n");
+		return -1;
+	}
+	osal_lock_unsleepable_lock(&p_opid_dbg->lock);
+
+	inIndex = p_opid_dbg->in;
+	dumpSize = p_opid_dbg->size;
+	if (STP_PSM_DBG_SIZE == dumpSize)
+		outIndex = inIndex;
+	else
+		outIndex = ((inIndex + STP_PSM_DBG_SIZE) - dumpSize) % STP_PSM_DBG_SIZE;
+
+	STP_PSM_INFO_FUNC("loged record size = %d, in(%d), out(%d)\n", dumpSize, inIndex, outIndex);
+	while (dumpSize > 0) {
+
+		pr_debug("STP-PSM:%d.%ds, n(%d)pre_flag(%d)cur_flag(%d)line_no(%d) pid(%d)\n",
+		       p_opid_dbg->queue[outIndex].sec,
+		       p_opid_dbg->queue[outIndex].usec,
+		       p_opid_dbg->queue[outIndex].package_no,
+		       p_opid_dbg->queue[outIndex].prev_flag,
+		       p_opid_dbg->queue[outIndex].cur_flag,
+		       p_opid_dbg->queue[outIndex].line_num, p_opid_dbg->queue[outIndex].pid);
+
+		outIndex = (outIndex >= (STP_PSM_DBG_SIZE - 1)) ? (0) : (outIndex + 1);
+		dumpSize--;
+
+	}
+
+	osal_unlock_unsleepable_lock(&p_opid_dbg->lock);
+
+	return 0;
+
+}
+
+MTKSTP_PSM_T *stp_psm_init(void)
+{
+	INT32 err = 0;
+	INT32 i = 0;
+	INT32 ret = -1;
+
+	STP_PSM_INFO_FUNC("psm init\n");
+
+	stp_psm->work_state = ACT;
+	stp_psm->wmt_notify = wmt_lib_ps_stp_cb;
+	stp_psm->is_wmt_quick_ps_support = wmt_lib_is_quick_ps_support;
+	stp_psm->idle_time_to_sleep = STP_PSM_IDLE_TIME_SLEEP;
+	stp_psm->flag.data = 0;
+	stp_psm->stp_tx_cb = NULL;
+	stp_psm_set_sleep_enable(stp_psm);
+
+	ret = osal_fifo_init(&stp_psm->hold_fifo, NULL, STP_PSM_FIFO_SIZE);
+	if (ret < 0) {
+		STP_PSM_ERR_FUNC("FIFO INIT FAILS\n");
+		goto ERR_EXIT4;
+	}
+
+	osal_fifo_reset(&stp_psm->hold_fifo);
+	osal_sleepable_lock_init(&stp_psm->hold_fifo_spinlock_global);
+	osal_unsleepable_lock_init(&stp_psm->wq_spinlock);
+	osal_sleepable_lock_init(&stp_psm->stp_psm_lock);
+
+/* osal_unsleepable_lock_init(&stp_psm->flagSpinlock); */
+
+	osal_memcpy(stp_psm->wake_lock.name, "MT662x", 6);
+	osal_wake_lock_init(&stp_psm->wake_lock);
+
+	osal_event_init(&stp_psm->STPd_event);
+	RB_INIT(&stp_psm->rFreeOpQ, STP_OP_BUF_SIZE);
+	RB_INIT(&stp_psm->rActiveOpQ, STP_OP_BUF_SIZE);
+	/* Put all to free Q */
+	for (i = 0; i < STP_OP_BUF_SIZE; i++) {
+		osal_signal_init(&(stp_psm->arQue[i].signal));
+		_stp_psm_put_op(stp_psm, &stp_psm->rFreeOpQ, &(stp_psm->arQue[i]));
+	}
+	/* stp_psm->current_active_op = NULL; */
+	stp_psm->last_active_opId = STP_OPID_PSM_INALID;
+	/*Generate BTM thread, to servie STP-CORE and WMT-CORE for sleeping, waking up and host awake */
+	stp_psm->PSMd.pThreadData = (VOID *) stp_psm;
+	stp_psm->PSMd.pThreadFunc = (VOID *) _stp_psm_proc;
+	osal_memcpy(stp_psm->PSMd.threadName, PSM_THREAD_NAME, osal_strlen(PSM_THREAD_NAME));
+
+	ret = osal_thread_create(&stp_psm->PSMd);
+	if (ret < 0) {
+		STP_PSM_ERR_FUNC("osal_thread_create fail...\n");
+		goto ERR_EXIT5;
+	}
+	/* init_waitqueue_head(&stp_psm->wait_wmt_q); */
+	stp_psm->wait_wmt_q.timeoutValue = STP_PSM_WAIT_EVENT_TIMEOUT;
+	osal_event_init(&stp_psm->wait_wmt_q);
+
+	err = _stp_psm_init_monitor(stp_psm);
+	if (err) {
+		STP_PSM_ERR_FUNC("__stp_psm_init ERROR\n");
+		goto ERR_EXIT6;
+	}
+	/* Start STPd thread */
+	ret = osal_thread_run(&stp_psm->PSMd);
+	if (ret < 0) {
+		STP_PSM_ERR_FUNC("osal_thread_run FAILS\n");
+		goto ERR_EXIT6;
+	}
+	/* psm disable in default */
+	_stp_psm_disable(stp_psm);
+
+	g_stp_psm_dbg = (STP_PSM_RECORD_T *) osal_malloc(osal_sizeof(STP_PSM_RECORD_T));
+	if (!g_stp_psm_dbg) {
+		STP_PSM_ERR_FUNC("stp psm dbg allocate memory fail!\n");
+		return NULL;
+	}
+	osal_memset(g_stp_psm_dbg, 0, osal_sizeof(STP_PSM_RECORD_T));
+	osal_unsleepable_lock_init(&g_stp_psm_dbg->lock);
+
+	g_stp_psm_opid_dbg = (STP_PSM_OPID_RECORD *) osal_malloc(osal_sizeof(STP_PSM_OPID_RECORD));
+	if (!g_stp_psm_opid_dbg) {
+		STP_PSM_ERR_FUNC("stp psm dbg allocate memory fail!\n");
+		return NULL;
+	}
+	osal_memset(g_stp_psm_opid_dbg, 0, osal_sizeof(STP_PSM_OPID_RECORD));
+	osal_unsleepable_lock_init(&g_stp_psm_opid_dbg->lock);
+
+	return stp_psm;
+
+ERR_EXIT6:
+
+	ret = osal_thread_destroy(&stp_psm->PSMd);
+	if (ret < 0) {
+		STP_PSM_ERR_FUNC("osal_thread_destroy FAILS\n");
+		goto ERR_EXIT5;
+	}
+ERR_EXIT5:
+	osal_fifo_deinit(&stp_psm->hold_fifo);
+ERR_EXIT4:
+
+	return NULL;
+}
+
+INT32 stp_psm_deinit(MTKSTP_PSM_T *stp_psm)
+{
+	INT32 ret = -1;
+
+	STP_PSM_INFO_FUNC("psm deinit\n");
+
+	if (g_stp_psm_dbg) {
+		osal_unsleepable_lock_deinit(&g_stp_psm_dbg->lock);
+		osal_free(g_stp_psm_dbg);
+		g_stp_psm_dbg = NULL;
+	}
+
+	if (!stp_psm)
+		return STP_PSM_OPERATION_FAIL;
+
+	ret = osal_thread_destroy(&stp_psm->PSMd);
+	if (ret < 0)
+		STP_PSM_ERR_FUNC("osal_thread_destroy FAILS\n");
+
+	ret = _stp_psm_deinit_monitor(stp_psm);
+	if (ret < 0)
+		STP_PSM_ERR_FUNC("_stp_psm_deinit_monitor ERROR\n");
+
+	osal_wake_lock_deinit(&stp_psm->wake_lock);
+	osal_fifo_deinit(&stp_psm->hold_fifo);
+	osal_sleepable_lock_deinit(&stp_psm->hold_fifo_spinlock_global);
+	osal_unsleepable_lock_deinit(&stp_psm->wq_spinlock);
+	osal_sleepable_lock_deinit(&stp_psm->stp_psm_lock);
+/* osal_unsleepable_lock_deinit(&stp_psm->flagSpinlock); */
+
+	return STP_PSM_OPERATION_SUCCESS;
+}
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/stp_core.c b/drivers/misc/mediatek/connectivity/common/conn_soc/core/stp_core.c
new file mode 100644
index 00000000..a3c24ca
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/stp_core.c
@@ -0,0 +1,3358 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "osal_typedef.h"
+#include "stp_core.h"
+#include "psm_core.h"
+#include "btm_core.h"
+#include "stp_dbg.h"
+#include "stp_btif.h"
+
+#define PFX                         "[STP] "
+#define STP_LOG_DBG                  4
+#define STP_LOG_PKHEAD               3
+#define STP_LOG_INFO                 2
+#define STP_LOG_WARN                 1
+#define STP_LOG_ERR                  0
+
+#define STP_DEL_SIZE   2	/* STP delimiter length */
+
+UINT32 gStpDbgLvl = STP_LOG_INFO;
+unsigned int g_coredump_mode = 0;
+#define REMOVE_USELESS_LOG 1
+
+#define STP_POLL_CPUPCR_NUM 16
+#define STP_POLL_CPUPCR_DELAY 10
+#define STP_RETRY_OPTIMIZE 0
+
+/* global variables */
+static const UINT8 stp_delimiter[STP_DEL_SIZE] = { 0x55, 0x55 };
+
+static INT32 fgEnableNak;	/* 0=enable NAK; 1=disable NAK */
+static INT32 fgEnableDelimiter;	/* 0=disable Delimiter; 1=enable Delimiter */
+#if STP_RETRY_OPTIMIZE
+static UINT32 g_retry_times;
+#endif
+/* common interface */
+static IF_TX sys_if_tx;
+/* event/signal */
+static EVENT_SET sys_event_set;
+static EVENT_TX_RESUME sys_event_tx_resume;
+static FUNCTION_STATUS sys_check_function_status;
+/* kernel lib */
+/* int                g_block_tx = 0; */
+static mtkstp_context_struct stp_core_ctx = { 0 };
+
+#define STP_PSM_CORE(x)           ((x).psm)
+#define STP_SET_PSM_CORE(x, v)     ((x).psm = (v))
+
+#define STP_BTM_CORE(x)           ((x).btm)
+#define STP_SET_BTM_CORE(x, v)     ((x).btm = (v))
+
+#define STP_IS_ENABLE(x)          ((x).f_enable != 0)
+#define STP_NOT_ENABLE(x)         ((x).f_enable == 0)
+#define STP_SET_ENABLE(x, v)       ((x).f_enable = (v))
+
+#define STP_IS_READY(x)           ((x).f_ready != 0)
+#define STP_NOT_READY(x)          ((x).f_ready == 0)
+#define STP_SET_READY(x, v)        ((x).f_ready = (v))
+
+#define STP_PENDING_TYPE(x)       ((x).f_pending_type)
+#define STP_SET_PENDING_TYPE(x, v) ((x).f_pending_type = (v))
+
+#define STP_BLUE_ANGEL        (0)
+#define STP_BLUE_Z            (1)
+#define STP_BT_STK(x)         ((x).f_bluez)
+#define STP_BT_STK_IS_BLUEZ(x) ((x).f_bluez == (STP_BLUE_Z))
+#define STP_SET_BT_STK(x, v) ((x).f_bluez = (v))
+
+#define STP_IS_ENABLE_DBG(x)         ((x).f_dbg_en != 0)
+#define STP_NOT_ENABLE_DBG(x)        ((x).f_dbg_en == 0)
+#define STP_SET_ENABLE_DBG(x, v)      ((x).f_dbg_en = (v))
+
+#define STP_IS_ENABLE_RST(x)         ((x).f_autorst_en != 0)
+#define STP_NOT_ENABLE_RST(x)        ((x).f_autorst_en == 0)
+#define STP_SET_ENABLE_RST(x, v)        ((x).f_autorst_en = (v))
+
+#define STP_SUPPORT_PROTOCOL(x)      ((x).f_mode)
+#define STP_SET_SUPPORT_PROTOCOL(x, v)  ((x).f_mode = (v))
+
+#define STP_FW_COREDUMP_FLAG(x)  ((x).f_coredump)
+#define STP_SET_FW_COREDUMP_FLAG(x, v)  ((x).f_coredump = (v))
+#define STP_ENABLE_FW_COREDUMP(x, v)  ((x).en_coredump = (v))
+#define STP_ENABLE_FW_COREDUMP_FLAG(x)  ((x).en_coredump)
+
+#define STP_WMT_LAST_CLOSE(x)       ((x).f_wmt_last_close)
+#define STP_SET_WMT_LAST_CLOSE(x, v) ((x).f_wmt_last_close = (v))
+
+#define STP_EVT_ERR_ASSERT(x)		((x).f_evt_err_assert)
+#define STP_SET_EVT_ERR_ASSERT(x, v)	((x).f_evt_err_assert = (v))
+
+/*[PatchNeed]Need to calculate the timeout value*/
+static UINT32 mtkstp_tx_timeout = MTKSTP_TX_TIMEOUT;
+static mtkstp_parser_state prev_state = -1;
+
+#define CONFIG_DEBUG_STP_TRAFFIC_SUPPORT
+#ifdef CONFIG_DEBUG_STP_TRAFFIC_SUPPORT
+static MTKSTP_DBG_T *g_mtkstp_dbg;
+#endif
+static VOID stp_dbg_pkt_log(INT32 type, INT32 txAck, INT32 seq, INT32 crc, INT32 dir, const UINT8 *pBuf, INT32 len);
+static MTK_WCN_BOOL stp_check_crc(UINT8 *buffer, UINT32 length, UINT16 crc);
+static VOID stp_update_tx_queue(UINT32 txseq);
+static VOID stp_rest_ctx_state(VOID);
+static VOID stp_change_rx_state(mtkstp_parser_state next);
+static void stp_tx_timeout_handler(/*unsigned long data*/ struct timer_list *t);
+static VOID stp_dump_data(const UINT8 *buf, const UINT8 *title, const UINT32 len);
+static VOID stp_dump_tx_queue(UINT32 txseq);
+static INT32 stp_is_apply_powersaving(VOID);
+/*static INT32 stp_is_privileges_cmd(const UINT8 *buffer, const UINT32 length, const UINT8 type);*/
+static MTK_WCN_BOOL stp_is_tx_res_available(UINT32 length);
+static VOID stp_add_to_tx_queue(const UINT8 *buffer, UINT32 length);
+static INT32 stp_add_to_rx_queue(UINT8 *buffer, UINT32 length, UINT8 type);
+static VOID stp_send_tx_queue(UINT32 txseq);
+static VOID stp_send_ack(UINT8 txAck, UINT8 nak);
+static INT32 stp_process_rxack(VOID);
+static VOID stp_process_packet(VOID);
+
+/*private functions*/
+
+static INT32 stp_ctx_lock_init(mtkstp_context_struct *pctx)
+{
+#if CFG_STP_CORE_CTX_SPIN_LOCK
+	return osal_unsleepable_lock_init(&((pctx)->stp_mutex));
+#else
+	osal_sleepable_lock_init(&((pctx)->stp_mutex));
+	return 0;
+#endif
+}
+
+static INT32 stp_ctx_lock_deinit(mtkstp_context_struct *pctx)
+{
+#if CFG_STP_CORE_CTX_SPIN_LOCK
+	return osal_unsleepable_lock_deinit(&((pctx)->stp_mutex));
+#else
+	return osal_sleepable_lock_deinit(&((pctx)->stp_mutex));
+#endif
+}
+
+static INT32 stp_ctx_lock(mtkstp_context_struct *pctx)
+{
+#if CFG_STP_CORE_CTX_SPIN_LOCK
+	return osal_lock_unsleepable_lock(&((pctx)->stp_mutex));
+#else
+	return osal_lock_sleepable_lock(&((pctx)->stp_mutex));
+#endif
+}
+
+static INT32 stp_ctx_unlock(mtkstp_context_struct *pctx)
+{
+#if CFG_STP_CORE_CTX_SPIN_LOCK
+	return osal_unlock_unsleepable_lock(&((pctx)->stp_mutex));
+#else
+	return osal_unlock_sleepable_lock(&((pctx)->stp_mutex));
+#endif
+}
+
+MTK_WCN_BOOL mtk_wcn_stp_dbg_level(UINT32 dbglevel)
+{
+	if (dbglevel <= 4) {
+		gStpDbgLvl = dbglevel;
+		STP_INFO_FUNC("gStpDbgLvl = %d\n", gStpDbgLvl);
+		return MTK_WCN_BOOL_TRUE;
+	}
+	STP_INFO_FUNC("invalid stp debug level. gStpDbgLvl = %d\n", gStpDbgLvl);
+
+	return MTK_WCN_BOOL_FALSE;
+}
+
+#if !(REMOVE_USELESS_LOG)
+static UINT8 *stp_type_to_dbg_string(UINT32 type)
+{
+	UINT8 *type_name = NULL;
+
+	if (type == BT_TASK_INDX)
+		type_name = "< BT>";
+	else if (type == GPS_TASK_INDX)
+		type_name = "<GPS>";
+	else if (type == WMT_TASK_INDX)
+		type_name = "<WMT>";
+	else if (type == FM_TASK_INDX)
+		type_name = "< FM>";
+	else if (type == ANT_TASK_INDX)
+		type_name = "<ANT>";
+
+	return type_name;
+}
+#endif
+#if 0
+/*****************************************************************************
+* FUNCTION
+*  crc16
+* DESCRIPTION
+*  Compute the CRC-16 for the data buffer
+* PARAMETERS
+*  crc         [IN]        previous CRC value
+*  buffer      [IN]        data buffer
+*  length      [IN]        data buffer length
+* RETURNS
+*  the updated CRC value
+*****************************************************************************/
+static UINT16 crc16(const UINT8 *buffer, const UINT32 length)
+{
+	UINT32 crc, i;
+
+	/* FIXME: Add STP checksum feature */
+	crc = 0;
+	for (i = 0; i < length; i++, buffer++)
+		crc = (crc >> 8) ^ crc16_table[(crc ^ (*buffer)) & 0xff];
+
+	return crc;
+}
+
+#endif
+
+VOID stp_dbg_pkt_log(INT32 type, INT32 txAck, INT32 seq, INT32 crc, INT32 dir, const UINT8 *pBuf, INT32 len)
+{
+
+#ifndef CONFIG_LOG_STP_INTERNAL
+	return;
+#endif
+
+	if (STP_IS_ENABLE_DBG(stp_core_ctx)) {
+		stp_dbg_log_pkt(g_mtkstp_dbg, STP_DBG_PKT, type,	/* type */
+				txAck,	/* ack */
+				seq,	/* seq */
+				crc,	/* crc */
+				dir,	/* dir */
+				len,	/* len */
+				pBuf);	/* body */
+	} else {
+		STP_DBG_FUNC("stp_dbg not enabled");
+	}
+}
+
+/*****************************************************************************
+* FUNCTION
+*  stp_check_crc
+* DESCRIPTION
+*  check the check sum of packet payload
+* PARAMETERS
+*  pdata       [IN]        the data want to check
+*  length      [IN]        the length of pdata
+*  crc         [IN]        the crc of pdata
+* RETURNS
+*  KAL_TRUE        crc is ok
+*  KAL_FALSE       crc is wrong
+*****************************************************************************/
+static MTK_WCN_BOOL stp_check_crc(UINT8 *buffer, UINT32 length, UINT16 crc)
+{
+    /*----------------------------------------------------------------*/
+	/* Local Variables                                                */
+    /*----------------------------------------------------------------*/
+	UINT16 checksum;
+
+    /*----------------------------------------------------------------*/
+	/* Code Body                                                      */
+    /*----------------------------------------------------------------*/
+
+	/* FIXME: Add STP feature: check or skip crc */
+
+	checksum = osal_crc16(buffer, length);
+	if (checksum == crc)
+		return MTK_WCN_BOOL_TRUE;
+
+	STP_ERR_FUNC("CRC fail, length = %d, rx = %x, calc = %x \r\n", length, crc, checksum);
+	return MTK_WCN_BOOL_FALSE;
+
+}
+
+/*****************************************************************************
+* FUNCTION
+*  stp_update_tx_queue
+* DESCRIPTION
+*  update packet's ACK field
+* PARAMETERS
+*  txseq       [IN]        index of the tx packet which we want to update
+* RETURNS
+*  void
+*****************************************************************************/
+static void stp_update_tx_queue(UINT32 txseq)
+{
+	INT32 tx_read, i;
+	UINT8 checksum = 0;
+
+	tx_read = stp_core_ctx.tx_start_addr[txseq];
+	stp_core_ctx.tx_buf[tx_read] &= 0xf8;
+	stp_core_ctx.tx_buf[tx_read] |= stp_core_ctx.sequence.txack;
+
+	for (i = 0; i < 3; i++) {
+		checksum += stp_core_ctx.tx_buf[tx_read];
+		tx_read++;
+		if (tx_read >= MTKSTP_BUFFER_SIZE)
+			tx_read -= MTKSTP_BUFFER_SIZE;
+
+	}
+
+	stp_core_ctx.tx_buf[tx_read] = checksum;
+
+}
+
+/*****************************************************************************
+* FUNCTION
+*  stp_rest_ctx_state
+* DESCRIPTION
+*  Reset stp context state variables only. Mutex and timer resources are not touched.
+*
+* PARAMETERS
+*  void
+* RETURNS
+*  void
+*****************************************************************************/
+static VOID stp_rest_ctx_state(VOID)
+{
+	INT32 i;
+
+	/* osal_lock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+	stp_ctx_lock(&stp_core_ctx);
+	stp_core_ctx.rx_counter = 0;
+
+	/*reset rx buffer pointer */
+	for (i = 0; i < MTKSTP_MAX_TASK_NUM; i++) {
+		stp_core_ctx.ring[i].read_p = 0;
+		stp_core_ctx.ring[i].write_p = 0;
+	}
+
+	/*reset tx buffer pointer */
+	stp_core_ctx.tx_write = 0;
+	stp_core_ctx.tx_read = 0;
+
+	/*reset STP protocol context */
+	stp_core_ctx.parser.state = MTKSTP_SYNC;
+	stp_core_ctx.sequence.txseq = 0;
+	stp_core_ctx.sequence.txack = 7;
+	stp_core_ctx.sequence.rxack = 7;
+	stp_core_ctx.sequence.winspace = MTKSTP_WINSIZE;
+	stp_core_ctx.sequence.expected_rxseq = 0;
+	stp_core_ctx.sequence.retry_times = 0;
+	stp_core_ctx.inband_rst_set = 0;
+
+	/* osal_unlock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+	stp_ctx_unlock(&stp_core_ctx);
+}
+
+/*****************************************************************************
+* FUNCTION
+*  stp_change_rx_state
+* DESCRIPTION
+*  change the rx fsm of STP to "next"
+* PARAMETERS
+*  next     [IN] the next state of rx fsm
+* RETURNS
+*  void
+*****************************************************************************/
+static VOID stp_change_rx_state(mtkstp_parser_state next)
+{
+	prev_state = stp_core_ctx.parser.state;
+	stp_core_ctx.parser.state = next;
+
+}
+
+/* static void stp_tx_timeout_handler(void){ */
+static void stp_tx_timeout_handler(/*unsigned long data*/struct timer_list *t)
+{
+	STP_WARN_FUNC("call retry btm retry wq ...\n");
+	/*shorten the softirq lattency */
+	stp_btm_notify_stp_retry_wq(STP_BTM_CORE(stp_core_ctx));
+	STP_WARN_FUNC("call retry btm retry wq ...#\n");
+}
+
+VOID stp_do_tx_timeout(VOID)
+{
+	UINT32 seq;
+	UINT32 ret;
+	INT32 iRet;
+	ENUM_STP_FW_ISSUE_TYPE issue_type;
+	UINT8 resync[4];
+
+	STP_WARN_FUNC("==============================================================================\n");
+
+	/* osal_lock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+	stp_ctx_lock(&stp_core_ctx);
+
+#if STP_RETRY_OPTIMIZE
+	if ((g_retry_times != 0) && (stp_core_ctx.sequence.retry_times == 0)) {
+		STP_INFO_FUNC("STP TX timeout has been recoveryed by resend,record_retry_time(%d)\n", g_retry_times);
+		g_retry_times = 0;
+		stp_ctx_unlock(&stp_core_ctx);
+		return;
+	}
+#endif
+	if (stp_core_ctx.sequence.retry_times > (MTKSTP_RETRY_LIMIT)) {
+		STP_INFO_FUNC("STP retry times(%d) have reached retry limit,stop it\n",
+			      stp_core_ctx.sequence.retry_times);
+		stp_ctx_unlock(&stp_core_ctx);
+		return;
+	}
+#if STP_RETRY_OPTIMIZE
+	else
+		STP_DBG_FUNC("current TX timeout package has not received ACK yet,retry_times(%d)\n",
+		g_retry_times);
+#endif
+	/*polling cpupcr when no ack occurs at first retry */
+	stp_notify_btm_poll_cpupcr(STP_BTM_CORE(stp_core_ctx), STP_POLL_CPUPCR_NUM, STP_POLL_CPUPCR_DELAY);
+
+	seq = stp_core_ctx.sequence.rxack;
+	INDEX_INC(seq);
+
+	if (seq != stp_core_ctx.sequence.txseq) {
+		osal_memset(&resync[0], 127, 4);
+		(*sys_if_tx) (&resync[0], 4, &ret);
+		if (ret != 4) {
+			STP_ERR_FUNC("mtkstp_tx_timeout_handler: send resync fail\n");
+			osal_assert(0);
+		}
+
+		do {
+			STP_WARN_FUNC("[stp.ctx]*rxack (=last rx ack) = %d\n\r", stp_core_ctx.sequence.rxack);
+			STP_WARN_FUNC("[stp.ctx]txack (=last rx seq)= %d\n\r", stp_core_ctx.sequence.txack);
+			STP_WARN_FUNC("[stp.ctx]*txseq (=next tx seq)= %d\n\r", stp_core_ctx.sequence.txseq);
+			STP_WARN_FUNC("Resend STP packet from %d -> %d\n\r", seq,
+				      (stp_core_ctx.sequence.txseq <= 0) ? (7) : (stp_core_ctx.sequence.txseq - 1));
+			stp_dump_tx_queue(seq);
+
+			stp_send_tx_queue(seq);
+			INDEX_INC(seq);
+		} while (seq != stp_core_ctx.sequence.txseq);
+
+	}
+
+	osal_timer_stop(&stp_core_ctx.tx_timer);
+	osal_timer_start(&stp_core_ctx.tx_timer, mtkstp_tx_timeout);
+
+	if (stp_core_ctx.sequence.winspace == MTKSTP_WINSIZE) {
+		osal_timer_stop(&stp_core_ctx.tx_timer);
+		STP_ERR_FUNC("mtkstp_tx_timeout_handler: wmt_stop_timer\n");
+	} else {
+		stp_core_ctx.sequence.retry_times++;
+		STP_ERR_FUNC("mtkstp_tx_timeout_handler, retry = %d\n", stp_core_ctx.sequence.retry_times);
+#if STP_RETRY_OPTIMIZE
+		g_retry_times = stp_core_ctx.sequence.retry_times;
+#endif
+		/*If retry too much, try to recover STP by return back to initializatin state */
+		/*And not to retry again */
+		if (stp_core_ctx.sequence.retry_times > MTKSTP_RETRY_LIMIT) {
+#if STP_RETRY_OPTIMIZE
+			g_retry_times = 0;
+#endif
+			osal_timer_stop(&stp_core_ctx.tx_timer);
+			stp_ctx_unlock(&stp_core_ctx);
+
+			STP_ERR_FUNC("mtkstp_tx_timeout_handler: wmt_stop_timer\n");
+
+			STP_ERR_FUNC("TX retry limit = %d\n", MTKSTP_RETRY_LIMIT);
+			osal_assert(0);
+			mtk_wcn_stp_dbg_dump_package();
+
+			/*Whole Chip Reset Procedure Invoke */
+			/*if(STP_NOT_ENABLE_DBG(stp_core_ctx)) */
+
+			if (0 == mtk_wcn_stp_get_wmt_evt_err_trg_assert()) {
+				stp_psm_disable(STP_PSM_CORE(stp_core_ctx));
+				mtk_wcn_stp_set_wmt_evt_err_trg_assert(1);
+				stp_dbg_set_host_assert_info(4, 36, 1);
+				STP_INFO_FUNC("**STP NoAck trigger firmware assert**\n");
+				iRet = stp_notify_btm_do_fw_assert_via_emi(STP_BTM_CORE(stp_core_ctx));
+
+				if (iRet) {
+					STP_ERR_FUNC("host tigger fw assert fail(%d), do noack handle flow\n", iRet);
+					mtk_wcn_stp_set_wmt_evt_err_trg_assert(0);
+					issue_type = STP_FW_NOACK_ISSUE;
+					iRet = stp_dbg_set_fw_info("STP NoAck", osal_strlen("STP NoAck"), issue_type);
+
+					osal_dbg_assert_aee("[SOC_CONNSYS]NoAck",
+						"**[WCN_ISSUE_INFO]STP Tx Timeout**\n F/W has NO any RESPONSE. Please check F/W status first\n");
+					if (STP_IS_ENABLE_RST(stp_core_ctx)) {
+						STP_SET_READY(stp_core_ctx, 0);
+						stp_btm_notify_wmt_rst_wq(STP_BTM_CORE(stp_core_ctx));
+					} else {
+						STP_INFO_FUNC("No to launch whole chip reset! for debugging purpose\n");
+					}
+				}
+			} else {
+				STP_INFO_FUNC("do trigger assert & chip reset in wmt\n");
+			}
+			return;
+		}
+	}
+
+	/* osal_unlock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+	stp_ctx_unlock(&stp_core_ctx);
+	STP_WARN_FUNC("==============================================================================#\n");
+}
+
+static VOID stp_dump_data(const UINT8 *buf, const UINT8 *title, const UINT32 len)
+{
+	osal_buffer_dump(buf, title, len, 32);
+}
+
+/*****************************************************************************
+ * FUNCTION
+ *  stp_tx_timeout_handler
+ * DESCRIPTION
+ *  tx timeout handler, send resync & retransmitt
+ * PARAMETERS
+ *  void
+ * RETURNS
+ *  void
+ *****************************************************************************/
+static VOID stp_dump_tx_queue(UINT32 txseq)
+{
+	INT32 tx_read, tx_length, last_len;
+
+	tx_read = stp_core_ctx.tx_start_addr[txseq];
+	tx_length = stp_core_ctx.tx_length[txseq];
+
+	STP_ERR_FUNC("tx_seq=%d ..", txseq);
+
+	if (tx_read + tx_length < MTKSTP_BUFFER_SIZE) {
+		stp_dump_data(&stp_core_ctx.tx_buf[tx_read], "tx_q", (tx_length >= 8) ? (8) : (tx_length));
+	} else {
+		last_len = MTKSTP_BUFFER_SIZE - tx_read;
+		stp_dump_data(&stp_core_ctx.tx_buf[tx_read], "tx_q_0", (last_len >= 8) ? (8) : (last_len));
+		stp_dump_data(&stp_core_ctx.tx_buf[0], "tx_q_0",
+			      ((tx_length - last_len) ? (8) : (tx_length - last_len)));
+	}
+}
+
+/*****************************************************************************
+* FUNCTION
+*  stp_is_apply_powersaving
+* DESCRIPTION
+*  Check if STP support power saving mode.
+* PARAMETERS
+*
+* RETURNS
+*  True: support power saving False: not support power saving
+*****************************************************************************/
+static INT32 stp_is_apply_powersaving(VOID)
+{
+
+	if (STP_IS_READY(stp_core_ctx) && !stp_psm_is_disable(STP_PSM_CORE(stp_core_ctx))) {
+		/* osal_dbg_print("apply power saving\n"); */
+		return MTK_WCN_BOOL_TRUE;
+	}
+	if (mtk_wcn_stp_is_sdio_mode())
+		return MTK_WCN_BOOL_FALSE;
+
+	STP_DBG_FUNC("not apply power saving\n");
+	return MTK_WCN_BOOL_FALSE;
+}
+#if 0
+/*****************************************************************************
+* FUNCTION
+*  stp_is_privileges_cmd
+* DESCRIPTION
+*  Check if the data is privilege command
+* PARAMETERS
+*
+* RETURNS
+*  True/False
+*****************************************************************************/
+static INT32 stp_is_privileges_cmd(const UINT8 *buffer, const UINT32 length, const UINT8 type)
+{
+	typedef struct privileges_cmd {
+		UINT32 length;
+		UINT8 type;
+		UINT8 buf[7];	/* MAX length of target command is only 5 currently */
+	} p_cmd_t;
+
+	p_cmd_t p_cmd_table[] = {
+		{0x05, WMT_TASK_INDX, {0x01, 0x03, 0x01, 0x00, 0x01} },	/* sleep command */
+		{0x05, WMT_TASK_INDX, {0x01, 0x03, 0x01, 0x00, 0x02} },	/* host_awake command */
+	};
+
+	UINT32 i;
+	UINT32 size = sizeof(p_cmd_table) / sizeof(p_cmd_table[0]);
+
+	for (i = 0; i < size; i++) {
+		if (type != p_cmd_table[i].type)
+			continue;
+
+		if (length != p_cmd_table[i].length)
+			continue;
+
+		if (osal_memcmp(p_cmd_table[i].buf, buffer, length))
+			continue;
+
+		/* matched entry is found */
+		STP_DBG_FUNC("It's p_cmd_t\n");
+		return MTK_WCN_BOOL_TRUE;
+	}
+
+	return MTK_WCN_BOOL_FALSE;
+}
+#endif
+/*****************************************************************************
+* FUNCTION
+*  tx_queue_room_available
+* DESCRIPTION
+*  check room if available,
+* PARAMETERS
+*  buffer      [IN]        data buffer
+*  length      [IN]        data buffer length
+* RETURNS
+*  void
+*****************************************************************************/
+static MTK_WCN_BOOL stp_is_tx_res_available(UINT32 length)
+{
+	UINT32 roomLeft;
+
+	/*
+	   Get available space of TX Queue
+	 */
+	if (stp_core_ctx.tx_read <= stp_core_ctx.tx_write)
+		roomLeft = MTKSTP_BUFFER_SIZE - stp_core_ctx.tx_write + stp_core_ctx.tx_read - 1;
+	else
+		roomLeft = stp_core_ctx.tx_read - stp_core_ctx.tx_write - 1;
+
+	if (roomLeft < length) {
+		STP_ERR_FUNC("%s: tx queue room shortage\n", __func__);
+		return MTK_WCN_BOOL_FALSE;
+	} else
+		return MTK_WCN_BOOL_TRUE;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  stp_add_to_tx_queue
+* DESCRIPTION
+*  put data to tx queue
+* PARAMETERS
+*  buffer      [IN]        data buffer
+*  length      [IN]        data buffer length
+* RETURNS
+*  void
+*****************************************************************************/
+static VOID stp_add_to_tx_queue(const UINT8 *buffer, UINT32 length)
+{
+	UINT32 last_len;
+
+	/* Get available space of TX Queue */
+	if (length + stp_core_ctx.tx_write < MTKSTP_BUFFER_SIZE) {
+		osal_memcpy(stp_core_ctx.tx_buf + stp_core_ctx.tx_write, buffer, length);
+		stp_core_ctx.tx_write += length;
+	} else {
+		last_len = MTKSTP_BUFFER_SIZE - stp_core_ctx.tx_write;
+		osal_memcpy(stp_core_ctx.tx_buf + stp_core_ctx.tx_write, buffer, last_len);
+		osal_memcpy(stp_core_ctx.tx_buf, buffer + last_len, length - last_len);
+
+		stp_core_ctx.tx_write = length - last_len;
+	}
+
+}
+
+/*****************************************************************************
+* FUNCTION
+*  stp_add_to_rx_queue
+* DESCRIPTION
+*  put data to corresponding task's rx queue and notify corresponding task
+* PARAMETERS
+*  buffer      [IN]        data buffer
+*  length      [IN]        data buffer length
+*  type        [IN]        corresponding task index
+* RETURNS
+*  INT32    0=success, others=error
+*****************************************************************************/
+static INT32 stp_add_to_rx_queue(UINT8 *buffer, UINT32 length, UINT8 type)
+{
+	UINT32 roomLeft, last_len;
+
+	osal_lock_unsleepable_lock(&stp_core_ctx.ring[type].mtx);
+
+	if (stp_core_ctx.ring[type].read_p <= stp_core_ctx.ring[type].write_p)
+		roomLeft = MTKSTP_BUFFER_SIZE - stp_core_ctx.ring[type].write_p + stp_core_ctx.ring[type].read_p - 1;
+	else
+		roomLeft = stp_core_ctx.ring[type].read_p - stp_core_ctx.ring[type].write_p - 1;
+
+	if (roomLeft < length) {
+		osal_unlock_unsleepable_lock(&stp_core_ctx.ring[type].mtx);
+		STP_ERR_FUNC("Queue is full !!!, type = %d\n", type);
+		osal_assert(0);
+		return -1;
+	}
+
+	if (length + stp_core_ctx.ring[type].write_p < MTKSTP_BUFFER_SIZE) {
+		osal_memcpy(stp_core_ctx.ring[type].buffer + stp_core_ctx.ring[type].write_p, buffer, length);
+		stp_core_ctx.ring[type].write_p += length;
+	} else {
+		last_len = MTKSTP_BUFFER_SIZE - stp_core_ctx.ring[type].write_p;
+		osal_memcpy(stp_core_ctx.ring[type].buffer + stp_core_ctx.ring[type].write_p, buffer, last_len);
+		osal_memcpy(stp_core_ctx.ring[type].buffer, buffer + last_len, length - last_len);
+		stp_core_ctx.ring[type].write_p = length - last_len;
+	}
+
+	osal_unlock_unsleepable_lock(&stp_core_ctx.ring[type].mtx);
+
+	return 0;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  stp_send_tx_queue
+* DESCRIPTION
+*  send data in tx buffer to common interface
+* PARAMETERS
+*  txseq       [IN]        sequence number of outgoing packet in tx buffer
+* RETURNS
+*  void
+*****************************************************************************/
+static VOID stp_send_tx_queue(UINT32 txseq)
+{
+	UINT32 ret;
+	INT32 tx_read, tx_length, last_len;
+
+	tx_read = stp_core_ctx.tx_start_addr[txseq];
+	tx_length = stp_core_ctx.tx_length[txseq];
+
+	stp_update_tx_queue(txseq);
+
+	if (tx_read + tx_length < MTKSTP_BUFFER_SIZE) {
+
+		(*sys_if_tx) (&stp_core_ctx.tx_buf[tx_read], tx_length, &ret);
+
+		if (ret != tx_length) {
+			STP_ERR_FUNC("stp_send_tx_queue, %d/%d\n", tx_length, ret);
+			osal_assert(0);
+		}
+	} else {
+		last_len = MTKSTP_BUFFER_SIZE - tx_read;
+		(*sys_if_tx) (&stp_core_ctx.tx_buf[tx_read], last_len, &ret);
+
+		if (ret != last_len) {
+			STP_ERR_FUNC("stp_send_tx_queue, %d/%d\n", last_len, ret);
+			osal_assert(0);
+		}
+
+		(*sys_if_tx) (&stp_core_ctx.tx_buf[0], tx_length - last_len, &ret);
+
+		if (ret != tx_length - last_len) {
+			STP_ERR_FUNC("stp_send_tx_queue, %d/%d\n", tx_length - last_len, ret);
+			osal_assert(0);
+		}
+	}
+
+}
+
+/*****************************************************************************
+* FUNCTION
+*  stp_send_ack
+* DESCRIPTION
+*  send ack packet to the peer
+* PARAMETERS
+*  txAck    [IN] Ack number
+*  nak      [IN] 0 = ack; !0 = NAK
+* RETURNS
+*  void
+*****************************************************************************/
+static VOID stp_send_ack(UINT8 txAck, UINT8 nak)
+{
+	UINT8 mtkstp_header[MTKSTP_HEADER_SIZE];
+	UINT32 ret;
+	INT32 iStatus;
+
+	mtkstp_header[0] = 0x80 + (0 << 3) + txAck;	/* stp_core_ctx.sequence.txack; */
+
+	if (fgEnableNak == 0)
+		mtkstp_header[1] = 0x00;	/* disable NAK */
+	else
+		mtkstp_header[1] = ((nak == 0) ? 0x00 : 0x80);
+
+	mtkstp_header[2] = 0;
+	mtkstp_header[3] = (mtkstp_header[0] + mtkstp_header[1] + mtkstp_header[2]) & 0xff;
+
+	stp_dbg_pkt_log(STP_TASK_INDX, txAck, 0, 0, PKT_DIR_TX, NULL, 0);
+
+	if (fgEnableDelimiter == 1) {
+		iStatus = (*sys_if_tx) ((PUINT8) &stp_delimiter[0], STP_DEL_SIZE, &ret);
+		STP_DUMP_PACKET_HEAD((PUINT8) &stp_delimiter[0], "tx del", STP_DEL_SIZE);
+		if (ret != STP_DEL_SIZE) {
+			STP_ERR_FUNC("stp_send_ack, %d/%d status %d\n", STP_DEL_SIZE, ret, iStatus);
+			osal_assert(0);
+		}
+	}
+
+	iStatus = (*sys_if_tx) (&mtkstp_header[0], MTKSTP_HEADER_SIZE, &ret);
+
+	if (ret != MTKSTP_HEADER_SIZE) {
+		STP_ERR_FUNC("stp_send_ack, %d/%d status %d\n", MTKSTP_HEADER_SIZE, ret, iStatus);
+		osal_assert(0);
+	}
+
+}
+
+INT32 stp_send_data_no_ps(UINT8 *buffer, UINT32 length, UINT8 type)
+{
+	UINT8 mtkstp_header[MTKSTP_HEADER_SIZE], temp[2];
+	UINT8 *p_tx_buf = NULL;
+	UINT16 crc;
+	INT32 ret = 0;
+
+	/* osal_lock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+	stp_ctx_lock(&stp_core_ctx);
+
+	/*Only WMT can set raw data */
+	if (STP_NOT_ENABLE(stp_core_ctx) && WMT_TASK_INDX != type) {
+		/* no op */
+		/* NULL; */
+	} else if (STP_NOT_ENABLE(stp_core_ctx) && WMT_TASK_INDX == type) {
+		/* ret = mtk_wcn_stp_send_data_raw(buffer, length, type); */
+		/* NULL; */
+	}
+	/* STP over SDIO */
+	else if ((mtk_wcn_stp_is_sdio_mode() || mtk_wcn_stp_is_btif_mand_mode()) && STP_IS_ENABLE(stp_core_ctx)) {
+		osal_printtimeofday("[ STP][SDIO][ B][W]");
+
+		mtkstp_header[0] = 0x80;
+		mtkstp_header[1] = (type << 4) + (((length) >> 8) & 0x0f);
+		mtkstp_header[2] = (length) & 0xff;
+		mtkstp_header[3] = 0x00;
+
+		p_tx_buf = &stp_core_ctx.tx_buf[0];
+		osal_memcpy(p_tx_buf, mtkstp_header, MTKSTP_HEADER_SIZE);
+		p_tx_buf += MTKSTP_HEADER_SIZE;
+
+		osal_memcpy(p_tx_buf, buffer, length);
+		p_tx_buf += length;
+
+		temp[0] = 0x00;
+		temp[1] = 0x00;
+		osal_memcpy(p_tx_buf, temp, 2);
+		stp_dbg_pkt_log(type,
+				stp_core_ctx.sequence.txack,
+				stp_core_ctx.sequence.txseq, 0, PKT_DIR_TX, buffer, length);
+		(*sys_if_tx) (&stp_core_ctx.tx_buf[0], (MTKSTP_HEADER_SIZE + length + 2), &ret);
+		if ((MTKSTP_HEADER_SIZE + length + 2) != ret) {
+			STP_ERR_FUNC("stp send tx packet: %d, maybe stp_if_tx == NULL\n", ret);
+			osal_assert(0);
+			ret = 0;
+		} else {
+			ret = (INT32) length;
+		}
+
+		osal_printtimeofday("[ STP][SDIO][ E][W]");
+	}
+	/* STP over BTIF OR UART */
+	else if ((mtk_wcn_stp_is_btif_fullset_mode()) && STP_IS_ENABLE(stp_core_ctx)) {
+
+		if ((stp_core_ctx.sequence.winspace > 0) &&
+		    (stp_is_tx_res_available(MTKSTP_HEADER_SIZE + length + MTKSTP_CRC_SIZE))) {
+			mtkstp_header[0] = 0x80 + (stp_core_ctx.sequence.txseq << 3) + stp_core_ctx.sequence.txack;
+			mtkstp_header[1] = (type << 4) + ((length & 0xf00) >> 8);
+			mtkstp_header[2] = length & 0xff;
+			mtkstp_header[3] = (mtkstp_header[0] + mtkstp_header[1] + mtkstp_header[2]) & 0xff;
+
+			stp_core_ctx.tx_start_addr[stp_core_ctx.sequence.txseq] = stp_core_ctx.tx_write;
+			stp_core_ctx.tx_length[stp_core_ctx.sequence.txseq] = MTKSTP_HEADER_SIZE + length + 2;
+
+			if (fgEnableDelimiter == 1) {
+				stp_core_ctx.tx_length[stp_core_ctx.sequence.txseq] += STP_DEL_SIZE;
+				stp_add_to_tx_queue(&stp_delimiter[0], STP_DEL_SIZE);
+			}
+
+			stp_add_to_tx_queue(mtkstp_header, MTKSTP_HEADER_SIZE);
+
+			/*Make Payload */
+			stp_add_to_tx_queue(buffer, length);
+
+			/*Make CRC */
+			crc = osal_crc16(buffer, length);
+			temp[0] = crc & 0xff;
+			temp[1] = (crc & 0xff00) >> 8;
+			stp_add_to_tx_queue(temp, 2);
+
+			stp_dbg_pkt_log(type,
+					stp_core_ctx.sequence.txack,
+					stp_core_ctx.sequence.txseq, crc, PKT_DIR_TX, buffer, length);
+
+			/*Kick to UART */
+			stp_send_tx_queue(stp_core_ctx.sequence.txseq);
+			INDEX_INC(stp_core_ctx.sequence.txseq);
+			stp_core_ctx.sequence.winspace--;
+
+			/*Setup the Retry Timer */
+			osal_timer_stop(&stp_core_ctx.tx_timer);
+			if (stp_core_ctx.sequence.winspace != MTKSTP_WINSIZE)
+				osal_timer_start(&stp_core_ctx.tx_timer, mtkstp_tx_timeout);
+			else
+				STP_ERR_FUNC("mtk_wcn_stp_send_data: wmt_stop_timer\n");
+
+			ret = (INT32) length;
+		} else {
+			/* No winspace to send. Let caller retry */
+			STP_ERR_FUNC("%s: There is no winspace/txqueue to send !!!\n", __func__);
+			ret = 0;
+		}
+	}
+
+	stp_ctx_unlock(&stp_core_ctx);
+	/* osal_unlock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+
+	return ret;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  stp_process_rxack
+* DESCRIPTION
+*  process ack packet
+* PARAMETERS
+*  void
+* RETURNS
+*  INT32    0=success, others=error
+*****************************************************************************/
+static INT32 stp_process_rxack(VOID)
+{
+	INT32 j, k;
+	UINT8 rxack;
+	INT32 fgResult = (-1);
+
+	if (stp_core_ctx.sequence.rxack != stp_core_ctx.parser.ack) {
+		j = k = 0;
+		rxack = stp_core_ctx.sequence.rxack;
+		INDEX_INC(rxack);
+		while (rxack != stp_core_ctx.sequence.txseq) {
+			j++;
+			if (rxack == stp_core_ctx.parser.ack) {
+				k = 1;
+				break;
+			}
+			INDEX_INC(rxack);
+		}
+		if (k == 1) {
+			stp_core_ctx.sequence.rxack = stp_core_ctx.parser.ack;
+			stp_core_ctx.tx_read = stp_core_ctx.tx_start_addr[rxack] + stp_core_ctx.tx_length[rxack];
+			if (stp_core_ctx.tx_read >= MTKSTP_BUFFER_SIZE)
+				stp_core_ctx.tx_read -= MTKSTP_BUFFER_SIZE;
+
+			stp_core_ctx.sequence.winspace += j;
+			stp_core_ctx.sequence.retry_times = 0;
+
+			osal_timer_stop(&stp_core_ctx.tx_timer);
+			if (stp_core_ctx.sequence.winspace != MTKSTP_WINSIZE)
+				osal_timer_start(&stp_core_ctx.tx_timer, mtkstp_tx_timeout);
+
+			fgResult = 0;
+		}
+	}
+
+	return fgResult;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  stp_process_packet
+* DESCRIPTION
+*  process STP packet
+* PARAMETERS
+*  void
+* RETURNS
+*  void
+*****************************************************************************/
+static VOID stp_process_packet(VOID)
+{
+	INT32 fgTriggerResume = (-1);
+	UINT8 txAck = 0;
+	static INT32 fgRxOk;
+	MTK_WCN_BOOL b;
+	MTK_WCN_BOOL is_function_active = 0;
+	static INT32 stp_process_packet_fail_count;
+	INT32 iRet = -1;
+
+	stp_dbg_pkt_log(stp_core_ctx.parser.type,
+			stp_core_ctx.parser.ack,
+			stp_core_ctx.parser.seq,
+			stp_core_ctx.parser.crc, PKT_DIR_RX, stp_core_ctx.rx_buf, stp_core_ctx.parser.length);
+	/*Optimization */
+	/*If bluez, direct send packet to hci_core not through RX buffer! */
+	if ((stp_core_ctx.sequence.expected_rxseq == stp_core_ctx.parser.seq) &&
+	    (stp_core_ctx.parser.type == BT_TASK_INDX) && STP_BT_STK_IS_BLUEZ(stp_core_ctx)) {
+		/*Indicate packet to hci_stp */
+		STP_DBG_FUNC("Send Packet to BT_SUBFUCTION, len = %d\n", stp_core_ctx.rx_counter);
+
+		b = mtk_wcn_sys_if_rx(stp_core_ctx.rx_buf, stp_core_ctx.rx_counter);
+		if (b)
+			STP_ERR_FUNC("mtk_wcn_sys_if_rx is NULL\n");
+
+		/* osal_lock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+		stp_ctx_lock(&stp_core_ctx);
+		/*Process rx ack */
+		fgTriggerResume = stp_process_rxack();
+		stp_core_ctx.sequence.txack = stp_core_ctx.parser.seq;
+		INDEX_INC(stp_core_ctx.sequence.expected_rxseq);
+		txAck = stp_core_ctx.sequence.txack;
+
+		/*Send ack back */
+		stp_send_ack(txAck, 0);
+
+		/* osal_unlock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+		stp_ctx_unlock(&stp_core_ctx);
+		fgRxOk = 0;
+	}
+	/* sequence matches expected, enqueue packet */
+	else if (stp_core_ctx.sequence.expected_rxseq == stp_core_ctx.parser.seq) {
+		is_function_active =
+		    ((*sys_check_function_status) (stp_core_ctx.parser.type, OP_FUNCTION_ACTIVE) ==
+		     STATUS_FUNCTION_ACTIVE);
+		/*If type is valid and function works, then try to enqueue */
+		if ((stp_core_ctx.parser.type < MTKSTP_MAX_TASK_NUM) && (is_function_active == MTK_WCN_BOOL_TRUE)) {
+			if (stp_core_ctx.parser.type == BT_TASK_INDX) {
+				static const UINT8 rst_buf[7] = { 0x04, 0x0e, 0x04, 0x01, 0x3, 0xc, 0x00 };
+
+				if (!osal_strncmp(stp_core_ctx.rx_buf, rst_buf, 7))
+					osal_printtimeofday("############ BT Rest end <--");
+			}
+
+			stp_ctx_lock(&stp_core_ctx);
+
+			fgTriggerResume = stp_process_rxack();
+			stp_core_ctx.sequence.txack = stp_core_ctx.parser.seq;
+			INDEX_INC(stp_core_ctx.sequence.expected_rxseq);
+
+			/*Send tx ack */
+			txAck = stp_core_ctx.sequence.txack;
+			stp_send_ack(txAck, 0);
+
+			stp_ctx_unlock(&stp_core_ctx);
+#if CFG_WMT_LTE_COEX_HANDLING
+			if ((stp_core_ctx.parser.type == WMT_TASK_INDX) &&
+			    (stp_core_ctx.parser.wmtsubtype == WMT_LTE_COEX_FLAG)) {
+				fgRxOk =
+				    stp_add_to_rx_queue(stp_core_ctx.rx_buf, stp_core_ctx.rx_counter, COEX_TASK_INDX);
+			} else {
+				fgRxOk =
+				    stp_add_to_rx_queue(stp_core_ctx.rx_buf, stp_core_ctx.rx_counter,
+							stp_core_ctx.parser.type);
+			}
+#else
+			if ((stp_core_ctx.parser.type == WMT_TASK_INDX) &&
+			    (stp_core_ctx.parser.wmtsubtype == WMT_LTE_COEX_FLAG)) {
+				STP_WARN_FUNC("BT/WIFI & LTE coex in non-LTE projects,drop it...\n");
+			} else {
+				fgRxOk =
+				    stp_add_to_rx_queue(stp_core_ctx.rx_buf, stp_core_ctx.rx_counter,
+							stp_core_ctx.parser.type);
+			}
+#endif
+		} else {
+			if (is_function_active == MTK_WCN_BOOL_FALSE) {
+				STP_ERR_FUNC("function type = %d is inactive, so no en-queue to rx\n",
+					     stp_core_ctx.parser.type);
+				fgRxOk = 0;	/*drop packet */
+			} else {
+				STP_ERR_FUNC("mtkstp_process_packet: type = %x, the type is invalid\n",
+					     stp_core_ctx.parser.type);
+				fgRxOk = 0;	/*drop packet */
+			}
+			stp_ctx_lock(&stp_core_ctx);
+
+			fgTriggerResume = stp_process_rxack();
+			stp_core_ctx.sequence.txack = stp_core_ctx.parser.seq;
+			INDEX_INC(stp_core_ctx.sequence.expected_rxseq);
+
+			/*Send tx ack */
+			txAck = stp_core_ctx.sequence.txack;
+			stp_send_ack(txAck, 0);
+
+			stp_ctx_unlock(&stp_core_ctx);
+		}
+
+		/* enqueue successfully */
+		if (fgRxOk == 0) {
+			stp_process_packet_fail_count = 0;
+			/*notify corresponding subfunction of incoming data */
+#if CFG_WMT_LTE_COEX_HANDLING
+			if ((stp_core_ctx.parser.type == WMT_TASK_INDX) &&
+			    (stp_core_ctx.parser.wmtsubtype == WMT_LTE_COEX_FLAG)) {
+#if 1
+				STP_DBG_FUNC
+				    ("WMT/LTE package:[0x%2x][0x%2x][0x%2x][0x%2x][0x%2x][0x%2x][0x%2x][0x%2x]\n",
+				     stp_core_ctx.rx_buf[0], stp_core_ctx.rx_buf[1], stp_core_ctx.rx_buf[2],
+				     stp_core_ctx.rx_buf[3], stp_core_ctx.rx_buf[4], stp_core_ctx.rx_buf[5],
+				     stp_core_ctx.rx_buf[6], stp_core_ctx.rx_buf[7]);
+#endif
+				stp_notify_btm_handle_wmt_lte_coex(STP_BTM_CORE(stp_core_ctx));
+			} else {
+				(*sys_event_set) (stp_core_ctx.parser.type);
+			}
+#else
+			if ((stp_core_ctx.parser.type == WMT_TASK_INDX) &&
+			    (stp_core_ctx.parser.wmtsubtype == WMT_LTE_COEX_FLAG)) {
+				STP_WARN_FUNC("omit BT/WIFI & LTE coex msg handling in non-LTE projects\n");
+			} else {
+				(*sys_event_set) (stp_core_ctx.parser.type);
+			}
+#endif
+		} else {
+			stp_process_packet_fail_count++;
+			/*Queue is full */
+			if (stp_core_ctx.parser.type == GPS_TASK_INDX) {
+				/*Clear Rx Queue if GPS */
+				mtk_wcn_stp_flush_rx_queue(GPS_TASK_INDX);
+			} else {
+				/*notify corresponding subfunction of incoming data */
+				(*sys_event_set) (stp_core_ctx.parser.type);
+			}
+			/*enqueue fail, don't send ack and wait for peer retry */
+			STP_ERR_FUNC("Enqueue to Rx queue fail, maybe function %d queue is full\n",
+				     stp_core_ctx.parser.type);
+		}
+	}
+	/*sequence not match && previous packet enqueue successfully, send the previous ACK */
+	else if (fgRxOk == 0) {
+		STP_ERR_FUNC("mtkstp_process_packet: expected_rxseq = %d, parser.seq = %d\n",
+			     stp_core_ctx.sequence.expected_rxseq, stp_core_ctx.parser.seq);
+		stp_process_packet_fail_count++;
+
+		stp_ctx_lock(&stp_core_ctx);
+		/* osal_lock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+		txAck = stp_core_ctx.sequence.txack;
+		stp_send_ack(txAck, 1);
+		stp_ctx_unlock(&stp_core_ctx);
+		/* osal_unlock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+		STP_ERR_FUNC
+		    ("sequence not match && previous packet enqueue successfully, send the previous ACK (ack no =%d)\n",
+		     txAck);
+	}
+	/*sequence not match && previous packet enqueue failed, do nothing, make the other side timeout */
+	else {
+		stp_process_packet_fail_count++;
+		STP_ERR_FUNC
+		    ("sequence not match && previous packet enqueue failed, do nothing, make the other side timeout\n");
+	}
+
+	if (fgTriggerResume == 0) {
+		/*[PatchNeed]Just Notificaiton, not blocking call */
+		/* notify adaptation layer for possible tx resume mechanism */
+		(*sys_event_tx_resume) (stp_core_ctx.sequence.winspace);
+	}
+
+	if (stp_process_packet_fail_count > MTKSTP_RETRY_LIMIT) {
+		stp_process_packet_fail_count = 0;
+		STP_ERR_FUNC("The process packet fail count > 10 lastly\n\r, whole chip reset\n\r");
+		mtk_wcn_stp_dbg_dump_package();
+		/*Whole Chip Reset Procedure Invoke */
+		/*if(STP_NOT_ENABLE_DBG(stp_core_ctx)) */
+		if (0 == mtk_wcn_stp_get_wmt_evt_err_trg_assert()) {
+			stp_psm_disable(STP_PSM_CORE(stp_core_ctx));
+			mtk_wcn_stp_set_wmt_evt_err_trg_assert(1);
+			stp_dbg_set_host_assert_info(4, 37, 1);
+			STP_INFO_FUNC("**Ack Miss trigger firmware assert**\n");
+			iRet = stp_notify_btm_do_fw_assert_via_emi(STP_BTM_CORE(stp_core_ctx));
+			if (iRet) {
+				mtk_wcn_stp_set_wmt_evt_err_trg_assert(0);
+				/* (*sys_dbg_assert_aee)("[MT662x]Ack Miss", "**STP Ack Miss**\n Ack Miss.\n"); */
+				osal_dbg_assert_aee("[SOC_CONSYS]Ack Miss",
+						    "**[WCN_ISSUE_INFO]STP Ack Miss**\n Ack Miss.\n");
+
+				if (STP_IS_ENABLE_RST(stp_core_ctx)) {
+					STP_SET_READY(stp_core_ctx, 0);
+					stp_btm_notify_wmt_rst_wq(STP_BTM_CORE(stp_core_ctx));
+				} else {
+					STP_INFO_FUNC("No to launch whole chip reset! for debugging purpose\n");
+				}
+			}
+		}
+	}
+
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_init
+* DESCRIPTION
+*  init STP kernel
+* PARAMETERS
+*  cb_func      [IN] function pointers of system APIs
+* RETURNS
+*  INT32    0 = success, others = failure
+*****************************************************************************/
+INT32 mtk_wcn_stp_init(const mtkstp_callback * const cb_func)
+{
+	INT32 ret = 0;
+	INT32 i = 0;
+
+	/* Function pointer to point to the currently used transmission interface
+	 */
+	sys_if_tx = cb_func->cb_if_tx;
+
+	/* Used to inform the function driver has received the corresponding type of information */
+	sys_event_set = cb_func->cb_event_set;
+
+	/*  Used to inform the function driver can continue to send information and
+	   STP has resources to deal with
+	 */
+	sys_event_tx_resume = cb_func->cb_event_tx_resume;
+
+	/*  STP driver determines whether the function is enable. If not enable and
+	   STP has received the kind of information, and STP have the right to put it away.
+	 */
+	sys_check_function_status = cb_func->cb_check_funciton_status;
+
+	/* osal_unsleepable_lock_init(&stp_core_ctx.stp_mutex); */
+	stp_ctx_lock_init(&stp_core_ctx);
+	/*  Setup timer to be used to check if f/w receive the data in the specific time
+	   interval after being sent
+	 */
+	for (i = 0; i < MTKSTP_MAX_TASK_NUM; i++)
+		osal_unsleepable_lock_init(&stp_core_ctx.ring[i].mtx);
+
+	stp_core_ctx.tx_timer.timeoutHandler = stp_tx_timeout_handler;
+	stp_core_ctx.tx_timer.timeroutHandlerData = 0;
+	osal_timer_create(&stp_core_ctx.tx_timer);
+
+	STP_SET_BT_STK(stp_core_ctx, 0);
+	STP_SET_ENABLE(stp_core_ctx, 0);
+	STP_SET_ENABLE_DBG(stp_core_ctx, 0);
+	STP_SET_ENABLE_RST(stp_core_ctx, 0);
+	STP_SET_PENDING_TYPE(stp_core_ctx, 0);
+	STP_SET_READY(stp_core_ctx, 0);
+	STP_SET_SUPPORT_PROTOCOL(stp_core_ctx, 0);
+	STP_SET_PSM_CORE(stp_core_ctx, stp_psm_init());
+	STP_SET_FW_COREDUMP_FLAG(stp_core_ctx, 0);
+	STP_ENABLE_FW_COREDUMP(stp_core_ctx, 0);
+	STP_SET_WMT_LAST_CLOSE(stp_core_ctx, 0);
+	STP_SET_EVT_ERR_ASSERT(stp_core_ctx, 0);
+
+	if (!STP_PSM_CORE(stp_core_ctx)) {
+		ret = (-3);
+		goto ERROR;
+	}
+
+	STP_SET_BTM_CORE(stp_core_ctx, stp_btm_init());
+	if (!STP_BTM_CORE(stp_core_ctx)) {
+		STP_ERR_FUNC("STP_BTM_CORE(stp_core_ctx) initialization fail!\n");
+		ret = (-3);
+		goto ERROR;
+	}
+
+	if (STP_BTM_CORE(stp_core_ctx) != NULL)
+		g_mtkstp_dbg = stp_dbg_init(STP_BTM_CORE(stp_core_ctx));
+	else
+		g_mtkstp_dbg = stp_dbg_init(NULL);
+
+	if (!g_mtkstp_dbg) {
+		STP_ERR_FUNC("g_mtkstp_dbg initialization fail!\n");
+		ret = (-3);
+		goto ERROR;
+	}
+	STP_SET_ENABLE_RST(stp_core_ctx, 1);
+#ifdef CONFIG_LOG_STP_INTERNAL
+	mtk_wcn_stp_dbg_enable();
+#else
+	mtk_wcn_stp_dbg_enable();
+#endif
+	goto RETURN;
+
+ERROR:
+	stp_psm_deinit(STP_PSM_CORE(stp_core_ctx));
+
+RETURN:
+	return ret;
+
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_deinit
+* DESCRIPTION
+*  deinit STP kernel
+* PARAMETERS
+*  void
+* RETURNS
+*  INT32    0 = success, others = failure
+*****************************************************************************/
+INT32 mtk_wcn_stp_deinit(void)
+{
+	UINT32 i = 0;
+
+	sys_if_tx = NULL;
+	sys_event_set = NULL;
+	sys_event_tx_resume = NULL;
+	sys_check_function_status = NULL;
+
+	stp_dbg_deinit(g_mtkstp_dbg);
+	stp_btm_deinit(STP_BTM_CORE(stp_core_ctx));
+	stp_psm_deinit(STP_PSM_CORE(stp_core_ctx));
+
+	for (i = 0; i < MTKSTP_MAX_TASK_NUM; i++)
+		osal_unsleepable_lock_deinit(&stp_core_ctx.ring[i].mtx);
+
+	stp_ctx_lock_deinit(&stp_core_ctx);
+	return 0;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_btm_get_dmp
+* DESCRIPTION
+*  get stp dump related information
+* PARAMETERS
+*  buffer: dump placement, len: dump size
+* RETURNS
+*   0: Success Negative Value: Fail
+*****************************************************************************/
+
+int mtk_wcn_stp_btm_get_dmp(char *buf, int *len)
+{
+	return stp_dbg_dmp_out(g_mtkstp_dbg, buf, len);
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_psm_notify_stp
+* DESCRIPTION
+*  WMT notification to STP that power saving job is done or not
+* PARAMETERS
+*
+* RETURNS
+*  0: Sccuess  Negative value: Fail
+*****************************************************************************/
+int mtk_wcn_stp_psm_notify_stp(const MTKSTP_PSM_ACTION_T action)
+{
+	return stp_psm_notify_stp(STP_PSM_CORE(stp_core_ctx), action);
+}
+
+int mtk_wcn_stp_set_psm_state(MTKSTP_PSM_STATE_T state)
+{
+	return stp_psm_set_state(STP_PSM_CORE(stp_core_ctx), state);
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_psm_enable
+* DESCRIPTION
+*  enable STP sleep/wakeup support
+* PARAMETERS
+*  void
+* RETURNS
+*  0: Sccuess  Negative value: Fail
+*****************************************************************************/
+INT32 mtk_wcn_stp_psm_enable(INT32 idle_time_to_sleep)
+{
+#if 0
+	if (MTK_WCN_BOOL_TRUE == stp_psm_is_quick_ps_support()) {
+		if (mtk_wcn_stp_is_ready())
+			return stp_psm_enable(STP_PSM_CORE(stp_core_ctx), idle_time_to_sleep);
+		STP_WARN_FUNC("STP Not Ready, Dont do Sleep/Wakeup\n");
+		return -1;
+	}
+	if (mtk_wcn_stp_is_ready() && mtk_wcn_stp_is_btif_fullset_mode()) {
+		return stp_psm_enable(STP_PSM_CORE(stp_core_ctx), idle_time_to_sleep);
+	} else if (mtk_wcn_stp_is_sdio_mode()) {
+		stp_psm_enable(STP_PSM_CORE(stp_core_ctx), idle_time_to_sleep);
+		STP_DBG_FUNC("PSM is not support under SDIO mode\n");
+		return 0;
+	}
+	STP_WARN_FUNC("STP Not Ready, Dont do Sleep/Wakeup\n");
+	return -1;
+
+#else
+	if (mtk_wcn_stp_is_ready() && mtk_wcn_stp_is_btif_fullset_mode()) {
+		return stp_psm_enable(STP_PSM_CORE(stp_core_ctx), idle_time_to_sleep);
+	} else if (mtk_wcn_stp_is_sdio_mode()) {
+		stp_psm_enable(STP_PSM_CORE(stp_core_ctx), idle_time_to_sleep);
+		STP_DBG_FUNC("PSM is not support under SDIO mode\n");
+		return 0;
+	}
+	STP_WARN_FUNC("STP Not Ready, Dont do Sleep/Wakeup\n");
+	return -1;
+#endif
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_psm_disable
+* DESCRIPTION
+*  disable STP sleep/wakeup support
+* PARAMETERS
+*  void
+* RETURNS
+*  0: Sccuess  Negative value: Fail
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_psm_disable(VOID)
+{
+#if 0
+	if (MTK_WCN_BOOL_TRUE == stp_psm_is_quick_ps_support()) {
+		if (mtk_wcn_stp_is_ready())
+			return stp_psm_disable(STP_PSM_CORE(stp_core_ctx));
+		STP_WARN_FUNC("STP Not Ready, Dont do Sleep/Wakeup\n");
+		return -1;
+	}
+	if (mtk_wcn_stp_is_ready() && mtk_wcn_stp_is_btif_fullset_mode()) {
+		return stp_psm_disable(STP_PSM_CORE(stp_core_ctx));
+	} else if (mtk_wcn_stp_is_sdio_mode()) {
+		stp_psm_disable(STP_PSM_CORE(stp_core_ctx));
+		return 0;
+	}
+	STP_WARN_FUNC("STP Not Ready, Dont do Sleep/Wakeup\n");
+	return -1;
+
+#else
+	if (mtk_wcn_stp_is_ready() && mtk_wcn_stp_is_btif_fullset_mode()) {
+		return stp_psm_disable(STP_PSM_CORE(stp_core_ctx));
+	} else if (mtk_wcn_stp_is_sdio_mode()) {
+		stp_psm_disable(STP_PSM_CORE(stp_core_ctx));
+		return 0;
+	}
+	STP_DBG_FUNC("STP Not Ready, Dont do Sleep/Wakeup\n");
+	return 0;
+
+#endif
+}
+
+extern INT32 mtk_wcn_stp_psm_reset(VOID)
+{
+	return stp_psm_reset(STP_PSM_CORE(stp_core_ctx));
+}
+
+extern INT32 mtk_wcn_stp_dbg_disable(VOID)
+{
+	if (STP_IS_ENABLE_DBG(stp_core_ctx)) {
+		STP_DBG_FUNC("STP dbg mode is turned off\n");
+		STP_SET_ENABLE_DBG(stp_core_ctx, 0);
+		stp_dbg_disable(g_mtkstp_dbg);
+	} else {
+		STP_WARN_FUNC("STP dbg mode has been turned off\n");
+	}
+
+	return 0;
+}
+
+extern INT32 mtk_wcn_stp_dbg_enable(VOID)
+{
+	if (STP_NOT_ENABLE_DBG(stp_core_ctx)) {
+		STP_DBG_FUNC("STP dbg mode is turned on\n");
+		STP_SET_ENABLE_DBG(stp_core_ctx, 1);
+		stp_dbg_enable(g_mtkstp_dbg);
+	} else {
+		STP_WARN_FUNC("STP dbg mode has been turned on\n");
+	}
+
+	return 0;
+}
+
+INT32 mtk_wcn_stp_dbg_log_ctrl(UINT32 on)
+{
+	stp_dbg_log_ctrl(on);
+	return 0;
+}
+
+INT32 mtk_wcn_stp_coredump_flag_ctrl(UINT32 on)
+{
+	STP_ENABLE_FW_COREDUMP(stp_core_ctx, on);
+	STP_INFO_FUNC("coredump function mode: %d.\n", on);
+	g_coredump_mode = on;
+	return 0;
+}
+
+INT32 mtk_wcn_stp_coredump_flag_get(VOID)
+{
+	return STP_ENABLE_FW_COREDUMP_FLAG(stp_core_ctx);
+}
+
+static INT32 stp_parser_data_in_mand_mode(UINT32 length, UINT8 *p_data)
+{
+	UINT8 padding_len = 0;
+	INT32 remain_length;	/* GeorgeKuo: sync from MAUI, change to unsigned */
+	MTK_WCN_BOOL is_function_active = 0;
+	INT32 i = length;
+
+	while (i > 0) {
+		switch (stp_core_ctx.parser.state) {
+		case MTKSTP_SYNC:	/* b'10 */
+			/* if (((*p_data & 0x80) == 0x80) && ((*p_data & 0x40) == 0x00)) */
+			/* if(*p_data == 0x80) */
+			if ((*p_data & 0x80) == 0x80) {
+				/* STP_DBG_FUNC("[STP] STP Packet Start =========>\n"); */
+				if (*p_data != 0x80)
+					STP_WARN_FUNC("SDIO not 0x80!!(0x%x)\n", *p_data);
+
+				if (i >= 4) {
+#if !(REMOVE_USELESS_LOG)
+					/*print header, when get the full STP header */
+					UINT32 type = (*(p_data + 1) & 0x70) >> 4;
+					UINT8 *type_name = "<UNKNOWN>";
+
+					type_name = stp_type_to_dbg_string(type);
+					STP_DBG_FUNC(
+						"STP Rx Header: [%02x %02x %02x %02x] type=%s, len=%d, seq=%d, ack=%d\n",
+						*p_data, *(p_data + 1), *(p_data + 2), *(p_data + 3),
+						type_name, ((*(p_data + 1) & 0x0f) << 8) + *(p_data + 2),
+						(*p_data & 0x38) >> 3, *p_data & 0x07);
+#endif
+				} else {
+						STP_WARN_FUNC("STP Rx: discard due to i < 4 (%d)\n", i);
+				}
+
+				/* STP_DBG_FUNC("[STP] sync->nak\n"); */
+				stp_change_rx_state(MTKSTP_NAK);
+				stp_core_ctx.rx_counter++;
+			} else {
+				STP_WARN_FUNC("sync to sync!!(0x%x)\n", *p_data);
+				stp_change_rx_state(MTKSTP_SYNC);
+			}
+			break;
+
+		case MTKSTP_NAK:
+			/* STP_DBG_FUNC("[STP] nak->length\n"); */
+			stp_change_rx_state(MTKSTP_LENGTH);
+			stp_core_ctx.parser.type = (*p_data & 0x70) >> 4;
+			if (stp_core_ctx.parser.type <= MTKSTP_MAX_TASK_NUM) {
+				stp_core_ctx.parser.length = (*p_data & 0x0f) << 8;
+				stp_core_ctx.rx_counter++;
+			} else {
+				STP_WARN_FUNC("nak to sync\n");
+				stp_change_rx_state(MTKSTP_SYNC);
+			}
+			break;
+
+		case MTKSTP_LENGTH:
+			/* STP_DBG_FUNC("[STP] length -> checksum\n"); */
+			stp_change_rx_state(MTKSTP_CHECKSUM);
+			stp_core_ctx.parser.length += *p_data;
+
+			/*Valid length checking */
+			if (stp_core_ctx.parser.length < 2000) {
+				stp_core_ctx.rx_counter++;
+			} else {
+				STP_WARN_FUNC("The length of STP packet is not valid !!! length = %d\n",
+					stp_core_ctx.parser.length);
+				stp_change_rx_state(MTKSTP_SYNC);
+				stp_core_ctx.rx_counter = 0;
+					/* return -1; */
+			}
+
+			break;
+
+		case MTKSTP_CHECKSUM:
+
+			if ((stp_core_ctx.parser.type == STP_TASK_INDX) ||
+				   (stp_core_ctx.parser.type == INFO_TASK_INDX)) {
+				stp_change_rx_state(MTKSTP_FW_MSG);
+				stp_core_ctx.rx_counter = 0;
+				i -= 1;
+				if (i != 0)
+					p_data += 1;
+
+				continue;
+			}
+
+			if (stp_core_ctx.parser.length == 0) {
+				STP_WARN_FUNC("checksum to sync\n");
+				stp_change_rx_state(MTKSTP_SYNC);
+				stp_core_ctx.rx_counter = 0;
+			} else {
+				/* STP_DBG_FUNC("[STP] checksum->data\n"); */
+				stp_change_rx_state(MTKSTP_DATA);
+				stp_core_ctx.rx_counter = 0;
+			}
+			break;
+
+		case MTKSTP_DATA:
+
+			/* block copy instead of byte copy */
+			if (stp_core_ctx.parser.length < stp_core_ctx.rx_counter) {
+				STP_ERR_FUNC("Abnormal length in STP_DATA phase 0x%x, 0x%x\n",
+						stp_core_ctx.parser.length, stp_core_ctx.rx_counter);
+				osal_assert(0);
+			}
+			remain_length = stp_core_ctx.parser.length - stp_core_ctx.rx_counter;
+			if (i >= remain_length) {
+				/*boundary checking */
+				if (stp_core_ctx.rx_counter + remain_length >= MTKSTP_BUFFER_SIZE) {
+					STP_ERR_FUNC("Abnormal!! Memory operation over boundary!!\n");
+					stp_change_rx_state(MTKSTP_SYNC);
+					stp_core_ctx.rx_counter = 0;
+					return -1;
+				}
+
+				osal_memcpy(stp_core_ctx.rx_buf + stp_core_ctx.rx_counter, p_data,
+							remain_length);
+				i -= remain_length;
+				p_data += remain_length;
+				stp_core_ctx.rx_counter = stp_core_ctx.parser.length;
+				stp_core_ctx.parser.state = MTKSTP_CRC1;
+				continue;
+
+			} else {	/* only copy by data length */
+
+				/*fixed klocwork insight issue */
+				/*boundary checking */
+				if (i + stp_core_ctx.rx_counter >= MTKSTP_BUFFER_SIZE) {
+					STP_ERR_FUNC("Abnormal!! Memory operation over boundary 2!!\n");
+					stp_core_ctx.rx_counter = 0;
+					return -1;
+				}
+
+				osal_memcpy(stp_core_ctx.rx_buf + stp_core_ctx.rx_counter, p_data, i);
+				stp_core_ctx.rx_counter += i;	/* all remain buffer are data */
+				i = 0;
+				p_data += i;
+				continue;
+			}
+			break;
+
+		case MTKSTP_CRC1:
+			stp_change_rx_state(MTKSTP_CRC2);
+			break;
+
+		case MTKSTP_CRC2:
+#if 1
+			if (stp_core_ctx.parser.type == WMT_TASK_INDX) {
+				stp_core_ctx.parser.wmtsubtype = stp_core_ctx.rx_buf[1];
+				STP_DBG_FUNC("wmt sub type (0x%x)\n", stp_core_ctx.parser.wmtsubtype);
+			}
+#endif
+			/*SDIO mode do it. */
+			if (mtk_wcn_stp_is_sdio_mode()) {
+				/*STP packet 4-bytes alignment */
+				/*Discard padding bytes , otherwise make parser state machine disorder */
+				if (i <= 4) {
+					/*STP_DBG_FUNC("STP last block padding %d bytes\n", i-1); */
+					p_data += (i - 1);
+					i -= (i - 1);
+				} else {
+					padding_len = (0x04 - ((stp_core_ctx.parser.length + 6) & 0x03)) & 0x03;
+					p_data += padding_len;
+					i -= padding_len;
+					/*STP_DBG_FUNC("STP Agg padding %d bytes\n", padding_len); */
+				}
+			}
+			stp_dbg_pkt_log(stp_core_ctx.parser.type,
+					0, 0, 0, PKT_DIR_RX, stp_core_ctx.rx_buf, stp_core_ctx.rx_counter);
+			if ((stp_core_ctx.parser.type == BT_TASK_INDX) && STP_BT_STK_IS_BLUEZ(stp_core_ctx)) {
+				int b;
+
+				/*Indicate packet to hci_stp */
+				if (gStpDbgLvl >= STP_LOG_DBG) {
+					stp_dump_data(stp_core_ctx.rx_buf, "indicate_to_bt_core",
+								stp_core_ctx.rx_counter);
+				}
+
+				b = mtk_wcn_sys_if_rx(stp_core_ctx.rx_buf, stp_core_ctx.rx_counter);
+				if (b)
+					STP_ERR_FUNC("mtk_wcn_sys_if_rx is NULL\n");
+
+			} else {
+
+				is_function_active = (
+					(*sys_check_function_status)(stp_core_ctx.parser.type, OP_FUNCTION_ACTIVE)
+					     == STATUS_FUNCTION_ACTIVE);
+
+				/*check type and function if active? */
+				if ((stp_core_ctx.parser.type < MTKSTP_MAX_TASK_NUM)
+						&& (is_function_active == MTK_WCN_BOOL_TRUE)) {
+#if CFG_WMT_LTE_COEX_HANDLING
+					if ((stp_core_ctx.parser.type == WMT_TASK_INDX)
+							&& stp_core_ctx.parser.wmtsubtype == WMT_LTE_COEX_FLAG) {
+						STP_INFO_FUNC("wmt/lte coex package!\n");
+						stp_add_to_rx_queue(stp_core_ctx.rx_buf,
+									stp_core_ctx.rx_counter, COEX_TASK_INDX);
+						stp_notify_btm_handle_wmt_lte_coex(STP_BTM_CORE(stp_core_ctx));
+					} else {
+						stp_add_to_rx_queue(stp_core_ctx.rx_buf,
+									stp_core_ctx.rx_counter,
+									stp_core_ctx.parser.type);
+
+						/*notify corresponding subfunction of incoming data */
+						(*sys_event_set) (stp_core_ctx.parser.type);
+					}
+#else
+					if ((stp_core_ctx.parser.type == WMT_TASK_INDX)
+							&& stp_core_ctx.parser.wmtsubtype == WMT_LTE_COEX_FLAG) {
+						STP_WARN_FUNC
+							("omit BT/WIFI & LTE coex msg handling in non-LTE projects\n");
+					} else {
+						stp_add_to_rx_queue(stp_core_ctx.rx_buf,
+											stp_core_ctx.rx_counter,
+											stp_core_ctx.parser.type);
+
+						/*notify corresponding subfunction of incoming data */
+						(*sys_event_set) (stp_core_ctx.parser.type);
+					}
+#endif
+				} else {
+					if (is_function_active == MTK_WCN_BOOL_FALSE) {
+						STP_ERR_FUNC
+							("function type = %d is inactive, so no en-queue to rx\n",
+							stp_core_ctx.parser.type);
+					} else {
+						STP_ERR_FUNC
+							("mtkstp_process_packet: type = %x, the type is invalid\n",
+							stp_core_ctx.parser.type);
+					}
+				}
+			}
+
+			/* STP_DBG_FUNC("[STP] crc2->sync\n"); */
+			/* STP_DBG_FUNC("[STP] STP Packet End <=========\n"); */
+			stp_core_ctx.rx_counter = 0;
+			stp_change_rx_state(MTKSTP_SYNC);
+
+			break;
+
+		case MTKSTP_FW_MSG:
+
+			/*f/w assert and exception information */
+			if (stp_core_ctx.parser.length < stp_core_ctx.rx_counter) {
+				STP_ERR_FUNC("Abnormal length in STP_DATA phase 0x%x, 0x%x\n",
+					     stp_core_ctx.parser.length, stp_core_ctx.rx_counter);
+			}
+
+			remain_length = stp_core_ctx.parser.length - stp_core_ctx.rx_counter;
+
+			if (i >= remain_length) {
+				osal_memcpy(stp_core_ctx.rx_buf + stp_core_ctx.rx_counter, p_data,
+					    remain_length);
+				i -= remain_length;
+				p_data += remain_length;
+				stp_core_ctx.rx_counter = stp_core_ctx.parser.length;
+				*(stp_core_ctx.rx_buf + stp_core_ctx.rx_counter) = '\0';
+				/*Trace32 Dump */
+				if (stp_core_ctx.parser.type == STP_TASK_INDX) {
+					/* g_block_tx = 1; */
+					mtk_wcn_stp_coredump_start_ctrl(1);
+					pr_debug("[len=%d][type=%d]\n%s\n", stp_core_ctx.rx_counter,
+					       stp_core_ctx.parser.type, stp_core_ctx.rx_buf);
+					/*use paged dump or full dump */
+					stp_btm_notify_wmt_dmp_wq(stp_core_ctx.btm);
+#if 0
+					stp_dbg_log_pkt(g_mtkstp_dbg, STP_DBG_FW_DMP /*STP_DBG_FW_ASSERT */ , 5,
+							0, 0, 0, 0,
+							(stp_core_ctx.rx_counter + 1), stp_core_ctx.rx_buf);
+#endif
+				}
+
+				/*discard CRC */
+				/* we will discard antoher CRC on the outer switch procedure. */
+				if (i >= 1) {
+					STP_INFO_FUNC("crc discard.. i = %d\n", i);
+					i -= 1;
+					if (i > 0)
+						p_data += 1;
+
+				}
+
+				/*STP packet 4-bytes alignment */
+				/*Discard padding bytes , otherwise make parser state machine disorder */
+				if (i <= 4) {
+					STP_INFO_FUNC
+					    ("\n[STP]FW_EVENT========= block padding %d bytes =========\n",
+					     i - 1);
+					p_data += (i - 1);
+					i -= (i - 1);
+				} else {
+					padding_len = (0x04 - ((stp_core_ctx.parser.length + 6) & 0x03)) & 0x03;
+					p_data += padding_len;
+					i -= padding_len;
+					STP_INFO_FUNC
+					    ("\n[STP]FW_EVENT========= STP Agg padding %d bytes =========\n",
+					     padding_len);
+				}
+				stp_change_rx_state(MTKSTP_SYNC);
+
+			} else {	/* only copy by data length */
+
+				STP_ERR_FUNC("raw data doesn't contain full stp packet!!\n");
+			}
+			break;
+		default:
+			break;
+		}
+		p_data++;
+		i--;
+	}
+
+	return 0;
+}
+
+static INT32 stp_parser_data_in_full_mode(UINT32 length, UINT8 *p_data)
+{
+	INT32 remain_length;	/* GeorgeKuo: sync from MAUI, change to unsigned */
+	INT32 i = length;
+
+	while (i > 0) {
+		switch (stp_core_ctx.parser.state) {
+
+		case MTKSTP_RESYNC1:	/* RESYNC must be 4 _continuous_ 0x7f */
+			if (*p_data == 0x7f)
+				stp_change_rx_state(MTKSTP_RESYNC2);
+			else
+				stp_change_rx_state(MTKSTP_RESYNC1);
+			break;
+		case MTKSTP_RESYNC2:
+			if (*p_data == 0x7f)
+				stp_change_rx_state(MTKSTP_RESYNC3);
+			else
+				stp_change_rx_state(MTKSTP_RESYNC1);
+			break;
+		case MTKSTP_RESYNC3:
+			if (*p_data == 0x7f)
+				stp_change_rx_state(MTKSTP_RESYNC4);
+			else
+				stp_change_rx_state(MTKSTP_RESYNC1);
+			break;
+		case MTKSTP_RESYNC4:
+			if (*p_data == 0x7f)
+				stp_change_rx_state(MTKSTP_SYNC);
+			else
+				stp_change_rx_state(MTKSTP_RESYNC1);
+			break;
+		case MTKSTP_SYNC:	/* b'10 */
+			STP_DUMP_PACKET_HEAD(p_data, "rx (uart):", length > 4 ? 4 : length);
+			if (((*p_data & 0x80) == 0x80) && ((*p_data & 0x40) == 0x00)) {
+				stp_change_rx_state(MTKSTP_NAK);
+				stp_core_ctx.parser.seq = (*p_data & 0x38) >> 3;
+				stp_core_ctx.parser.ack = *p_data & 0x07;
+				stp_core_ctx.rx_buf[0] = *p_data;
+				/* Geoge FIXME: WHY comment the following line? */
+				/* stp_core_ctx.rx_counter++; */
+
+				if (i >= 4 && gStpDbgLvl >= STP_LOG_DBG) {
+					/*print header, when get the full STP header */
+#if !(REMOVE_USELESS_LOG)
+					int type = (*(p_data + 1) & 0x70) >> 4;
+					char *type_name = "<UNKNOWN>";
+
+					type_name = stp_type_to_dbg_string(type);
+
+					STP_DBG_FUNC
+					    ("STP Rx Header: [%02x %02x %02x %02x] type=%s, len=%d, seq=%d, ack=%d\n",
+					     *p_data, *(p_data + 1), *(p_data + 2), *(p_data + 3), type_name,
+					     ((*(p_data + 1) & 0x0f) << 8) + *(p_data + 2),
+					     (*p_data & 0x38) >> 3, *p_data & 0x07);
+#endif
+				} else {
+					STP_DBG_FUNC("STP Rx: discard due to i < 4\n");
+				}
+			} else if ((*p_data == 0x7f) && (prev_state == MTKSTP_RESYNC4)) {
+				/* if this 0x7f is continuous to resync pattern */
+				/* skip this continuous 0x7f, remain current & prev state */
+				osal_assert(0);
+				STP_ERR_FUNC("MTKSTP_SYNC: continuous resync pattern, buff = %x\n", *p_data);
+			} else if (*p_data == 0x7f) {	/* a start of 0x7f, maybe this is resync pattern */
+				stp_change_rx_state(MTKSTP_RESYNC2);
+				osal_assert(0);
+				STP_ERR_FUNC("MTKSTP_SYNC: go to MTKSTP_RESYNC2, buff = %x\n", *p_data);
+			} else if (*p_data == 0x55) {	/* STP delimiter */
+				/* do nothing for delimiter */
+			} else {	/* unexpected, go to resync1 */
+				osal_assert(0);
+				STP_ERR_FUNC("MTKSTP_SYNC: unexpected data, buff = %x\n", *p_data);
+			}
+			break;
+
+		case MTKSTP_NAK:
+			/* (*sys_dbg_print)("MTKSTP_NAK : mtk_wcn_stp_parser_data, buff = %x", *p_data); */
+			if (fgEnableNak == 0)
+				stp_core_ctx.parser.nak = 0;	/* disable NAK */
+			else
+				stp_core_ctx.parser.nak = (*p_data & 0x80) >> 7;
+
+			stp_core_ctx.parser.type = (*p_data & 0x70) >> 4;
+			stp_core_ctx.parser.length = (*p_data & 0x0f) << 8;
+			stp_core_ctx.rx_buf[1] = *p_data;
+			/* Geoge FIXME: WHY comment the following line? */
+			/*stp_core_ctx.rx_counter++; */
+			if (stp_core_ctx.parser.nak)
+				STP_ERR_FUNC("MTKSTP_NAK TRUE: mtk_wcn_stp_parser_data, buff = %x\n", *p_data);
+
+			if (stp_core_ctx.parser.type < MTKSTP_MAX_TASK_NUM)
+				stp_change_rx_state(MTKSTP_LENGTH);
+			else
+				stp_change_rx_state(MTKSTP_SYNC);
+			break;
+
+		case MTKSTP_LENGTH:
+			/* (*sys_dbg_print)("MTKSTP_LENGTH : mtk_wcn_stp_parser_data, buff = %x", *p_data); */
+			stp_change_rx_state(MTKSTP_CHECKSUM);
+			stp_core_ctx.parser.length += *p_data;
+
+			/*Valid length checking */
+			if (stp_core_ctx.parser.length > 2048) {
+				STP_ERR_FUNC("The length of STP packet is not valid !!! length = %d\n",
+					     stp_core_ctx.parser.length);
+				stp_change_rx_state(MTKSTP_RESYNC1);
+				stp_core_ctx.rx_counter = 0;
+				STP_TRACE_FUNC("--\n");
+				return -1;
+			}
+
+			stp_core_ctx.rx_buf[2] = *p_data;
+			/* Geoge FIXME: WHY comment the following line? */
+			/*stp_core_ctx.rx_counter++; */
+			break;
+
+		case MTKSTP_CHECKSUM:
+			/* (*sys_dbg_print)("MTKSTP_CHECKSUM : mtk_wcn_stp_parser_data, buff = %x", *p_data); */
+			if ((stp_core_ctx.parser.type == STP_TASK_INDX) ||
+			    (stp_core_ctx.parser.type == INFO_TASK_INDX)) {
+				stp_change_rx_state(MTKSTP_FW_MSG);
+				stp_core_ctx.rx_counter = 0;
+				i -= 1;
+				if (i != 0)
+					p_data += 1;
+
+				continue;
+			}
+
+			if (((stp_core_ctx.rx_buf[0] +
+			      stp_core_ctx.rx_buf[1] + stp_core_ctx.rx_buf[2]) & 0xff) == *p_data) {
+				/* header only packet */
+				if (stp_core_ctx.parser.length == 0) {
+					INT32 fgTriggerResume = (-1);
+
+					/* osal_lock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+					stp_ctx_lock(&stp_core_ctx);
+					if (stp_core_ctx.inband_rst_set == 0) {
+						stp_dbg_pkt_log(STP_TASK_INDX,
+								stp_core_ctx.parser.ack,
+								stp_core_ctx.parser.seq,
+								5,	/* STP type id */
+								PKT_DIR_RX,
+								NULL,
+								0);
+						fgTriggerResume = stp_process_rxack();
+					} else {
+						STP_WARN_FUNC
+						    ("Now it's inband reset process and drop ACK packet.\n");
+					}
+
+					if (fgTriggerResume == 0) {
+						/* notify adaptation layer for
+						* possible tx resume mechanism
+						*/
+						(*sys_event_tx_resume) (stp_core_ctx.sequence.winspace);
+					}
+					stp_ctx_unlock(&stp_core_ctx);
+					/* osal_unlock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+					stp_change_rx_state(MTKSTP_SYNC);
+					stp_core_ctx.rx_counter = 0;
+				} else {
+					stp_change_rx_state(MTKSTP_DATA);
+					stp_core_ctx.rx_counter = 0;
+				}
+			} else {
+				STP_ERR_FUNC("The checksum of header is error !!! %02x %02x %02x %02x\n",
+					     stp_core_ctx.rx_buf[0], stp_core_ctx.rx_buf[1],
+					     stp_core_ctx.rx_buf[2], *p_data);
+				/* George FIXME: error handling mechanism shall be refined */
+				stp_change_rx_state(MTKSTP_RESYNC1);
+				stp_core_ctx.rx_counter = 0;
+
+				/* since checksum error is usually related to interface
+				 * buffer overflow, so we just let timeout mechanism to
+				 * handle such error.
+				 */
+				STP_TRACE_FUNC("--\n");
+				/* return and purge COMM port */
+				return -1;
+				/*stp_send_ack(1); NAK mechanism is removed */
+			}
+			break;
+
+		case MTKSTP_DATA:
+#if 0
+			if (stp_core_ctx.rx_counter < stp_core_ctx.parser.length) {
+				stp_core_ctx.rx_buf[stp_core_ctx.rx_counter] = *p_data;
+				stp_core_ctx.rx_counter++;
+			}
+			if (stp_core_ctx.rx_counter == stp_core_ctx.parser.length)
+				stp_change_rx_state(MTKSTP_CRC1);
+#else
+			/* block copy instead of byte copy */
+			if (stp_core_ctx.parser.length < stp_core_ctx.rx_counter) {
+				STP_ERR_FUNC("Abnormal length in STP_DATA phase 0x%x, 0x%x\n",
+					     stp_core_ctx.parser.length, stp_core_ctx.rx_counter);
+				osal_assert(0);
+			}
+			remain_length = stp_core_ctx.parser.length - stp_core_ctx.rx_counter;
+			if (i >= remain_length) {
+				osal_memcpy(stp_core_ctx.rx_buf + stp_core_ctx.rx_counter, p_data,
+					    remain_length);
+
+				i -= remain_length;
+				p_data += remain_length;
+				stp_core_ctx.rx_counter = stp_core_ctx.parser.length;
+				stp_core_ctx.parser.state = MTKSTP_CRC1;
+				continue;
+			} else {	/* only copy by data length */
+
+				/*fixed klocwork insight issue */
+				if (i + stp_core_ctx.rx_counter >= MTKSTP_BUFFER_SIZE) {
+					STP_ERR_FUNC
+					    ("Fail to handle Packet, maybe it doesn't follow STP protocol.\n");
+					stp_change_rx_state(MTKSTP_RESYNC1);
+					stp_core_ctx.rx_counter = 0;
+					STP_TRACE_FUNC("--\n");
+					return -1;
+				}
+
+				osal_memcpy(stp_core_ctx.rx_buf + stp_core_ctx.rx_counter, p_data, i);
+				stp_core_ctx.rx_counter += i;	/* all remain buffer are data */
+				i = 0;
+				p_data += i;
+				continue;
+			}
+#endif
+			break;
+
+		case MTKSTP_CRC1:
+			stp_change_rx_state(MTKSTP_CRC2);
+			stp_core_ctx.parser.crc = *p_data;
+			break;
+		case MTKSTP_CRC2:
+			stp_change_rx_state(MTKSTP_SYNC);
+			stp_core_ctx.parser.crc += (*p_data) << 8;
+#if 1
+			if (stp_core_ctx.parser.type == WMT_TASK_INDX) {
+				stp_core_ctx.parser.wmtsubtype = stp_core_ctx.rx_buf[1];
+				STP_DBG_FUNC("wmt sub type is (0x%x)\n", stp_core_ctx.parser.wmtsubtype);
+			}
+#endif
+			if (stp_check_crc(stp_core_ctx.rx_buf, stp_core_ctx.rx_counter, stp_core_ctx.parser.crc)
+			    == MTK_WCN_BOOL_TRUE) {
+				if (stp_core_ctx.inband_rst_set == 0)
+					stp_process_packet();
+				else
+					STP_WARN_FUNC("Now it's inband reset process and drop packet.\n");
+			} else {
+				STP_ERR_FUNC("The CRC of packet is error !!!\n");
+				/* George FIXME: error handling mechanism shall be refined */
+				stp_change_rx_state(MTKSTP_RESYNC1);
+				stp_core_ctx.rx_counter = 0;
+
+				/* since checksum error is usually related to interface
+				 * buffer overflow, so we just let timeout mechanism to
+				 * handle such error.
+				 */
+				STP_TRACE_FUNC("--\n");
+				/* return and purge COMM port */
+				return -1;
+				/*stp_send_ack(1); NAK mechanism is removed */
+			}
+			break;
+
+		case MTKSTP_FW_MSG:
+#if CFG_WMT_DUMP_INT_STATUS
+			if (MTK_WCN_BOOL_TRUE == wmt_plat_dump_BGF_irq_status())
+				wmt_plat_BGF_irq_dump_status();
+#endif
+			if (STP_IS_READY(stp_core_ctx))
+				mtk_wcn_stp_dbg_dump_package();
+
+			STP_SET_READY(stp_core_ctx, 0);
+			/*stp inband reset */
+			if (stp_core_ctx.parser.type == STP_TASK_INDX &&
+			    stp_core_ctx.parser.seq == 0 &&
+			    stp_core_ctx.parser.ack == 0 &&
+			    stp_core_ctx.parser.length == 0 && stp_core_ctx.inband_rst_set == 1) {
+				STP_INFO_FUNC("Inband reset event get! Resync STP with firmware!\n\r");
+				stp_rest_ctx_state();
+				stp_change_rx_state(MTKSTP_RESYNC1);
+				stp_core_ctx.inband_rst_set = 0;
+				/* STP_INFO_FUNC("Restart STP Timer\n\r"); */
+				/* (*sys_timer_start)(stp_core_ctx.tx_timer,
+				*		mtkstp_tx_timeout,
+				*		(MTK_WCN_TIMER_CB)stp_tx_timeout_handler,
+				*		NULL);
+				*/
+				STP_TRACE_FUNC("--\n");
+				return 0;
+			}
+
+			/*f/w assert and exception information */
+			if (stp_core_ctx.parser.length < stp_core_ctx.rx_counter) {
+				STP_ERR_FUNC("Abnormal length in STP_DATA phase 0x%x, 0x%x\n",
+					     stp_core_ctx.parser.length, stp_core_ctx.rx_counter);
+				osal_assert(0);
+			}
+
+			remain_length = stp_core_ctx.parser.length - stp_core_ctx.rx_counter;
+			if (i >= remain_length) {
+				osal_memcpy(stp_core_ctx.rx_buf + stp_core_ctx.rx_counter, p_data,
+					    remain_length);
+				i -= remain_length;
+				p_data += remain_length;
+				stp_core_ctx.rx_counter = stp_core_ctx.parser.length;
+				stp_change_rx_state(MTKSTP_SYNC);
+				*(stp_core_ctx.rx_buf + stp_core_ctx.rx_counter) = '\0';
+				/* STP_ERR_FUNC("%s [%d]\n", stp_core_ctx.rx_buf, stp_core_ctx.rx_counter); */
+#if 0
+				if ((stp_core_ctx.rx_counter == 1) && (stp_core_ctx.rx_buf[0] == 0xFF)) {
+					/* For MT6620, enable/disable coredump function is controlled by
+					* firmware for the moment, we need to set coredump enable flag
+					* to be 1 after see firmware send a pariticallar character(0xff)
+					* before any coredump packet is sent
+					*/
+					mtk_wcn_stp_coredump_flag_ctrl(1);
+				}
+#endif
+				/*Trace32 Dump */
+				if (STP_IS_ENABLE_DBG(stp_core_ctx) &&
+					(stp_core_ctx.parser.type == STP_TASK_INDX)) {
+					if (0 != stp_core_ctx.rx_counter) {
+						STP_SET_READY(stp_core_ctx, 0);
+						mtk_wcn_stp_ctx_save();
+						STP_INFO_FUNC("++ start to read paged dump and paged trace ++\n");
+						stp_btm_notify_wmt_dmp_wq(stp_core_ctx.btm);
+						stp_btm_notify_wmt_trace_wq(stp_core_ctx.btm);
+						STP_INFO_FUNC("++ start to read paged dump and paged trace --\n");
+
+					}
+					STP_INFO_FUNC("[len=%d][type=%d]\n%s\n", stp_core_ctx.rx_counter,
+					       stp_core_ctx.parser.type, stp_core_ctx.rx_buf);
+				}
+
+				/*Runtime FW Log */
+				else if (STP_IS_ENABLE_DBG(stp_core_ctx)
+					 && (stp_core_ctx.parser.type == INFO_TASK_INDX)) {
+					stp_dbg_log_pkt(g_mtkstp_dbg, STP_DBG_FW_LOG, STP_TASK_INDX, 5, 0, 0, 0,
+							(stp_core_ctx.rx_counter + 1), stp_core_ctx.rx_buf);
+					mtk_wcn_stp_dbg_dump_package();
+				}
+				/*Normal mode: whole chip reset */
+				else {
+					/*Aee Kernel Warning Message Shown First */
+					/* (*sys_dbg_assert_aee)("[MT662x]f/w Assert", stp_core_ctx.rx_buf); */
+					mtk_wcn_stp_coredump_start_ctrl(0);
+					mtk_wcn_stp_dbg_dump_package();
+
+					osal_dbg_assert_aee(stp_core_ctx.rx_buf, stp_core_ctx.rx_buf);
+					/*Whole Chip Reset Procedure Invoke */
+					if (STP_IS_ENABLE_RST(stp_core_ctx)) {
+						STP_SET_READY(stp_core_ctx, 0);
+						stp_btm_notify_wmt_rst_wq(STP_BTM_CORE(stp_core_ctx));
+					} else {
+						STP_INFO_FUNC
+						    ("No to launch whole chip reset! for debugging purpose\n");
+					}
+				}
+				/*discard CRC */
+				if (i >= 2) {
+					STP_DBG_FUNC("crc discard.. i = %d\n", i);
+					i -= 2;
+					if (i > 0)
+						p_data += 2;
+				}
+				continue;
+			} else {	/* only copy by data length */
+
+				/*fixed klocwork insight issue */
+				if (i + stp_core_ctx.rx_counter >= MTKSTP_BUFFER_SIZE) {
+					STP_ERR_FUNC
+					    ("Fail to handle Packet, maybe it doesn't follow STP protocol.\n");
+					stp_change_rx_state(MTKSTP_RESYNC1);
+					stp_core_ctx.rx_counter = 0;
+					return -1;
+				}
+				osal_memcpy(stp_core_ctx.rx_buf + stp_core_ctx.rx_counter, p_data, i);
+				stp_core_ctx.rx_counter += i;	/* all remain buffer are data */
+				i = 0;
+				p_data += i;
+				continue;
+			}
+
+			break;
+		default:
+			break;
+		}
+		p_data++;
+		i--;
+	}
+
+	return 0;
+}
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_parser_data
+* DESCRIPTION
+*  push data to serial transport protocol parser engine
+* PARAMETERS
+*  buffer      [IN]        data buffer
+*  length      [IN]        data buffer length
+* RETURNS
+*  int            0 = success; -1 = crc/checksum error
+*****************************************************************************/
+#if STP_EXP_HID_API_EXPORT
+int _mtk_wcn_stp_parser_data(UINT8 *buffer, UINT32 length)
+#else
+int mtk_wcn_stp_parser_data(UINT8 *buffer, UINT32 length)
+#endif
+{
+    /*----------------------------------------------------------------*/
+	/* Local Variables                                                */
+    /*----------------------------------------------------------------*/
+	INT32 i;
+	UINT8 *p_data;
+	INT32 ret = 0;
+#ifdef DEBUG_DUMP_PACKET_HEAD
+	static UINT32 counter;
+
+	STP_TRACE_FUNC("++, rx (cnt=%d,len=%d)\n", ++counter, length);
+#endif
+
+#if 0
+#ifdef CONFIG_POWER_SAVING_SUPPORT
+	if (stp_is_apply_powersaving()) {
+		/* If now chip is awake, to restart monitor! */
+		if (!stp_psm_is_to_block_traffic(STP_PSM_CORE(stp_core_ctx))) {
+			STP_DBG_FUNC("To restart moinotr when rx\n\r");
+			stp_psm_start_monitor(STP_PSM_CORE(stp_core_ctx));
+		}
+	}
+#endif
+#endif
+
+    /*----------------------------------------------------------------*/
+	/* Code Body                                                      */
+    /*----------------------------------------------------------------*/
+	/* George FIXME: WHY or HOW can we reduct the locked region? */
+	/*flags = (*sys_mutex_lock)(stp_core_ctx.stp_mutex); */
+	i = length;
+	p_data = (UINT8 *) buffer;
+
+/* stp_dump_data(buffer, "rx queue", length); */
+
+	/*STP is not enabled and only WMT can use Raw data path */
+	if (STP_NOT_ENABLE(stp_core_ctx) && WMT_TASK_INDX == STP_PENDING_TYPE(stp_core_ctx)) {
+		/* route to task who send command */
+		stp_add_to_rx_queue(buffer, length, STP_PENDING_TYPE(stp_core_ctx));
+
+		/* mike: notify corresponding subfunction of incoming data */
+		(*sys_event_set) (STP_PENDING_TYPE(stp_core_ctx));
+	}
+	/* STP over SDIO */
+	else if ((mtk_wcn_stp_is_sdio_mode() || mtk_wcn_stp_is_btif_mand_mode()) && STP_IS_ENABLE(stp_core_ctx)) {
+#if !(REMOVE_USELESS_LOG)
+		if (gStpDbgLvl >= STP_LOG_DBG)
+			stp_dump_data(buffer, "sdio parser_in", length);
+#endif
+		/* STP_DBG_FUNC("sdio stp parser data length = %d\n", length); */
+		ret = stp_parser_data_in_mand_mode(i, p_data);
+	}
+	/* STP over UART */
+	else if (mtk_wcn_stp_is_btif_fullset_mode() && STP_IS_ENABLE(stp_core_ctx))
+		ret = stp_parser_data_in_full_mode(i, p_data);
+
+	/* George FIXME: WHY or HOW can we reduct the locked region? */
+	/*(*sys_mutex_unlock)(stp_core_ctx.stp_mutex, flags); */
+	STP_TRACE_FUNC("--\n");
+	return ret;
+}
+#if !STP_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_stp_parser_data);
+#endif
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_enable
+* DESCRIPTION
+*  enable/disable STP
+* PARAMETERS
+*  value        [IN]        0=disable, others=enable
+* RETURNS
+*  INT32    0=success, others=error
+*****************************************************************************/
+INT32 mtk_wcn_stp_enable(INT32 value)
+{
+	STP_DBG_FUNC("%s: set the current enable = (%d)\n", __func__, value);
+
+	stp_rest_ctx_state();
+	STP_SET_ENABLE(stp_core_ctx, value);
+	if (!value) {
+		mtk_wcn_stp_psm_reset();
+	} else {
+/* g_block_tx = 0; */
+		mtk_wcn_stp_coredump_start_ctrl(0);
+	}
+	return 0;
+}
+
+INT32 mtk_wcn_stp_dbg_dump_package(VOID)
+{
+	if (STP_NOT_ENABLE(stp_core_ctx)) {
+		STP_INFO_FUNC("STP dbg mode is off\n");
+
+	} else {
+		STP_INFO_FUNC("STP dbg mode is on\n");
+		/* if (0 == g_block_tx) */
+		if (0 == mtk_wcn_stp_coredump_start_get()) {
+			mtk_wcn_consys_stp_btif_logger_ctrl(BTIF_DUMP_LOG);
+			mtk_wcn_consys_stp_btif_logger_ctrl(BTIF_DUMP_BTIF_REG);
+			stp_dbg_dmp_printk(g_mtkstp_dbg);
+		} else {
+			STP_INFO_FUNC("assert start flag is set, disable packet dump function\n");
+		}
+	}
+	return 0;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_ready
+* DESCRIPTION
+*  ready/un-ready STP
+* PARAMETERS
+*  value        [IN]        0=un-ready, others=ready
+* RETURNS
+*  INT32    0=success, others=error
+*****************************************************************************/
+INT32 mtk_wcn_stp_ready(INT32 value)
+{
+	STP_DBG_FUNC("set ready (%d)\n", value);
+
+	STP_SET_READY(stp_core_ctx, value);
+	/*if whole chip reset, reset the debuggine mode */
+#ifndef CONFIG_LOG_STP_INTERNAL
+	/* mtk_wcn_stp_dbg_disable(); */
+#endif
+
+	if (stp_is_apply_powersaving()) {
+		STP_INFO_FUNC("Restart the stp-psm monitor !!\n");
+		stp_psm_disable(STP_PSM_CORE(stp_core_ctx));
+	}
+
+	return 0;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_coredump_start_ctrl
+* DESCRIPTION
+*  set f/w assert flag in STP context
+* PARAMETERS
+*  value        [IN]        0=assert end, others=assert begins
+* RETURNS
+*  INT32    0=success, others=error
+*****************************************************************************/
+INT32 mtk_wcn_stp_coredump_start_ctrl(UINT32 value)
+{
+	STP_DBG_FUNC("set f/w assert (%d)\n", value);
+
+	STP_SET_FW_COREDUMP_FLAG(stp_core_ctx, value);
+
+	return 0;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_coredump_start_get
+* DESCRIPTION
+*  get f/w assert flag in STP context
+* PARAMETERS
+*  VOID
+* RETURNS
+*  INT32    0= f/w assert flag is not set, others=f/w assert flag is set
+*****************************************************************************/
+#if STP_EXP_HID_API_EXPORT
+INT32 _mtk_wcn_stp_coredump_start_get(VOID)
+#else
+INT32 mtk_wcn_stp_coredump_start_get(VOID)
+#endif
+{
+	return STP_FW_COREDUMP_FLAG(stp_core_ctx);
+}
+
+/* mtk_wcn_stp_set_wmt_last_close -- set the state of link(UART or SDIO)
+ * @ value - 1, link already be closed; 0, link is open
+ *
+ * Return 0 if success; else error code
+ */
+INT32 mtk_wcn_stp_set_wmt_last_close(UINT32 value)
+{
+	STP_INFO_FUNC("set wmt_last_close flag (%d)\n", value);
+
+	STP_SET_WMT_LAST_CLOSE(stp_core_ctx, value);
+
+	return 0;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_send_data
+* DESCRIPTION
+*  subfunction send data through STP
+* PARAMETERS
+*  buffer      [IN]        data buffer
+*  length      [IN]        data buffer length
+*  type        [IN]        subfunction type
+* RETURNS
+*  INT32    > 0: length transmitted; = 0: error
+*****************************************************************************/
+#if STP_EXP_HID_API_EXPORT
+INT32 _mtk_wcn_stp_send_data(const PUINT8 buffer, const UINT32 length, const UINT8 type)
+#else
+INT32 mtk_wcn_stp_send_data(const PUINT8 buffer, const UINT32 length, const UINT8 type)
+#endif
+{
+	UINT8 mtkstp_header[MTKSTP_HEADER_SIZE], temp[2];
+	UINT8 *p_tx_buf = NULL;
+	UINT16 crc;
+	INT32 ret = 0;
+	MTK_WCN_BOOL is_quick_enable = MTK_WCN_BOOL_TRUE;
+
+	/* osal_buffer_dump(buffer,"tx", length, 32); */
+
+	if (0 != STP_WMT_LAST_CLOSE(stp_core_ctx)) {
+		STP_ERR_FUNC("WMT lats close,should not have tx request!\n");
+		return length;
+	}
+	/* if(g_block_tx) */
+	if (0 != mtk_wcn_stp_coredump_start_get()) {
+		STP_ERR_FUNC("STP fw coredump start flag set...\n");
+		return length;
+	}
+#ifdef CONFIG_POWER_SAVING_SUPPORT
+	is_quick_enable = stp_psm_is_quick_ps_support();
+	STP_DBG_FUNC("is quick sleep enable:%s\n", is_quick_enable ? "yes" : "no");
+	if (MTK_WCN_BOOL_TRUE == is_quick_enable) {
+		if (type != WMT_TASK_INDX) {
+#if PSM_USE_COUNT_PACKAGE
+			stp_psm_disable_by_tx_rx_density(STP_PSM_CORE(stp_core_ctx), 0);
+#else
+			stp_psm_disable_by_tx_rx_density(STP_PSM_CORE(stp_core_ctx), 0, length);
+#endif
+		}
+		/* if(stp_is_apply_powersaving()) */
+		{
+			if (type == WMT_TASK_INDX)
+				goto DONT_MONITOR;
+		/*-----------------------------STP_PSM_Lock----------------------------------------*/
+			ret = stp_psm_thread_lock_aquire(STP_PSM_CORE(stp_core_ctx));
+			if (ret) {
+				STP_ERR_FUNC("--->lock psm_thread_lock failed ret=%d\n", ret);
+				return ret;
+			}
+
+			if (!stp_psm_is_to_block_traffic(STP_PSM_CORE(stp_core_ctx))) {
+				if (stp_psm_has_pending_data(STP_PSM_CORE(stp_core_ctx))) {
+					STP_WARN_FUNC("***** Release psm hold data before send normal data *****\n");
+					stp_psm_release_data(STP_PSM_CORE(stp_core_ctx));
+				}
+			} else {
+				ret = stp_psm_hold_data(STP_PSM_CORE(stp_core_ctx), buffer, length, type);
+				stp_psm_notify_wmt_wakeup(STP_PSM_CORE(stp_core_ctx));
+				/*-----------------------------STP_PSM_UnLock----------------------------------------*/
+				stp_psm_thread_lock_release(STP_PSM_CORE(stp_core_ctx));
+				return ret;
+			}
+		}
+	} else {
+		/* if(stp_is_apply_powersaving()) */
+		{
+		 if (type == WMT_TASK_INDX)
+				goto DONT_MONITOR;
+			/* If now chip is awake, to restart monitor! */
+			/* STP_INFO_FUNC("check if block traffic !!\n"); */
+		/*-----------------------------STP_PSM_Lock----------------------------------------*/
+			ret = stp_psm_thread_lock_aquire(STP_PSM_CORE(stp_core_ctx));
+			if (ret) {
+				STP_ERR_FUNC("--->lock psm_thread_lock failed ret=%d\n", ret);
+				return ret;
+			}
+
+			if (!stp_psm_is_to_block_traffic(STP_PSM_CORE(stp_core_ctx))) {
+				/* STP_INFO_FUNC("not to block !!\n"); */
+				if (stp_psm_has_pending_data(STP_PSM_CORE(stp_core_ctx))) {
+					STP_WARN_FUNC("***** Release psm hold data before send normal data *****\n");
+					stp_psm_release_data(STP_PSM_CORE(stp_core_ctx));
+				}
+				stp_psm_start_monitor(STP_PSM_CORE(stp_core_ctx));
+			} else {
+				/* STP_INFO_FUNC("to block !!\n"); */
+
+				/* STP_INFO_FUNC("*****hold data in psm queue data length = %d\n",
+				* length);
+				*/
+				/* stp_dump_data(buffer, "Hold in psm queue", length); */
+				/* hold datas */
+				ret = stp_psm_hold_data(STP_PSM_CORE(stp_core_ctx), buffer, length, type);
+				/* wmt notification */
+				STP_INFO_FUNC("#####Type = %d, to inform WMT to wakeup chip, ret = %d:0x%2x,0x%2x\n",
+					      type, ret, *buffer, *(buffer + 1));
+				stp_psm_notify_wmt_wakeup(STP_PSM_CORE(stp_core_ctx));
+				/* STP_INFO_FUNC("*********Type = %d, to inform WMT to wakeup chip>end\n", type); */
+		    /*-----------------------------STP_PSM_UnLock----------------------------------------*/
+				stp_psm_thread_lock_release(STP_PSM_CORE(stp_core_ctx));
+				return ret;
+			}
+		}
+	}
+DONT_MONITOR:
+#endif
+	if (type == BT_TASK_INDX) {
+		static const UINT8 rst_buf[4] = { 0x01, 0x03, 0x0c, 0x00 };
+
+		if (!osal_strncmp(buffer, rst_buf, 4))
+			osal_printtimeofday("############ BT Rest start -->");
+	}
+	/* osal_lock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+	stp_ctx_lock(&stp_core_ctx);
+	/*Only WMT can set raw data */
+	if (STP_NOT_ENABLE(stp_core_ctx) && WMT_TASK_INDX != type) {
+		/* no-op */
+		/* NULL; */
+	} else if (STP_NOT_ENABLE(stp_core_ctx) && WMT_TASK_INDX == type) {
+		/* ret = mtk_wcn_stp_send_data_raw(buffer, length, type); */
+		/* NULL; */
+	}
+	/* STP over SDIO */
+	else if ((mtk_wcn_stp_is_sdio_mode() || mtk_wcn_stp_is_btif_mand_mode()) && STP_IS_ENABLE(stp_core_ctx)) {
+
+		/* osal_printtimeofday("[ STP][SDIO][ B][W]"); */
+
+		mtkstp_header[0] = 0x80;
+		mtkstp_header[1] = (type << 4) + (((length) >> 8) & 0x0f);
+		mtkstp_header[2] = (length) & 0xff;
+		mtkstp_header[3] = 0x00;
+
+		/* HEADER */
+		p_tx_buf = &stp_core_ctx.tx_buf[0];
+		osal_memcpy(p_tx_buf, mtkstp_header, MTKSTP_HEADER_SIZE);
+		p_tx_buf += MTKSTP_HEADER_SIZE;
+
+		/* PAYLOAD */
+		osal_memcpy(p_tx_buf, buffer, length);
+		p_tx_buf += length;
+
+		/* CRC */
+		temp[0] = 0x00;
+		temp[1] = 0x00;
+		osal_memcpy(p_tx_buf, temp, 2);
+		stp_dbg_pkt_log(type, 0, 0, 0, PKT_DIR_TX, buffer, length);
+		(*sys_if_tx) (&stp_core_ctx.tx_buf[0], (MTKSTP_HEADER_SIZE + length + 2), &ret);
+
+		if ((MTKSTP_HEADER_SIZE + length + 2) != ret) {
+			STP_ERR_FUNC("stp send tx packet: %d, maybe stp_if_tx == NULL\n", ret);
+			osal_assert(0);
+			ret = 0;
+		} else {
+			ret = (INT32) length;
+		}
+
+		/* osal_printtimeofday("[ STP][SDIO][ E][W]"); */
+	}
+	/* STP over UART */
+	else if (mtk_wcn_stp_is_btif_fullset_mode() && STP_IS_ENABLE(stp_core_ctx)) {
+
+		/* osal_printtimeofday("[ STP][UART][ B][W]"); */
+		/* STP_INFO_FUNC("Write byte %d\n", length); */
+
+		if ((stp_core_ctx.sequence.winspace > 0) &&
+		    (stp_core_ctx.inband_rst_set == 0) &&
+		    (stp_is_tx_res_available(MTKSTP_HEADER_SIZE + length + MTKSTP_CRC_SIZE))) {
+			/*Make Header */
+			/* (*sys_dbg_print)("mtk_wcn_stp_send_data 1, txseq = %d, winspace = %d",
+			* stp_core_ctx.sequence.txseq, stp_core_ctx.sequence.winspace);
+			*/
+			mtkstp_header[0] = 0x80 + (stp_core_ctx.sequence.txseq << 3) + stp_core_ctx.sequence.txack;
+			mtkstp_header[1] = (type << 4) + ((length & 0xf00) >> 8);
+			mtkstp_header[2] = length & 0xff;
+			mtkstp_header[3] = (mtkstp_header[0] + mtkstp_header[1] + mtkstp_header[2]) & 0xff;
+			stp_core_ctx.tx_start_addr[stp_core_ctx.sequence.txseq] = stp_core_ctx.tx_write;
+			stp_core_ctx.tx_length[stp_core_ctx.sequence.txseq] = MTKSTP_HEADER_SIZE + length + 2;
+			if (fgEnableDelimiter == 1) {
+				stp_core_ctx.tx_length[stp_core_ctx.sequence.txseq] += STP_DEL_SIZE;
+				stp_add_to_tx_queue(&stp_delimiter[0], STP_DEL_SIZE);
+			}
+			stp_add_to_tx_queue(mtkstp_header, MTKSTP_HEADER_SIZE);
+
+			/*Make Payload */
+			stp_add_to_tx_queue(buffer, length);
+
+			/*Make CRC */
+			crc = osal_crc16(buffer, length);
+			temp[0] = crc & 0xff;
+			temp[1] = (crc & 0xff00) >> 8;
+			stp_add_to_tx_queue(temp, 2);
+			stp_dbg_pkt_log(type,
+					stp_core_ctx.sequence.txack,
+					stp_core_ctx.sequence.txseq, crc, PKT_DIR_TX, buffer, length);
+
+			/*Kick to UART */
+			stp_send_tx_queue(stp_core_ctx.sequence.txseq);
+
+			INDEX_INC(stp_core_ctx.sequence.txseq);
+			stp_core_ctx.sequence.winspace--;
+
+			/*Setup the Retry Timer */
+			osal_timer_stop(&stp_core_ctx.tx_timer);
+			if (stp_core_ctx.sequence.winspace != MTKSTP_WINSIZE)
+				osal_timer_start(&stp_core_ctx.tx_timer, mtkstp_tx_timeout);
+			else
+				STP_ERR_FUNC("mtk_wcn_stp_send_data: wmt_stop_timer\n");
+
+			ret = (INT32) length;
+		} else {
+			/*
+			   No winspace to send. Let caller retry
+			 */
+			if (stp_core_ctx.inband_rst_set == 1)
+				STP_WARN_FUNC("Now it's inband reset process and drop sent packet.\n");
+			else
+				STP_ERR_FUNC("There is no winspace/txqueue to send !!!\n");
+
+			ret = 0;
+		}
+
+		/* osal_printtimeofday("[ STP][UART][ E][W]"); */
+	}
+	/* osal_unlock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+	stp_ctx_unlock(&stp_core_ctx);
+
+#ifdef CONFIG_POWER_SAVING_SUPPORT
+
+	if (MTK_WCN_BOOL_TRUE == is_quick_enable) {
+		if (type != WMT_TASK_INDX) {
+			stp_psm_notify_wmt_sleep(STP_PSM_CORE(stp_core_ctx));
+			/*-----------------------STP_PSM_UnLock-------------------------*/
+			stp_psm_thread_lock_release(STP_PSM_CORE(stp_core_ctx));
+		}
+	} else {
+		/* if(stp_is_apply_powersaving()) */
+		/* { */
+		if (type != WMT_TASK_INDX) {
+
+			/*--------------------STP_PSM_UnLock--------------------------*/
+			stp_psm_thread_lock_release(STP_PSM_CORE(stp_core_ctx));
+		}
+		/* } */
+	}
+#endif
+
+	return ret;
+}
+#if !STP_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_stp_send_data);
+#endif
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_send_data_raw
+* DESCRIPTION
+*  send raw data to common interface, bypass STP
+* PARAMETERS
+*  buffer      [IN]        data buffer
+*  length      [IN]        data buffer length
+*  type        [IN]        subfunction type
+* RETURNS
+*  INT32    >= 0: length transmitted; < 0: error
+*****************************************************************************/
+#if STP_EXP_HID_API_EXPORT
+INT32 _mtk_wcn_stp_send_data_raw(const PUINT8 buffer, const UINT32 length, const UINT8 type)
+#else
+INT32 mtk_wcn_stp_send_data_raw(const PUINT8 buffer, const UINT32 length, const UINT8 type)
+#endif
+{
+	UINT32 written = 0;
+	INT32 ret = 0;
+
+	if (0 != STP_WMT_LAST_CLOSE(stp_core_ctx)) {
+		STP_ERR_FUNC("WMT lats close,should not have tx request!");
+		return length;
+	}
+
+	STP_DBG_FUNC("mtk_wcn_stp_send_data_raw, type = %d, data = %x %x %x %x %x %x ", type, buffer[0], buffer[1],
+		     buffer[2], buffer[3], buffer[4], buffer[5]);
+	STP_SET_PENDING_TYPE(stp_core_ctx, type);	/* remember tx type, forward following rx to this type */
+
+	/* osal_lock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+	stp_ctx_lock(&stp_core_ctx);
+	stp_dbg_pkt_log(type, 0, 0, 0, PKT_DIR_TX, buffer, 1);
+	(*sys_if_tx) (&buffer[0], length, &written);
+	/* osal_unlock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+	stp_ctx_unlock(&stp_core_ctx);
+
+	if (written == 0)
+		stp_dump_data(&buffer[0], "tx raw failed:", length);
+
+	if (written == length)
+		ret = (INT32) written;
+	else
+		ret = (-1);
+
+	return ret;
+}
+#if !STP_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_stp_send_data_raw);
+#endif
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_receive_data
+* DESCRIPTION
+*  receive data from serial protocol engine
+* PARAMETERS
+*  buffer      [IN]        data buffer
+*  length      [IN]        data buffer length
+*  type        [IN]        subfunction type
+* RETURNS
+*  INT32    >= 0: size of data received; < 0: error
+*****************************************************************************/
+#if STP_EXP_HID_API_EXPORT
+INT32 _mtk_wcn_stp_receive_data(UINT8 *buffer, UINT32 length, UINT8 type)
+#else
+INT32 mtk_wcn_stp_receive_data(UINT8 *buffer, UINT32 length, UINT8 type)
+#endif
+{
+	/* GeorgeKuo modify: reduce "if" branch */
+	UINT16 copyLen = 0;
+	UINT16 tailLen = 0;
+
+	osal_lock_unsleepable_lock(&stp_core_ctx.ring[type].mtx);
+
+	while (stp_core_ctx.ring[type].read_p != stp_core_ctx.ring[type].write_p) {
+		/* GeorgeKuo modify: reduce if branch */
+		if (stp_core_ctx.ring[type].write_p > stp_core_ctx.ring[type].read_p) {
+			copyLen = stp_core_ctx.ring[type].write_p - stp_core_ctx.ring[type].read_p;
+			if (copyLen > length)
+				copyLen = length;
+
+			osal_memcpy(buffer, stp_core_ctx.ring[type].buffer + stp_core_ctx.ring[type].read_p, copyLen);
+			stp_core_ctx.ring[type].read_p += copyLen;
+		} else {
+			tailLen = MTKSTP_BUFFER_SIZE - stp_core_ctx.ring[type].read_p;
+			if (tailLen > length) {	/* exclude equal case to skip wrap check */
+				copyLen = length;
+				osal_memcpy(buffer, stp_core_ctx.ring[type].buffer + stp_core_ctx.ring[type].read_p,
+					    copyLen);
+				stp_core_ctx.ring[type].read_p += copyLen;
+			} else {
+				/* part 1: copy tailLen */
+				osal_memcpy(buffer, stp_core_ctx.ring[type].buffer + stp_core_ctx.ring[type].read_p,
+					    tailLen);
+
+				buffer += tailLen;	/* update buffer offset */
+
+				/* part 2: check if head length is enough */
+				copyLen = length - tailLen;
+				copyLen =
+				    (stp_core_ctx.ring[type].write_p <
+				     copyLen) ? stp_core_ctx.ring[type].write_p : copyLen;
+
+				if (copyLen)
+					osal_memcpy(buffer, stp_core_ctx.ring[type].buffer + 0, copyLen);
+
+				/* Update read_p final position */
+				stp_core_ctx.ring[type].read_p = copyLen;
+
+				/* update return length: head + tail */
+				copyLen += tailLen;
+			}
+		}
+		break;
+	}
+
+	osal_unlock_unsleepable_lock(&stp_core_ctx.ring[type].mtx);
+
+	if ((MTK_WCN_BOOL_TRUE == stp_psm_is_quick_ps_support()) && (type != WMT_TASK_INDX)) {
+#if PSM_USE_COUNT_PACKAGE
+		stp_psm_disable_by_tx_rx_density(STP_PSM_CORE(stp_core_ctx), 1);
+#else
+		stp_psm_disable_by_tx_rx_density(STP_PSM_CORE(stp_core_ctx), 1, copyLen);
+#endif
+	}
+
+	return copyLen;
+}
+#if !STP_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_stp_receive_data);
+#endif
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_is_rxqueue_empty
+* DESCRIPTION
+*  Is certain rx queue empty?
+* PARAMETERS
+*  type        [IN]        subfunction type
+* RETURNS
+*  INT32    0: queue is NOT empyt; !0: queue is empty
+*****************************************************************************/
+#if STP_EXP_HID_API_EXPORT
+INT32 _mtk_wcn_stp_is_rxqueue_empty(UINT8 type)
+#else
+INT32 mtk_wcn_stp_is_rxqueue_empty(UINT8 type)
+#endif
+{
+	INT32 ret;
+
+	osal_lock_unsleepable_lock(&stp_core_ctx.ring[type].mtx);
+
+	if (stp_core_ctx.ring[type].read_p == stp_core_ctx.ring[type].write_p)
+		ret = 1;	/* queue is empty */
+	else
+		ret = 0;	/* queue is not empty */
+
+	osal_unlock_unsleepable_lock(&stp_core_ctx.ring[type].mtx);
+
+	return ret;
+}
+#if !STP_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_stp_is_rxqueue_empty);
+#endif
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_set_sdio_mode
+* DESCRIPTION
+*  Set stp for SDIO mode
+* PARAMETERS
+*  sdio_flag  [IN]        sdio mode flag (TRUE:SDIO mode, FALSE:UART mode)
+* RETURNS
+*  void
+*****************************************************************************/
+
+void mtk_wcn_stp_set_mode(UINT32 mode)
+{
+	STP_SET_SUPPORT_PROTOCOL(stp_core_ctx, mode);
+
+	STP_DBG_FUNC("STP_SUPPORT_PROTOCOL = %08x\n", STP_SUPPORT_PROTOCOL(stp_core_ctx));
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_is_uart_fullset_mode
+* DESCRIPTION
+*  Is stp use UART fullset mode?
+* PARAMETERS
+*  none.
+* RETURNS
+*  MTK_WCN_BOOL    TRUE:Uart Fullset mode, FALSE:Not UART Fullset mode
+*****************************************************************************/
+MTK_WCN_BOOL mtk_wcn_stp_is_uart_fullset_mode(void)
+{
+	/*
+	   bit 0: uart fullset   mode
+	   bit 1: uart mandatory mode
+	   bit 2: sdio mode
+	 */
+	if (STP_SUPPORT_PROTOCOL(stp_core_ctx) & MTKSTP_UART_FULL_MODE)
+		return MTK_WCN_BOOL_TRUE;
+	else
+		return MTK_WCN_BOOL_FALSE;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_is_uart_mand_mode
+* DESCRIPTION
+*  Is stp use UART mandatory mode?
+* PARAMETERS
+*  none.
+* RETURNS
+*  MTK_WCN_BOOL    TRUE:Uart Mandatory mode, FALSE:Not UART Mandotary mode
+*****************************************************************************/
+MTK_WCN_BOOL mtk_wcn_stp_is_uart_mand_mode(void)
+{
+	/*
+	   bit 0: uart fullset   mode
+	   bit 1: uart mandatory mode
+	   bit 2: sdio mode
+	 */
+	if (STP_SUPPORT_PROTOCOL(stp_core_ctx) & MTKSTP_UART_MAND_MODE)
+		return MTK_WCN_BOOL_TRUE;
+	else
+		return MTK_WCN_BOOL_FALSE;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_is_btif_fullset_mode
+* DESCRIPTION
+*  Is stp use BTIF fullset mode?
+* PARAMETERS
+*  none.
+* RETURNS
+*  MTK_WCN_BOOL    TRUE:BTIF Fullset mode, FALSE:Not BTIF Fullset mode
+*****************************************************************************/
+MTK_WCN_BOOL mtk_wcn_stp_is_btif_fullset_mode(void)
+{
+
+	if (STP_SUPPORT_PROTOCOL(stp_core_ctx) & MTKSTP_BTIF_FULL_MODE)
+		return MTK_WCN_BOOL_TRUE;
+	else
+		return MTK_WCN_BOOL_FALSE;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_is_btif_mand_mode
+* DESCRIPTION
+*  Is stp use BTIF mandatory mode?
+* PARAMETERS
+*  none.
+* RETURNS
+*  MTK_WCN_BOOL    TRUE:BTIF Mandatory mode, FALSE:Not BTIF Mandotary mode
+*****************************************************************************/
+
+MTK_WCN_BOOL mtk_wcn_stp_is_btif_mand_mode(void)
+{
+
+	if (STP_SUPPORT_PROTOCOL(stp_core_ctx) & MTKSTP_BTIF_MAND_MODE)
+		return MTK_WCN_BOOL_TRUE;
+	else
+		return MTK_WCN_BOOL_FALSE;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_is_sdio_mode
+* DESCRIPTION
+*  Is stp use SDIO mode?
+* PARAMETERS
+*  none.
+* RETURNS
+*  MTK_WCN_BOOL    TRUE:SDIO mode, FALSE:UART mode
+*****************************************************************************/
+MTK_WCN_BOOL mtk_wcn_stp_is_sdio_mode(void)
+{
+	/*
+	   bit 0: uart fullset   mode
+	   bit 1: uart mandatory mode
+	   bit 2: sdio mode
+	 */
+	if (STP_SUPPORT_PROTOCOL(stp_core_ctx) & MTKSTP_SDIO_MODE)
+		return MTK_WCN_BOOL_TRUE;
+	else
+		return MTK_WCN_BOOL_FALSE;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  stp_send_inband_reset
+* DESCRIPTION
+*  To sync to oringnal stp state with f/w stp
+* PARAMETERS
+*  none.
+* RETURNS
+*  none
+*****************************************************************************/
+void mtk_wcn_stp_inband_reset(void)
+{
+	UINT8 inband_reset_packet[64];
+	UINT32 txseq = 0;
+	UINT32 txack = 0;
+	UINT32 crc = 0;
+	UINT32 ret = 0;
+	UINT32 reset_payload_len = 0;
+
+	/*512 bytes */
+	UINT8 reset_payload[] = {
+		0xc0, 0x01, 0xc0, 0xde, 0x3e, 0xd1, 0xa7, 0xef
+	};
+
+	/* osal_lock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+	stp_ctx_lock(&stp_core_ctx);
+
+	 /*RESYNC*/ inband_reset_packet[0] = 0x7f;
+	inband_reset_packet[1] = 0x7f;
+	inband_reset_packet[2] = 0x7f;
+	inband_reset_packet[3] = 0x7f;
+	inband_reset_packet[4] = 0x7f;
+	inband_reset_packet[5] = 0x7f;
+	inband_reset_packet[6] = 0x7f;
+	inband_reset_packet[7] = 0x7f;
+
+	/*header */
+	reset_payload_len = sizeof(reset_payload) / sizeof(reset_payload[0]);
+	inband_reset_packet[8] = 0x80 + (txseq << 3) + txack;
+	inband_reset_packet[9] = (STP_TASK_INDX << 4) + ((reset_payload_len & 0xf00) >> 8);
+	inband_reset_packet[10] = reset_payload_len & 0xff;
+	inband_reset_packet[11] = (inband_reset_packet[8] + inband_reset_packet[9] + inband_reset_packet[10]) & 0xff;
+
+	/*payload */
+	osal_memcpy(&inband_reset_packet[12], reset_payload, reset_payload_len);
+
+	/*crc */
+	crc = osal_crc16(&reset_payload[0], reset_payload_len);
+	inband_reset_packet[12 + reset_payload_len] = crc & 0xff;
+	inband_reset_packet[12 + reset_payload_len + 1] = (crc & 0xff00) >> 8;
+
+	(*sys_if_tx) (&inband_reset_packet[0], 14 + reset_payload_len, &ret);
+
+	if (ret != (14 + reset_payload_len))
+		STP_ERR_FUNC("Inband sending error, sending %d , but ret = %d\n", 10 + reset_payload_len, ret);
+
+	stp_core_ctx.inband_rst_set = 1;
+	stp_ctx_unlock(&stp_core_ctx);
+	/* osal_unlock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+}
+
+void mtk_wcn_stp_debug_ctrl(INT32 op, INT32 filter, INT32 filter_param)
+{
+	/*nothing at now*/
+}
+
+void mtk_wcn_stp_test_cmd(INT32 cmd_no)
+{
+	UINT8 test_packet[64];
+	UINT32 txseq = 0;
+	UINT32 txack = 0;
+	UINT32 crc = 0;
+	UINT32 ret = 0;
+	UINT32 reset_payload_len = 0;
+
+	UINT8 test_payload[] = {
+		0xAA, 0xAA, 0xC0, 0xDE, 0x3E, 0xD1, 0xA7, 0xEF
+	};
+/*  */
+/* select your test command by cmd_no */
+/*  */
+	if (cmd_no == 0) {
+		/* to test new command to chip */
+		/* osal_lock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+		stp_ctx_lock(&stp_core_ctx);
+
+		 /*RESYNC*/ test_packet[0] = 0x7f;
+		test_packet[1] = 0x7f;
+		test_packet[2] = 0x7f;
+		test_packet[3] = 0x7f;
+		test_packet[4] = 0x7f;
+		test_packet[5] = 0x7f;
+		test_packet[6] = 0x7f;
+		test_packet[7] = 0x7f;
+
+		/*header */
+		reset_payload_len = sizeof(test_payload) / sizeof(test_payload[0]);
+		test_packet[8] = 0x80 + (txseq << 3) + txack;
+		test_packet[9] = (STP_TASK_INDX << 4) + ((reset_payload_len & 0xf00) >> 8);
+		test_packet[10] = reset_payload_len & 0xff;
+		test_packet[11] = (test_packet[8] + test_packet[9] + test_packet[10]) & 0xff;
+
+		/*payload */
+		osal_memcpy(&test_packet[12], test_payload, reset_payload_len);
+
+		/*crc */
+		crc = osal_crc16(&test_payload[0], reset_payload_len);
+		test_packet[12 + reset_payload_len] = crc & 0xff;
+		test_packet[12 + reset_payload_len + 1] = (crc & 0xff00) >> 8;
+
+		(*sys_if_tx) (&test_packet[0], 14 + reset_payload_len, &ret);
+		if (ret != (14 + reset_payload_len)) {
+			STP_ERR_FUNC("stp test sending error, sending %d , but ret = %d\n", 10 + reset_payload_len,
+				     ret);
+		}
+		/* osal_unlock_unsleepable_lock(&stp_core_ctx.stp_mutex); */
+		stp_ctx_unlock(&stp_core_ctx);
+	}
+
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_flush_context
+* DESCRIPTION
+*  Flush STP Context
+* PARAMETERS
+*  none.
+* RETURNS
+*  none
+*****************************************************************************/
+void mtk_wcn_stp_flush_context(void)
+{
+	stp_rest_ctx_state();
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_flush_rx_queue
+* DESCRIPTION
+*  Flush STP Rx Queue
+* PARAMETERS
+*  none.
+* RETURNS
+*  none
+*****************************************************************************/
+
+void mtk_wcn_stp_flush_rx_queue(UINT32 type)
+{
+	osal_lock_unsleepable_lock(&stp_core_ctx.ring[type].mtx);
+	if (type < MTKSTP_MAX_TASK_NUM) {
+		stp_core_ctx.ring[type].read_p = 0;
+		stp_core_ctx.ring[type].write_p = 0;
+	}
+	osal_unlock_unsleepable_lock(&stp_core_ctx.ring[type].mtx);
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_is_enable
+* DESCRIPTION
+*  STP is ready?
+* PARAMETERS
+*  none.
+* RETURNS
+*  none
+*****************************************************************************/
+#if STP_EXP_HID_API_EXPORT
+MTK_WCN_BOOL _mtk_wcn_stp_is_ready(void)
+#else
+MTK_WCN_BOOL mtk_wcn_stp_is_ready(void)
+#endif
+{
+	return STP_IS_READY(stp_core_ctx);
+}
+#if !STP_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_stp_is_ready);
+#endif
+/*****************************************************************************
+* FUNCTION
+*  set_bluetooth_rx_interface
+* DESCRIPTION
+*  Set bluetooth rx interface
+* PARAMETERS
+*  rx interface type
+* RETURNS
+*  void
+*****************************************************************************/
+#if STP_EXP_HID_API_EXPORT
+void _mtk_wcn_stp_set_bluez(MTK_WCN_BOOL bluez_flag)
+#else
+void mtk_wcn_stp_set_bluez(MTK_WCN_BOOL bluez_flag)
+#endif
+{
+	/* g_mtkstp_bluez_flag = bluez_flag; */
+	STP_SET_BT_STK(stp_core_ctx, bluez_flag);
+}
+#if !STP_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_stp_set_bluez);
+#endif
+/*****************************************************************************
+* FUNCTION
+*  set stp debugging mdoe
+* DESCRIPTION
+*  set stp debugging mdoe
+* PARAMETERS
+* dbg_mode: switch to dbg mode ?
+* RETURNS
+*  void
+*****************************************************************************/
+void mtk_wcn_stp_set_dbg_mode(MTK_WCN_BOOL dbg_mode)
+{
+	STP_SET_ENABLE_DBG(stp_core_ctx, dbg_mode);
+}
+
+/*****************************************************************************
+* FUNCTION
+*  set stp auto reset mdoe
+* DESCRIPTION
+*  set stp auto reset mdoe
+* PARAMETERS
+* auto_rst: switch to auto reset mode ?
+* RETURNS
+*  void
+*****************************************************************************/
+void mtk_wcn_stp_set_auto_rst(MTK_WCN_BOOL auto_rst)
+{
+	STP_SET_ENABLE_RST(stp_core_ctx, auto_rst);
+}
+
+INT32 mtk_wcn_stp_notify_sleep_for_thermal(void)
+{
+	return stp_psm_sleep_for_thermal(STP_PSM_CORE(stp_core_ctx));
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_open_btif
+* DESCRIPTION
+*  init btif hw & sw by owner stp
+* PARAMETERS
+* VOID
+* RETURNS
+*  INT32 0-success,other fail.
+*****************************************************************************/
+INT32 mtk_wcn_stp_open_btif(VOID)
+{
+	return mtk_wcn_consys_stp_btif_open();
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_open_close
+* DESCRIPTION
+*  close btif hw & sw by owner stp
+* PARAMETERS
+* VOID
+* RETURNS
+*  INT32 0-success,other fail.
+*****************************************************************************/
+INT32 mtk_wcn_stp_close_btif(VOID)
+{
+	return mtk_wcn_consys_stp_btif_close();
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_rx_cb_register
+* DESCRIPTION
+*  register stp rx cb to btif
+* PARAMETERS
+* MTK_WCN_BTIF_RX_CB stp rx handle function
+* RETURNS
+*  INT32 0-success,other fail.
+*****************************************************************************/
+INT32 mtk_wcn_stp_rxcb_register(MTK_WCN_BTIF_RX_CB rx_cb)
+{
+	return mtk_wcn_consys_stp_btif_rx_cb_register(rx_cb);
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_tx
+* DESCRIPTION
+*  send stp package by btif
+* PARAMETERS
+* pBuf:package buffer pointer,len:package length
+* written_len:package written length
+* RETURNS
+*  INT32 package length-success,other fail.
+*****************************************************************************/
+INT32 mtk_wcn_stp_tx(UINT8 *pBuf, UINT32 len, UINT32 *written_len)
+{
+	INT32 iRet = -1;
+
+	iRet = mtk_wcn_consys_stp_btif_tx(pBuf, len, written_len);
+	return iRet;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_wakeup_consys
+* DESCRIPTION
+*  STP wakeup consys by btif
+* PARAMETERS
+* VOID
+* RETURNS
+*  INT32 0-success,other fail.
+*****************************************************************************/
+INT32 mtk_wcn_stp_wakeup_consys(VOID)
+{
+	/*log wakeup int for debug */
+	stp_dbg_pkt_log(7, 0, 0, 0, PKT_DIR_TX, NULL, 0);
+	return mtk_wcn_consys_stp_btif_wakeup();
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_dpidle_ctrl
+* DESCRIPTION
+*  decide AP enter or exit deep idle
+* PARAMETERS
+* en_flag:1,enter,0,exit
+* RETURNS
+*  always 0
+*****************************************************************************/
+INT32 mtk_wcn_stp_dpidle_ctrl(ENUM_BTIF_DPIDLE_CTRL en_flag)
+{
+	mtk_wcn_consys_stp_btif_dpidle_ctrl(en_flag);
+
+	return 0;
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_lpbk_ctrl
+* DESCRIPTION
+*  enable stp internal lpbk test or not
+* PARAMETERS
+* mode:1,enable,0,disabel
+* RETURNS
+*  INT32 0-success,other fail.
+*****************************************************************************/
+INT32 mtk_wcn_stp_lpbk_ctrl(ENUM_BTIF_LPBK_MODE mode)
+{
+	return mtk_wcn_consys_stp_btif_lpbk_ctrl(mode);
+}
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_logger_ctrl
+* DESCRIPTION
+*  dump btif buffer or register status when No ACK or assert occurs
+* PARAMETERS
+* flag:see enum value in ENUM_BTIF_DBG_ID
+* RETURNS
+*  INT32 0-success,other fail.
+*****************************************************************************/
+INT32 mtk_wcn_stp_logger_ctrl(ENUM_BTIF_DBG_ID flag)
+{
+	return mtk_wcn_consys_stp_btif_logger_ctrl(flag);
+}
+
+VOID mtk_wcn_stp_ctx_save(void)
+{
+	STP_INFO_FUNC("start ++\n");
+	mtk_wcn_stp_coredump_start_ctrl(1);
+	stp_psm_set_sleep_disable(stp_core_ctx.psm);
+	STP_INFO_FUNC("exit --\n");
+}
+
+VOID mtk_wcn_stp_ctx_restore(void)
+{
+	STP_INFO_FUNC("start ++\n");
+	stp_psm_set_sleep_enable(stp_core_ctx.psm);
+	stp_btm_reset_btm_wq(STP_BTM_CORE(stp_core_ctx));
+
+	if (STP_IS_ENABLE_RST(stp_core_ctx))
+		stp_btm_notify_wmt_rst_wq(STP_BTM_CORE(stp_core_ctx));
+	else
+		STP_INFO_FUNC("No to launch whole chip reset! for debugging purpose\n");
+#if STP_RETRY_OPTIMIZE
+	g_retry_times = 0;
+#endif
+	STP_INFO_FUNC("exit --\n");
+}
+
+INT32 mtk_wcn_stp_wmt_evt_err_trg_assert(void)
+{
+	INT32 ret = -1;
+
+	if (mtk_wcn_stp_coredump_start_get() != 0) {
+		STP_INFO_FUNC("firmware assert has been triggered\n");
+		return 0;
+	}
+
+	ret = stp_notify_btm_do_fw_assert_via_emi(STP_BTM_CORE(stp_core_ctx));
+	if (ret) {
+		STP_ERR_FUNC("evt err trigger assert fail,do chip reset to recovery\n");
+
+		mtk_wcn_stp_set_wmt_evt_err_trg_assert(0);
+		if (STP_IS_ENABLE_RST(stp_core_ctx))
+			stp_btm_notify_wmt_rst_wq(STP_BTM_CORE(stp_core_ctx));
+		else
+			STP_INFO_FUNC("No to launch whole chip reset! for debugging purpose\n");
+	}
+
+	return ret;
+}
+
+VOID mtk_wcn_stp_set_wmt_evt_err_trg_assert(UINT32 value)
+{
+	STP_INFO_FUNC("set evt err tigger assert flag to %d\n", value);
+	STP_SET_EVT_ERR_ASSERT(stp_core_ctx, value);
+}
+
+UINT32 mtk_wcn_stp_get_wmt_evt_err_trg_assert(void)
+{
+	return STP_EVT_ERR_ASSERT(stp_core_ctx);
+}
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_conf.c b/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_conf.c
new file mode 100644
index 00000000..3009bd2
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_conf.c
@@ -0,0 +1,529 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[WMT-CONF]"
+
+#include "osal_typedef.h"
+/* #include "osal.h" */
+#include "wmt_lib.h"
+#include "wmt_dev.h"
+#include "wmt_conf.h"
+
+/*******************************************************************************
+*                         D A T A   T Y P E S
+********************************************************************************
+*/
+struct parse_data {
+	PINT8 name;
+	INT32 (*parser)(P_DEV_WMT pWmtDev, const struct parse_data *data, const PINT8 value);
+	PINT8 (*writer)(P_DEV_WMT pWmtDev, const struct parse_data *data);
+	/*PINT8 param1, *param2, *param3; */
+	/* TODO:[FixMe][George] CLARIFY WHAT SHOULD BE USED HERE!!! */
+	PINT8 param1;
+	PINT8 param2;
+	PINT8 param3;
+};
+
+/*******************************************************************************
+*                        P U B L I C   D A T A
+********************************************************************************
+*/
+
+
+/*******************************************************************************
+*                       P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+/******************************************************************************
+*                   F U N C T I O N   D E C L A R A T I O N S
+*******************************************************************************
+*/
+static INT32 wmt_conf_parse_char(P_DEV_WMT pWmtDev, const struct parse_data *data, const PINT8 pos);
+
+static PINT8 wmt_conf_write_char(P_DEV_WMT pWmtDev, const struct parse_data *data);
+
+static INT32 wmt_conf_parse_short(P_DEV_WMT pWmtDev, const struct parse_data *data, const PINT8 pos);
+
+static PINT8 wmt_conf_write_short(P_DEV_WMT pWmtDev, const struct parse_data *data);
+
+static INT32 wmt_conf_parse_int(P_DEV_WMT pWmtDev, const struct parse_data *data, const PINT8 pos);
+
+static PINT8 wmt_conf_write_int(P_DEV_WMT pWmtDev, const struct parse_data *data);
+
+static INT32 wmt_conf_parse_pair(P_DEV_WMT pWmtDev, const PINT8 pKey, const PINT8 pVal);
+
+static INT32 wmt_conf_parse(P_DEV_WMT pWmtDev, const PINT8 pInBuf, UINT32 size);
+
+#define OFFSET(v) ((void *) &((P_DEV_WMT) 0)->v)
+
+#define CHAR(f) \
+{ \
+	#f, \
+	wmt_conf_parse_char, \
+	wmt_conf_write_char, \
+	OFFSET(rWmtGenConf.f), \
+	NULL, \
+	NULL \
+}
+/* #define CHAR(f) _CHAR(f), NULL, NULL} */
+
+#define SHORT(f) \
+{ \
+	#f, \
+	wmt_conf_parse_short, \
+	wmt_conf_write_short, \
+	OFFSET(rWmtGenConf.f), \
+	NULL, \
+	NULL \
+}
+/* #define SHORT(f) _SHORT(f), NULL, NULL */
+
+#define INT(f) \
+{ \
+	#f, \
+	wmt_conf_parse_int, \
+	wmt_conf_write_int, \
+	OFFSET(rWmtGenConf.f), \
+	NULL, \
+	NULL \
+}
+/* #define INT(f) _INT(f), NULL, NULL */
+
+/*******************************************************************************
+*                          F U N C T I O N S
+********************************************************************************
+*/
+
+static const struct parse_data wmtcfg_fields[] = {
+	CHAR(coex_wmt_ant_mode),
+	CHAR(coex_wmt_ext_component),
+	CHAR(coex_wmt_wifi_time_ctl),
+	CHAR(coex_wmt_ext_pta_dev_on),
+	CHAR(coex_wmt_filter_mode),
+
+	CHAR(coex_bt_rssi_upper_limit),
+	CHAR(coex_bt_rssi_mid_limit),
+	CHAR(coex_bt_rssi_lower_limit),
+	CHAR(coex_bt_pwr_high),
+	CHAR(coex_bt_pwr_mid),
+	CHAR(coex_bt_pwr_low),
+
+	CHAR(coex_wifi_rssi_upper_limit),
+	CHAR(coex_wifi_rssi_mid_limit),
+	CHAR(coex_wifi_rssi_lower_limit),
+	CHAR(coex_wifi_pwr_high),
+	CHAR(coex_wifi_pwr_mid),
+	CHAR(coex_wifi_pwr_low),
+
+	CHAR(coex_ext_pta_hi_tx_tag),
+	CHAR(coex_ext_pta_hi_rx_tag),
+	CHAR(coex_ext_pta_lo_tx_tag),
+	CHAR(coex_ext_pta_lo_rx_tag),
+	SHORT(coex_ext_pta_sample_t1),
+	SHORT(coex_ext_pta_sample_t2),
+	CHAR(coex_ext_pta_wifi_bt_con_trx),
+
+	INT(coex_misc_ext_pta_on),
+	INT(coex_misc_ext_feature_set),
+
+	CHAR(wmt_gps_lna_pin),
+	CHAR(wmt_gps_lna_enable),
+
+	CHAR(pwr_on_rtc_slot),
+	CHAR(pwr_on_ldo_slot),
+	CHAR(pwr_on_rst_slot),
+	CHAR(pwr_on_off_slot),
+	CHAR(pwr_on_on_slot),
+	CHAR(co_clock_flag),
+
+	INT(sdio_driving_cfg),
+
+};
+
+#define NUM_WMTCFG_FIELDS (osal_sizeof(wmtcfg_fields) / osal_sizeof(wmtcfg_fields[0]))
+
+static int wmt_conf_parse_char(P_DEV_WMT pWmtDev, const struct parse_data *data, const PINT8 pos)
+{
+	PINT8 dst;
+	long res;
+	int ret;
+
+	dst = (PINT8) (((PUINT8) pWmtDev) + (long)data->param1);
+
+	if ((osal_strlen(pos) > 2) && ((*pos) == '0') && (*(pos + 1) == 'x')) {
+		ret = osal_strtol(pos + 2, 16, &res);
+		if (ret)
+			WMT_ERR_FUNC("fail(%d)\n", ret);
+		*dst = res;
+		WMT_DBG_FUNC("wmtcfg==> %s=0x%x\n", data->name, *dst);
+	} else {
+		ret = osal_strtol(pos, 10, &res);
+		if (ret)
+			WMT_ERR_FUNC("fail(%d)\n", ret);
+		*dst = res;
+		WMT_DBG_FUNC("wmtcfg==> %s=%d\n", data->name, *dst);
+	}
+	return 0;
+}
+
+static PINT8 wmt_conf_write_char(P_DEV_WMT pWmtDev, const struct parse_data *data)
+{
+	PINT8 src;
+	INT32 res;
+	PINT8 value;
+
+	src = (PINT8) (((PUINT8) pWmtDev) + (long)data->param1);
+
+	value = osal_malloc(20);
+	if (value == NULL)
+		return NULL;
+	res = osal_snprintf(value, 20, "0x%x", *src);
+	if (res < 0 || res >= 20) {
+		osal_free(value);
+		return NULL;
+	}
+	value[20 - 1] = '\0';
+	return value;
+}
+
+static int wmt_conf_parse_short(P_DEV_WMT pWmtDev, const struct parse_data *data, const PINT8 pos)
+{
+	PUINT16 dst;
+	long res;
+	int ret;
+
+	dst = (PINT16) (((PUINT8) pWmtDev) + (long)data->param1);
+
+	/* WMT_INFO_FUNC(">strlen(pos)=%d\n", strlen(pos)); */
+
+	if ((osal_strlen(pos) > 2) && ((*pos) == '0') && (*(pos + 1) == 'x')) {
+		ret = osal_strtol(pos + 2, 16, &res);
+		if (ret)
+			WMT_ERR_FUNC("fail(%d)\n", ret);
+		*dst = res;
+		WMT_DBG_FUNC("wmtcfg==> %s=0x%x\n", data->name, *dst);
+	} else {
+		ret = osal_strtol(pos, 10, &res);
+		if (ret)
+			WMT_ERR_FUNC("fail(%d)\n", ret);
+		*dst = res;
+		WMT_DBG_FUNC("wmtcfg==> %s=%d\n", data->name, *dst);
+	}
+
+	return 0;
+}
+
+static PINT8 wmt_conf_write_short(P_DEV_WMT pWmtDev, const struct parse_data *data)
+{
+	PINT16 src;
+	INT32 res;
+	PINT8 value;
+
+	/* TODO: [FixMe][George] FIX COMPILE WARNING HERE! */
+	src = (PINT16) (((PUINT8) pWmtDev) + (long)data->param1);
+
+	value = osal_malloc(20);
+	if (value == NULL)
+		return NULL;
+	res = osal_snprintf(value, 20, "0x%x", *src);
+	if (res < 0 || res >= 20) {
+		osal_free(value);
+		return NULL;
+	}
+	value[20 - 1] = '\0';
+	return value;
+}
+
+static int wmt_conf_parse_int(P_DEV_WMT pWmtDev, const struct parse_data *data, const PINT8 pos)
+{
+	PUINT32 dst;
+	long res;
+	int ret;
+
+	dst = (PINT32) (((PUINT8) pWmtDev) + (long)data->param1);
+
+	/* WMT_INFO_FUNC(">strlen(pos)=%d\n", strlen(pos)); */
+
+	if ((osal_strlen(pos) > 2) && ((*pos) == '0') && (*(pos + 1) == 'x')) {
+		ret = osal_strtol(pos + 2, 16, &res);
+		if (ret)
+			WMT_ERR_FUNC("fail(%d)\n", ret);
+		*dst = res;
+		WMT_DBG_FUNC("wmtcfg==> %s=0x%x\n", data->name, *dst);
+	} else {
+		ret = osal_strtol(pos, 10, &res);
+		if (ret)
+			WMT_ERR_FUNC("fail(%d)\n", ret);
+		*dst = res;
+		WMT_DBG_FUNC("wmtcfg==> %s=%d\n", data->name, *dst);
+	}
+
+	return 0;
+}
+
+static PINT8 wmt_conf_write_int(P_DEV_WMT pWmtDev, const struct parse_data *data)
+{
+	PINT32 src;
+	INT32 res;
+	PINT8 value;
+
+	src = (PUINT32) (((PUINT8) pWmtDev) + (long)data->param1);
+
+	value = osal_malloc(20);
+	if (value == NULL)
+		return NULL;
+	res = osal_snprintf(value, 20, "0x%x", *src);
+	if (res < 0 || res >= 20) {
+		osal_free(value);
+		return NULL;
+	}
+	value[20 - 1] = '\0';
+	return value;
+}
+
+static INT32 wmt_conf_parse_pair(P_DEV_WMT pWmtDev, const PINT8 pKey, const PINT8 pVal)
+{
+	int i = 0;
+	int ret = 0;
+
+	/* WMT_INFO_FUNC( DBG_NAME "cfg(%s) val(%s)\n", pKey, pVal); */
+
+	for (i = 0; i < NUM_WMTCFG_FIELDS; i++) {
+		const struct parse_data *field = &wmtcfg_fields[i];
+
+		if (osal_strcmp(pKey, field->name) != 0)
+			continue;
+		if (field->parser(pWmtDev, field, pVal)) {
+			WMT_ERR_FUNC("failed to parse %s '%s'.\n", pKey, pVal);
+			ret = -1;
+		}
+		break;
+	}
+	if (i == NUM_WMTCFG_FIELDS) {
+		WMT_ERR_FUNC("unknown field '%s'.\n", pKey);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static INT32 wmt_conf_parse(P_DEV_WMT pWmtDev, const PINT8 pInBuf, UINT32 size)
+{
+	PINT8 pch;
+	PINT8 pBuf;
+	PINT8 pLine;
+	PINT8 pKey;
+	PINT8 pVal;
+	PINT8 pPos;
+	INT32 ret = 0;
+	INT32 i = 0;
+	PINT8 pa = NULL;
+
+	pBuf = osal_malloc(size);
+	if (!pBuf)
+		return -1;
+
+	osal_memcpy(pBuf, pInBuf, size);
+	pBuf[size] = '\0';
+
+	pch = pBuf;
+	/* pch is to be updated by strsep(). Keep pBuf unchanged!! */
+
+#if 0
+	{
+		PINT8 buf_ptr = pBuf;
+		INT32 k = 0;
+
+		WMT_INFO_FUNC("%s len=%d", "wmcfg.content:", size);
+		for (k = 0; k < size; k++) {
+			/* if(k%16 == 0)  WMT_INFO_FUNC("\n"); */
+			WMT_INFO_FUNC("%c", buf_ptr[k]);
+		}
+		WMT_INFO_FUNC("--end\n");
+	}
+#endif
+
+	while ((pLine = osal_strsep(&pch, "\r\n")) != NULL) {
+		/* pch is updated to the end of pLine by strsep() and updated to '\0' */
+		/*WMT_INFO_FUNC("strsep offset(%d), char(%d, '%c' )\n", pLine-pBuf, *pLine, *pLine); */
+		/* parse each line */
+
+		/* WMT_INFO_FUNC("==> Line = (%s)\n", pLine); */
+
+		if (!*pLine)
+			continue;
+
+		pVal = osal_strchr(pLine, '=');
+		if (!pVal) {
+			WMT_WARN_FUNC("mal-format cfg string(%s)\n", pLine);
+			continue;
+		}
+
+		/* |<-pLine->|'='<-pVal->|'\n' ('\0')|  */
+		*pVal = '\0';	/* replace '=' with '\0' to get key */
+		/* |<-pKey->|'\0'|<-pVal->|'\n' ('\0')|  */
+		pKey = pLine;
+
+		if ((pVal - pBuf) < size)
+			pVal++;
+
+		/*key handling */
+		pPos = pKey;
+		/*skip space characeter */
+		while (((*pPos) == ' ') || ((*pPos) == '\t') || ((*pPos) == '\n')) {
+			if ((pPos - pBuf) >= size)
+				break;
+			pPos++;
+		}
+		/*key head */
+		pKey = pPos;
+		while (((*pPos) != ' ') && ((*pPos) != '\t') && ((*pPos) != '\0') && ((*pPos) != '\n')) {
+			if ((pPos - pBuf) >= size)
+				break;
+			pPos++;
+		}
+		/*key tail */
+		(*pPos) = '\0';
+
+		/*value handling */
+		pPos = pVal;
+		/*skip space characeter */
+		while (((*pPos) == ' ') || ((*pPos) == '\t') || ((*pPos) == '\n')) {
+			if ((pPos - pBuf) >= size)
+				break;
+			pPos++;
+		}
+		/*value head */
+		pVal = pPos;
+		while (((*pPos) != ' ') && ((*pPos) != '\t') && ((*pPos) != '\0') && ((*pPos) != '\n')) {
+			if ((pPos - pBuf) >= size)
+				break;
+			pPos++;
+		}
+		/*value tail */
+		(*pPos) = '\0';
+
+		/* WMT_DBG_FUNC("parse (key: #%s#, value: #%s#)\n", pKey, pVal); */
+		ret = wmt_conf_parse_pair(pWmtDev, pKey, pVal);
+		WMT_DBG_FUNC("parse (%s, %s, %d)\n", pKey, pVal, ret);
+		if (ret)
+			WMT_WARN_FUNC("parse fail (%s, %s, %d)\n", pKey, pVal, ret);
+	}
+
+	for (i = 0; i < NUM_WMTCFG_FIELDS; i++) {
+		const struct parse_data *field = &wmtcfg_fields[i];
+
+		pa = field->writer(pWmtDev, field);
+		if (pa) {
+			WMT_DBG_FUNC("#%d(%s)=>%s\n", i, field->name, pa);
+			osal_free(pa);
+		} else {
+			WMT_ERR_FUNC("failed to parse '%s'.\n", field->name);
+		}
+	}
+	osal_free(pBuf);
+	return 0;
+}
+
+INT32 wmt_conf_set_cfg_file(const char *name)
+{
+	if (NULL == name) {
+		WMT_ERR_FUNC("name is NULL\n");
+		return -1;
+	}
+	if (osal_strlen(name) >= osal_sizeof(gDevWmt.cWmtcfgName)) {
+		WMT_ERR_FUNC("name is too long, length=%d, expect to < %d\n", osal_strlen(name),
+			     osal_sizeof(gDevWmt.cWmtcfgName));
+		return -2;
+	}
+	osal_memset(&gDevWmt.cWmtcfgName[0], 0, osal_sizeof(gDevWmt.cWmtcfgName));
+	osal_strcpy(&(gDevWmt.cWmtcfgName[0]), name);
+	WMT_ERR_FUNC("WMT config file is set to (%s)\n", &(gDevWmt.cWmtcfgName[0]));
+
+	return 0;
+}
+
+INT32 wmt_conf_read_file(VOID)
+{
+	INT32 ret = -1;
+
+	osal_memset(&gDevWmt.rWmtGenConf, 0, osal_sizeof(gDevWmt.rWmtGenConf));
+	osal_memset(&gDevWmt.pWmtCfg, 0, osal_sizeof(gDevWmt.pWmtCfg));
+
+#if 1
+	osal_memset(&gDevWmt.cWmtcfgName[0], 0, osal_sizeof(gDevWmt.cWmtcfgName));
+
+	osal_strncat(&(gDevWmt.cWmtcfgName[0]), CUST_CFG_WMT_PREFIX, osal_sizeof(CUST_CFG_WMT_PREFIX));
+	osal_strncat(&(gDevWmt.cWmtcfgName[0]), CUST_CFG_WMT, osal_sizeof(CUST_CFG_WMT));
+#endif
+
+	if (!osal_strlen(&(gDevWmt.cWmtcfgName[0]))) {
+		WMT_ERR_FUNC("empty Wmtcfg name\n");
+		osal_assert(0);
+		return ret;
+	}
+	WMT_DBG_FUNC("WMT config file:%s\n", &(gDevWmt.cWmtcfgName[0]));
+	if (0 == wmt_dev_patch_get(&gDevWmt.cWmtcfgName[0], (osal_firmware **) &gDevWmt.pWmtCfg, 0)) {
+		/*get full name patch success */
+		WMT_DBG_FUNC("get full file name(%s) buf(0x%p) size(%d)\n",
+			      &gDevWmt.cWmtcfgName[0], gDevWmt.pWmtCfg->data, gDevWmt.pWmtCfg->size);
+
+		if (0 == wmt_conf_parse(&gDevWmt, (const PINT8)gDevWmt.pWmtCfg->data, gDevWmt.pWmtCfg->size)) {
+			/*config file exists */
+			gDevWmt.rWmtGenConf.cfgExist = 1;
+
+			WMT_DBG_FUNC("&gDevWmt.rWmtGenConf=%p\n", &gDevWmt.rWmtGenConf);
+			ret = 0;
+		} else {
+			WMT_ERR_FUNC("wmt conf parsing fail\n");
+			osal_assert(0);
+			ret = -1;
+		}
+		wmt_dev_patch_put((osal_firmware **) &gDevWmt.pWmtCfg);
+/*
+	if (gDevWmt.pWmtCfg)
+	{
+	    if (gDevWmt.pWmtCfg->data)
+	    {
+		osal_free(gDevWmt.pWmtCfg->data);
+	    }
+	    osal_free(gDevWmt.pWmtCfg);
+	    gDevWmt.pWmtCfg = 0;
+	}
+*/
+		return ret;
+	}
+	WMT_ERR_FUNC("read %s file fails\n", &(gDevWmt.cWmtcfgName[0]));
+	osal_assert(0);
+
+	gDevWmt.rWmtGenConf.cfgExist = 0;
+	return ret;
+}
+
+P_WMT_GEN_CONF wmt_conf_get_cfg(VOID)
+{
+	if (0 == gDevWmt.rWmtGenConf.cfgExist)
+		return NULL;
+
+	return &gDevWmt.rWmtGenConf;
+}
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_core.c b/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_core.c
new file mode 100644
index 00000000..cca6729d
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_core.c
@@ -0,0 +1,2521 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[WMT-CORE]"
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+#include "osal_typedef.h"
+
+#include "wmt_lib.h"
+#include "wmt_core.h"
+#include "wmt_ctrl.h"
+#include "wmt_ic.h"
+#include "wmt_conf.h"
+
+#include "wmt_func.h"
+#include "stp_core.h"
+#include "psm_core.h"
+
+
+P_WMT_FUNC_OPS gpWmtFuncOps[4] = {
+#if CFG_FUNC_BT_SUPPORT
+	[0] = &wmt_func_bt_ops,
+#else
+	[0] = NULL,
+#endif
+
+#if CFG_FUNC_FM_SUPPORT
+	[1] = &wmt_func_fm_ops,
+#else
+	[1] = NULL,
+#endif
+
+#if CFG_FUNC_GPS_SUPPORT
+	[2] = &wmt_func_gps_ops,
+#else
+	[2] = NULL,
+#endif
+
+#if CFG_FUNC_WIFI_SUPPORT
+	[3] = &wmt_func_wifi_ops,
+#else
+	[3] = NULL,
+#endif
+
+};
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/* TODO:[FixMe][GeorgeKuo]: is it an MT6620 only or general general setting?
+*move to wmt_ic_6620 temporarily.
+*/
+/* BT Port 2 Feature. */
+/* #define CFG_WMT_BT_PORT2 (1) */
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+static WMT_CTX gMtkWmtCtx;
+static UINT8 gLpbkBuf[1024+5] = { 0 };
+#ifdef CONFIG_MTK_COMBO_ANT
+static UINT8 gAntBuf[1024] = { 0 };
+#define CFG_CHECK_WMT_RESULT (1)
+#endif
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+static INT32 opfunc_hif_conf(P_WMT_OP pWmtOp);
+static INT32 opfunc_pwr_on(P_WMT_OP pWmtOp);
+static INT32 opfunc_pwr_off(P_WMT_OP pWmtOp);
+static INT32 opfunc_func_on(P_WMT_OP pWmtOp);
+static INT32 opfunc_func_off(P_WMT_OP pWmtOp);
+static INT32 opfunc_reg_rw(P_WMT_OP pWmtOp);
+static INT32 opfunc_exit(P_WMT_OP pWmtOp);
+static INT32 opfunc_pwr_sv(P_WMT_OP pWmtOp);
+static INT32 opfunc_dsns(P_WMT_OP pWmtOp);
+static INT32 opfunc_lpbk(P_WMT_OP pWmtOp);
+static INT32 opfunc_cmd_test(P_WMT_OP pWmtOp);
+static INT32 opfunc_hw_rst(P_WMT_OP pWmtOp);
+static INT32 opfunc_sw_rst(P_WMT_OP pWmtOp);
+static INT32 opfunc_stp_rst(P_WMT_OP pWmtOp);
+static INT32 opfunc_therm_ctrl(P_WMT_OP pWmtOp);
+static INT32 opfunc_efuse_rw(P_WMT_OP pWmtOp);
+static INT32 opfunc_therm_ctrl(P_WMT_OP pWmtOp);
+static INT32 opfunc_gpio_ctrl(P_WMT_OP pWmtOp);
+static INT32 opfunc_pin_state(P_WMT_OP pWmtOp);
+static INT32 opfunc_bgw_ds(P_WMT_OP pWmtOp);
+static INT32 opfunc_set_mcu_clk(P_WMT_OP pWmtOp);
+static INT32 opfunc_adie_lpbk_test(P_WMT_OP pWmtOp);
+#if CFG_WMT_LTE_COEX_HANDLING
+static INT32 opfunc_idc_msg_handling(P_WMT_OP pWmtOp);
+#endif
+#ifdef CONFIG_MTK_COMBO_ANT
+static INT32 opfunc_ant_ram_down(P_WMT_OP pWmtOp);
+static INT32 opfunc_ant_ram_stat_get(P_WMT_OP pWmtOp);
+#endif
+static VOID wmt_core_dump_func_state(PINT8 pSource);
+static INT32 wmt_core_stp_init(VOID);
+static INT32 wmt_core_stp_deinit(VOID);
+static INT32 wmt_core_hw_check(VOID);
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+static const UINT8 WMT_SLEEP_CMD[] = { 0x01, 0x03, 0x01, 0x00, 0x01 };
+static const UINT8 WMT_SLEEP_EVT[] = { 0x02, 0x03, 0x02, 0x00, 0x00, 0x01 };
+
+static const UINT8 WMT_HOST_AWAKE_CMD[] = { 0x01, 0x03, 0x01, 0x00, 0x02 };
+static const UINT8 WMT_HOST_AWAKE_EVT[] = { 0x02, 0x03, 0x02, 0x00, 0x00, 0x02 };
+
+static const UINT8 WMT_WAKEUP_CMD[] = { 0xFF };
+static const UINT8 WMT_WAKEUP_EVT[] = { 0x02, 0x03, 0x02, 0x00, 0x00, 0x03 };
+
+static UINT8 WMT_THERM_CMD[] = { 0x01, 0x11, 0x01, 0x00,
+	0x00			/*thermal sensor operation */
+};
+static UINT8 WMT_THERM_CTRL_EVT[] = { 0x02, 0x11, 0x01, 0x00, 0x00 };
+static UINT8 WMT_THERM_READ_EVT[] = { 0x02, 0x11, 0x02, 0x00, 0x00, 0x00 };
+
+static UINT8 WMT_EFUSE_CMD[] = { 0x01, 0x0D, 0x08, 0x00,
+	0x01,			/*[4]operation, 0:init, 1:write 2:read */
+	0x01,			/*[5]Number of register setting */
+	0xAA, 0xAA,		/*[6-7]Address */
+	0xBB, 0xBB, 0xBB, 0xBB	/*[8-11] Value */
+};
+
+static UINT8 WMT_EFUSE_EVT[] = { 0x02, 0x0D, 0x08, 0x00,
+	0xAA,			/*[4]operation, 0:init, 1:write 2:read */
+	0xBB,			/*[5]Number of register setting */
+	0xCC, 0xCC,		/*[6-7]Address */
+	0xDD, 0xDD, 0xDD, 0xDD	/*[8-11] Value */
+};
+
+static UINT8 WMT_DSNS_CMD[] = { 0x01, 0x0E, 0x02, 0x00, 0x01,
+	0x00			/*desnse type */
+};
+static UINT8 WMT_DSNS_EVT[] = { 0x02, 0x0E, 0x01, 0x00, 0x00 };
+
+/* TODO:[NewFeature][GeorgeKuo] Update register group in ONE CMD/EVT */
+static UINT8 WMT_SET_REG_CMD[] = { 0x01, 0x08, 0x10, 0x00	/*length */
+	    , 0x00		/*op: w(1) & r(2) */
+	    , 0x01		/*type: reg */
+	    , 0x00		/*res */
+	    , 0x01		/*1 register */
+	    , 0x00, 0x00, 0x00, 0x00	/* addr */
+	    , 0x00, 0x00, 0x00, 0x00	/* value */
+	    , 0xFF, 0xFF, 0xFF, 0xFF	/*mask */
+};
+
+static UINT8 WMT_SET_REG_WR_EVT[] = { 0x02, 0x08, 0x04, 0x00	/*length */
+	    , 0x00		/*S: 0 */
+	    , 0x00		/*type: reg */
+	    , 0x00		/*rev */
+	    , 0x01		/*1 register */
+	    /* , 0x00, 0x00, 0x00, 0x00  */		/* addr */
+	    /* , 0x00, 0x00, 0x00, 0x00  */		/* value */
+};
+
+static UINT8 WMT_SET_REG_RD_EVT[] = { 0x02, 0x08, 0x04, 0x00	/*length */
+	    , 0x00		/*S: 0 */
+	    , 0x00		/*type: reg */
+	    , 0x00		/*rev */
+	    , 0x01		/*1 register */
+	    , 0x00, 0x00, 0x00, 0x00	/* addr */
+	    , 0x00, 0x00, 0x00, 0x00	/* value */
+};
+
+#ifdef CONFIG_MTK_COMBO_ANT
+static UINT8 WMT_ANT_RAM_STA_GET_CMD[] = { 0x01, 0x06, 0x02, 0x00, 0x05, 0x02
+};
+
+static UINT8 WMT_ANT_RAM_STA_GET_EVT[] = { 0x02, 0x06, 0x03, 0x00	/*length */
+	    , 0x05, 0x02, 0x00	/*S: result */
+};
+
+static UINT8 WMT_ANT_RAM_DWN_CMD[] = { 0x01, 0x15, 0x00, 0x00, 0x01
+};
+
+static UINT8 WMT_ANT_RAM_DWN_EVT[] = { 0x02, 0x15, 0x01, 0x00	/*length */
+	, 0x00
+};
+#endif
+
+/* GeorgeKuo: Use designated initializers described in
+ * http://gcc.gnu.org/onlinedocs/gcc-4.0.4/gcc/Designated-Inits.html
+ */
+
+static const WMT_OPID_FUNC wmt_core_opfunc[] = {
+	[WMT_OPID_HIF_CONF] = opfunc_hif_conf,
+	[WMT_OPID_PWR_ON] = opfunc_pwr_on,
+	[WMT_OPID_PWR_OFF] = opfunc_pwr_off,
+	[WMT_OPID_FUNC_ON] = opfunc_func_on,
+	[WMT_OPID_FUNC_OFF] = opfunc_func_off,
+	[WMT_OPID_REG_RW] = opfunc_reg_rw,	/* TODO:[ChangeFeature][George] is this OP obsoleted? */
+	[WMT_OPID_EXIT] = opfunc_exit,
+	[WMT_OPID_PWR_SV] = opfunc_pwr_sv,
+	[WMT_OPID_DSNS] = opfunc_dsns,
+	[WMT_OPID_LPBK] = opfunc_lpbk,
+	[WMT_OPID_CMD_TEST] = opfunc_cmd_test,
+	[WMT_OPID_HW_RST] = opfunc_hw_rst,
+	[WMT_OPID_SW_RST] = opfunc_sw_rst,
+	[WMT_OPID_STP_RST] = opfunc_stp_rst,
+	[WMT_OPID_THERM_CTRL] = opfunc_therm_ctrl,
+	[WMT_OPID_EFUSE_RW] = opfunc_efuse_rw,
+	[WMT_OPID_GPIO_CTRL] = opfunc_gpio_ctrl,
+	[WMT_OPID_GPIO_STATE] = opfunc_pin_state,
+	[WMT_OPID_BGW_DS] = opfunc_bgw_ds,
+	[WMT_OPID_SET_MCU_CLK] = opfunc_set_mcu_clk,
+	[WMT_OPID_ADIE_LPBK_TEST] = opfunc_adie_lpbk_test,
+#if CFG_WMT_LTE_COEX_HANDLING
+	[WMT_OPID_IDC_MSG_HANDLING] = opfunc_idc_msg_handling,
+#endif
+#ifdef CONFIG_MTK_COMBO_ANT
+	[WMT_OPID_ANT_RAM_DOWN] = opfunc_ant_ram_down,
+	[WMT_OPID_ANT_RAM_STA_GET] = opfunc_ant_ram_stat_get,
+#endif
+};
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+INT32 wmt_core_init(VOID)
+{
+	INT32 i = 0;
+
+	osal_memset(&gMtkWmtCtx, 0, osal_sizeof(gMtkWmtCtx));
+	/* gMtkWmtCtx.p_ops is cleared to NULL */
+
+	/* default FUNC_OFF state */
+	for (i = 0; i < WMTDRV_TYPE_MAX; ++i) {
+		/* WinMo is default to DRV_STS_UNREG; */
+		gMtkWmtCtx.eDrvStatus[i] = DRV_STS_POWER_OFF;
+	}
+
+	return 0;
+}
+
+INT32 wmt_core_deinit(VOID)
+{
+	/* return to init state */
+	osal_memset(&gMtkWmtCtx, 0, osal_sizeof(gMtkWmtCtx));
+	/* gMtkWmtCtx.p_ops is cleared to NULL */
+	return 0;
+}
+
+/* TODO: [ChangeFeature][George] Is wmt_ctrl a good interface? maybe not...... */
+/* parameters shall be copied in/from ctrl buffer, which is also a size-wasting buffer. */
+INT32 wmt_core_tx(const PUINT8 pData, const UINT32 size, PUINT32 writtenSize, const MTK_WCN_BOOL bRawFlag)
+{
+	INT32 iRet;
+#if 0				/* Test using direct function call instead of wmt_ctrl() interface */
+	WMT_CTRL_DATA ctrlData;
+
+	ctrlData.ctrlId = WMT_CTRL_TX;
+	ctrlData.au4CtrlData[0] = (UINT32) pData;
+	ctrlData.au4CtrlData[1] = size;
+	ctrlData.au4CtrlData[2] = (UINT32) writtenSize;
+	ctrlData.au4CtrlData[3] = bRawFlag;
+
+	iRet = wmt_ctrl(&ctrlData);
+	if (iRet) {
+		/* ERROR */
+		WMT_ERR_FUNC("WMT-CORE: wmt_core_ctrl failed: WMT_CTRL_TX, iRet:%d\n", iRet);
+		/* (*sys_dbg_assert)(0, __FILE__, __LINE__); */
+		osal_assert(0);
+	}
+#endif
+	iRet = wmt_ctrl_tx_ex(pData, size, writtenSize, bRawFlag);
+	if (0 == *writtenSize) {
+		INT32 retry_times = 0;
+		INT32 max_retry_times = 3;
+		INT32 retry_delay_ms = 360;
+
+		WMT_WARN_FUNC("WMT-CORE: wmt_ctrl_tx_ex failed and written ret:%d, maybe no winspace in STP layer\n",
+			      *writtenSize);
+		while ((0 == *writtenSize) && (retry_times < max_retry_times)) {
+			WMT_ERR_FUNC("WMT-CORE: retrying, wait for %d ms\n", retry_delay_ms);
+			osal_sleep_ms(retry_delay_ms);
+
+			iRet = wmt_ctrl_tx_ex(pData, size, writtenSize, bRawFlag);
+			retry_times++;
+		}
+	}
+	return iRet;
+}
+
+INT32 wmt_core_rx(PUINT8 pBuf, UINT32 bufLen, UINT32 *readSize)
+{
+	INT32 iRet;
+	WMT_CTRL_DATA ctrlData;
+
+	ctrlData.ctrlId = WMT_CTRL_RX;
+	ctrlData.au4CtrlData[0] = (SIZE_T) pBuf;
+	ctrlData.au4CtrlData[1] = bufLen;
+	ctrlData.au4CtrlData[2] = (SIZE_T) readSize;
+
+	iRet = wmt_ctrl(&ctrlData);
+	if (iRet) {
+		/* ERROR */
+		WMT_ERR_FUNC("WMT-CORE: wmt_core_ctrl failed: WMT_CTRL_RX, iRet:%d\n", iRet);
+		mtk_wcn_stp_dbg_dump_package();
+		osal_assert(0);
+	}
+	return iRet;
+}
+
+INT32 wmt_core_rx_flush(UINT32 type)
+{
+	INT32 iRet;
+	WMT_CTRL_DATA ctrlData;
+
+	ctrlData.ctrlId = WMT_CTRL_RX_FLUSH;
+	ctrlData.au4CtrlData[0] = (UINT32) type;
+
+	iRet = wmt_ctrl(&ctrlData);
+	if (iRet) {
+		/* ERROR */
+		WMT_ERR_FUNC("WMT-CORE: wmt_core_ctrl failed: WMT_CTRL_RX_FLUSH, iRet:%d\n", iRet);
+		osal_assert(0);
+	}
+	return iRet;
+}
+
+INT32 wmt_core_func_ctrl_cmd(ENUM_WMTDRV_TYPE_T type, MTK_WCN_BOOL fgEn)
+{
+	INT32 iRet = 0;
+	UINT32 u4WmtCmdPduLen;
+	UINT32 u4WmtEventPduLen;
+	UINT32 u4ReadSize;
+	UINT32 u4WrittenSize;
+	WMT_PKT rWmtPktCmd;
+	WMT_PKT rWmtPktEvent;
+	MTK_WCN_BOOL fgFail;
+
+	/* TODO:[ChangeFeature][George] remove WMT_PKT. replace it with hardcoded arrays. */
+	/* Using this struct relies on compiler's implementation and pack() settings */
+	osal_memset(&rWmtPktCmd, 0, osal_sizeof(rWmtPktCmd));
+	osal_memset(&rWmtPktEvent, 0, osal_sizeof(rWmtPktEvent));
+
+	rWmtPktCmd.eType = (UINT8) PKT_TYPE_CMD;
+	rWmtPktCmd.eOpCode = (UINT8) OPCODE_FUNC_CTRL;
+
+	/* Flag field: driver type */
+	rWmtPktCmd.aucParam[0] = (UINT8) type;
+	/* Parameter field: ON/OFF */
+	rWmtPktCmd.aucParam[1] = (fgEn == WMT_FUNC_CTRL_ON) ? 1 : 0;
+	rWmtPktCmd.u2SduLen = WMT_FLAG_LEN + WMT_FUNC_CTRL_PARAM_LEN;	/* (2) */
+
+	/* WMT Header + WMT SDU */
+	u4WmtCmdPduLen = WMT_HDR_LEN + rWmtPktCmd.u2SduLen;	/* (6) */
+	u4WmtEventPduLen = WMT_HDR_LEN + WMT_STS_LEN;	/* (5) */
+
+	do {
+		fgFail = MTK_WCN_BOOL_TRUE;
+/* iRet = (*kal_stp_tx)((PUINT8)&rWmtPktCmd, u4WmtCmdPduLen, &u4WrittenSize); */
+		iRet = wmt_core_tx((PUINT8) &rWmtPktCmd, u4WmtCmdPduLen, &u4WrittenSize, MTK_WCN_BOOL_FALSE);
+		if (iRet) {
+			WMT_ERR_FUNC("WMT-CORE: wmt_func_ctrl_cmd kal_stp_tx failed\n");
+			break;
+		}
+
+		iRet = wmt_core_rx((PUINT8) &rWmtPktEvent, u4WmtEventPduLen, &u4ReadSize);
+		if (iRet) {
+			WMT_ERR_FUNC("WMT-CORE: wmt_func_ctrl_cmd kal_stp_rx failed\n");
+			break;
+		}
+
+		/* Error Checking */
+		if (PKT_TYPE_EVENT != rWmtPktEvent.eType) {
+			WMT_ERR_FUNC("WMT-CORE: wmt_func_ctrl_cmd PKT_TYPE_EVENT != rWmtPktEvent.eType %d\n",
+				     rWmtPktEvent.eType);
+			break;
+		}
+
+		if (rWmtPktCmd.eOpCode != rWmtPktEvent.eOpCode) {
+			WMT_ERR_FUNC
+			    ("WMT-CORE: wmt_func_ctrl_cmd rWmtPktCmd.eOpCode(0x%x) != rWmtPktEvent.eType(0x%x)\n",
+			     rWmtPktCmd.eOpCode, rWmtPktEvent.eOpCode);
+			break;
+		}
+
+		if (u4WmtEventPduLen != (rWmtPktEvent.u2SduLen + WMT_HDR_LEN)) {
+			WMT_ERR_FUNC
+			    ("WMT-CORE: wmt_func_ctrl_cmd u4WmtEventPduLen(0x%x) != rWmtPktEvent.u2SduLen(0x%x)+4\n",
+			     u4WmtEventPduLen, rWmtPktEvent.u2SduLen);
+			break;
+		}
+		/* Status field of event check */
+		if (0 != rWmtPktEvent.aucParam[0]) {
+			WMT_ERR_FUNC("WMT-CORE: wmt_func_ctrl_cmd, 0 != status(%d)\n", rWmtPktEvent.aucParam[0]);
+			break;
+		}
+
+		fgFail = MTK_WCN_BOOL_FALSE;
+	} while (0);
+
+	if (MTK_WCN_BOOL_FALSE == fgFail) {
+		/* WMT_INFO_FUNC("WMT-CORE: wmt_func_ctrl_cmd OK!\n"); */
+		return 0;
+	}
+	WMT_ERR_FUNC("WMT-CORE: wmt_func_ctrl_cmd 0x%x FAIL\n", rWmtPktCmd.aucParam[0]);
+	return -3;
+}
+
+INT32 wmt_core_opid_handler(P_WMT_OP pWmtOp)
+{
+	UINT32 opId;
+	INT32 ret;
+
+	opId = pWmtOp->opId;
+
+	if (wmt_core_opfunc[opId]) {
+		ret = (*(wmt_core_opfunc[opId])) (pWmtOp);	/*wmtCoreOpidHandlerPack[].opHandler */
+		return ret;
+	}
+	WMT_ERR_FUNC("WMT-CORE: null handler (%d)\n", pWmtOp->opId);
+	return -2;
+
+}
+
+INT32 wmt_core_opid(P_WMT_OP pWmtOp)
+{
+
+	/*sanity check */
+	if (NULL == pWmtOp) {
+		WMT_ERR_FUNC("null pWmtOP\n");
+		/*print some message with error info */
+		return -1;
+	}
+
+	if (WMT_OPID_MAX <= pWmtOp->opId) {
+		WMT_ERR_FUNC("WMT-CORE: invalid OPID(%d)\n", pWmtOp->opId);
+		return -2;
+	}
+	/* TODO: [FixMe][GeorgeKuo] do sanity check to const function table when init and skip checking here */
+	return wmt_core_opid_handler(pWmtOp);
+}
+
+INT32 wmt_core_ctrl(ENUM_WMT_CTRL_T ctrId, unsigned long *pPa1, unsigned long *pPa2)
+{
+	INT32 iRet = -1;
+	WMT_CTRL_DATA ctrlData;
+	SIZE_T val1 = (pPa1) ? *pPa1 : 0;
+	SIZE_T val2 = (pPa2) ? *pPa2 : 0;
+
+	ctrlData.ctrlId = (SIZE_T) ctrId;
+	ctrlData.au4CtrlData[0] = val1;
+	ctrlData.au4CtrlData[1] = val2;
+
+	iRet = wmt_ctrl(&ctrlData);
+	if (iRet) {
+		/* ERROR */
+		WMT_ERR_FUNC("WMT-CORE: wmt_core_ctrl failed: id(%d), type(%d), value(%d) iRet:(%d)\n", ctrId, val1,
+			     val2, iRet);
+		osal_assert(0);
+	} else {
+		if (pPa1)
+			*pPa1 = ctrlData.au4CtrlData[0];
+		if (pPa2)
+			*pPa2 = ctrlData.au4CtrlData[1];
+	}
+	return iRet;
+}
+
+VOID wmt_core_dump_data(PUINT8 pData, PUINT8 pTitle, UINT32 len)
+{
+	PUINT8 ptr = pData;
+	INT32 k = 0;
+
+	WMT_INFO_FUNC("%s len=%d\n", pTitle, len);
+	for (k = 0; k < len; k++) {
+		if (k % 16 == 0)
+			WMT_INFO_FUNC("\n");
+		WMT_INFO_FUNC("0x%02x ", *ptr);
+		ptr++;
+	}
+	WMT_INFO_FUNC("--end\n");
+}
+
+/*!
+ * \brief An WMT-CORE function to support read, write, and read after write to
+ * an internal register.
+ *
+ * Detailed description.
+ *
+ * \param isWrite 1 for write, 0 for read
+ * \param offset of register to be written or read
+ * \param pVal a pointer to the 32-bit value to be writtern or read
+ * \param mask a 32-bit mask to be applied for the read or write operation
+ *
+ * \retval 0 operation success
+ * \retval -1 invalid parameters
+ * \retval -2 tx cmd fail
+ * \retval -3 rx event fail
+ * \retval -4 read check error
+ */
+INT32 wmt_core_reg_rw_raw(UINT32 isWrite, UINT32 offset, PUINT32 pVal, UINT32 mask)
+{
+	INT32 iRet;
+	UINT32 u4Res;
+	UINT32 evtLen;
+	UINT8 evtBuf[16] = { 0 };
+
+	WMT_SET_REG_CMD[4] = (isWrite) ? 0x1 : 0x2;	/* w:1, r:2 */
+	osal_memcpy(&WMT_SET_REG_CMD[8], &offset, 4);	/* offset */
+	osal_memcpy(&WMT_SET_REG_CMD[12], pVal, 4);	/* [2] is var addr */
+	osal_memcpy(&WMT_SET_REG_CMD[16], &mask, 4);	/* mask */
+
+	/* send command */
+	iRet = wmt_core_tx(WMT_SET_REG_CMD, sizeof(WMT_SET_REG_CMD), &u4Res, MTK_WCN_BOOL_FALSE);
+	if ((iRet) || (u4Res != sizeof(WMT_SET_REG_CMD))) {
+		WMT_ERR_FUNC("Tx REG_CMD fail!(%d) len (%d, %d)\n", iRet, u4Res, sizeof(WMT_SET_REG_CMD));
+		return -2;
+	}
+
+	/* receive event */
+	evtLen = (isWrite) ? sizeof(WMT_SET_REG_WR_EVT) : sizeof(WMT_SET_REG_RD_EVT);
+	iRet = wmt_core_rx(evtBuf, evtLen, &u4Res);
+	if ((iRet) || (u4Res != evtLen)) {
+		WMT_ERR_FUNC("Rx REG_EVT fail!(%d) len(%d, %d)\n", iRet, u4Res, evtLen);
+		return -3;
+	}
+
+	if (!isWrite) {
+		UINT32 rxEvtAddr;
+		UINT32 txCmdAddr;
+
+		osal_memcpy(&txCmdAddr, &WMT_SET_REG_CMD[8], 4);
+		osal_memcpy(&rxEvtAddr, &evtBuf[8], 4);
+
+		/* check read result */
+		if (txCmdAddr != rxEvtAddr) {
+			WMT_ERR_FUNC("Check read addr fail (0x%08x, 0x%08x)\n", rxEvtAddr, txCmdAddr);
+			return -4;
+		}
+		WMT_DBG_FUNC("Check read addr(0x%08x) ok\n", rxEvtAddr);
+
+		osal_memcpy(pVal, &evtBuf[12], 4);
+	}
+
+	/* no error here just return 0 */
+	return 0;
+}
+
+INT32 wmt_core_init_script(struct init_script *script, INT32 count)
+{
+	UINT8 evtBuf[256];
+	UINT32 u4Res;
+	INT32 i = 0;
+	INT32 iRet;
+
+	for (i = 0; i < count; i++) {
+		WMT_DBG_FUNC("WMT-CORE: init_script operation %s start\n", script[i].str);
+		/* CMD */
+		/* iRet = (*kal_stp_tx)(script[i].cmd, script[i].cmdSz, &u4Res); */
+		iRet = wmt_core_tx(script[i].cmd, script[i].cmdSz, &u4Res, MTK_WCN_BOOL_FALSE);
+		if (iRet || (u4Res != script[i].cmdSz)) {
+			WMT_ERR_FUNC("WMT-CORE: write (%s) iRet(%d) cmd len err(%d, %d)\n", script[i].str, iRet, u4Res,
+				     script[i].cmdSz);
+			break;
+		}
+		/* EVENT BUF */
+		osal_memset(evtBuf, 0, sizeof(evtBuf));
+		iRet = wmt_core_rx(evtBuf, script[i].evtSz, &u4Res);
+		if (iRet || (u4Res != script[i].evtSz)) {
+			WMT_ERR_FUNC("WMT-CORE: read (%s) iRet(%d) evt len err(rx:%d, exp:%d)\n", script[i].str, iRet,
+				     u4Res, script[i].evtSz);
+			mtk_wcn_stp_dbg_dump_package();
+			break;
+		}
+		/* RESULT */
+		if (0x14 != evtBuf[1]) {	/* workaround RF calibration data EVT,do not care this EVT */
+			if (osal_memcmp(evtBuf, script[i].evt, script[i].evtSz) != 0) {
+				WMT_ERR_FUNC("WMT-CORE:compare %s result error\n", script[i].str);
+				WMT_ERR_FUNC
+				    ("WMT-CORE:rx(%d):[%02X,%02X,%02X,%02X,%02X] exp(%d):[%02X,%02X,%02X,%02X,%02X]\n",
+				     u4Res, evtBuf[0], evtBuf[1], evtBuf[2], evtBuf[3], evtBuf[4], script[i].evtSz,
+				     script[i].evt[0], script[i].evt[1], script[i].evt[2], script[i].evt[3],
+				     script[i].evt[4]);
+				mtk_wcn_stp_dbg_dump_package();
+				break;
+			}
+		}
+		WMT_DBG_FUNC("init_script operation %s ok\n", script[i].str);
+	}
+
+	return (i == count) ? 0 : -1;
+}
+
+static INT32 wmt_core_stp_init(VOID)
+{
+	INT32 iRet = -1;
+	unsigned long ctrlPa1;
+	unsigned long ctrlPa2;
+	UINT8 co_clock_type;
+	P_WMT_CTX pctx = &gMtkWmtCtx;
+	P_WMT_GEN_CONF pWmtGenConf = NULL;
+
+	wmt_conf_read_file();
+	pWmtGenConf = wmt_conf_get_cfg();
+	if (!(pctx->wmtInfoBit & WMT_OP_HIF_BIT)) {
+		WMT_ERR_FUNC("WMT-CORE: no hif info!\n");
+		osal_assert(0);
+		return -1;
+	}
+	/* 4 <1> open stp */
+	ctrlPa1 = 0;
+	ctrlPa2 = 0;
+	iRet = wmt_core_ctrl(WMT_CTRL_STP_OPEN, &ctrlPa1, &ctrlPa2);
+	if (iRet) {
+		WMT_ERR_FUNC("WMT-CORE: wmt open stp\n");
+		return -2;
+	}
+	/* 4 <1.5> disable and un-ready stp */
+	ctrlPa1 = WMT_STP_CONF_EN;
+	ctrlPa2 = 0;
+	iRet += wmt_core_ctrl(WMT_CTRL_STP_CONF, &ctrlPa1, &ctrlPa2);
+	ctrlPa1 = WMT_STP_CONF_RDY;
+	ctrlPa2 = 0;
+	iRet += wmt_core_ctrl(WMT_CTRL_STP_CONF, &ctrlPa1, &ctrlPa2);
+
+	/* 4 <2> set mode and enable */
+	if (WMT_HIF_BTIF == pctx->wmtHifConf.hifType) {
+		ctrlPa1 = WMT_STP_CONF_MODE;
+		ctrlPa2 = MTKSTP_BTIF_MAND_MODE;
+		iRet += wmt_core_ctrl(WMT_CTRL_STP_CONF, &ctrlPa1, &ctrlPa2);
+	}
+
+	ctrlPa1 = WMT_STP_CONF_EN;
+	ctrlPa2 = 1;
+	iRet += wmt_core_ctrl(WMT_CTRL_STP_CONF, &ctrlPa1, &ctrlPa2);
+	if (iRet) {
+		WMT_ERR_FUNC("WMT-CORE: stp_init <1><2> fail:%d\n", iRet);
+		return -3;
+	}
+	/* TODO: [ChangeFeature][GeorgeKuo] can we apply raise UART baud rate firstly for ALL supported chips??? */
+
+	iRet = wmt_core_hw_check();
+	if (iRet) {
+		WMT_ERR_FUNC("hw_check fail:%d\n", iRet);
+		return -4;
+	}
+	/* mtkWmtCtx.p_ic_ops is identified and checked ok */
+	if ((NULL != pctx->p_ic_ops->co_clock_ctrl) && (pWmtGenConf != NULL)) {
+		co_clock_type = (pWmtGenConf->co_clock_flag & 0x0f);
+		(*(pctx->p_ic_ops->co_clock_ctrl)) (co_clock_type == 0 ? WMT_CO_CLOCK_DIS : WMT_CO_CLOCK_EN);
+	} else {
+		WMT_WARN_FUNC("pctx->p_ic_ops->co_clock_ctrl(0x%x), pWmtGenConf(0x%x)\n", pctx->p_ic_ops->co_clock_ctrl,
+			      pWmtGenConf);
+	}
+	osal_assert(NULL != pctx->p_ic_ops->sw_init);
+	if (NULL != pctx->p_ic_ops->sw_init) {
+		iRet = (*(pctx->p_ic_ops->sw_init)) (&pctx->wmtHifConf);
+	} else {
+		WMT_ERR_FUNC("gMtkWmtCtx.p_ic_ops->sw_init is NULL\n");
+		return -5;
+	}
+	if (iRet) {
+		WMT_ERR_FUNC("gMtkWmtCtx.p_ic_ops->sw_init fail:%d\n", iRet);
+		return -6;
+	}
+	/* 4 <10> set stp ready */
+	ctrlPa1 = WMT_STP_CONF_RDY;
+	ctrlPa2 = 1;
+	iRet = wmt_core_ctrl(WMT_CTRL_STP_CONF, &ctrlPa1, &ctrlPa2);
+
+	return iRet;
+}
+
+static INT32 wmt_core_stp_deinit(VOID)
+{
+	INT32 iRet;
+	unsigned long ctrlPa1;
+	unsigned long ctrlPa2;
+
+	WMT_DBG_FUNC(" start\n");
+
+	if (NULL == gMtkWmtCtx.p_ic_ops) {
+		WMT_WARN_FUNC("gMtkWmtCtx.p_ic_ops is NULL\n");
+		goto deinit_ic_ops_done;
+	}
+	if (NULL != gMtkWmtCtx.p_ic_ops->sw_deinit) {
+		iRet = (*(gMtkWmtCtx.p_ic_ops->sw_deinit)) (&gMtkWmtCtx.wmtHifConf);
+		/* unbind WMT-IC */
+		gMtkWmtCtx.p_ic_ops = NULL;
+	} else {
+		WMT_ERR_FUNC("gMtkWmtCtx.p_ic_ops->sw_init is NULL\n");
+	}
+
+deinit_ic_ops_done:
+
+	/* 4 <1> un-ready, disable, and close stp. */
+	ctrlPa1 = WMT_STP_CONF_RDY;
+	ctrlPa2 = 0;
+	iRet = wmt_core_ctrl(WMT_CTRL_STP_CONF, &ctrlPa1, &ctrlPa2);
+	ctrlPa1 = WMT_STP_CONF_EN;
+	ctrlPa2 = 0;
+	iRet += wmt_core_ctrl(WMT_CTRL_STP_CONF, &ctrlPa1, &ctrlPa2);
+	ctrlPa1 = 0;
+	ctrlPa2 = 0;
+	iRet += wmt_core_ctrl(WMT_CTRL_STP_CLOSE, &ctrlPa1, &ctrlPa2);
+
+	if (iRet)
+		WMT_WARN_FUNC("end with fail:%d\n", iRet);
+
+	return iRet;
+}
+
+static VOID wmt_core_dump_func_state(PINT8 pSource)
+{
+	WMT_WARN_FUNC("[%s]status(b:%d f:%d g:%d w:%d lpbk:%d coredump:%d wmt:%d stp:%d)\n",
+		      (pSource == NULL ? (PINT8) "CORE" : pSource),
+		      gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_BT],
+		      gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_FM],
+		      gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_GPS],
+		      gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WIFI],
+		      gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_LPBK],
+		      gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_COREDUMP],
+		      gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT], gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_STP]
+	    );
+	return;
+
+}
+
+MTK_WCN_BOOL wmt_core_patch_check(UINT32 u4PatchVer, UINT32 u4HwVer)
+{
+	if (MAJORNUM(u4HwVer) != MAJORNUM(u4PatchVer)) {
+		/*major no. does not match */
+		WMT_ERR_FUNC("WMT-CORE: chip version(0x%d) does not match patch version(0x%d)\n", u4HwVer, u4PatchVer);
+		return MTK_WCN_BOOL_FALSE;
+	}
+	return MTK_WCN_BOOL_TRUE;
+}
+
+static INT32 wmt_core_hw_check(VOID)
+{
+	UINT32 chipid;
+	P_WMT_IC_OPS p_ops;
+	INT32 iret;
+
+	/* 1. get chip id */
+	chipid = 0;
+	WMT_LOUD_FUNC("before read hwcode (chip id)\n");
+	iret = wmt_core_reg_rw_raw(0, GEN_HCR, &chipid, GEN_HCR_MASK);	/* read 0x80000008 */
+	if (iret) {
+		WMT_ERR_FUNC("get hwcode (chip id) fail (%d)\n", iret);
+		return -2;
+	}
+	WMT_DBG_FUNC("get hwcode (chip id) (0x%x)\n", chipid);
+
+	/* TODO:[ChangeFeature][George]: use a better way to select a correct ops table based on chip id */
+	switch (chipid) {
+#if CFG_CORE_MT6620_SUPPORT
+	case 0x6620:
+		p_ops = &wmt_ic_ops_mt6620;
+		break;
+#endif
+#if CFG_CORE_MT6628_SUPPORT
+	case 0x6628:
+		p_ops = &wmt_ic_ops_mt6628;
+		break;
+#endif
+#if CFG_CORE_SOC_SUPPORT
+	case 0x6572:
+	case 0x6582:
+	case 0x6592:
+	case 0x8127:
+	case 0x6571:
+	case 0x6752:
+	case 0x0279:
+	case 0x0326:
+	case 0x0321:
+	case 0x0335:
+	case 0x0337:
+	case 0x8163:
+	case 0x6580:
+		p_ops = &wmt_ic_ops_soc;
+		break;
+#endif
+	default:
+		p_ops = (P_WMT_IC_OPS) NULL;
+#if CFG_CORE_SOC_SUPPORT
+		if (0x7f90 == chipid - 0x600) {
+			p_ops = &wmt_ic_ops_soc;
+			chipid -= 0xf6d;
+		}
+#endif
+		break;
+	}
+
+	if (NULL == p_ops) {
+		WMT_ERR_FUNC("unsupported chip id (hw_code): 0x%x\n", chipid);
+		return -3;
+	} else if (MTK_WCN_BOOL_FALSE == wmt_core_ic_ops_check(p_ops)) {
+		WMT_ERR_FUNC
+		    ("chip id(0x%x) with null operation fp: init(0x%p), deinit(0x%p), pin_ctrl(0x%p), ver_chk(0x%p)\n",
+		     chipid, p_ops->sw_init, p_ops->sw_deinit, p_ops->ic_pin_ctrl, p_ops->ic_ver_check);
+		return -4;
+	}
+	WMT_DBG_FUNC("chip id(0x%x) fp: init(0x%p), deinit(0x%p), pin_ctrl(0x%p), ver_chk(0x%p)\n",
+		     chipid, p_ops->sw_init, p_ops->sw_deinit, p_ops->ic_pin_ctrl, p_ops->ic_ver_check);
+
+	wmt_ic_ops_soc.icId = chipid;
+	WMT_DBG_FUNC("wmt_ic_ops_soc.icId(0x%x)\n", wmt_ic_ops_soc.icId);
+	iret = p_ops->ic_ver_check();
+	if (iret) {
+		WMT_ERR_FUNC("chip id(0x%x) ver_check error:%d\n", chipid, iret);
+		return -5;
+	}
+
+	WMT_DBG_FUNC("chip id(0x%x) ver_check ok\n", chipid);
+	gMtkWmtCtx.p_ic_ops = p_ops;
+	return 0;
+}
+
+static INT32 opfunc_hif_conf(P_WMT_OP pWmtOp)
+{
+	if (!(pWmtOp->u4InfoBit & WMT_OP_HIF_BIT)) {
+		WMT_ERR_FUNC("WMT-CORE: no HIF_BIT in WMT_OP!\n");
+		return -1;
+	}
+
+	if (gMtkWmtCtx.wmtInfoBit & WMT_OP_HIF_BIT) {
+		WMT_ERR_FUNC("WMT-CORE: WMT HIF already exist. overwrite! old (%d), new(%d))\n",
+			     gMtkWmtCtx.wmtHifConf.hifType, pWmtOp->au4OpData[0]);
+	} else {
+		gMtkWmtCtx.wmtInfoBit |= WMT_OP_HIF_BIT;
+		WMT_ERR_FUNC("WMT-CORE: WMT HIF info added\n");
+	}
+
+	osal_memcpy(&gMtkWmtCtx.wmtHifConf, &pWmtOp->au4OpData[0], osal_sizeof(gMtkWmtCtx.wmtHifConf));
+	return 0;
+
+}
+
+static INT32 opfunc_pwr_on(P_WMT_OP pWmtOp)
+{
+
+	INT32 iRet;
+	unsigned long ctrlPa1;
+	unsigned long ctrlPa2;
+	INT32 retry = WMT_PWRON_RTY_DFT;
+
+	if (DRV_STS_POWER_OFF != gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT]) {
+		WMT_ERR_FUNC("WMT-CORE: already powered on, WMT DRV_STS_[0x%x]\n",
+			     gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT]);
+		osal_assert(0);
+		return -1;
+	}
+	/* TODO: [FixMe][GeorgeKuo]: clarify the following is reqiured or not! */
+	if (pWmtOp->u4InfoBit & WMT_OP_HIF_BIT)
+		opfunc_hif_conf(pWmtOp);
+
+pwr_on_rty:
+	/* power on control */
+	ctrlPa1 = 0;
+	ctrlPa2 = 0;
+	iRet = wmt_core_ctrl(WMT_CTRL_HW_PWR_ON, &ctrlPa1, &ctrlPa2);
+	if (iRet) {
+		WMT_ERR_FUNC("WMT-CORE: WMT_CTRL_HW_PWR_ON fail iRet(%d)\n", iRet);
+		if (0 == retry--) {
+			WMT_INFO_FUNC("WMT-CORE: retry (%d)\n", retry);
+			goto pwr_on_rty;
+		}
+		return -1;
+	}
+	gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT] = DRV_STS_POWER_ON;
+
+	/* init stp */
+	iRet = wmt_core_stp_init();
+	if (iRet) {
+		WMT_ERR_FUNC("WMT-CORE: wmt_core_stp_init fail (%d)\n", iRet);
+		osal_assert(0);
+
+		/* deinit stp */
+		iRet = wmt_core_stp_deinit();
+		iRet = opfunc_pwr_off(pWmtOp);
+		if (iRet)
+			WMT_ERR_FUNC("WMT-CORE: opfunc_pwr_off fail during pwr_on retry\n");
+
+		if (0 < retry--) {
+			WMT_INFO_FUNC("WMT-CORE: retry (%d)\n", retry);
+			goto pwr_on_rty;
+		}
+		iRet = -2;
+		return iRet;
+	}
+
+	WMT_DBG_FUNC("WMT-CORE: WMT [FUNC_ON]\n");
+	gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT] = DRV_STS_FUNC_ON;
+
+	/* What to do when state is changed from POWER_OFF to POWER_ON?
+	 * 1. STP driver does s/w reset
+	 * 2. UART does 0xFF wake up
+	 * 3. SDIO does re-init command(changed to trigger by host)
+	 */
+	return iRet;
+
+}
+
+static INT32 opfunc_pwr_off(P_WMT_OP pWmtOp)
+{
+
+	INT32 iRet;
+	unsigned long ctrlPa1;
+	unsigned long ctrlPa2;
+
+	if (DRV_STS_POWER_OFF == gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT]) {
+		WMT_WARN_FUNC("WMT-CORE: WMT already off, WMT DRV_STS_[0x%x]\n",
+			      gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT]);
+		osal_assert(0);
+		return -1;
+	}
+	if (MTK_WCN_BOOL_FALSE == g_pwr_off_flag) {
+		WMT_WARN_FUNC("CONNSYS power off be disabled, maybe need trigger core dump!\n");
+		osal_assert(0);
+		return -2;
+	}
+
+	/* wmt and stp are initialized successfully */
+	if (DRV_STS_FUNC_ON == gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT]) {
+		iRet = wmt_core_stp_deinit();
+		if (iRet) {
+			WMT_WARN_FUNC("wmt_core_stp_deinit fail (%d)\n", iRet);
+			/*should let run to power down chip */
+		}
+	}
+	gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT] = DRV_STS_POWER_ON;
+
+	/* power off control */
+	ctrlPa1 = 0;
+	ctrlPa2 = 0;
+	iRet = wmt_core_ctrl(WMT_CTRL_HW_PWR_OFF, &ctrlPa1, &ctrlPa2);
+	if (iRet)
+		WMT_WARN_FUNC("HW_PWR_OFF fail (%d)\n", iRet);
+	WMT_WARN_FUNC("HW_PWR_OFF ok\n");
+
+	/*anyway, set to POWER_OFF state */
+	gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT] = DRV_STS_POWER_OFF;
+	return iRet;
+
+}
+
+static INT32 opfunc_func_on(P_WMT_OP pWmtOp)
+{
+	INT32 iRet = -1;
+	INT32 iPwrOffRet = -1;
+	UINT32 drvType;
+
+	drvType = pWmtOp->au4OpData[0];
+
+	/* Check abnormal type */
+	if (WMTDRV_TYPE_COREDUMP < drvType) {
+		WMT_ERR_FUNC("abnormal Fun(%d)\n", drvType);
+		osal_assert(0);
+		return -1;
+	}
+
+	/* Check abnormal state */
+	if ((DRV_STS_POWER_OFF > gMtkWmtCtx.eDrvStatus[drvType])
+	    || (DRV_STS_MAX <= gMtkWmtCtx.eDrvStatus[drvType])) {
+		WMT_ERR_FUNC("func(%d) status[0x%x] abnormal\n", drvType, gMtkWmtCtx.eDrvStatus[drvType]);
+		osal_assert(0);
+		return -2;
+	}
+
+	/* check if func already on */
+	if (DRV_STS_FUNC_ON == gMtkWmtCtx.eDrvStatus[drvType]) {
+		WMT_WARN_FUNC("func(%d) already on\n", drvType);
+		return 0;
+	}
+	/*enable power off flag, if flag=0, power off connsys will not be executed */
+	mtk_wcn_set_connsys_power_off_flag(MTK_WCN_BOOL_TRUE);
+	/* check if chip power on is needed */
+	if (DRV_STS_FUNC_ON != gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT]) {
+		iRet = opfunc_pwr_on(pWmtOp);
+
+		if (iRet) {
+			WMT_ERR_FUNC("func(%d) pwr_on fail(%d)\n", drvType, iRet);
+			osal_assert(0);
+
+			/* check all sub-func and do power off */
+			return -3;
+		}
+	}
+
+	if (WMTDRV_TYPE_WMT > drvType) {
+		if (NULL != gpWmtFuncOps[drvType] && NULL != gpWmtFuncOps[drvType]->func_on) {
+			iRet = (*(gpWmtFuncOps[drvType]->func_on)) (gMtkWmtCtx.p_ic_ops, wmt_conf_get_cfg());
+			if (0 != iRet)
+				gMtkWmtCtx.eDrvStatus[drvType] = DRV_STS_POWER_OFF;
+			else
+				gMtkWmtCtx.eDrvStatus[drvType] = DRV_STS_FUNC_ON;
+		} else {
+			WMT_WARN_FUNC("WMT-CORE: ops for type(%d) not found\n", drvType);
+			iRet = -5;
+		}
+	} else {
+		if (WMTDRV_TYPE_LPBK == drvType)
+			gMtkWmtCtx.eDrvStatus[drvType] = DRV_STS_FUNC_ON;
+		else if (WMTDRV_TYPE_COREDUMP == drvType)
+			gMtkWmtCtx.eDrvStatus[drvType] = DRV_STS_FUNC_ON;
+		iRet = 0;
+	}
+
+	if (iRet) {
+		WMT_ERR_FUNC("WMT-CORE:type(0x%x) function on failed, ret(%d)\n", drvType, iRet);
+		osal_assert(0);
+		/* FIX-ME:[Chaozhong Liang], Error handling? check subsystem state and do pwr off if necessary? */
+		/* check all sub-func and do power off */
+		if ((DRV_STS_POWER_OFF == gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_BT]) &&
+		    (DRV_STS_POWER_OFF == gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_GPS]) &&
+		    (DRV_STS_POWER_OFF == gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_FM]) &&
+		    (DRV_STS_POWER_OFF == gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WIFI]) &&
+		    (DRV_STS_POWER_OFF == gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_LPBK]) &&
+		    (DRV_STS_POWER_OFF == gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_COREDUMP])) {
+			WMT_INFO_FUNC("WMT-CORE:Fun(%d) [POWER_OFF] and power down chip\n", drvType);
+			mtk_wcn_wmt_system_state_reset();
+
+			iPwrOffRet = opfunc_pwr_off(pWmtOp);
+			if (iPwrOffRet) {
+				WMT_ERR_FUNC("WMT-CORE: wmt_pwr_off fail(%d) when turn off func(%d)\n", iPwrOffRet,
+					     drvType);
+				osal_assert(0);
+			}
+		}
+		return iRet;
+	}
+
+	wmt_core_dump_func_state("AF FUNC ON");
+
+	return 0;
+}
+
+static INT32 opfunc_func_off(P_WMT_OP pWmtOp)
+{
+
+	INT32 iRet = -1;
+	UINT32 drvType;
+
+	drvType = pWmtOp->au4OpData[0];
+	/* Check abnormal type */
+	if (WMTDRV_TYPE_COREDUMP < drvType) {
+		WMT_ERR_FUNC("WMT-CORE: abnormal Fun(%d) in wmt_func_off\n", drvType);
+		osal_assert(0);
+		return -1;
+	}
+
+	/* Check abnormal state */
+	if (DRV_STS_MAX <= gMtkWmtCtx.eDrvStatus[drvType]) {
+		WMT_ERR_FUNC("WMT-CORE: Fun(%d) DRV_STS_[0x%x] abnormal in wmt_func_off\n",
+			     drvType, gMtkWmtCtx.eDrvStatus[drvType]);
+		osal_assert(0);
+		return -2;
+	}
+
+	if (DRV_STS_FUNC_ON != gMtkWmtCtx.eDrvStatus[drvType]) {
+		WMT_WARN_FUNC("WMT-CORE: Fun(%d) DRV_STS_[0x%x] already non-FUN_ON in wmt_func_off\n",
+			      drvType, gMtkWmtCtx.eDrvStatus[drvType]);
+		/* needs to check 4 subsystem's state? */
+		return 0;
+	} else if (WMTDRV_TYPE_WMT > drvType) {
+		if (NULL != gpWmtFuncOps[drvType] && NULL != gpWmtFuncOps[drvType]->func_off) {
+			iRet = (*(gpWmtFuncOps[drvType]->func_off)) (gMtkWmtCtx.p_ic_ops, wmt_conf_get_cfg());
+		} else {
+			WMT_WARN_FUNC("WMT-CORE: ops for type(%d) not found\n", drvType);
+			iRet = -3;
+		}
+	} else {
+		if (WMTDRV_TYPE_LPBK == drvType)
+			gMtkWmtCtx.eDrvStatus[drvType] = DRV_STS_POWER_OFF;
+		else if (WMTDRV_TYPE_COREDUMP == drvType)
+			gMtkWmtCtx.eDrvStatus[drvType] = DRV_STS_POWER_OFF;
+		iRet = 0;
+	}
+
+	/* shall we put device state to POWER_OFF state when fail? */
+	gMtkWmtCtx.eDrvStatus[drvType] = DRV_STS_POWER_OFF;
+
+	if (iRet) {
+		WMT_ERR_FUNC("WMT-CORE: type(0x%x) function off failed, ret(%d)\n", drvType, iRet);
+		osal_assert(0);
+		/* no matter subsystem function control fail or not,
+		*chip should be powered off when no subsystem is active
+		*/
+		/* return iRet; */
+	}
+
+	/* check all sub-func and do power off */
+	if ((DRV_STS_POWER_OFF == gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_BT]) &&
+	    (DRV_STS_POWER_OFF == gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_GPS]) &&
+	    (DRV_STS_POWER_OFF == gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_FM]) &&
+	    (DRV_STS_POWER_OFF == gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WIFI]) &&
+	    (DRV_STS_POWER_OFF == gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_LPBK]) &&
+	    (DRV_STS_POWER_OFF == gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_COREDUMP])) {
+		WMT_INFO_FUNC("WMT-CORE:Fun(%d) [POWER_OFF] and power down chip\n", drvType);
+
+		iRet = opfunc_pwr_off(pWmtOp);
+		if (iRet) {
+			WMT_ERR_FUNC("WMT-CORE: wmt_pwr_off fail(%d) when turn off func(%d)\n", iRet, drvType);
+			osal_assert(0);
+		}
+	}
+
+	wmt_core_dump_func_state("AF FUNC OFF");
+	return iRet;
+}
+
+/* TODO:[ChangeFeature][George] is this OP obsoleted? */
+static INT32 opfunc_reg_rw(P_WMT_OP pWmtOp)
+{
+	INT32 iret;
+
+	if (DRV_STS_FUNC_ON != gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT]) {
+		WMT_ERR_FUNC("reg_rw when WMT is powered off\n");
+		return -1;
+	}
+	iret = wmt_core_reg_rw_raw(pWmtOp->au4OpData[0],
+				   pWmtOp->au4OpData[1], (PUINT32) pWmtOp->au4OpData[2], pWmtOp->au4OpData[3]);
+
+	return iret;
+}
+
+static INT32 opfunc_exit(P_WMT_OP pWmtOp)
+{
+	/* TODO: [FixMe][George] is ok to leave this function empty??? */
+	WMT_WARN_FUNC("EMPTY FUNCTION\n");
+	return 0;
+}
+
+static INT32 opfunc_pwr_sv(P_WMT_OP pWmtOp)
+{
+	INT32 ret = -1;
+	UINT32 u4_result = 0;
+	UINT32 evt_len;
+	UINT8 evt_buf[16] = { 0 };
+	unsigned long ctrlPa1 = 0;
+	unsigned long ctrlPa2 = 0;
+
+	typedef INT32(*STP_PSM_CB) (INT32);
+	STP_PSM_CB psm_cb = NULL;
+
+	if (SLEEP == pWmtOp->au4OpData[0]) {
+		WMT_DBG_FUNC("**** Send sleep command\n");
+		/* mtk_wcn_stp_set_psm_state(ACT_INACT); */
+		/* (*kal_stp_flush_rx)(WMT_TASK_INDX); */
+		ret = wmt_core_tx((PUINT8) &WMT_SLEEP_CMD[0], sizeof(WMT_SLEEP_CMD), &u4_result, 0);
+		if (ret || (u4_result != sizeof(WMT_SLEEP_CMD))) {
+			WMT_ERR_FUNC("wmt_core: SLEEP_CMD ret(%d) cmd len err(%d, %d) ", ret, u4_result,
+				     sizeof(WMT_SLEEP_CMD));
+			goto pwr_sv_done;
+		}
+
+		evt_len = sizeof(WMT_SLEEP_EVT);
+		ret = wmt_core_rx(evt_buf, evt_len, &u4_result);
+		if (ret || (u4_result != evt_len)) {
+			unsigned long type = WMTDRV_TYPE_WMT;
+			unsigned long reason = 33;
+			unsigned long ctrlpa = 1;
+
+			wmt_core_rx_flush(WMT_TASK_INDX);
+			WMT_ERR_FUNC("wmt_core: read SLEEP_EVT fail(%d) len(%d, %d)", ret, u4_result, evt_len);
+			mtk_wcn_stp_dbg_dump_package();
+			ret = wmt_core_ctrl(WMT_CTRL_EVT_PARSER, &ctrlpa, 0);
+			if (!ret) {	/* parser ok */
+				reason = 38;	/* host schedule issue reason code */
+				WMT_WARN_FUNC("This evt error may be caused by system schedule issue\n");
+			}
+			wmt_core_ctrl(WMT_CTRL_EVT_ERR_TRG_ASSERT, &type, &reason);
+			goto pwr_sv_done;
+		}
+
+		if (osal_memcmp(evt_buf, WMT_SLEEP_EVT, sizeof(WMT_SLEEP_EVT)) != 0) {
+			WMT_ERR_FUNC("wmt_core: compare WMT_SLEEP_EVT error\n");
+			wmt_core_rx_flush(WMT_TASK_INDX);
+			WMT_ERR_FUNC("wmt_core: rx(%d):[%02X,%02X,%02X,%02X,%02X,%02X]\n",
+				u4_result,
+				evt_buf[0],
+				evt_buf[1],
+				evt_buf[2],
+				evt_buf[3],
+				evt_buf[4],
+				evt_buf[5]);
+			WMT_ERR_FUNC("wmt_core: exp(%d):[%02X,%02X,%02X,%02X,%02X,%02X]\n",
+				sizeof(WMT_SLEEP_EVT),
+				WMT_SLEEP_EVT[0],
+				WMT_SLEEP_EVT[1],
+				WMT_SLEEP_EVT[2],
+			    WMT_SLEEP_EVT[3],
+			    WMT_SLEEP_EVT[4],
+			    WMT_SLEEP_EVT[5]);
+			mtk_wcn_stp_dbg_dump_package();
+			goto pwr_sv_done;
+		} else {
+			WMT_DBG_FUNC("Send sleep command OK!\n");
+		}
+	} else if (pWmtOp->au4OpData[0] == WAKEUP) {
+		WMT_DBG_FUNC("wakeup connsys by btif");
+
+		ret = wmt_core_ctrl(WMT_CTRL_SOC_WAKEUP_CONSYS, &ctrlPa1, &ctrlPa2);
+		if (ret) {
+			WMT_ERR_FUNC("wmt-core:WAKEUP_CONSYS by BTIF fail(%d)", ret);
+			goto pwr_sv_done;
+		}
+#if 0
+		WMT_DBG_FUNC("**** Send wakeup command\n");
+		ret = wmt_core_tx(WMT_WAKEUP_CMD, sizeof(WMT_WAKEUP_CMD), &u4_result, 1);
+
+		if (ret || (u4_result != sizeof(WMT_WAKEUP_CMD))) {
+			wmt_core_rx_flush(WMT_TASK_INDX);
+			WMT_ERR_FUNC("wmt_core: WAKEUP_CMD ret(%d) cmd len err(%d, %d) ", ret, u4_result,
+				     sizeof(WMT_WAKEUP_CMD));
+			goto pwr_sv_done;
+		}
+#endif
+		evt_len = sizeof(WMT_WAKEUP_EVT);
+		ret = wmt_core_rx(evt_buf, evt_len, &u4_result);
+		if (ret || (u4_result != evt_len)) {
+			unsigned long type = WMTDRV_TYPE_WMT;
+			unsigned long reason = 34;
+			unsigned long ctrlpa = 2;
+
+			WMT_ERR_FUNC("wmt_core: read WAKEUP_EVT fail(%d) len(%d, %d)", ret, u4_result, evt_len);
+			mtk_wcn_stp_dbg_dump_package();
+			ret = wmt_core_ctrl(WMT_CTRL_EVT_PARSER, &ctrlpa, 0);
+			if (!ret) {	/* parser ok */
+				reason = 39;	/* host schedule issue reason code */
+				WMT_WARN_FUNC("This evt error may be caused by system schedule issue\n");
+			}
+			wmt_core_ctrl(WMT_CTRL_EVT_ERR_TRG_ASSERT, &type, &reason);
+			goto pwr_sv_done;
+		}
+
+		if (osal_memcmp(evt_buf, WMT_WAKEUP_EVT, sizeof(WMT_WAKEUP_EVT)) != 0) {
+			WMT_ERR_FUNC("wmt_core: compare WMT_WAKEUP_EVT error\n");
+			wmt_core_rx_flush(WMT_TASK_INDX);
+			WMT_ERR_FUNC("wmt_core: rx(%d):[%02X,%02X,%02X,%02X,%02X,%02X]\n",
+				u4_result,
+				evt_buf[0],
+				evt_buf[1],
+				evt_buf[2],
+				evt_buf[3],
+				evt_buf[4],
+				evt_buf[5]);
+			WMT_ERR_FUNC("wmt_core: exp(%d):[%02X,%02X,%02X,%02X,%02X,%02X]\n",
+				sizeof(WMT_WAKEUP_EVT),
+				WMT_WAKEUP_EVT[0],
+				WMT_WAKEUP_EVT[1],
+				WMT_WAKEUP_EVT[2],
+			    WMT_WAKEUP_EVT[3],
+			    WMT_WAKEUP_EVT[4],
+			    WMT_WAKEUP_EVT[5]);
+			mtk_wcn_stp_dbg_dump_package();
+			goto pwr_sv_done;
+		} else {
+			WMT_DBG_FUNC("Send wakeup command OK!\n");
+		}
+	} else if (pWmtOp->au4OpData[0] == HOST_AWAKE) {
+
+		WMT_DBG_FUNC("**** Send host awake command\n");
+
+		psm_cb = (STP_PSM_CB) pWmtOp->au4OpData[1];
+		/* (*kal_stp_flush_rx)(WMT_TASK_INDX); */
+		ret = wmt_core_tx((PUINT8) WMT_HOST_AWAKE_CMD, sizeof(WMT_HOST_AWAKE_CMD), &u4_result, 0);
+		if (ret || (u4_result != sizeof(WMT_HOST_AWAKE_CMD))) {
+			WMT_ERR_FUNC("wmt_core: HOST_AWAKE_CMD ret(%d) cmd len err(%d, %d) ", ret, u4_result,
+				     sizeof(WMT_HOST_AWAKE_CMD));
+			goto pwr_sv_done;
+		}
+
+		evt_len = sizeof(WMT_HOST_AWAKE_EVT);
+		ret = wmt_core_rx(evt_buf, evt_len, &u4_result);
+		if (ret || (u4_result != evt_len)) {
+			unsigned long type = WMTDRV_TYPE_WMT;
+			unsigned long reason = 35;
+			unsigned long ctrlpa = 3;
+
+			wmt_core_rx_flush(WMT_TASK_INDX);
+			WMT_ERR_FUNC("wmt_core: read HOST_AWAKE_EVT fail(%d) len(%d, %d)", ret, u4_result, evt_len);
+			mtk_wcn_stp_dbg_dump_package();
+			ret = wmt_core_ctrl(WMT_CTRL_EVT_PARSER, &ctrlpa, 0);
+			if (!ret) {	/* parser ok */
+				reason = 40;	/* host schedule issue reason code */
+				WMT_WARN_FUNC("This evt error may be caused by system schedule issue\n");
+			}
+			wmt_core_ctrl(WMT_CTRL_EVT_ERR_TRG_ASSERT, &type, &reason);
+			goto pwr_sv_done;
+		}
+
+		if (osal_memcmp(evt_buf, WMT_HOST_AWAKE_EVT, sizeof(WMT_HOST_AWAKE_EVT)) != 0) {
+			WMT_ERR_FUNC("wmt_core: compare WMT_HOST_AWAKE_EVT error\n");
+			wmt_core_rx_flush(WMT_TASK_INDX);
+			WMT_ERR_FUNC("wmt_core: rx(%d):[%02X,%02X,%02X,%02X,%02X,%02X]\n",
+				u4_result,
+				evt_buf[0],
+				evt_buf[1],
+				evt_buf[2],
+				evt_buf[3],
+				evt_buf[4],
+				evt_buf[5]);
+			WMT_ERR_FUNC("wmt_core: exp(%d):[%02X,%02X,%02X,%02X,%02X,%02X]\n",
+				sizeof(WMT_HOST_AWAKE_EVT),
+				WMT_HOST_AWAKE_EVT[0],
+				WMT_HOST_AWAKE_EVT[1],
+				WMT_HOST_AWAKE_EVT[2],
+			    WMT_HOST_AWAKE_EVT[3],
+			    WMT_HOST_AWAKE_EVT[4],
+			    WMT_HOST_AWAKE_EVT[5]);
+			mtk_wcn_stp_dbg_dump_package();
+			/* goto pwr_sv_done; */
+		} else {
+			WMT_DBG_FUNC("Send host awake command OK!\n");
+		}
+	}
+pwr_sv_done:
+
+	if (pWmtOp->au4OpData[0] < STP_PSM_MAX_ACTION) {
+		psm_cb = (STP_PSM_CB) pWmtOp->au4OpData[1];
+		WMT_DBG_FUNC("Do STP-CB! %d %p / %p\n", pWmtOp->au4OpData[0], (PVOID) pWmtOp->au4OpData[1],
+			     (PVOID) psm_cb);
+		if (NULL != psm_cb) {
+			psm_cb(pWmtOp->au4OpData[0]);
+		} else {
+			WMT_ERR_FUNC("fatal error !!!, psm_cb = %p, god, someone must have corrupted our memory.\n",
+				     psm_cb);
+		}
+	}
+
+	return ret;
+}
+
+static INT32 opfunc_dsns(P_WMT_OP pWmtOp)
+{
+
+	INT32 iRet = -1;
+	UINT32 u4Res;
+	UINT32 evtLen;
+	UINT8 evtBuf[16] = { 0 };
+
+	WMT_DSNS_CMD[4] = (UINT8) pWmtOp->au4OpData[0];
+	WMT_DSNS_CMD[5] = (UINT8) pWmtOp->au4OpData[1];
+
+	/* send command */
+	/* iRet = (*kal_stp_tx)(WMT_DSNS_CMD, osal_sizeof(WMT_DSNS_CMD), &u4Res); */
+	iRet = wmt_core_tx((PUINT8) WMT_DSNS_CMD, osal_sizeof(WMT_DSNS_CMD), &u4Res, MTK_WCN_BOOL_FALSE);
+	if (iRet || (u4Res != osal_sizeof(WMT_DSNS_CMD))) {
+		WMT_ERR_FUNC("WMT-CORE: DSNS_CMD iRet(%d) cmd len err(%d, %d)\n", iRet, u4Res,
+			     osal_sizeof(WMT_DSNS_CMD));
+		return iRet;
+	}
+
+	evtLen = osal_sizeof(WMT_DSNS_EVT);
+
+	iRet = wmt_core_rx(evtBuf, evtLen, &u4Res);
+	if (iRet || (u4Res != evtLen)) {
+		WMT_ERR_FUNC("WMT-CORE: read DSNS_EVT fail(%d) len(%d, %d)\n", iRet, u4Res, evtLen);
+		mtk_wcn_stp_dbg_dump_package();
+		return iRet;
+	}
+
+	if (osal_memcmp(evtBuf, WMT_DSNS_EVT, osal_sizeof(WMT_DSNS_EVT)) != 0) {
+		WMT_ERR_FUNC("WMT-CORE: compare WMT_DSNS_EVT error\n");
+		WMT_ERR_FUNC("WMT-CORE: rx(%d):[%02X,%02X,%02X,%02X,%02X] exp(%d):[%02X,%02X,%02X,%02X,%02X]\n",
+			     u4Res, evtBuf[0], evtBuf[1], evtBuf[2], evtBuf[3], evtBuf[4],
+			     osal_sizeof(WMT_DSNS_EVT), WMT_DSNS_EVT[0], WMT_DSNS_EVT[1], WMT_DSNS_EVT[2],
+			     WMT_DSNS_EVT[3], WMT_DSNS_EVT[4]);
+	} else {
+		WMT_INFO_FUNC("Send WMT_DSNS_CMD command OK!\n");
+	}
+
+	return iRet;
+}
+
+#if CFG_CORE_INTERNAL_TXRX
+INT32 wmt_core_lpbk_do_stp_init(void)
+{
+	INT32 iRet = 0;
+	unsigned long ctrlPa1 = 0;
+	unsigned long ctrlPa2 = 0;
+
+	ctrlPa1 = 0;
+	ctrlPa2 = 0;
+	iRet = wmt_core_ctrl(WMT_CTRL_STP_OPEN, &ctrlPa1, &ctrlPa2);
+	if (iRet) {
+		WMT_ERR_FUNC("WMT-CORE: wmt open stp\n");
+		return -1;
+	}
+
+	ctrlPa1 = WMT_STP_CONF_MODE;
+	ctrlPa2 = MTKSTP_BTIF_MAND_MODE;
+	iRet += wmt_core_ctrl(WMT_CTRL_STP_CONF, &ctrlPa1, &ctrlPa2);
+
+	ctrlPa1 = WMT_STP_CONF_EN;
+	ctrlPa2 = 1;
+	iRet += wmt_core_ctrl(WMT_CTRL_STP_CONF, &ctrlPa1, &ctrlPa2);
+	if (iRet) {
+		WMT_ERR_FUNC("WMT-CORE: stp_init <1><2> fail:%d\n", iRet);
+		return -2;
+	}
+}
+
+INT32 wmt_core_lpbk_do_stp_deinit(void)
+{
+	INT32 iRet = 0;
+	unsigned long ctrlPa1 = 0;
+	unsigned long ctrlPa2 = 0;
+
+	ctrlPa1 = 0;
+	ctrlPa2 = 0;
+	iRet = wmt_core_ctrl(WMT_CTRL_STP_CLOSE, &ctrlPa1, &ctrlPa2);
+	if (iRet) {
+		WMT_ERR_FUNC("WMT-CORE: wmt open stp\n");
+		return -1;
+	}
+
+	return 0;
+}
+#endif
+static INT32 opfunc_lpbk(P_WMT_OP pWmtOp)
+{
+
+	INT32 iRet;
+	UINT32 u4WrittenSize = 0;
+	UINT32 u4ReadSize = 0;
+	UINT32 buf_length = 0;
+	UINT32 *pbuffer = NULL;
+	UINT16 len_in_cmd;
+
+	/* UINT32 offset; */
+	UINT8 WMT_TEST_LPBK_CMD[] = { 0x1, 0x2, 0x0, 0x0, 0x7 };
+	UINT8 WMT_TEST_LPBK_EVT[] = { 0x2, 0x2, 0x0, 0x0, 0x0 };
+
+	/* UINT8 lpbk_buf[1024 + 5] = {0}; */
+	MTK_WCN_BOOL fgFail;
+
+	buf_length = pWmtOp->au4OpData[0];	/* packet length */
+	pbuffer = (VOID *) pWmtOp->au4OpData[1];	/* packet buffer pointer */
+	WMT_DBG_FUNC("WMT-CORE: -->wmt_do_lpbk\n");
+
+#if 0
+	osal_memcpy(&WMT_TEST_LPBK_EVT[0], &WMT_TEST_LPBK_CMD[0], osal_sizeof(WMT_TEST_LPBK_CMD));
+#endif
+#if !CFG_CORE_INTERNAL_TXRX
+	/*check if WMTDRV_TYPE_LPBK function is already on */
+	if (DRV_STS_FUNC_ON != gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_LPBK]
+	    || buf_length + osal_sizeof(WMT_TEST_LPBK_CMD) > osal_sizeof(gLpbkBuf)) {
+		WMT_ERR_FUNC("WMT-CORE: abnormal LPBK in wmt_do_lpbk\n");
+		osal_assert(0);
+		return -2;
+	}
+#endif
+	/*package loopback for STP */
+
+	/* init buffer */
+	osal_memset(gLpbkBuf, 0, osal_sizeof(gLpbkBuf));
+
+	len_in_cmd = buf_length + 1;	/* add flag field */
+
+	osal_memcpy(&WMT_TEST_LPBK_CMD[2], &len_in_cmd, 2);
+	osal_memcpy(&WMT_TEST_LPBK_EVT[2], &len_in_cmd, 2);
+
+	/* wmt cmd */
+	osal_memcpy(gLpbkBuf, WMT_TEST_LPBK_CMD, osal_sizeof(WMT_TEST_LPBK_CMD));
+	osal_memcpy(gLpbkBuf + osal_sizeof(WMT_TEST_LPBK_CMD), pbuffer, buf_length);
+
+	do {
+		fgFail = MTK_WCN_BOOL_TRUE;
+		/*send packet through STP */
+
+		/* iRet = (*kal_stp_tx)(
+		*(PUINT8)gLpbkBuf,
+		*osal_sizeof(WMT_TEST_LPBK_CMD) + buf_length,
+		*&u4WrittenSize);
+		*/
+		iRet = wmt_core_tx((PUINT8) gLpbkBuf,
+				(osal_sizeof(WMT_TEST_LPBK_CMD) + buf_length),
+				&u4WrittenSize,
+				MTK_WCN_BOOL_FALSE);
+		if (iRet) {
+			WMT_ERR_FUNC("opfunc_lpbk wmt_core_tx failed\n");
+			break;
+		}
+		WMT_INFO_FUNC("opfunc_lpbk wmt_core_tx OK\n");
+
+		/*receive firmware response from STP */
+		iRet = wmt_core_rx((PUINT8) gLpbkBuf, (osal_sizeof(WMT_TEST_LPBK_EVT) + buf_length), &u4ReadSize);
+		if (iRet) {
+			WMT_ERR_FUNC("opfunc_lpbk wmt_core_rx failed\n");
+			break;
+		}
+		WMT_INFO_FUNC("opfunc_lpbk wmt_core_rx  OK\n");
+		/*check if loopback response ok or not */
+		if (u4ReadSize != (osal_sizeof(WMT_TEST_LPBK_CMD) + buf_length)) {
+			WMT_ERR_FUNC("lpbk event read size wrong(%d, %d)\n", u4ReadSize,
+				     (osal_sizeof(WMT_TEST_LPBK_CMD) + buf_length));
+			break;
+		}
+		WMT_INFO_FUNC("lpbk event read size right(%d, %d)\n", u4ReadSize,
+			      (osal_sizeof(WMT_TEST_LPBK_CMD) + buf_length));
+
+		if (osal_memcmp(WMT_TEST_LPBK_EVT, gLpbkBuf, osal_sizeof(WMT_TEST_LPBK_EVT))) {
+			WMT_ERR_FUNC("WMT-CORE WMT_TEST_LPBK_EVT error! read len %d [%02x,%02x,%02x,%02x,%02x]\n",
+				     (INT32) u4ReadSize, gLpbkBuf[0], gLpbkBuf[1], gLpbkBuf[2], gLpbkBuf[3], gLpbkBuf[4]
+			    );
+			break;
+		}
+		pWmtOp->au4OpData[0] = u4ReadSize - osal_sizeof(WMT_TEST_LPBK_EVT);
+		osal_memcpy((VOID *) pWmtOp->au4OpData[1], gLpbkBuf + osal_sizeof(WMT_TEST_LPBK_CMD), buf_length);
+		fgFail = MTK_WCN_BOOL_FALSE;
+	} while (0);
+	/*return result */
+	/* WMT_DBG_FUNC("WMT-CORE: <--wmt_do_lpbk, fgFail = %d\n", fgFail); */
+	return fgFail;
+
+}
+
+static INT32 opfunc_cmd_test(P_WMT_OP pWmtOp)
+{
+
+	INT32 iRet = 0;
+	UINT32 cmdNo = 0;
+	UINT32 cmdNoPa = 0;
+
+	UINT8 tstCmd[64];
+	UINT8 tstEvt[64];
+	UINT8 tstEvtTmp[64];
+	UINT32 u4Res;
+	SIZE_T tstCmdSz = 0;
+	SIZE_T tstEvtSz = 0;
+
+	UINT8 *pRes = NULL;
+	UINT32 resBufRoom = 0;
+	/*test command list */
+	/*1 */
+	UINT8 WMT_ASSERT_CMD[] = { 0x01, 0x02, 0x01, 0x00, 0x08 };
+	UINT8 WMT_ASSERT_EVT[] = { 0x02, 0x02, 0x00, 0x00, 0x00 };
+	UINT8 WMT_NOACK_CMD[] = { 0x01, 0x02, 0x01, 0x00, 0x0A };
+	UINT8 WMT_NOACK_EVT[] = { 0x02, 0x02, 0x00, 0x00, 0x00 };
+	UINT8 WMT_WARNRST_CMD[] = { 0x01, 0x02, 0x01, 0x00, 0x0B };
+	UINT8 WMT_WARNRST_EVT[] = { 0x02, 0x02, 0x00, 0x00, 0x00 };
+	UINT8 WMT_FWLOGTST_CMD[] = { 0x01, 0x02, 0x01, 0x00, 0x0C };
+	UINT8 WMT_FWLOGTST_EVT[] = { 0x02, 0x02, 0x00, 0x00, 0x00 };
+
+	UINT8 WMT_EXCEPTION_CMD[] = { 0x01, 0x02, 0x01, 0x00, 0x09 };
+	UINT8 WMT_EXCEPTION_EVT[] = { 0x02, 0x02, 0x00, 0x00, 0x00 };
+	/*2 */
+	UINT8 WMT_COEXDBG_CMD[] = { 0x01, 0x10, 0x02, 0x00,
+		0x08,
+		0xAA		/*Debugging Parameter */
+	};
+	UINT8 WMT_COEXDBG_1_EVT[] = { 0x02, 0x10, 0x05, 0x00,
+		0x00,
+		0xAA, 0xAA, 0xAA, 0xAA	/*event content */
+	};
+	UINT8 WMT_COEXDBG_2_EVT[] = { 0x02, 0x10, 0x07, 0x00,
+		0x00,
+		0xAA, 0xAA, 0xAA, 0xAA, 0xBB, 0xBB	/*event content */
+	};
+	UINT8 WMT_COEXDBG_3_EVT[] = { 0x02, 0x10, 0x0B, 0x00,
+		0x00,
+		0xAA, 0xAA, 0xAA, 0xAA, 0xBB, 0xBB, 0xBB, 0xBB	/*event content */
+	};
+	/*test command list -end */
+
+	cmdNo = pWmtOp->au4OpData[0];
+
+	WMT_INFO_FUNC("Send Test command %d!\n", cmdNo);
+	if (cmdNo == 0) {
+		/*dead command */
+		WMT_INFO_FUNC("Send Assert command !\n");
+		tstCmdSz = osal_sizeof(WMT_ASSERT_CMD);
+		tstEvtSz = osal_sizeof(WMT_ASSERT_EVT);
+		osal_memcpy(tstCmd, WMT_ASSERT_CMD, tstCmdSz);
+		osal_memcpy(tstEvt, WMT_ASSERT_EVT, tstEvtSz);
+	} else if (cmdNo == 1) {
+		/*dead command */
+		WMT_INFO_FUNC("Send Exception command !\n");
+		tstCmdSz = osal_sizeof(WMT_EXCEPTION_CMD);
+		tstEvtSz = osal_sizeof(WMT_EXCEPTION_EVT);
+		osal_memcpy(tstCmd, WMT_EXCEPTION_CMD, tstCmdSz);
+		osal_memcpy(tstEvt, WMT_EXCEPTION_EVT, tstEvtSz);
+	} else if (cmdNo == 2) {
+		cmdNoPa = pWmtOp->au4OpData[1];
+		pRes = (PUINT8) pWmtOp->au4OpData[2];
+		resBufRoom = pWmtOp->au4OpData[3];
+		if (cmdNoPa <= 0xf) {
+			WMT_INFO_FUNC("Send Coexistence Debug command [0x%x]!\n", cmdNoPa);
+			tstCmdSz = osal_sizeof(WMT_COEXDBG_CMD);
+			osal_memcpy(tstCmd, WMT_COEXDBG_CMD, tstCmdSz);
+			if (tstCmdSz > 5)
+				tstCmd[5] = cmdNoPa;
+
+			/*setup the expected event length */
+			if (cmdNoPa <= 0x4) {
+				tstEvtSz = osal_sizeof(WMT_COEXDBG_1_EVT);
+				osal_memcpy(tstEvt, WMT_COEXDBG_1_EVT, tstEvtSz);
+			} else if (cmdNoPa == 0x5) {
+				tstEvtSz = osal_sizeof(WMT_COEXDBG_2_EVT);
+				osal_memcpy(tstEvt, WMT_COEXDBG_2_EVT, tstEvtSz);
+			} else if (cmdNoPa >= 0x6 && cmdNoPa <= 0xf) {
+				tstEvtSz = osal_sizeof(WMT_COEXDBG_3_EVT);
+				osal_memcpy(tstEvt, WMT_COEXDBG_3_EVT, tstEvtSz);
+			} else {
+
+			}
+		} else {
+			WMT_ERR_FUNC("cmdNoPa is wrong\n");
+			return iRet;
+		}
+	} else if (cmdNo == 3) {
+		/*dead command */
+		WMT_INFO_FUNC("Send No Ack command !\n");
+		tstCmdSz = osal_sizeof(WMT_NOACK_CMD);
+		tstEvtSz = osal_sizeof(WMT_NOACK_EVT);
+		osal_memcpy(tstCmd, WMT_NOACK_CMD, tstCmdSz);
+		osal_memcpy(tstEvt, WMT_NOACK_EVT, tstEvtSz);
+	} else if (cmdNo == 4) {
+		/*dead command */
+		WMT_INFO_FUNC("Send Warm reset command !\n");
+		tstCmdSz = osal_sizeof(WMT_WARNRST_CMD);
+		tstEvtSz = osal_sizeof(WMT_WARNRST_EVT);
+		osal_memcpy(tstCmd, WMT_WARNRST_CMD, tstCmdSz);
+		osal_memcpy(tstEvt, WMT_WARNRST_EVT, tstEvtSz);
+	} else if (cmdNo == 5) {
+		/*dead command */
+		WMT_INFO_FUNC("Send f/w log test command !\n");
+		tstCmdSz = osal_sizeof(WMT_FWLOGTST_CMD);
+		tstEvtSz = osal_sizeof(WMT_FWLOGTST_EVT);
+		osal_memcpy(tstCmd, WMT_FWLOGTST_CMD, tstCmdSz);
+		osal_memcpy(tstEvt, WMT_FWLOGTST_EVT, tstEvtSz);
+	}
+
+	else {
+		/*Placed youer test WMT command here, easiler to integrate and test with F/W side */
+	}
+
+	/* send command */
+	/* iRet = (*kal_stp_tx)(tstCmd, tstCmdSz, &u4Res); */
+	iRet = wmt_core_tx((PUINT8) tstCmd, tstCmdSz, &u4Res, MTK_WCN_BOOL_FALSE);
+	if (iRet || (u4Res != tstCmdSz)) {
+		WMT_ERR_FUNC("WMT-CORE: wmt_cmd_test iRet(%d) cmd len err(%d, %d)\n", iRet, u4Res, tstCmdSz);
+		return -1;
+	}
+
+	if ((cmdNo == 0) || (cmdNo == 1) || cmdNo == 3) {
+		WMT_INFO_FUNC("WMT-CORE: not to rx event for assert command\n");
+		return 0;
+	}
+
+	iRet = wmt_core_rx(tstEvtTmp, tstEvtSz, &u4Res);
+
+	/*Event Post Handling */
+	if (cmdNo == 2) {
+		WMT_INFO_FUNC("#=========================================================#\n");
+		WMT_INFO_FUNC("coext debugging id = %d", cmdNoPa);
+		if (tstEvtSz > 5) {
+			wmt_core_dump_data(&tstEvtTmp[5], "coex debugging ", tstEvtSz - 5);
+		} else {
+			/* error log */
+			WMT_ERR_FUNC("error coex debugging event\n");
+		}
+		/*put response to buffer for shell to read */
+		if (pRes != NULL && resBufRoom > 0) {
+			pWmtOp->au4OpData[3] = resBufRoom < tstEvtSz - 5 ? resBufRoom : tstEvtSz - 5;
+			osal_memcpy(pRes, &tstEvtTmp[5], pWmtOp->au4OpData[3]);
+		} else
+			pWmtOp->au4OpData[3] = 0;
+		WMT_INFO_FUNC("#=========================================================#\n");
+	}
+
+	return iRet;
+
+}
+
+static INT32 opfunc_hw_rst(P_WMT_OP pWmtOp)
+{
+
+	INT32 iRet = -1;
+	unsigned long ctrlPa1;
+	unsigned long ctrlPa2;
+
+	wmt_core_dump_func_state("BE HW RST");
+    /*-->Reset WMT  data structure*/
+	/* gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_BT]   = DRV_STS_POWER_OFF; */
+	gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_FM] = DRV_STS_POWER_OFF;
+	gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_GPS] = DRV_STS_POWER_OFF;
+	/* gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WIFI] = DRV_STS_POWER_OFF; */
+	gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_LPBK] = DRV_STS_POWER_OFF;
+	gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_STP] = DRV_STS_POWER_OFF;
+	gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_COREDUMP] = DRV_STS_POWER_OFF;
+	/*enable power off flag, if flag=0, power off connsys will not be executed */
+	mtk_wcn_set_connsys_power_off_flag(MTK_WCN_BOOL_TRUE);
+	/* if wmt is poweroff, we need poweron chip first */
+	/* Zhiguo : this action also needed in BTIF interface to avoid KE */
+#if 1
+	if (DRV_STS_POWER_OFF == gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT]) {
+		WMT_WARN_FUNC("WMT-CORE: WMT is off, need re-poweron\n");
+		/* power on control */
+		ctrlPa1 = 0;
+		ctrlPa2 = 0;
+		iRet = wmt_core_ctrl(WMT_CTRL_HW_PWR_ON, &ctrlPa1, &ctrlPa2);
+		if (iRet) {
+			WMT_ERR_FUNC("WMT-CORE: WMT_CTRL_HW_PWR_ON fail iRet(%d)\n", iRet);
+			return -1;
+		}
+		gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT] = DRV_STS_POWER_ON;
+	}
+#endif
+	if (gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_BT] == DRV_STS_FUNC_ON) {
+
+		ctrlPa1 = BT_PALDO;
+		ctrlPa2 = PALDO_OFF;
+		iRet = wmt_core_ctrl(WMT_CTRL_SOC_PALDO_CTRL, &ctrlPa1, &ctrlPa2);
+		if (iRet)
+			WMT_ERR_FUNC("WMT-CORE: wmt_ctrl_soc_paldo_ctrl failed(%d)(%d)(%d)\n", iRet, ctrlPa1, ctrlPa2);
+
+		gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_BT] = DRV_STS_POWER_OFF;
+	}
+
+	if (gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WIFI] == DRV_STS_FUNC_ON) {
+
+		if (NULL != gpWmtFuncOps[WMTDRV_TYPE_WIFI] && NULL != gpWmtFuncOps[WMTDRV_TYPE_WIFI]->func_off) {
+			iRet = gpWmtFuncOps[WMTDRV_TYPE_WIFI]->func_off(gMtkWmtCtx.p_ic_ops, wmt_conf_get_cfg());
+			if (iRet) {
+				WMT_ERR_FUNC("WMT-CORE: turn off WIFI func fail (%d)\n", iRet);
+
+				/* check all sub-func and do power off */
+			} else {
+				WMT_INFO_FUNC("wmt core: turn off  WIFI func ok!!\n");
+			}
+		}
+		gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WIFI] = DRV_STS_POWER_OFF;
+	}
+#if 0
+	/*<4>Power off Combo chip */
+	ctrlPa1 = 0;
+	ctrlPa2 = 0;
+	iRet = wmt_core_ctrl(WMT_CTRL_HW_RST, &ctrlPa1, &ctrlPa2);
+	if (iRet)
+		WMT_ERR_FUNC("WMT-CORE: [HW RST] WMT_CTRL_POWER_OFF fail (%d)", iRet);
+	WMT_INFO_FUNC("WMT-CORE: [HW RST] WMT_CTRL_POWER_OFF ok (%d)", iRet);
+#endif
+	gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT] = DRV_STS_POWER_OFF;
+
+    /*-->PesetCombo chip*/
+	iRet = wmt_core_ctrl(WMT_CTRL_HW_RST, &ctrlPa1, &ctrlPa2);
+	if (iRet)
+		WMT_ERR_FUNC("WMT-CORE: -->[HW RST] fail iRet(%d)\n", iRet);
+	WMT_WARN_FUNC("WMT-CORE: -->[HW RST] ok\n");
+
+	gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT] = DRV_STS_POWER_ON;
+
+	/* 4  close stp */
+	ctrlPa1 = 0;
+	ctrlPa2 = 0;
+	iRet = wmt_core_ctrl(WMT_CTRL_STP_CLOSE, &ctrlPa1, &ctrlPa2);
+	if (iRet) {
+		if (iRet == -2) {
+			WMT_INFO_FUNC("WMT-CORE:stp should have be closed\n");
+			return 0;
+		}
+		WMT_ERR_FUNC("WMT-CORE: wmt close stp failed\n");
+		return -1;
+	}
+
+	wmt_core_dump_func_state("AF HW RST");
+	return iRet;
+
+}
+
+static INT32 opfunc_sw_rst(P_WMT_OP pWmtOp)
+{
+	INT32 iRet = 0;
+
+	iRet = wmt_core_stp_init();
+	if (!iRet)
+		gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT] = DRV_STS_FUNC_ON;
+	return iRet;
+}
+
+static INT32 opfunc_stp_rst(P_WMT_OP pWmtOp)
+{
+
+	return 0;
+}
+
+static INT32 opfunc_therm_ctrl(P_WMT_OP pWmtOp)
+{
+
+	INT32 iRet = -1;
+	UINT32 u4Res;
+	UINT32 evtLen;
+	UINT8 evtBuf[16] = { 0 };
+
+	WMT_THERM_CMD[4] = pWmtOp->au4OpData[0];	/*CMD type, refer to ENUM_WMTTHERM_TYPE_T */
+
+	/* send command */
+	/* iRet = (*kal_stp_tx)(WMT_THERM_CMD, osal_sizeof(WMT_THERM_CMD), &u4Res); */
+	iRet = wmt_core_tx((PUINT8) WMT_THERM_CMD, osal_sizeof(WMT_THERM_CMD), &u4Res, MTK_WCN_BOOL_FALSE);
+	if (iRet || (u4Res != osal_sizeof(WMT_THERM_CMD))) {
+		WMT_ERR_FUNC("WMT-CORE: THERM_CTRL_CMD iRet(%d) cmd len err(%d, %d)\n", iRet, u4Res,
+			     osal_sizeof(WMT_THERM_CMD));
+		return iRet;
+	}
+
+	evtLen = 16;
+
+	iRet = wmt_core_rx(evtBuf, evtLen, &u4Res);
+	if (iRet || ((u4Res != osal_sizeof(WMT_THERM_CTRL_EVT)) && (u4Res != osal_sizeof(WMT_THERM_READ_EVT)))) {
+		WMT_ERR_FUNC("WMT-CORE: read THERM_CTRL_EVT/THERM_READ_EVENT fail(%d) len(%d, %d)\n", iRet, u4Res,
+			     evtLen);
+		mtk_wcn_stp_dbg_dump_package();
+		return iRet;
+	}
+	if (u4Res == osal_sizeof(WMT_THERM_CTRL_EVT)) {
+		if (osal_memcmp(evtBuf, WMT_THERM_CTRL_EVT, osal_sizeof(WMT_THERM_CTRL_EVT)) != 0) {
+			WMT_ERR_FUNC("WMT-CORE: compare WMT_THERM_CTRL_EVT error\n");
+			WMT_ERR_FUNC("WMT-CORE: rx(%d):[%02X,%02X,%02X,%02X,%02X] exp(%d):[%02X,%02X,%02X,%02X,%02X]\n",
+				     u4Res, evtBuf[0], evtBuf[1], evtBuf[2], evtBuf[3], evtBuf[4],
+				     osal_sizeof(WMT_THERM_CTRL_EVT), WMT_THERM_CTRL_EVT[0], WMT_THERM_CTRL_EVT[1],
+				     WMT_THERM_CTRL_EVT[2], WMT_THERM_CTRL_EVT[3], WMT_THERM_CTRL_EVT[4]);
+			pWmtOp->au4OpData[1] = MTK_WCN_BOOL_FALSE;	/*will return to function driver */
+			mtk_wcn_stp_dbg_dump_package();
+		} else {
+			WMT_DBG_FUNC("Send WMT_THERM_CTRL_CMD command OK!\n");
+			pWmtOp->au4OpData[1] = MTK_WCN_BOOL_TRUE;	/*will return to function driver */
+		}
+	} else {
+		/*no need to judge the real thermal value */
+		if (osal_memcmp(evtBuf, WMT_THERM_READ_EVT, osal_sizeof(WMT_THERM_READ_EVT) - 1) != 0) {
+			WMT_ERR_FUNC("WMT-CORE: compare WMT_THERM_READ_EVT error\n");
+			WMT_ERR_FUNC("WMT-CORE: rx(%d):[%02X,%02X,%02X,%02X,%02X,%02X] exp(%d):[%02X,%02X,%02X,%02X]\n",
+				     u4Res, evtBuf[0], evtBuf[1], evtBuf[2], evtBuf[3], evtBuf[4], evtBuf[5],
+				     osal_sizeof(WMT_THERM_READ_EVT), WMT_THERM_READ_EVT[0], WMT_THERM_READ_EVT[1],
+				     WMT_THERM_READ_EVT[2], WMT_THERM_READ_EVT[3]);
+			pWmtOp->au4OpData[1] = 0xFF;	/*will return to function driver */
+			mtk_wcn_stp_dbg_dump_package();
+		} else {
+			WMT_DBG_FUNC("Send WMT_THERM_READ_CMD command OK!\n");
+			pWmtOp->au4OpData[1] = evtBuf[5];	/*will return to function driver */
+		}
+	}
+
+	return iRet;
+
+}
+
+static INT32 opfunc_efuse_rw(P_WMT_OP pWmtOp)
+{
+
+	INT32 iRet = -1;
+	UINT32 u4Res;
+	UINT32 evtLen;
+	UINT8 evtBuf[16] = { 0 };
+
+	if (DRV_STS_FUNC_ON != gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT]) {
+		WMT_ERR_FUNC("WMT-CORE: wmt_efuse_rw fail: chip is powered off\n");
+		return -1;
+	}
+
+	WMT_EFUSE_CMD[4] = (pWmtOp->au4OpData[0]) ? 0x1 : 0x2;	/* w:2, r:1 */
+	osal_memcpy(&WMT_EFUSE_CMD[6], (PUINT8) &pWmtOp->au4OpData[1], 2);	/* address */
+	osal_memcpy(&WMT_EFUSE_CMD[8], (PUINT32) pWmtOp->au4OpData[2], 4);	/* value */
+
+	wmt_core_dump_data(&WMT_EFUSE_CMD[0], "efuse_cmd", osal_sizeof(WMT_EFUSE_CMD));
+
+	/* send command */
+	/* iRet = (*kal_stp_tx)(WMT_EFUSE_CMD, osal_sizeof(WMT_EFUSE_CMD), &u4Res); */
+	iRet = wmt_core_tx((PUINT8) WMT_EFUSE_CMD, osal_sizeof(WMT_EFUSE_CMD), &u4Res, MTK_WCN_BOOL_FALSE);
+	if (iRet || (u4Res != osal_sizeof(WMT_EFUSE_CMD))) {
+		WMT_ERR_FUNC("WMT-CORE: EFUSE_CMD iRet(%d) cmd len err(%d, %d)\n", iRet, u4Res,
+			     osal_sizeof(WMT_EFUSE_CMD));
+		return iRet;
+	}
+
+	evtLen = (pWmtOp->au4OpData[0]) ? osal_sizeof(WMT_EFUSE_EVT) : osal_sizeof(WMT_EFUSE_EVT);
+
+	iRet = wmt_core_rx(evtBuf, evtLen, &u4Res);
+	if (iRet || (u4Res != evtLen))
+		WMT_ERR_FUNC("WMT-CORE: read REG_EVB fail(%d) len(%d, %d)\n", iRet, u4Res, evtLen);
+	wmt_core_dump_data(&evtBuf[0], "efuse_evt", osal_sizeof(evtBuf));
+
+	return iRet;
+
+}
+
+static INT32 opfunc_gpio_ctrl(P_WMT_OP pWmtOp)
+{
+	INT32 iRet = -1;
+	WMT_IC_PIN_ID id;
+	WMT_IC_PIN_STATE stat;
+	UINT32 flag;
+
+	if (DRV_STS_FUNC_ON != gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_WMT]) {
+		WMT_ERR_FUNC("WMT-CORE: wmt_gpio_ctrl fail: chip is powered off\n");
+		return -1;
+	}
+
+	if (!gMtkWmtCtx.p_ic_ops->ic_pin_ctrl) {
+		WMT_ERR_FUNC("WMT-CORE: error, gMtkWmtCtx.p_ic_ops->ic_pin_ctrl(NULL)\n");
+		return -1;
+	}
+
+	id = pWmtOp->au4OpData[0];
+	stat = pWmtOp->au4OpData[1];
+	flag = pWmtOp->au4OpData[2];
+
+	WMT_INFO_FUNC("ic pin id:%d, stat:%d, flag:0x%x\n", id, stat, flag);
+
+	iRet = (*(gMtkWmtCtx.p_ic_ops->ic_pin_ctrl)) (id, stat, flag);
+
+	return iRet;
+}
+
+MTK_WCN_BOOL wmt_core_is_quick_ps_support(void)
+{
+	P_WMT_CTX pctx = &gMtkWmtCtx;
+
+	if ((NULL != pctx->p_ic_ops) && (NULL != pctx->p_ic_ops->is_quick_sleep))
+		return (*(pctx->p_ic_ops->is_quick_sleep)) ();
+
+	return MTK_WCN_BOOL_FALSE;
+}
+
+MTK_WCN_BOOL wmt_core_get_aee_dump_flag(void)
+{
+	MTK_WCN_BOOL bRet = MTK_WCN_BOOL_FALSE;
+	P_WMT_CTX pctx = &gMtkWmtCtx;
+
+	if ((NULL != pctx->p_ic_ops) && (NULL != pctx->p_ic_ops->is_aee_dump_support))
+		bRet = (*(pctx->p_ic_ops->is_aee_dump_support)) ();
+	else
+		bRet = MTK_WCN_BOOL_FALSE;
+
+	return bRet;
+}
+
+INT32 opfunc_pin_state(P_WMT_OP pWmtOp)
+{
+
+	unsigned long ctrlPa1 = 0;
+	unsigned long ctrlPa2 = 0;
+	UINT32 iRet = 0;
+
+	iRet = wmt_core_ctrl(WMT_CTRL_HW_STATE_DUMP, &ctrlPa1, &ctrlPa2);
+	return iRet;
+}
+
+static INT32 opfunc_bgw_ds(P_WMT_OP pWmtOp)
+{
+	INT32 iRet = -1;
+	UINT32 u4WrittenSize = 0;
+	UINT32 u4ReadSize = 0;
+	UINT32 buf_len = 0;
+	UINT8 *buffer = NULL;
+	UINT8 evt_buffer[8] = { 0 };
+	MTK_WCN_BOOL fgFail;
+
+	UINT8 WMT_BGW_DESENSE_CMD[] = {
+		0x01, 0x0e, 0x0f, 0x00,
+		0x02, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00
+	};
+	UINT8 WMT_BGW_DESENSE_EVT[] = { 0x02, 0x0e, 0x01, 0x00, 0x00 };
+
+	buf_len = pWmtOp->au4OpData[0];
+	buffer = (PUINT8) pWmtOp->au4OpData[1];
+
+	osal_memcpy(&WMT_BGW_DESENSE_CMD[5], buffer, buf_len);
+
+	do {
+		fgFail = MTK_WCN_BOOL_TRUE;
+
+		iRet =
+		    wmt_core_tx(&WMT_BGW_DESENSE_CMD[0], osal_sizeof(WMT_BGW_DESENSE_CMD), &u4WrittenSize,
+				MTK_WCN_BOOL_FALSE);
+		if (iRet || (u4WrittenSize != osal_sizeof(WMT_BGW_DESENSE_CMD))) {
+			WMT_ERR_FUNC("bgw desense tx CMD fail(%d),size(%d)\n", iRet, u4WrittenSize);
+			break;
+		}
+
+		iRet = wmt_core_rx(evt_buffer, osal_sizeof(WMT_BGW_DESENSE_EVT), &u4ReadSize);
+		if (iRet || (u4ReadSize != osal_sizeof(WMT_BGW_DESENSE_EVT))) {
+			WMT_ERR_FUNC("bgw desense rx EVT fail(%d),size(%d)\n", iRet, u4ReadSize);
+			break;
+		}
+
+		if (osal_memcmp(evt_buffer, WMT_BGW_DESENSE_EVT, osal_sizeof(WMT_BGW_DESENSE_EVT)) != 0) {
+			WMT_ERR_FUNC
+			    ("bgw desense WMT_BGW_DESENSE_EVT compare fail:0x%02x,0x%02x,0x%02x,0x%02x,0x%02x\n",
+			     evt_buffer[0], evt_buffer[1], evt_buffer[2], evt_buffer[3], evt_buffer[4]);
+			break;
+		}
+
+		fgFail = MTK_WCN_BOOL_FALSE;
+
+	} while (0);
+
+	return fgFail;
+}
+
+static INT32 opfunc_set_mcu_clk(P_WMT_OP pWmtOp)
+{
+	UINT32 kind = 0;
+	INT32 iRet = -1;
+	UINT32 u4WrittenSize = 0;
+	UINT32 u4ReadSize = 0;
+	UINT8 evt_buffer[12] = { 0 };
+	MTK_WCN_BOOL fgFail;
+	PUINT8 set_mcu_clk_str[] = {
+		"Enable MCU PLL",
+		"SET MCU CLK to 26M",
+		"SET MCU CLK to 37M",
+		"SET MCU CLK to 64M",
+		"SET MCU CLK to 69M",
+		"SET MCU CLK to 104M",
+		"SET MCU CLK to 118.857M",
+		"SET MCU CLK to 138.67M",
+		"Disable MCU PLL"
+	};
+	UINT8 WMT_SET_MCU_CLK_CMD[] = {
+		0x01, 0x08, 0x10, 0x00,
+		0x01, 0x01, 0x00, 0x01,
+		0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00,
+		0xff, 0xff, 0xff, 0xff
+	};
+	UINT8 WMT_SET_MCU_CLK_EVT[] = { 0x02, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01 };
+
+	UINT8 WMT_EN_MCU_CLK_CMD[] = { 0x34, 0x03, 0x00, 0x80, 0x00, 0x00, 0x01, 0x00 };	/* enable pll clk */
+	UINT8 WMT_26_MCU_CLK_CMD[] = { 0x0c, 0x01, 0x00, 0x80, 0x00, 0x4d, 0x84, 0x00 };	/* set 26M */
+	UINT8 WMT_37_MCU_CLK_CMD[] = { 0x0c, 0x01, 0x00, 0x80, 0x1e, 0x4d, 0x84, 0x00 };	/* set 37.8M */
+	UINT8 WMT_64_MCU_CLK_CMD[] = { 0x0c, 0x01, 0x00, 0x80, 0x1d, 0x4d, 0x84, 0x00 };	/* set 64M */
+	UINT8 WMT_69_MCU_CLK_CMD[] = { 0x0c, 0x01, 0x00, 0x80, 0x1c, 0x4d, 0x84, 0x00 };	/* set 69M */
+	UINT8 WMT_104_MCU_CLK_CMD[] = { 0x0c, 0x01, 0x00, 0x80, 0x5b, 0x4d, 0x84, 0x00 };	/* set 104M */
+	UINT8 WMT_108_MCU_CLK_CMD[] = { 0x0c, 0x01, 0x00, 0x80, 0x5a, 0x4d, 0x84, 0x00 };	/* set 118.857M */
+	UINT8 WMT_138_MCU_CLK_CMD[] = { 0x0c, 0x01, 0x00, 0x80, 0x59, 0x4d, 0x84, 0x00 };	/* set 138.67M */
+	UINT8 WMT_DIS_MCU_CLK_CMD[] = { 0x34, 0x03, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00 };	/* disable pll clk */
+
+	kind = pWmtOp->au4OpData[0];
+	WMT_INFO_FUNC("do %s\n", set_mcu_clk_str[kind]);
+
+	switch (kind) {
+	case 0:
+		osal_memcpy(&WMT_SET_MCU_CLK_CMD[8], &WMT_EN_MCU_CLK_CMD[0], osal_sizeof(WMT_EN_MCU_CLK_CMD));
+		break;
+	case 1:
+		osal_memcpy(&WMT_SET_MCU_CLK_CMD[8], &WMT_26_MCU_CLK_CMD[0], osal_sizeof(WMT_26_MCU_CLK_CMD));
+		break;
+	case 2:
+		osal_memcpy(&WMT_SET_MCU_CLK_CMD[8], &WMT_37_MCU_CLK_CMD[0], osal_sizeof(WMT_37_MCU_CLK_CMD));
+		break;
+	case 3:
+		osal_memcpy(&WMT_SET_MCU_CLK_CMD[8], &WMT_64_MCU_CLK_CMD[0], osal_sizeof(WMT_64_MCU_CLK_CMD));
+		break;
+	case 4:
+		osal_memcpy(&WMT_SET_MCU_CLK_CMD[8], &WMT_69_MCU_CLK_CMD[0], osal_sizeof(WMT_69_MCU_CLK_CMD));
+		break;
+	case 5:
+		osal_memcpy(&WMT_SET_MCU_CLK_CMD[8], &WMT_104_MCU_CLK_CMD[0], osal_sizeof(WMT_104_MCU_CLK_CMD));
+		break;
+	case 6:
+		osal_memcpy(&WMT_SET_MCU_CLK_CMD[8], &WMT_108_MCU_CLK_CMD[0], osal_sizeof(WMT_108_MCU_CLK_CMD));
+		break;
+	case 7:
+		osal_memcpy(&WMT_SET_MCU_CLK_CMD[8], &WMT_138_MCU_CLK_CMD[0], osal_sizeof(WMT_138_MCU_CLK_CMD));
+		break;
+	case 8:
+		osal_memcpy(&WMT_SET_MCU_CLK_CMD[8], &WMT_DIS_MCU_CLK_CMD[0], osal_sizeof(WMT_DIS_MCU_CLK_CMD));
+		break;
+	default:
+		WMT_ERR_FUNC("unknown kind\n");
+		break;
+	}
+
+	do {
+		fgFail = MTK_WCN_BOOL_TRUE;
+
+		iRet =
+		    wmt_core_tx(&WMT_SET_MCU_CLK_CMD[0], osal_sizeof(WMT_SET_MCU_CLK_CMD), &u4WrittenSize,
+				MTK_WCN_BOOL_FALSE);
+		if (iRet || (u4WrittenSize != osal_sizeof(WMT_SET_MCU_CLK_CMD))) {
+			WMT_ERR_FUNC("WMT_SET_MCU_CLK_CMD fail(%d),size(%d)\n", iRet, u4WrittenSize);
+			break;
+		}
+
+		iRet = wmt_core_rx(evt_buffer, osal_sizeof(WMT_SET_MCU_CLK_EVT), &u4ReadSize);
+		if (iRet || (u4ReadSize != osal_sizeof(WMT_SET_MCU_CLK_EVT))) {
+			WMT_ERR_FUNC("WMT_SET_MCU_CLK_EVT fail(%d),size(%d)\n", iRet, u4ReadSize);
+			break;
+		}
+
+		if (osal_memcmp(evt_buffer, WMT_SET_MCU_CLK_EVT, osal_sizeof(WMT_SET_MCU_CLK_EVT)) != 0) {
+			WMT_ERR_FUNC("WMT_SET_MCU_CLK_EVT compare fail:0x%02x,0x%02x,0x%02x,0x%02x,0x%02x\n",
+				     evt_buffer[0], evt_buffer[1], evt_buffer[2], evt_buffer[3], evt_buffer[4],
+				     evt_buffer[5], evt_buffer[6], evt_buffer[7]);
+			break;
+		}
+
+		fgFail = MTK_WCN_BOOL_FALSE;
+
+	} while (0);
+
+	if (MTK_WCN_BOOL_FALSE == fgFail)
+		WMT_INFO_FUNC("wmt-core:%s: ok!\n", set_mcu_clk_str[kind]);
+
+	WMT_INFO_FUNC("wmt-core:%s: fail!\n", set_mcu_clk_str[kind]);
+
+	return fgFail;
+}
+
+static INT32 opfunc_adie_lpbk_test(P_WMT_OP pWmtOp)
+{
+	UINT8 *buffer = NULL;
+	MTK_WCN_BOOL fgFail;
+	UINT32 u4Res;
+	UINT32 aDieChipid = 0;
+	UINT8 soc_adie_chipid_cmd[] = { 0x01, 0x13, 0x04, 0x00, 0x02, 0x04, 0x24, 0x00 };
+	UINT8 soc_adie_chipid_evt[] = { 0x02, 0x13, 0x09, 0x00, 0x00, 0x02, 0x04, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00 };
+	UINT8 evtbuf[20];
+	INT32 iRet = -1;
+
+	buffer = (PUINT8) pWmtOp->au4OpData[1];
+
+	do {
+		fgFail = MTK_WCN_BOOL_TRUE;
+
+		/* read A die chipid by wmt cmd */
+		iRet =
+		    wmt_core_tx((PUINT8) &soc_adie_chipid_cmd[0], osal_sizeof(soc_adie_chipid_cmd), &u4Res,
+				MTK_WCN_BOOL_FALSE);
+		if (iRet || (u4Res != osal_sizeof(soc_adie_chipid_cmd))) {
+			WMT_ERR_FUNC("wmt_core:read A die chipid CMD fail(%d),size(%d)\n", iRet, u4Res);
+			break;
+		}
+		osal_memset(evtbuf, 0, osal_sizeof(evtbuf));
+		iRet = wmt_core_rx(evtbuf, osal_sizeof(soc_adie_chipid_evt), &u4Res);
+		if (iRet || (u4Res != osal_sizeof(soc_adie_chipid_evt))) {
+			WMT_ERR_FUNC("wmt_core:read A die chipid EVT fail(%d),size(%d)\n", iRet, u4Res);
+			break;
+		}
+		osal_memcpy(&aDieChipid, &evtbuf[u4Res - 2], 2);
+		osal_memcpy(buffer, &evtbuf[u4Res - 2], 2);
+		pWmtOp->au4OpData[0] = 2;
+		WMT_INFO_FUNC("get SOC A die chipid(0x%x)\n", aDieChipid);
+
+		fgFail = MTK_WCN_BOOL_FALSE;
+
+	} while (0);
+
+	return fgFail;
+}
+
+#if CFG_WMT_LTE_COEX_HANDLING
+static INT32 opfunc_idc_msg_handling(P_WMT_OP pWmtOp)
+{
+	MTK_WCN_BOOL fgFail;
+	UINT32 u4Res;
+	UINT8 host_lte_btwf_coex_cmd[] = { 0x01, 0x10, 0x00, 0x00, 0x00 };
+	UINT8 host_lte_btwf_coex_evt[] = { 0x02, 0x10, 0x01, 0x00, 0x00 };
+	UINT8 *pTxBuf = NULL;
+	UINT8 evtbuf[8] = { 0 };
+	INT32 iRet = -1;
+	UINT16 msg_len = 0;
+	UINT32 total_len = 0;
+	UINT32 index = 0;
+	UINT8 *msg_local_buffer = NULL;
+
+	msg_local_buffer = kmalloc(1300, GFP_KERNEL);
+	if (!msg_local_buffer) {
+			WMT_ERR_FUNC("msg_local_buffer kmalloc memory fail\n");
+			return 0;
+	}
+
+	pTxBuf = (UINT8 *) pWmtOp->au4OpData[0];
+	if (NULL == pTxBuf) {
+		WMT_ERR_FUNC("idc msg buffer is NULL\n");
+		return -1;
+	}
+	iRet = wmt_lib_idc_lock_aquire();
+	if (iRet) {
+		WMT_ERR_FUNC("--->lock idc_lock failed, ret=%d\n", iRet);
+		return iRet;
+	}
+	osal_memcpy(&msg_len, &pTxBuf[0], osal_sizeof(msg_len));
+	if (msg_len > 1200) {
+		wmt_lib_idc_lock_release();
+		WMT_ERR_FUNC("abnormal idc msg len:%d\n", msg_len);
+		return -2;
+	}
+	msg_len += 1;	/*flag byte */
+
+	osal_memcpy(&host_lte_btwf_coex_cmd[2], &msg_len, 2);
+	host_lte_btwf_coex_cmd[4] = (pWmtOp->au4OpData[1] & 0x00ff);
+	osal_memcpy(&msg_local_buffer[0], &host_lte_btwf_coex_cmd[0], osal_sizeof(host_lte_btwf_coex_cmd));
+	osal_memcpy(&msg_local_buffer[osal_sizeof(host_lte_btwf_coex_cmd)],
+		&pTxBuf[osal_sizeof(msg_len)], msg_len - 1);
+
+	wmt_lib_idc_lock_release();
+	total_len = osal_sizeof(host_lte_btwf_coex_cmd) + msg_len - 1;
+
+	WMT_DBG_FUNC("wmt_core:idc msg payload len form lte(%d),wmt msg total len(%d)\n", msg_len - 1,
+		     total_len);
+	WMT_DBG_FUNC("wmt_core:idc msg payload:\n");
+
+	for (index = 0; index < total_len; index++)
+		WMT_DBG_FUNC("0x%02x ", msg_local_buffer[index]);
+
+
+	do {
+		fgFail = MTK_WCN_BOOL_TRUE;
+
+		/* read A die chipid by wmt cmd */
+		iRet = wmt_core_tx((PUINT8) &msg_local_buffer[0], total_len, &u4Res, MTK_WCN_BOOL_FALSE);
+		if (iRet || (u4Res != total_len)) {
+			WMT_ERR_FUNC("wmt_core:send lte idc msg to connsys fail(%d),size(%d)\n", iRet, u4Res);
+			break;
+		}
+		osal_memset(evtbuf, 0, osal_sizeof(evtbuf));
+		iRet = wmt_core_rx(evtbuf, osal_sizeof(host_lte_btwf_coex_evt), &u4Res);
+		if (iRet || (u4Res != osal_sizeof(host_lte_btwf_coex_evt))) {
+			WMT_ERR_FUNC("wmt_core:recv host_lte_btwf_coex_evt fail(%d),size(%d)\n", iRet, u4Res);
+			break;
+		}
+
+		fgFail = MTK_WCN_BOOL_FALSE;
+
+	} while (0);
+	kfree(msg_local_buffer);
+	return fgFail;
+}
+#endif
+
+VOID wmt_core_set_coredump_state(ENUM_DRV_STS state)
+{
+	WMT_INFO_FUNC("wmt-core: set coredump state(%d)\n", state);
+	gMtkWmtCtx.eDrvStatus[WMTDRV_TYPE_COREDUMP] = state;
+}
+#ifdef CONFIG_MTK_COMBO_ANT
+INT32 opfunc_ant_ram_down(P_WMT_OP pWmtOp)
+{
+	INT32 iRet = 0;
+	size_t ctrlPa1 = pWmtOp->au4OpData[0];
+	UINT32 ctrlPa2 = pWmtOp->au4OpData[1];
+	PUINT8 pbuf = (PUINT8) ctrlPa1;
+	UINT32 fragSeq = 0;
+	UINT16 fragSize = 0;
+	UINT16 wmtCmdLen;
+	UINT16 wmtPktLen;
+	UINT32 u4Res = 0;
+	UINT8 antEvtBuf[osal_sizeof(WMT_ANT_RAM_DWN_EVT)];
+#if 1
+	UINT32 ctrlPa3 = pWmtOp->au4OpData[2];
+
+	do {
+		fragSize = ctrlPa2;
+		fragSeq = ctrlPa3;
+		gAntBuf[5] = fragSeq;
+
+
+		wmtPktLen = fragSize + sizeof(WMT_ANT_RAM_DWN_CMD) + 1;
+
+		/*WMT command length cal */
+		wmtCmdLen = wmtPktLen - 4;
+#if 0
+		WMT_ANT_RAM_DWN_CMD[2] = wmtCmdLen & 0xFF;
+		WMT_ANT_RAM_DWN_CMD[3] = (wmtCmdLen & 0xFF00) >> 16;
+#else
+		osal_memcpy(&WMT_ANT_RAM_DWN_CMD[2], &wmtCmdLen, 2);
+#endif
+
+
+
+		WMT_ANT_RAM_DWN_CMD[4] = 1;	/*RAM CODE download */
+
+		osal_memcpy(gAntBuf, WMT_ANT_RAM_DWN_CMD, sizeof(WMT_ANT_RAM_DWN_CMD));
+
+		/*copy ram code content to global buffer */
+		osal_memcpy(&gAntBuf[osal_sizeof(WMT_ANT_RAM_DWN_CMD) + 1], pbuf, fragSize);
+
+		iRet = wmt_core_tx(gAntBuf, wmtPktLen, &u4Res, MTK_WCN_BOOL_FALSE);
+		if (iRet || (u4Res != wmtPktLen)) {
+			WMT_ERR_FUNC("wmt_core: write fragSeq(%d) size(%d, %d) fail(%d)\n", fragSeq,
+				     wmtPktLen, u4Res, iRet);
+			iRet = -4;
+			break;
+		}
+		WMT_DBG_FUNC("wmt_core: write fragSeq(%d) size(%d, %d) ok\n",
+			     fragSeq, wmtPktLen, u4Res);
+
+		osal_memset(antEvtBuf, 0, sizeof(antEvtBuf));
+
+		WMT_ANT_RAM_DWN_EVT[4] = 0;	/*download result; 0 */
+
+		iRet = wmt_core_rx(antEvtBuf, sizeof(WMT_ANT_RAM_DWN_EVT), &u4Res);
+		if (iRet || (u4Res != sizeof(WMT_ANT_RAM_DWN_EVT))) {
+			WMT_ERR_FUNC("wmt_core: read WMT_ANT_RAM_DWN_EVT length(%zu, %d) fail(%d)\n",
+				     sizeof(WMT_ANT_RAM_DWN_EVT), u4Res, iRet);
+			iRet = -5;
+			break;
+		}
+#if CFG_CHECK_WMT_RESULT
+		if (osal_memcmp(antEvtBuf, WMT_ANT_RAM_DWN_EVT, sizeof(WMT_ANT_RAM_DWN_EVT)) != 0) {
+			WMT_ERR_FUNC("wmt_core: compare WMT_ANT_RAM_DWN_EVT result error\n");
+			WMT_ERR_FUNC("rx(%d):[%02X,%02X,%02X,%02X,%02X] exp(%zu):[%02X,%02X,%02X,%02X,%02X]\n",
+					u4Res, antEvtBuf[0], antEvtBuf[1], antEvtBuf[2], antEvtBuf[3],
+					antEvtBuf[4], sizeof(WMT_ANT_RAM_DWN_EVT), WMT_ANT_RAM_DWN_EVT[0],
+					WMT_ANT_RAM_DWN_EVT[1], WMT_ANT_RAM_DWN_EVT[2], WMT_ANT_RAM_DWN_EVT[3],
+					WMT_ANT_RAM_DWN_EVT[4]);
+			iRet = -6;
+			break;
+		}
+#endif
+		WMT_DBG_FUNC("wmt_core: read WMT_ANT_RAM_DWN_EVT length(%zu, %d) ok\n",
+			     sizeof(WMT_ANT_RAM_DWN_EVT), u4Res);
+
+	} while (0);
+#else
+	UINT32 patchSize = ctrlPa2;
+	UINT32 patchSizePerFrag = 1000;
+	UINT32 offset;
+	UINT32 fragNum = 0;
+	/*cal patch fragNum */
+	fragNum = (patchSize + patchSizePerFrag - 1) / patchSizePerFrag;
+	if (2 >= fragNum) {
+		WMT_WARN_FUNC("ANT ramcode size(%d) too short\n", patchSize);
+		return -1;
+	}
+
+	while (fragSeq < fragNum) {
+		/*update fragNum */
+		fragSeq++;
+
+		if (1 == fragSeq) {
+			fragSize = patchSizePerFrag;
+			/*first package */
+			gAntBuf[5] = 1;	/*RAM CODE start */
+		} else if (fragNum == fragSeq) {
+			/*last package */
+			fragSize = patchSizePerFrag;
+			gAntBuf[5] = 3;	/*RAM CODE end */
+		} else {
+			/*middle package */
+			fragSize = patchSize - ((fragNum - 1) * patchSizePerFrag);
+			gAntBuf[5] = 2;	/*RAM CODE confinue */
+		}
+		wmtPktLen = fragSize + sizeof(WMT_ANT_RAM_OP_CMD) + 1;
+
+		/*WMT command length cal */
+		wmtCmdLen = wmtPktLen - 4;
+
+		WMT_ANT_RAM_OP_CMD[2] = wmtCmdLen & 0xFF;
+		WMT_ANT_RAM_OP_CMD[3] = (wmtCmdLen & 0xFF00) >> 16;
+
+		WMT_ANT_RAM_OP_CMD[4] = 1;	/*RAM CODE download */
+
+		osal_memcpy(gAntBuf, WMT_ANT_RAM_OP_CMD, sizeof(WMT_ANT_RAM_OP_CMD));
+
+		/*copy ram code content to global buffer */
+		osal_memcpy(&gAntBuf[6], pbuf, fragSize);
+
+		/*update offset */
+		offset += fragSize;
+		pbuf += offset;
+
+		iRet = wmt_core_tx(gAntBuf, wmtPktLen, &u4Res, MTK_WCN_BOOL_FALSE);
+		if (iRet || (u4Res != wmtPktLen)) {
+			WMT_ERR_FUNC("wmt_core: write fragSeq(%d) size(%d, %d) fail(%d)\n", fragSeq,
+				     wmtPktLen, u4Res, iRet);
+			iRet = -4;
+			break;
+		}
+		WMT_DBG_FUNC("wmt_core: write fragSeq(%d) size(%d, %d) ok\n",
+			     fragSeq, wmtPktLen, u4Res);
+
+		osal_memset(antEvtBuf, 0, sizeof(antEvtBuf));
+
+		WMT_SET_RAM_OP_EVT[4] = 0;	/*download result; 0 */
+
+		iRet = wmt_core_rx(antEvtBuf, sizeof(WMT_SET_RAM_OP_EVT), &u4Res);
+		if (iRet || (u4Res != sizeof(WMT_SET_RAM_OP_EVT))) {
+			WMT_ERR_FUNC("wmt_core: read WMT_SET_RAM_OP_EVT length(%d, %d) fail(%d)\n",
+				     sizeof(WMT_SET_RAM_OP_EVT), u4Res, iRet);
+			iRet = -5;
+			break;
+		}
+#if CFG_CHECK_WMT_RESULT
+		if (osal_memcmp(antEvtBuf, WMT_SET_RAM_OP_EVT, sizeof(WMT_SET_RAM_OP_EVT)) != 0) {
+			WMT_ERR_FUNC("wmt_core: compare WMT_SET_RAM_OP_EVT result error\n");
+			WMT_ERR_FUNC("rx(%d):[%02X,%02X,%02X,%02X,%02X] exp(%d):[%02X,%02X,%02X,%02X,%02X]\n",
+			     u4Res, antEvtBuf[0], antEvtBuf[1], antEvtBuf[2], antEvtBuf[3],
+			     antEvtBuf[4], sizeof(WMT_SET_RAM_OP_EVT), WMT_SET_RAM_OP_EVT[0],
+			     WMT_SET_RAM_OP_EVT[1], WMT_SET_RAM_OP_EVT[2], WMT_SET_RAM_OP_EVT[3],
+			     WMT_SET_RAM_OP_EVT[4]);
+			iRet = -6;
+			break;
+		}
+#endif
+		WMT_DBG_FUNC("wmt_core: read WMT_SET_RAM_OP_EVT length(%d, %d) ok\n",
+			     sizeof(WMT_SET_RAM_OP_EVT), u4Res);
+
+
+	}
+	if (fragSeq != fragNum)
+		iRet = -7;
+#endif
+	return iRet;
+}
+
+
+INT32 opfunc_ant_ram_stat_get(P_WMT_OP pWmtOp)
+{
+	INT32 iRet = 0;
+	UINT32 u4Res = 0;
+	UINT32 wmtPktLen = osal_sizeof(WMT_ANT_RAM_STA_GET_CMD);
+	UINT32 u4AntRamStatus = 0;
+	UINT8 antEvtBuf[osal_sizeof(WMT_ANT_RAM_STA_GET_EVT)];
+
+
+	iRet = wmt_core_tx(WMT_ANT_RAM_STA_GET_CMD, wmtPktLen, &u4Res, MTK_WCN_BOOL_FALSE);
+	if (iRet || (u4Res != wmtPktLen)) {
+		WMT_ERR_FUNC
+		    ("wmt_core: write wmt and ramcode status query command failed, (%d, %d), iRet(%d)\n",
+		     wmtPktLen, u4Res, iRet);
+		iRet = -4;
+		return iRet;
+	}
+
+
+	iRet = wmt_core_rx(antEvtBuf, sizeof(WMT_ANT_RAM_STA_GET_EVT), &u4Res);
+	if (iRet || (u4Res != sizeof(WMT_ANT_RAM_STA_GET_EVT))) {
+		WMT_ERR_FUNC("wmt_core: read WMT_ANT_RAM_STA_GET_EVT length(%zu, %d) fail(%d)\n",
+			     sizeof(WMT_ANT_RAM_STA_GET_EVT), u4Res, iRet);
+		iRet = -5;
+		return iRet;
+	}
+#if CFG_CHECK_WMT_RESULT
+	if (osal_memcmp(antEvtBuf, WMT_ANT_RAM_STA_GET_EVT, sizeof(WMT_ANT_RAM_STA_GET_EVT) - 1) !=
+	    0) {
+		WMT_ERR_FUNC("wmt_core: compare WMT_ANT_RAM_STA_GET_EVT result error\n");
+		WMT_ERR_FUNC("rx(%d):[%02X,%02X,%02X,%02X,%02X] exp(%zu):[%02X,%02X,%02X,%02X,%02X]\n",
+				u4Res, antEvtBuf[0], antEvtBuf[1], antEvtBuf[2], antEvtBuf[3], antEvtBuf[4],
+				sizeof(WMT_ANT_RAM_STA_GET_EVT), WMT_ANT_RAM_STA_GET_EVT[0],
+				WMT_ANT_RAM_STA_GET_EVT[1], WMT_ANT_RAM_STA_GET_EVT[2],
+				WMT_ANT_RAM_STA_GET_EVT[3], WMT_ANT_RAM_STA_GET_EVT[4]);
+		iRet = -6;
+		return iRet;
+	}
+#endif
+	if (0 == iRet) {
+		u4AntRamStatus = antEvtBuf[sizeof(WMT_ANT_RAM_STA_GET_EVT) - 1];
+		pWmtOp->au4OpData[2] = u4AntRamStatus;
+		WMT_INFO_FUNC("ANT ram code %s\n",
+			      1 == u4AntRamStatus ? "exist already" : "not exist");
+	}
+	return iRet;
+}
+#endif
+
+#if CFG_WMT_LTE_COEX_HANDLING
+/*TEST CODE*/
+static UINT32 g_open_wmt_lte_flag;
+VOID wmt_core_set_flag_for_test(UINT32 enable)
+{
+	WMT_INFO_FUNC("%s wmt_lte_flag\n", enable ? "enable" : "disable");
+	g_open_wmt_lte_flag = enable;
+}
+
+UINT32 wmt_core_get_flag_for_test(VOID)
+{
+	return g_open_wmt_lte_flag;
+}
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_ctrl.c b/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_ctrl.c
new file mode 100644
index 00000000..fa603c2
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_ctrl.c
@@ -0,0 +1,1019 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[WMT-CTRL]"
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+#include "osal_typedef.h"
+#include "osal.h"
+
+#include "wmt_ctrl.h"
+#include "wmt_core.h"
+#include "wmt_ic.h"
+#include "wmt_lib.h"
+#include "wmt_dev.h"
+#include "wmt_plat.h"
+#include "stp_core.h"
+#include "stp_dbg.h"
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                    F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+/* moved to wmt_ctrl.h */
+/*static INT32  wmt_ctrl_tx_ex (UINT8 *pData, UINT32 size, UINT32 *writtenSize, MTK_WCN_BOOL bRawFlag);*/
+
+static INT32 wmt_ctrl_stp_conf_ex(WMT_STP_CONF_TYPE type, UINT32 value);
+
+static INT32 wmt_ctrl_hw_pwr_off(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_hw_pwr_on(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_hw_rst(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_stp_close(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_stp_open(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_stp_conf(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_free_patch(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_get_patch(P_WMT_CTRL_DATA);
+#if 0
+static INT32 wmt_ctrl_host_baudrate_set(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_sdio_hw(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_sdio_func(P_WMT_CTRL_DATA);
+#endif
+static INT32 wmt_ctrl_hwidver_set(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_stp_rst(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_get_wmt_conf(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_others(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_tx(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_rx(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_patch_search(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_crystal_triming_put(P_WMT_CTRL_DATA pWmtCtrlData);
+static INT32 wmt_ctrl_crystal_triming_get(P_WMT_CTRL_DATA pWmtCtrlData);
+static INT32 wmt_ctrl_hw_state_show(P_WMT_CTRL_DATA pWmtCtrlData);
+static INT32 wmt_ctrl_get_patch_num(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_get_patch_info(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_soc_paldo_ctrl(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_soc_wakeup_consys(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_set_stp_dbg_info(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_bgw_desense_ctrl(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_evt_err_trg_assert(P_WMT_CTRL_DATA);
+static INT32 wmt_ctrl_evt_parser(P_WMT_CTRL_DATA pWmtCtrlData);
+#if CFG_WMT_LTE_COEX_HANDLING
+static INT32 wmt_ctrl_get_tdm_req_antsel(P_WMT_CTRL_DATA);
+#endif
+
+static INT32 wmt_ctrl_rx_flush(P_WMT_CTRL_DATA);
+
+static INT32 wmt_ctrl_gps_sync_set(P_WMT_CTRL_DATA pData);
+
+static INT32 wmt_ctrl_gps_lna_set(P_WMT_CTRL_DATA pData);
+
+static INT32 wmt_ctrl_get_patch_name(P_WMT_CTRL_DATA pWmtCtrlData);
+
+/* TODO: [FixMe][GeorgeKuo]: remove unused function */
+/*static INT32  wmt_ctrl_hwver_get(P_WMT_CTRL_DATA);*/
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/* GeorgeKuo: Use designated initializers described in
+ * http://gcc.gnu.org/onlinedocs/gcc-4.0.4/gcc/Designated-Inits.html
+ */
+static const WMT_CTRL_FUNC wmt_ctrl_func[] = {
+	[WMT_CTRL_HW_PWR_OFF] = wmt_ctrl_hw_pwr_off,
+	[WMT_CTRL_HW_PWR_ON] = wmt_ctrl_hw_pwr_on,
+	[WMT_CTRL_HW_RST] = wmt_ctrl_hw_rst,
+	[WMT_CTRL_STP_CLOSE] = wmt_ctrl_stp_close,
+	[WMT_CTRL_STP_OPEN] = wmt_ctrl_stp_open,
+	[WMT_CTRL_STP_CONF] = wmt_ctrl_stp_conf,
+	[WMT_CTRL_FREE_PATCH] = wmt_ctrl_free_patch,
+	[WMT_CTRL_GET_PATCH] = wmt_ctrl_get_patch,
+	[WMT_CTRL_GET_PATCH_NAME] = wmt_ctrl_get_patch_name,
+	[WMT_CTRL_HWIDVER_SET] = wmt_ctrl_hwidver_set,
+	[WMT_CTRL_STP_RST] = wmt_ctrl_stp_rst,
+	[WMT_CTRL_GET_WMT_CONF] = wmt_ctrl_get_wmt_conf,
+	[WMT_CTRL_TX] = wmt_ctrl_tx,
+	[WMT_CTRL_RX] = wmt_ctrl_rx,
+	[WMT_CTRL_RX_FLUSH] = wmt_ctrl_rx_flush,
+	[WMT_CTRL_GPS_SYNC_SET] = wmt_ctrl_gps_sync_set,
+	[WMT_CTRL_GPS_LNA_SET] = wmt_ctrl_gps_lna_set,
+	[WMT_CTRL_PATCH_SEARCH] = wmt_ctrl_patch_search,
+	[WMT_CTRL_CRYSTAL_TRIMING_GET] = wmt_ctrl_crystal_triming_get,
+	[WMT_CTRL_CRYSTAL_TRIMING_PUT] = wmt_ctrl_crystal_triming_put,
+	[WMT_CTRL_HW_STATE_DUMP] = wmt_ctrl_hw_state_show,
+	[WMT_CTRL_GET_PATCH_NUM] = wmt_ctrl_get_patch_num,
+	[WMT_CTRL_GET_PATCH_INFO] = wmt_ctrl_get_patch_info,
+	[WMT_CTRL_SOC_PALDO_CTRL] = wmt_ctrl_soc_paldo_ctrl,
+	[WMT_CTRL_SOC_WAKEUP_CONSYS] = wmt_ctrl_soc_wakeup_consys,
+	[WMT_CTRL_SET_STP_DBG_INFO] = wmt_ctrl_set_stp_dbg_info,
+	[WMT_CTRL_BGW_DESENSE_CTRL] = wmt_ctrl_bgw_desense_ctrl,
+	[WMT_CTRL_EVT_ERR_TRG_ASSERT] = wmt_ctrl_evt_err_trg_assert,
+#if CFG_WMT_LTE_COEX_HANDLING
+	[WMT_CTRL_GET_TDM_REQ_ANTSEL] = wmt_ctrl_get_tdm_req_antsel,
+#endif
+	[WMT_CTRL_EVT_PARSER] = wmt_ctrl_evt_parser,
+	[WMT_CTRL_MAX] = wmt_ctrl_others,
+};
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+INT32 wmt_ctrl(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	UINT32 ctrlId;
+
+	if (NULL == pWmtCtrlData) {
+		osal_assert(0);
+		return -1;
+	}
+
+	ctrlId = pWmtCtrlData->ctrlId;
+	/*1sanity check, including wmtCtrlId */
+	if ((NULL == pWmtCtrlData)
+	    || (WMT_CTRL_MAX <= ctrlId))
+		/* || (ctrlId < WMT_CTRL_HW_PWR_OFF) ) [FixMe][GeorgeKuo]: useless comparison */
+	{
+		osal_assert(NULL != pWmtCtrlData);
+		osal_assert(WMT_CTRL_MAX > ctrlId);
+		/* osal_assert(ctrlId >= WMT_CTRL_HW_PWR_OFF); [FixMe][GeorgeKuo]: useless comparison */
+		return -2;
+	}
+	/* TODO: [FixMe][GeorgeKuo] do sanity check to const function table when init and skip checking here */
+	if (wmt_ctrl_func[ctrlId]) {
+		/*call servicd handling API */
+		return (*(wmt_ctrl_func[ctrlId])) (pWmtCtrlData);	/* serviceHandlerPack[ctrlId].serviceHandler */
+	}
+	osal_assert(NULL != wmt_ctrl_func[ctrlId]);
+	return -3;
+
+}
+
+INT32 wmt_ctrl_tx(P_WMT_CTRL_DATA pWmtCtrlData /*UINT8 *pData, UINT32 size, UINT32 *writtenSize */)
+{
+	UINT8 *pData = (PUINT8) pWmtCtrlData->au4CtrlData[0];
+	UINT32 size = pWmtCtrlData->au4CtrlData[1];
+	PUINT32 writtenSize = (PUINT32) pWmtCtrlData->au4CtrlData[2];
+	MTK_WCN_BOOL bRawFlag = pWmtCtrlData->au4CtrlData[3];
+
+	return wmt_ctrl_tx_ex(pData, size, writtenSize, bRawFlag);
+}
+
+INT32 wmt_ctrl_rx(P_WMT_CTRL_DATA pWmtCtrlData /*UINT8 *pBuff, UINT32 buffLen, UINT32 *readSize */)
+{
+	P_DEV_WMT pDev = &gDevWmt;	/* single instance */
+	INT32 readLen;
+	long waitRet = -1;
+	PUINT8 pBuff = (PUINT8) pWmtCtrlData->au4CtrlData[0];
+	UINT32 buffLen = pWmtCtrlData->au4CtrlData[1];
+	PUINT32 readSize = (PUINT32) pWmtCtrlData->au4CtrlData[2];
+
+	if (readSize)
+		*readSize = 0;
+
+	/* sanity check */
+	if (!buffLen) {
+		WMT_WARN_FUNC("buffLen = 0\n");
+		osal_assert(buffLen);
+		return 0;
+	}
+#if 0
+	if (!pDev) {
+		WMT_WARN_FUNC("gpDevWmt = NULL\n");
+		osal_assert(pDev);
+		return -1;
+	}
+#endif
+
+	if (!osal_test_bit(WMT_STAT_STP_OPEN, &pDev->state)) {
+		WMT_WARN_FUNC("state(0x%lx)\n", pDev->state);
+		osal_assert(osal_test_bit(WMT_STAT_STP_OPEN, &pDev->state));
+		return -2;
+	}
+
+	/* sanity ok, proceeding rx operation */
+	/* read_len = mtk_wcn_stp_receive_data(data, size, WMT_TASK_INDX); */
+	readLen = mtk_wcn_stp_receive_data(pBuff, buffLen, WMT_TASK_INDX);
+
+	while (readLen == 0) {	/* got nothing, wait for STP's signal */
+		WMT_LOUD_FUNC("before wmt_dev_rx_timeout\n");
+		/* iRet = wait_event_interruptible(pdev->rWmtRxWq, osal_test_bit(WMT_STAT_RX, &pdev->state)); */
+		/* waitRet = wait_event_interruptible_timeout(
+		* pDev->rWmtRxWq,
+		* osal_test_bit(WMT_STAT_RX, &pdev->state),
+		* msecs_to_jiffies(WMT_LIB_RX_TIMEOUT));
+		*/
+		pDev->rWmtRxWq.timeoutValue = WMT_LIB_RX_TIMEOUT;
+		/* waitRet = osal_wait_for_event_bit_timeout(&pDev->rWmtRxWq, &pDev->state, WMT_STAT_RX); */
+		waitRet = wmt_dev_rx_timeout(&pDev->rWmtRxWq);
+
+		WMT_LOUD_FUNC("wmt_dev_rx_timeout returned\n");
+
+		if (0 == waitRet) {
+			WMT_ERR_FUNC("wmt_dev_rx_timeout: timeout,jiffies(%lu),timeoutvalue(%d)\n",
+				     jiffies, pDev->rWmtRxWq.timeoutValue);
+			return -1;
+		} else if (waitRet < 0) {
+			WMT_WARN_FUNC("wmt_dev_rx_timeout: interrupted by signal (%ld)\n", waitRet);
+			return waitRet;
+		}
+		WMT_DBG_FUNC("wmt_dev_rx_timeout, iRet(%ld)\n", waitRet);
+		/* read_len = mtk_wcn_stp_receive_data(data, size, WMT_TASK_INDX); */
+		readLen = mtk_wcn_stp_receive_data(pBuff, buffLen, WMT_TASK_INDX);
+
+		if (0 == readLen)
+			WMT_WARN_FUNC("wmt_ctrl_rx be signaled, but no rx data(%ld)\n", waitRet);
+
+	}
+
+	if (readSize)
+		*readSize = readLen;
+
+	return 0;
+
+}
+
+INT32 wmt_ctrl_tx_ex(const PUINT8 pData, const UINT32 size, PUINT32 writtenSize, const MTK_WCN_BOOL bRawFlag)
+{
+	P_DEV_WMT pDev = &gDevWmt;	/* single instance */
+	INT32 iRet;
+
+	if (NULL != writtenSize)
+		*writtenSize = 0;
+
+	/* sanity check */
+	if (0 == size) {
+		WMT_WARN_FUNC("size to tx is 0\n");
+		osal_assert(size);
+		return -1;
+	}
+
+	/* if STP is not enabled yet, can't use this function. Use tx_raw instead */
+	if (!osal_test_bit(WMT_STAT_STP_OPEN, &pDev->state) || !osal_test_bit(WMT_STAT_STP_EN, &pDev->state)) {
+		WMT_ERR_FUNC("wmt state(0x%lx)\n", pDev->state);
+		osal_assert(osal_test_bit(WMT_STAT_STP_EN, &pDev->state));
+		osal_assert(osal_test_bit(WMT_STAT_STP_OPEN, &pDev->state));
+		return -2;
+	}
+
+	/* sanity ok, proceeding tx operation */
+	/*retval = mtk_wcn_stp_send_data(data, size, WMTDRV_TYPE_WMT); */
+	mtk_wcn_stp_flush_rx_queue(WMT_TASK_INDX);
+	if (bRawFlag)
+		iRet = mtk_wcn_stp_send_data_raw(pData, size, WMT_TASK_INDX);
+	else
+		iRet = mtk_wcn_stp_send_data(pData, size, WMT_TASK_INDX);
+
+	if (iRet != size) {
+		WMT_WARN_FUNC("write(%d) written(%d)\n", size, iRet);
+		osal_assert(iRet == size);
+	}
+
+	if (writtenSize)
+		*writtenSize = iRet;
+
+	return 0;
+
+}
+
+INT32 wmt_ctrl_rx_flush(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	UINT32 type = pWmtCtrlData->au4CtrlData[0];
+
+	WMT_INFO_FUNC("flush rx %d queue\n", type);
+	mtk_wcn_stp_flush_rx_queue(type);
+
+	return 0;
+}
+
+INT32 wmt_ctrl_hw_pwr_off(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	INT32 iret;
+
+/*psm should be disabled before wmt_ic_deinit*/
+	P_DEV_WMT pDev = &gDevWmt;
+
+	if (osal_test_and_clear_bit(WMT_STAT_PWR, &pDev->state)) {
+		WMT_DBG_FUNC("on->off\n");
+		iret = wmt_plat_pwr_ctrl(FUNC_OFF);
+	} else {
+		WMT_WARN_FUNC("already off\n");
+		iret = 0;
+	}
+
+	return iret;
+}
+
+INT32 wmt_ctrl_hw_pwr_on(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	INT32 iret;
+	/*psm should be enabled right after wmt_ic_init */
+	P_DEV_WMT pDev = &gDevWmt;
+	if (osal_test_and_set_bit(WMT_STAT_PWR, &pDev->state)) {
+		WMT_WARN_FUNC("already on\n");
+		iret = 0;
+	} else {
+		WMT_DBG_FUNC("off->on\n");
+		iret = wmt_plat_pwr_ctrl(FUNC_ON);
+	}
+
+	return iret;
+}
+
+INT32 wmt_ctrl_ul_cmd(P_DEV_WMT pWmtDev, const UINT8 *pCmdStr)
+{
+	INT32 waitRet = -1;
+	P_OSAL_SIGNAL pCmdSignal;
+	P_OSAL_EVENT pCmdReq;
+
+	if (osal_test_and_set_bit(WMT_STAT_CMD, &pWmtDev->state)) {
+		WMT_WARN_FUNC("cmd buf is occupied by (%s)\n", pWmtDev->cCmd);
+		return -1;
+	}
+
+	/* indicate baud rate change to user space app */
+#if 0
+	INIT_COMPLETION(pWmtDev->cmd_comp);
+	pWmtDev->cmd_result = -1;
+	strncpy(pWmtDev->cCmd, pCmdStr, NAME_MAX);
+	pWmtDev->cCmd[NAME_MAX] = '\0';
+	wake_up_interruptible(&pWmtDev->cmd_wq);
+#endif
+
+	pCmdSignal = &pWmtDev->cmdResp;
+	osal_signal_init(pCmdSignal);
+	pCmdSignal->timeoutValue = 2000;
+	osal_strncpy(pWmtDev->cCmd, pCmdStr, NAME_MAX);
+	pWmtDev->cCmd[NAME_MAX] = '\0';
+
+	pCmdReq = &pWmtDev->cmdReq;
+
+	osal_trigger_event(&pWmtDev->cmdReq);
+	WMT_DBG_FUNC("str(%s) request ok\n", pCmdStr);
+
+/* waitRet = wait_for_completion_interruptible_timeout(&pWmtDev->cmd_comp, msecs_to_jiffies(2000)); */
+	waitRet = osal_wait_for_signal_timeout(pCmdSignal);
+	WMT_LOUD_FUNC("wait signal iRet:%d\n", waitRet);
+	if (0 == waitRet) {
+		WMT_ERR_FUNC("wait signal timeout\n");
+		return -2;
+	}
+
+	WMT_DBG_FUNC("str(%s) result(%d)\n", pCmdStr, pWmtDev->cmdResult);
+
+	return pWmtDev->cmdResult;
+}
+
+INT32 wmt_ctrl_hw_rst(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	wmt_plat_pwr_ctrl(FUNC_RST);
+	return 0;
+}
+
+INT32 wmt_ctrl_hw_state_show(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	wmt_plat_pwr_ctrl(FUNC_STAT);
+	return 0;
+}
+
+INT32 wmt_ctrl_stp_close(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	P_DEV_WMT pDev = &gDevWmt;	/* single instance */
+	INT32 iRet = 0;
+	/* un-register to STP-core for rx */
+	iRet = mtk_wcn_stp_register_event_cb(WMT_TASK_INDX, NULL);	/* mtk_wcn_stp_register_event_cb */
+	if (iRet) {
+		WMT_WARN_FUNC("stp_reg cb unregister fail(%d)\n", iRet);
+		return -1;
+	}
+
+	/*un-register rxcb to btif */
+	iRet = mtk_wcn_stp_rxcb_register(NULL);
+	if (iRet) {
+		WMT_WARN_FUNC("mtk_wcn_stp_rxcb_unregister fail(%d)\n", iRet);
+		return -2;
+	}
+
+	iRet = mtk_wcn_stp_close_btif();
+	if (iRet) {
+		WMT_WARN_FUNC("mtk_wcn_stp_close_btif fail(%d)\n", iRet);
+		return -3;
+	}
+	osal_clear_bit(WMT_STAT_STP_OPEN, &pDev->state);
+
+	return 0;
+}
+
+INT32 wmt_ctrl_stp_open(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	P_DEV_WMT pDev = &gDevWmt;	/* single instance */
+	INT32 iRet;
+
+	iRet = mtk_wcn_stp_open_btif();
+	if (iRet) {
+		WMT_WARN_FUNC("mtk_wcn_stp_open_btif fail(%d)\n", iRet);
+		return -1;
+	}
+
+	/*register stp rx call back to btif */
+	iRet = mtk_wcn_stp_rxcb_register((MTK_WCN_BTIF_RX_CB) mtk_wcn_stp_parser_data);
+	if (iRet) {
+		WMT_WARN_FUNC("mtk_wcn_stp_rxcb_register fail(%d)\n", iRet);
+		return -2;
+	}
+	/* register to STP-core for rx */
+	iRet = mtk_wcn_stp_register_event_cb(WMT_TASK_INDX, wmt_dev_rx_event_cb);
+	if (iRet) {
+		WMT_WARN_FUNC("stp_reg cb fail(%d)\n", iRet);
+		return -3;
+	}
+
+	osal_set_bit(WMT_STAT_STP_OPEN, &pDev->state);
+
+#if 0
+	iRet = mtk_wcn_stp_lpbk_ctrl(1);
+#endif
+
+	return 0;
+}
+
+INT32 wmt_ctrl_patch_search(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	P_DEV_WMT pDev = &gDevWmt;	/* single instance */
+	INT32 iRet;
+	UINT8 cmdStr[NAME_MAX + 1] = { 0 };
+
+	osal_snprintf(cmdStr, NAME_MAX, "srh_patch");
+	iRet = wmt_ctrl_ul_cmd(pDev, cmdStr);
+	if (iRet) {
+		WMT_WARN_FUNC("wmt_ctrl_ul_cmd fail(%d)\n", iRet);
+		return -1;
+	}
+	return 0;
+}
+
+INT32 wmt_ctrl_get_patch_num(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	P_DEV_WMT pDev = &gDevWmt;	/* single instance */
+
+	pWmtCtrlData->au4CtrlData[0] = pDev->patchNum;
+	return 0;
+}
+
+INT32 wmt_ctrl_get_patch_info(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	P_DEV_WMT pDev = &gDevWmt;	/* single instance */
+	UINT32 downLoadSeq = 0;
+	P_WMT_PATCH_INFO pPatchinfo = NULL;
+	PUINT8 pNbuf = NULL;
+	PUINT8 pAbuf = NULL;
+
+	downLoadSeq = pWmtCtrlData->au4CtrlData[0];
+	WMT_DBG_FUNC("download seq is %d\n", downLoadSeq);
+
+	pPatchinfo = pDev->pWmtPatchInfo + downLoadSeq - 1;
+	pNbuf = (PUINT8) pWmtCtrlData->au4CtrlData[1];
+	pAbuf = (PUINT8) pWmtCtrlData->au4CtrlData[2];
+	if (pPatchinfo) {
+		osal_memcpy(pNbuf, pPatchinfo->patchName, osal_sizeof(pPatchinfo->patchName));
+		osal_memcpy(pAbuf, pPatchinfo->addRess, osal_sizeof(pPatchinfo->addRess));
+		WMT_DBG_FUNC("get 4 address bytes is 0x%2x,0x%2x,0x%2x,0x%2x", pAbuf[0], pAbuf[1], pAbuf[2], pAbuf[3]);
+	} else {
+		WMT_ERR_FUNC("NULL patchinfo pointer\n");
+	}
+
+	return 0;
+}
+
+INT32 wmt_ctrl_soc_paldo_ctrl(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	INT32 iRet = 0;
+	ENUM_PALDO_TYPE ept = pWmtCtrlData->au4CtrlData[0];
+	ENUM_PALDO_OP epo = pWmtCtrlData->au4CtrlData[1];
+
+	WMT_DBG_FUNC("ept(%d),epo(%d)\n", ept, epo);
+	iRet = wmt_plat_soc_paldo_ctrl(ept, epo);
+	if (iRet) {
+		if (PMIC_CHIPID_PALDO == ept) {
+			/* special handling for PMIC CHIPID */
+			pWmtCtrlData->au4CtrlData[2] = iRet;
+		} else {
+			/* for other PA handling */
+			WMT_ERR_FUNC("soc palod ctrl fail(%d)\n", iRet);
+		}
+	}
+
+	return iRet;
+}
+
+INT32 wmt_ctrl_soc_wakeup_consys(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	INT32 iRet = 0;
+
+	iRet = mtk_wcn_stp_wakeup_consys();
+	if (iRet)
+		WMT_ERR_FUNC("soc palod ctrl fail(%d)\n", iRet);
+
+	return iRet;
+}
+
+INT32 wmt_ctrl_stp_conf_ex(WMT_STP_CONF_TYPE type, UINT32 value)
+{
+	INT32 iRet = -1;
+
+	switch (type) {
+	case WMT_STP_CONF_EN:
+		iRet = mtk_wcn_stp_enable(value);
+		break;
+
+	case WMT_STP_CONF_RDY:
+		iRet = mtk_wcn_stp_ready(value);
+		break;
+
+	case WMT_STP_CONF_MODE:
+		mtk_wcn_stp_set_mode(value);
+		iRet = 0;
+		break;
+
+	default:
+		WMT_WARN_FUNC("invalid type(%d) value(%d)\n", type, value);
+		break;
+	}
+	return iRet;
+}
+
+INT32 wmt_ctrl_stp_conf(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	INT32 iRet = -1;
+	P_DEV_WMT pDev = &gDevWmt;	/* single instance */
+	UINT32 type;
+	UINT32 value;
+
+	if (!osal_test_bit(WMT_STAT_STP_OPEN, &pDev->state)) {
+		WMT_WARN_FUNC("CTRL_STP_ENABLE but invalid Handle of WmtStp\n");
+		return -1;
+	}
+
+	type = pWmtCtrlData->au4CtrlData[0];
+	value = pWmtCtrlData->au4CtrlData[1];
+	iRet = wmt_ctrl_stp_conf_ex(type, value);
+
+	if (!iRet) {
+		if (WMT_STP_CONF_EN == type) {
+			if (value) {
+				osal_set_bit(WMT_STAT_STP_EN, &pDev->state);
+				WMT_DBG_FUNC("enable STP\n");
+			} else {
+				osal_clear_bit(WMT_STAT_STP_EN, &pDev->state);
+				WMT_DBG_FUNC("disable STP\n");
+			}
+		}
+	}
+
+	return iRet;
+}
+
+INT32 wmt_ctrl_free_patch(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	UINT32 patchSeq = pWmtCtrlData->au4CtrlData[0];
+
+	WMT_DBG_FUNC("BF free patch, gDevWmt.pPatch(0x%08x)\n", gDevWmt.pPatch);
+	if (NULL != gDevWmt.pPatch)
+		wmt_dev_patch_put((osal_firmware **) &(gDevWmt.pPatch));
+
+	WMT_DBG_FUNC("AF free patch, gDevWmt.pPatch(0x%08x)\n", gDevWmt.pPatch);
+	if (patchSeq == gDevWmt.patchNum) {
+		WMT_DBG_FUNC("the %d patch has been download\n", patchSeq);
+		wmt_dev_patch_info_free();
+	}
+	return 0;
+}
+
+INT32 wmt_ctrl_get_patch_name(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	PUINT8 pBuf = (PUINT8) pWmtCtrlData->au4CtrlData[0];
+
+	osal_memcpy(pBuf, gDevWmt.cPatchName, osal_sizeof(gDevWmt.cPatchName));
+	return 0;
+}
+
+INT32 wmt_ctrl_crystal_triming_put(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	WMT_DBG_FUNC("BF free patch, gDevWmt.pPatch(0x%08x)\n", gDevWmt.pPatch);
+	if (NULL != gDevWmt.pNvram)
+		wmt_dev_patch_put((osal_firmware **) &(gDevWmt.pNvram));
+
+	WMT_DBG_FUNC("AF free patch, gDevWmt.pNvram(0x%08x)\n", gDevWmt.pNvram);
+	return 0;
+}
+
+INT32 wmt_ctrl_crystal_triming_get(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	INT32 iRet = 0x0;
+	PUINT8 pFileName = (PUINT8) pWmtCtrlData->au4CtrlData[0];
+	PPUINT8 ppBuf = (PPUINT8) pWmtCtrlData->au4CtrlData[1];
+	PUINT32 pSize = (PUINT32) pWmtCtrlData->au4CtrlData[2];
+
+	osal_firmware *pNvram = NULL;
+
+	if ((NULL == pFileName) || (NULL == pSize)) {
+		WMT_ERR_FUNC("parameter error, pFileName(0x%08x), pSize(0x%08x)\n", pFileName, pSize);
+		iRet = -1;
+		return iRet;
+	}
+	if (0 == wmt_dev_patch_get(pFileName, &pNvram, 0)) {
+		*ppBuf = (PUINT8) (pNvram)->data;
+		*pSize = (pNvram)->size;
+		gDevWmt.pNvram = pNvram;
+		return 0;
+	}
+	return -1;
+
+}
+
+INT32 wmt_ctrl_get_patch(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	UINT8 *pFullPatchName = NULL;
+	UINT8 *pDefPatchName = NULL;
+	PUINT8 *ppBuf = (PUINT8 *) pWmtCtrlData->au4CtrlData[2];
+	PUINT32 pSize = (PUINT32) pWmtCtrlData->au4CtrlData[3];
+
+	osal_firmware *pPatch = NULL;
+
+	pFullPatchName = (PUINT8) pWmtCtrlData->au4CtrlData[1];
+	WMT_DBG_FUNC("BF get patch, pPatch(0x%08x)\n", pPatch);
+	if ((NULL != pFullPatchName)
+	    && (0 == wmt_dev_patch_get(pFullPatchName, &pPatch, BCNT_PATCH_BUF_HEADROOM))) {
+		/*get full name patch success */
+		WMT_DBG_FUNC("get full patch name(%s) buf(0x%p) size(%d)\n",
+			     pFullPatchName, (pPatch)->data, (pPatch)->size);
+		WMT_DBG_FUNC("AF get patch, pPatch(0x%08x)\n", pPatch);
+		*ppBuf = (PUINT8) (pPatch)->data;
+		*pSize = (pPatch)->size;
+		gDevWmt.pPatch = pPatch;
+		return 0;
+	}
+
+	pDefPatchName = (PUINT8) pWmtCtrlData->au4CtrlData[0];
+	if ((NULL != pDefPatchName)
+	    && (0 == wmt_dev_patch_get(pDefPatchName, &pPatch, BCNT_PATCH_BUF_HEADROOM))) {
+		WMT_DBG_FUNC("get def patch name(%s) buf(0x%p) size(%d)\n",
+			     pDefPatchName, (pPatch)->data, (pPatch)->size);
+		WMT_DBG_FUNC("AF get patch, pPatch(0x%08x)\n", pPatch);
+		/*get full name patch success */
+		*ppBuf = (PUINT8) (pPatch)->data;
+		*pSize = (pPatch)->size;
+		gDevWmt.pPatch = pPatch;
+		return 0;
+	}
+	return -1;
+
+}
+
+/*do not need contol uart because B/G/F send/receive data by BTIF*/
+#if 0
+INT32 wmt_ctrl_host_baudrate_set(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	INT32 iRet = -1;
+	char cmdStr[NAME_MAX + 1] = { 0 };
+	UINT32 u4Baudrate = pWmtCtrlData->au4CtrlData[0];
+	UINT32 u4FlowCtrl = pWmtCtrlData->au4CtrlData[1];
+
+	WMT_DBG_FUNC("baud(%d), flowctrl(%d)\n", u4Baudrate, u4FlowCtrl);
+
+	if (osal_test_bit(WMT_STAT_STP_OPEN, &gDevWmt.state)) {
+		osal_snprintf(cmdStr, NAME_MAX, "baud_%d_%d", u4Baudrate, u4FlowCtrl);
+		iRet = wmt_ctrl_ul_cmd(&gDevWmt, cmdStr);
+		if (iRet) {
+			WMT_WARN_FUNC("CTRL_BAUDRATE baud(%d), flowctrl(%d) fail(%d)\n",
+				      u4Baudrate, pWmtCtrlData->au4CtrlData[1], iRet);
+		} else {
+			WMT_DBG_FUNC("CTRL_BAUDRATE baud(%d), flowctrl(%d) ok\n", u4Baudrate, u4FlowCtrl);
+		}
+	} else {
+		WMT_INFO_FUNC("CTRL_BAUDRATE but invalid Handle of WmtStp\n");
+	}
+	return iRet;
+}
+#endif
+/*do not need control SDIO because wifi send/receive data by sdio*/
+#if 0
+INT32 wmt_ctrl_sdio_hw(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	INT32 iRet = 0;
+	UINT32 statBit = WMT_STAT_SDIO1_ON;
+	P_DEV_WMT pDev = &gDevWmt;	/* single instance */
+
+	WMT_SDIO_SLOT_NUM sdioSlotNum = pWmtCtrlData->au4CtrlData[0];
+	ENUM_FUNC_STATE funcState = pWmtCtrlData->au4CtrlData[1];
+
+	if ((WMT_SDIO_SLOT_INVALID == sdioSlotNum)
+	    || (WMT_SDIO_SLOT_MAX <= sdioSlotNum)) {
+		WMT_WARN_FUNC("CTRL_SDIO_SLOT(%d) but invalid slot num\n", sdioSlotNum);
+		return -1;
+	}
+
+	WMT_DBG_FUNC("WMT_CTRL_SDIO_HW (0x%x, %d)\n", sdioSlotNum, funcState);
+
+	if (WMT_SDIO_SLOT_SDIO2 == sdioSlotNum)
+		statBit = WMT_STAT_SDIO2_ON;
+
+	if (funcState) {
+		if (osal_test_and_set_bit(statBit, &pDev->state)) {
+			WMT_WARN_FUNC("CTRL_SDIO_SLOT slotNum(%d) already ON\n", sdioSlotNum);
+			/* still return 0 */
+			iRet = 0;
+		} else {
+			iRet = wmt_plat_sdio_ctrl(sdioSlotNum, FUNC_ON);
+		}
+	} else {
+		if (osal_test_and_clear_bit(statBit, &pDev->state)) {
+			iRet = wmt_plat_sdio_ctrl(sdioSlotNum, FUNC_OFF);
+		} else {
+			WMT_WARN_FUNC("CTRL_SDIO_SLOT slotNum(%d) already OFF\n", sdioSlotNum);
+			/* still return 0 */
+			iRet = 0;
+		}
+	}
+
+	return iRet;
+}
+
+INT32 wmt_ctrl_sdio_func(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	INT32 iRet = -1;
+	UINT32 statBit = WMT_STAT_SDIO_WIFI_ON;
+	INT32 retry = 10;
+	P_DEV_WMT pDev = &gDevWmt;	/* single instance */
+	WMT_SDIO_FUNC_TYPE sdioFuncType = pWmtCtrlData->au4CtrlData[0];
+	UINT32 u4On = pWmtCtrlData->au4CtrlData[1];
+
+	if (WMT_SDIO_FUNC_MAX <= sdioFuncType) {
+		WMT_ERR_FUNC("CTRL_SDIO_FUNC, invalid func type (%d)\n", sdioFuncType);
+		return -1;
+	}
+
+	if (WMT_SDIO_FUNC_STP == sdioFuncType)
+		statBit = WMT_STAT_SDIO_STP_ON;
+
+	if (u4On) {
+		if (osal_test_bit(statBit, &pDev->state)) {
+			WMT_WARN_FUNC("CTRL_SDIO_FUNC(%d) but already ON\n", sdioFuncType);
+			iRet = 0;
+		} else {
+			while (retry-- > 0 && iRet != 0) {
+				if (iRet) {
+					/* sleep 150ms before sdio slot ON ready */
+					osal_sleep_ms(150);
+				}
+				iRet = mtk_wcn_hif_sdio_wmt_control(sdioFuncType, MTK_WCN_BOOL_TRUE);
+				if (HIF_SDIO_ERR_NOT_PROBED == iRet) {
+					/* not probed case, retry */
+					continue;
+				} else if (HIF_SDIO_ERR_CLT_NOT_REG == iRet) {
+					/* For WiFi, client not reg yet, no need to retry,
+					*WiFi function can work any time when wlan.ko
+					*is insert into system
+					*/
+					iRet = 0;
+				} else {
+					/* other fail cases, stop */
+					break;
+				}
+			}
+			if (!retry || iRet) {
+				WMT_ERR_FUNC("mtk_wcn_hif_sdio_wmt_control(%d, TRUE) fail(%d) retry(%d)\n",
+					     sdioFuncType, iRet, retry);
+			} else {
+				osal_set_bit(statBit, &pDev->state);
+			}
+		}
+	} else {
+		if (osal_test_bit(statBit, &pDev->state)) {
+			iRet = mtk_wcn_hif_sdio_wmt_control(sdioFuncType, MTK_WCN_BOOL_FALSE);
+			if (iRet)
+				WMT_ERR_FUNC("mtk_wcn_hif_sdio_wmt_control(%d, FALSE) fail(%d)\n", sdioFuncType, iRet);
+			/*any way, set to OFF state */
+			osal_clear_bit(statBit, &pDev->state);
+		} else {
+			WMT_WARN_FUNC("CTRL_SDIO_FUNC(%d) but already OFF\n", sdioFuncType);
+			iRet = 0;
+		}
+	}
+
+	return iRet;
+}
+#endif
+
+
+INT32 wmt_ctrl_hwidver_set(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	P_DEV_WMT pDev = &gDevWmt;	/* single instance */
+
+	/* input sanity check is done in wmt_ctrl() */
+	pDev->chip_id = (pWmtCtrlData->au4CtrlData[0] & 0xFFFF0000) >> 16;
+	pDev->hw_ver = pWmtCtrlData->au4CtrlData[0] & 0x0000FFFF;
+	pDev->fw_ver = pWmtCtrlData->au4CtrlData[1] & 0x0000FFFF;
+
+	/* TODO: [FixMe][GeorgeKuo] remove translated ENUM_WMTHWVER_TYPE_T in the future!!! */
+	/* Only use hw_ver read from hw. */
+	pDev->eWmtHwVer = (ENUM_WMTHWVER_TYPE_T) (pWmtCtrlData->au4CtrlData[1] & 0xFFFF0000) >> 16;
+
+	return 0;
+}
+
+INT32 wmt_ctrl_set_stp_dbg_info(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	UINT8 *pRomVer = NULL;
+	P_WMT_PATCH pPatch = NULL;
+	UINT32 chipID = 0;
+
+	chipID = pWmtCtrlData->au4CtrlData[0];
+	pRomVer = (PUINT8) (pWmtCtrlData->au4CtrlData[1]);
+	pPatch = (P_WMT_PATCH) (pWmtCtrlData->au4CtrlData[2]);
+	if (!pRomVer) {
+		WMT_ERR_FUNC("pRomVer null pointer\n");
+		return -1;
+	}
+	if (!pPatch) {
+		WMT_ERR_FUNC("pPatch null pointer\n");
+		return -2;
+	}
+	WMT_DBG_FUNC("chipid(0x%x),rom(%s),patch date(%s),patch plat(%s)\n", chipID, pRomVer, pPatch->ucDateTime,
+		     pPatch->ucPLat);
+	return stp_dbg_set_version_info(chipID, pRomVer, &(pPatch->ucDateTime[0]), &(pPatch->ucPLat[0]));
+}
+
+static INT32 wmt_ctrl_bgw_desense_ctrl(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	UINT32 cmd = pWmtCtrlData->au4CtrlData[0];
+
+	WMT_INFO_FUNC("wmt-ctrl:send native cmd(%d)\n", cmd);
+	wmt_dev_send_cmd_to_daemon(cmd);
+
+	return 0;
+}
+
+static INT32 wmt_ctrl_evt_err_trg_assert(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	INT32 iRet = -1;
+
+	ENUM_WMTDRV_TYPE_T drv_type;
+	UINT32 reason = 0;
+
+	drv_type = pWmtCtrlData->au4CtrlData[0];
+	reason = pWmtCtrlData->au4CtrlData[1];
+	WMT_WARN_FUNC("wmt-ctrl:drv_type(%d),reason(%d)\n", drv_type, reason);
+
+	if (0 == mtk_wcn_stp_get_wmt_evt_err_trg_assert()) {
+		mtk_wcn_stp_set_wmt_evt_err_trg_assert(1);
+		wmt_lib_set_host_assert_info(drv_type, reason, 1);
+
+		iRet = mtk_wcn_stp_wmt_evt_err_trg_assert();
+		if (iRet)
+			mtk_wcn_stp_set_wmt_evt_err_trg_assert(0);
+	} else {
+		/* maybe assert triggered by stp noack*/
+		WMT_INFO_FUNC("do trigger assert & chip reset in stp noack\n");
+	}
+	return 0;
+}
+
+#if CFG_WMT_LTE_COEX_HANDLING
+static INT32 wmt_ctrl_get_tdm_req_antsel(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	INT32 antsel_index = wmt_plat_get_tdm_antsel_index();
+
+	if (0 <= antsel_index)
+		pWmtCtrlData->au4CtrlData[0] = antsel_index;
+	else
+		pWmtCtrlData->au4CtrlData[0] = 0xff;
+
+	WMT_INFO_FUNC("get tdm req antsel index is %d\n", antsel_index);
+
+	return 0;
+}
+#endif
+
+static INT32 wmt_ctrl_evt_parser(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	INT32 ret = -1;
+	UINT32 evt_idx = (UINT32) pWmtCtrlData->au4CtrlData[0];
+	UINT8 *p_buf = NULL;
+
+	static UINT8 sleep_evt[] = { 0x02, 0x03, 0x02, 0x00, 0x00, 0x01 };
+	static UINT8 wakeup_evt[] = { 0x02, 0x03, 0x02, 0x00, 0x00, 0x03 };
+	static UINT8 hostawake_evt[] = { 0x02, 0x03, 0x02, 0x00, 0x00, 0x02 };
+	static UINT8 *evt_array[] = { sleep_evt, wakeup_evt, hostawake_evt };
+
+	p_buf = evt_array[evt_idx - 1];
+
+	WMT_INFO_FUNC("evt index:%d,p_buf:%p\n", evt_idx, p_buf);
+
+	ret = mtk_wcn_consys_stp_btif_parser_wmt_evt(p_buf, 6);
+	if (ret == 1) {
+		WMT_INFO_FUNC("parser wmt evt from BTIF buf is OK\n");
+		return 0;
+	}
+	WMT_ERR_FUNC("parser wmt evt from BTIF buf fail(%d)\n", ret);
+	return -1;
+}
+
+static INT32 wmt_ctrl_gps_sync_set(P_WMT_CTRL_DATA pData)
+{
+	INT32 iret;
+
+	WMT_INFO_FUNC("ctrl GPS_SYNC(%d)\n", (0 == pData->au4CtrlData[0]) ? PIN_STA_DEINIT : PIN_STA_MUX);
+	iret = wmt_plat_gpio_ctrl(PIN_GPS_SYNC, (0 == pData->au4CtrlData[0]) ? PIN_STA_DEINIT : PIN_STA_MUX);
+
+	if (iret) {
+		WMT_WARN_FUNC("ctrl GPS_SYNC(%d) fail!(%d) ignore it...\n",
+			      (0 == pData->au4CtrlData[0]) ? PIN_STA_DEINIT : PIN_STA_MUX, iret);
+	}
+
+	return 0;
+}
+
+static INT32 wmt_ctrl_gps_lna_set(P_WMT_CTRL_DATA pData)
+{
+	INT32 iret;
+
+	WMT_INFO_FUNC("ctrl GPS_LNA(%d)\n", (0 == pData->au4CtrlData[0]) ? PIN_STA_DEINIT : PIN_STA_OUT_H);
+	iret = wmt_plat_gpio_ctrl(PIN_GPS_LNA, (0 == pData->au4CtrlData[0]) ? PIN_STA_DEINIT : PIN_STA_OUT_H);
+
+	if (iret) {
+		WMT_WARN_FUNC("ctrl GPS_SYNC(%d) fail!(%d) ignore it...\n",
+			      (0 == pData->au4CtrlData[0]) ? PIN_STA_DEINIT : PIN_STA_OUT_H, iret);
+	}
+
+	return 0;
+}
+
+INT32 wmt_ctrl_stp_rst(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	return 0;
+}
+
+INT32 wmt_ctrl_get_wmt_conf(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	P_DEV_WMT pDev = &gDevWmt;	/* single instance */
+
+	pWmtCtrlData->au4CtrlData[0] = (SIZE_T) &pDev->rWmtGenConf;
+
+	return 0;
+}
+
+INT32 wmt_ctrl_others(P_WMT_CTRL_DATA pWmtCtrlData)
+{
+	WMT_ERR_FUNC("wmt_ctrl_others, invalid CTRL ID (%d)\n", pWmtCtrlData->ctrlId);
+	return -1;
+}
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_func.c b/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_func.c
new file mode 100644
index 00000000..d42d572
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_func.c
@@ -0,0 +1,713 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[WMT-FUNC]"
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+#include "osal_typedef.h"
+
+#include "wmt_func.h"
+#include "wmt_lib.h"
+#include "wmt_core.h"
+#include "wmt_exp.h"
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+#if CFG_FUNC_BT_SUPPORT
+
+static INT32 wmt_func_bt_on(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf);
+static INT32 wmt_func_bt_off(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf);
+
+WMT_FUNC_OPS wmt_func_bt_ops = {
+	/* BT subsystem function on/off */
+	.func_on = wmt_func_bt_on,
+	.func_off = wmt_func_bt_off
+};
+#endif
+
+#if CFG_FUNC_FM_SUPPORT
+
+static INT32 wmt_func_fm_on(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf);
+static INT32 wmt_func_fm_off(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf);
+
+WMT_FUNC_OPS wmt_func_fm_ops = {
+	/* FM subsystem function on/off */
+	.func_on = wmt_func_fm_on,
+	.func_off = wmt_func_fm_off
+};
+#endif
+
+#if CFG_FUNC_GPS_SUPPORT
+
+static INT32 wmt_func_gps_on(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf);
+static INT32 wmt_func_gps_off(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf);
+
+WMT_FUNC_OPS wmt_func_gps_ops = {
+	/* GPS subsystem function on/off */
+	.func_on = wmt_func_gps_on,
+	.func_off = wmt_func_gps_off
+};
+
+#endif
+
+#if CFG_FUNC_WIFI_SUPPORT
+static INT32 wmt_func_wifi_on(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf);
+static INT32 wmt_func_wifi_off(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf);
+
+WMT_FUNC_OPS wmt_func_wifi_ops = {
+	/* Wi-Fi subsystem function on/off */
+	.func_on = wmt_func_wifi_on,
+	.func_off = wmt_func_wifi_off
+};
+#endif
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+#if CFG_FUNC_GPS_SUPPORT
+CMB_PIN_CTRL_REG eediPinOhRegs[] = {
+	{
+	 /* pull down ctrl register */
+	 .regAddr = 0x80050020,
+	 .regValue = ~(0x1 << 5),
+	 .regMask = 0x00000020,
+	 },
+	{
+	 /* pull up ctrl register */
+	 .regAddr = 0x80050000,
+	 .regValue = 0x1 << 5,
+	 .regMask = 0x00000020,
+	 },
+	{
+	 /* iomode ctrl register */
+	 .regAddr = 0x80050110,
+	 .regValue = 0x1 << 0,
+	 .regMask = 0x00000007,
+	 },
+	{
+	 /* output high/low ctrl register */
+	 .regAddr = 0x80050040,
+	 .regValue = 0x1 << 5,
+	 .regMask = 0x00000020,
+	 }
+
+};
+
+CMB_PIN_CTRL_REG eediPinOlRegs[] = {
+	{
+	 .regAddr = 0x80050020,
+	 .regValue = 0x1 << 5,
+	 .regMask = 0x00000020UL,
+	 },
+	{
+	 .regAddr = 0x80050000,
+	 .regValue = ~(0x1 << 5),
+	 .regMask = 0x00000020,
+	 },
+	{
+	 .regAddr = 0x80050110,
+	 .regValue = 0x1 << 0,
+	 .regMask = 0x00000007,
+	 },
+	{
+	 .regAddr = 0x80050040,
+	 .regValue = ~(0x1 << 5),
+	 .regMask = 0x00000020,
+	 }
+};
+
+CMB_PIN_CTRL_REG eedoPinOhRegs[] = {
+	{
+	 .regAddr = 0x80050020,
+	 .regValue = ~(0x1 << 7),
+	 .regMask = 0x00000080UL,
+	 },
+	{
+	 .regAddr = 0x80050000,
+	 .regValue = 0x1 << 7,
+	 .regMask = 0x00000080UL,
+	 },
+	{
+	 .regAddr = 0x80050110,
+	 .regValue = 0x1 << 12,
+	 .regMask = 0x00007000UL,
+	 },
+	{
+	 .regAddr = 0x80050040,
+	 .regValue = 0x1 << 7,
+	 .regMask = 0x00000080,
+	 }
+};
+
+CMB_PIN_CTRL_REG eedoPinOlRegs[] = {
+	{
+	 .regAddr = 0x80050020,
+	 .regValue = 0x1 << 7,
+	 .regMask = 0x00000080,
+	 },
+	{
+	 .regAddr = 0x80050000,
+	 .regValue = ~(0x1 << 7),
+	 .regMask = 0x00000080,
+	 },
+	{
+	 .regAddr = 0x80050110,
+	 .regValue = 0x1 << 12,
+	 .regMask = 0x00007000,
+	 },
+	{
+	 .regAddr = 0x80050040,
+	 .regValue = ~(0x1 << 7),
+	 .regMask = 0x00000080,
+	 }
+
+};
+
+CMB_PIN_CTRL_REG gsyncPinOnRegs[] = {
+	{
+	 .regAddr = 0x80050110,
+	 .regValue = 0x3 << 20,
+	 .regMask = 0x7 << 20,
+	 }
+
+};
+
+CMB_PIN_CTRL_REG gsyncPinOffRegs[] = {
+	{
+	 .regAddr = 0x80050110,
+	 .regValue = 0x0 << 20,
+	 .regMask = 0x7 << 20,
+	 }
+};
+
+/* templete usage for GPIO control */
+CMB_PIN_CTRL gCmbPinCtrl[3] = {
+	{
+	 .pinId = CMB_PIN_EEDI_ID,
+	 .regNum = 4,
+	 .pFuncOnArray = eediPinOhRegs,
+	 .pFuncOffArray = eediPinOlRegs,
+	 },
+	{
+	 .pinId = CMB_PIN_EEDO_ID,
+	 .regNum = 4,
+	 .pFuncOnArray = eedoPinOhRegs,
+	 .pFuncOffArray = eedoPinOlRegs,
+	 },
+	{
+	 .pinId = CMB_PIN_GSYNC_ID,
+	 .regNum = 1,
+	 .pFuncOnArray = gsyncPinOnRegs,
+	 .pFuncOffArray = gsyncPinOffRegs,
+	 }
+};
+#endif
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+#if CFG_FUNC_BT_SUPPORT
+
+INT32 _osal_inline_ wmt_func_bt_ctrl(ENUM_FUNC_STATE funcState)
+{
+	/*only need to send turn BT subsystem wmt command */
+	return wmt_core_func_ctrl_cmd(WMTDRV_TYPE_BT, (FUNC_ON == funcState) ? MTK_WCN_BOOL_TRUE : MTK_WCN_BOOL_FALSE);
+}
+
+INT32 wmt_func_bt_on(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf)
+{
+	/* return wmt_func_bt_ctrl(FUNC_ON); */
+	INT32 iRet = -1;
+	unsigned long ctrlPa1;
+	unsigned long ctrlPa2;
+
+	ctrlPa1 = BT_PALDO;
+	ctrlPa2 = PALDO_ON;
+	iRet = wmt_core_ctrl(WMT_CTRL_SOC_PALDO_CTRL, &ctrlPa1, &ctrlPa2);
+	if (iRet) {
+		WMT_ERR_FUNC("wmt-func: wmt_ctrl_soc_paldo_ctrl failed(%d)(%d)(%d)\n", iRet, ctrlPa1, ctrlPa2);
+		return -1;
+	}
+	iRet = wmt_core_func_ctrl_cmd(WMTDRV_TYPE_BT, MTK_WCN_BOOL_TRUE);
+	if (iRet) {
+		WMT_ERR_FUNC("wmt-func: wmt_core_func_ctrl_cmd(bt_on) failed(%d)\n", iRet);
+		ctrlPa1 = BT_PALDO;
+		ctrlPa2 = PALDO_OFF;
+		wmt_core_ctrl(WMT_CTRL_SOC_PALDO_CTRL, &ctrlPa1, &ctrlPa2);
+
+		/*do coredump when bt on fail */
+		wmt_core_set_coredump_state(DRV_STS_FUNC_ON);
+		ctrlPa1 = WMTDRV_TYPE_BT;
+		ctrlPa2 = 32;
+		wmt_core_ctrl(WMT_CTRL_EVT_ERR_TRG_ASSERT, &ctrlPa1, &ctrlPa2);
+		return -2;
+	}
+	osal_set_bit(WMT_BT_ON, &gBtWifiGpsState);
+	if (osal_test_bit(WMT_GPS_ON, &gBtWifiGpsState)) {
+		/* send msg to GPS native for sending de-sense CMD */
+		ctrlPa1 = 1;
+		ctrlPa2 = 0;
+		wmt_core_ctrl(WMT_CTRL_BGW_DESENSE_CTRL, &ctrlPa1, &ctrlPa2);
+	}
+		return 0;
+}
+
+INT32 wmt_func_bt_off(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf)
+{
+	/* return wmt_func_bt_ctrl(FUNC_OFF); */
+	INT32 iRet1 = -1;
+	INT32 iRet2 = -1;
+	unsigned long ctrlPa1;
+	unsigned long ctrlPa2;
+
+	iRet1 = wmt_core_func_ctrl_cmd(WMTDRV_TYPE_BT, MTK_WCN_BOOL_FALSE);
+	if (iRet1)
+		WMT_ERR_FUNC("wmt-func: wmt_core_func_ctrl_cmd(bt_off) failed(%d)\n", iRet1);
+
+	ctrlPa1 = BT_PALDO;
+	ctrlPa2 = PALDO_OFF;
+	iRet2 = wmt_core_ctrl(WMT_CTRL_SOC_PALDO_CTRL, &ctrlPa1, &ctrlPa2);
+	if (iRet2)
+		WMT_ERR_FUNC("wmt-func: wmt_ctrl_soc_paldo_ctrl(bt_off) failed(%d)\n", iRet2);
+
+	if (iRet1 + iRet2) {
+		/*do coredump when bt off fail */
+		wmt_core_set_coredump_state(DRV_STS_FUNC_ON);
+		ctrlPa1 = WMTDRV_TYPE_BT;
+		ctrlPa2 = 32;
+		wmt_core_ctrl(WMT_CTRL_EVT_ERR_TRG_ASSERT, &ctrlPa1, &ctrlPa2);
+		return -1;
+	}
+
+	osal_clear_bit(WMT_BT_ON, &gBtWifiGpsState);
+	if ((!osal_test_bit(WMT_WIFI_ON, &gBtWifiGpsState)) && (osal_test_bit(WMT_GPS_ON, &gBtWifiGpsState))) {
+		/* send msg to GPS native for stopping send de-sense CMD */
+		ctrlPa1 = 0;
+		ctrlPa2 = 0;
+		wmt_core_ctrl(WMT_CTRL_BGW_DESENSE_CTRL, &ctrlPa1, &ctrlPa2);
+	}
+	return 0;
+}
+
+#endif
+
+#if CFG_FUNC_GPS_SUPPORT
+
+INT32 _osal_inline_ wmt_func_gps_ctrl(ENUM_FUNC_STATE funcState)
+{
+	/*send turn GPS subsystem wmt command */
+	return wmt_core_func_ctrl_cmd(WMTDRV_TYPE_GPS, (FUNC_ON == funcState) ? MTK_WCN_BOOL_TRUE : MTK_WCN_BOOL_FALSE);
+}
+
+INT32 wmt_func_gps_pre_ctrl(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf, ENUM_FUNC_STATE funcStatus)
+{
+	UINT32 i = 0;
+	INT32 iRet = 0;
+	UINT32 regAddr = 0;
+	UINT32 regValue = 0;
+	UINT32 regMask = 0;
+	UINT32 regNum = 0;
+	P_CMB_PIN_CTRL_REG pReg;
+	P_CMB_PIN_CTRL pCmbPinCtrl = &gCmbPinCtrl[CMB_PIN_GSYNC_ID];
+	WMT_CTRL_DATA ctrlData;
+	WMT_IC_PIN_ID wmtIcPinId = WMT_IC_PIN_MAX;
+	/* sanity check */
+	if (FUNC_ON != funcStatus && FUNC_OFF != funcStatus) {
+		WMT_ERR_FUNC("invalid funcStatus(%d)\n", funcStatus);
+		return -1;
+	}
+	/* turn on GPS sync function on both side */
+	ctrlData.ctrlId = WMT_CTRL_GPS_SYNC_SET;
+	ctrlData.au4CtrlData[0] = (FUNC_ON == funcStatus) ? 1 : 0;
+	iRet = wmt_ctrl(&ctrlData);
+	if (iRet) {
+		/*we suppose this would never print */
+		WMT_ERR_FUNC("ctrl GPS_SYNC_SET(%d) fail, ret(%d)\n", funcStatus, iRet);
+		/* TODO:[FixMe][George] error handling? */
+		return -2;
+	}
+	WMT_INFO_FUNC("ctrl GPS_SYNC_SET(%d) ok\n", funcStatus);
+
+
+	if ((NULL == pOps->ic_pin_ctrl) ||
+		(0 > pOps->ic_pin_ctrl(
+				WMT_IC_PIN_GSYNC,
+				FUNC_ON == funcStatus ? WMT_IC_PIN_MUX : WMT_IC_PIN_GPIO,
+				1))) {	/*WMT_IC_PIN_GSYNC */
+		pCmbPinCtrl = &gCmbPinCtrl[CMB_PIN_GSYNC_ID];
+		regNum = pCmbPinCtrl->regNum;
+		for (i = 0; i < regNum; i++) {
+			if (FUNC_ON == funcStatus)
+				pReg = &pCmbPinCtrl->pFuncOnArray[i];
+			else
+				pReg = &pCmbPinCtrl->pFuncOffArray[i];
+
+			regAddr = pReg->regAddr;
+			regValue = pReg->regValue;
+			regMask = pReg->regMask;
+
+			iRet = wmt_core_reg_rw_raw(1, regAddr, &regValue, regMask);
+			if (iRet) {
+				WMT_ERR_FUNC("set reg for GPS_SYNC function fail(%d)\n", iRet);
+				/* TODO:[FixMe][Chaozhong] error handling? */
+				return -2;
+			}
+
+		}
+	} else {
+		WMT_INFO_FUNC("set reg for GPS_SYNC function okay by chip ic_pin_ctrl\n");
+	}
+	WMT_INFO_FUNC("ctrl combo chip gps sync function succeed\n");
+	/* turn on GPS lna ctrl function */
+	if (NULL != pConf) {
+		if (0 == pConf->wmt_gps_lna_enable) {
+
+			WMT_INFO_FUNC("host pin used for gps lna\n");
+			/* host LNA ctrl pin needed */
+			ctrlData.ctrlId = WMT_CTRL_GPS_LNA_SET;
+			ctrlData.au4CtrlData[0] = FUNC_ON == funcStatus ? 1 : 0;
+			iRet = wmt_ctrl(&ctrlData);
+			if (iRet) {
+				/*we suppose this would never print */
+				WMT_ERR_FUNC("ctrl host GPS_LNA output high fail, ret(%d)\n", iRet);
+				/* TODO:[FixMe][Chaozhong] error handling? */
+				return -3;
+			}
+			WMT_INFO_FUNC("ctrl host gps lna function succeed\n");
+		} else {
+			WMT_INFO_FUNC("combo chip pin(%s) used for gps lna\n",
+				      0 == pConf->wmt_gps_lna_pin ? "EEDI" : "EEDO");
+			wmtIcPinId = 0 == pConf->wmt_gps_lna_pin ? WMT_IC_PIN_EEDI : WMT_IC_PIN_EEDO;
+			if ((NULL == pOps->ic_pin_ctrl) ||
+				(0 > pOps->ic_pin_ctrl(
+					wmtIcPinId,
+					FUNC_ON == funcStatus ? WMT_IC_PIN_GPIO_HIGH : WMT_IC_PIN_GPIO_LOW,
+					1))) {	/*WMT_IC_PIN_GSYNC */
+				if (0 == pConf->wmt_gps_lna_pin) {
+					/* EEDI needed */
+					pCmbPinCtrl = &gCmbPinCtrl[CMB_PIN_EEDI_ID];
+				} else if (1 == pConf->wmt_gps_lna_pin) {
+					/* EEDO needed */
+					pCmbPinCtrl = &gCmbPinCtrl[CMB_PIN_EEDO_ID];
+				}
+				regNum = pCmbPinCtrl->regNum;
+				for (i = 0; i < regNum; i++) {
+					if (FUNC_ON == funcStatus)
+						pReg = &pCmbPinCtrl->pFuncOnArray[i];
+					else
+						pReg = &pCmbPinCtrl->pFuncOffArray[i];
+					regAddr = pReg->regAddr;
+					regValue = pReg->regValue;
+					regMask = pReg->regMask;
+
+					iRet = wmt_core_reg_rw_raw(1, regAddr, &regValue, regMask);
+					if (iRet) {
+						WMT_ERR_FUNC("set reg for GPS_LNA function fail(%d)\n", iRet);
+						/* TODO:[FixMe][Chaozhong] error handling? */
+						return -3;
+					}
+				}
+				WMT_INFO_FUNC("ctrl combo chip gps lna succeed\n");
+			} else {
+				WMT_INFO_FUNC("set reg for GPS_LNA function okay by chip ic_pin_ctrl\n");
+			}
+		}
+	}
+	return 0;
+
+}
+
+INT32 wmt_func_gps_pre_on(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf)
+{
+	return wmt_func_gps_pre_ctrl(pOps, pConf, FUNC_ON);
+}
+
+INT32 wmt_func_gps_pre_off(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf)
+{
+
+	return wmt_func_gps_pre_ctrl(pOps, pConf, FUNC_OFF);
+}
+
+INT32 wmt_func_gps_on(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf)
+{
+	INT32 iRet = 0;
+	unsigned long ctrlPa1;
+	unsigned long ctrlPa2;
+	UINT8 co_clock_type = (pConf->co_clock_flag & 0x0f);
+
+	if ((co_clock_type) && (0 == pConf->wmt_gps_lna_enable)) {	/* use SOC external LNA */
+		if (!osal_test_bit(WMT_FM_ON, &gGpsFmState)) {
+			ctrlPa1 = GPS_PALDO;
+			ctrlPa2 = PALDO_ON;
+			wmt_core_ctrl(WMT_CTRL_SOC_PALDO_CTRL, &ctrlPa1, &ctrlPa2);
+		} else {
+			WMT_INFO_FUNC("LDO VCN28 has been turn on by FM\n");
+		}
+	}
+
+	iRet = wmt_func_gps_pre_on(pOps, pConf);
+	if (0 == iRet) {
+		iRet = wmt_func_gps_ctrl(FUNC_ON);
+		if (!iRet) {
+			osal_set_bit(WMT_GPS_ON, &gBtWifiGpsState);
+			if ((osal_test_bit(WMT_BT_ON, &gBtWifiGpsState))
+			    || (osal_test_bit(WMT_WIFI_ON, &gBtWifiGpsState))) {
+				/* send msg to GPS native for sending de-sense CMD */
+				ctrlPa1 = 1;
+				ctrlPa2 = 0;
+				wmt_core_ctrl(WMT_CTRL_BGW_DESENSE_CTRL, &ctrlPa1, &ctrlPa2);
+			}
+
+			if ((co_clock_type) && (0 == pConf->wmt_gps_lna_enable))	/* use SOC external LNA */
+				osal_set_bit(WMT_GPS_ON, &gGpsFmState);
+		}
+	}
+	return iRet;
+}
+
+INT32 wmt_func_gps_off(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf)
+{
+	INT32 iRet = 0;
+	unsigned long ctrlPa1 = 0;
+	unsigned long ctrlPa2 = 0;
+	UINT8 co_clock_type = (pConf->co_clock_flag & 0x0f);
+
+	iRet = wmt_func_gps_pre_off(pOps, pConf);
+	if (0 == iRet) {
+		iRet = wmt_func_gps_ctrl(FUNC_OFF);
+		if (!iRet) {
+			osal_clear_bit(WMT_GPS_ON, &gBtWifiGpsState);
+			if ((osal_test_bit(WMT_BT_ON, &gBtWifiGpsState))
+			    || (osal_test_bit(WMT_WIFI_ON, &gBtWifiGpsState))) {
+				/* send msg to GPS native for stop sending de-sense CMD */
+				ctrlPa1 = 0;
+				ctrlPa2 = 0;
+				wmt_core_ctrl(WMT_CTRL_BGW_DESENSE_CTRL, &ctrlPa1, &ctrlPa2);
+			}
+		}
+	}
+
+	if ((co_clock_type) && (0 == pConf->wmt_gps_lna_enable)) {	/* use SOC external LNA */
+		if (osal_test_bit(WMT_FM_ON, &gGpsFmState))
+			WMT_INFO_FUNC("FM is still on, do not turn off LDO VCN28\n");
+		else {
+			ctrlPa1 = GPS_PALDO;
+			ctrlPa2 = PALDO_OFF;
+			wmt_core_ctrl(WMT_CTRL_SOC_PALDO_CTRL, &ctrlPa1, &ctrlPa2);
+		}
+
+		osal_clear_bit(WMT_GPS_ON, &gGpsFmState);
+	}
+
+	return iRet;
+
+}
+#endif
+
+#if CFG_FUNC_FM_SUPPORT
+
+INT32 _osal_inline_ wmt_func_fm_ctrl(ENUM_FUNC_STATE funcState)
+{
+	/*only need to send turn FM subsystem wmt command */
+	return wmt_core_func_ctrl_cmd(WMTDRV_TYPE_FM, (FUNC_ON == funcState) ? MTK_WCN_BOOL_TRUE : MTK_WCN_BOOL_FALSE);
+}
+
+INT32 wmt_func_fm_on(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf)
+{
+	/* return wmt_func_fm_ctrl(FUNC_ON); */
+	unsigned long ctrlPa1 = 0;
+	unsigned long ctrlPa2 = 0;
+	INT32 iRet = -1;
+	UINT8 co_clock_type = (pConf->co_clock_flag & 0x0f);
+
+	if (co_clock_type) {
+		if (!osal_test_bit(WMT_GPS_ON, &gGpsFmState)) {
+			ctrlPa1 = FM_PALDO;
+			ctrlPa2 = PALDO_ON;
+			wmt_core_ctrl(WMT_CTRL_SOC_PALDO_CTRL, &ctrlPa1, &ctrlPa2);
+		} else {
+			WMT_INFO_FUNC("LDO VCN28 has been turn on by GPS\n");
+		}
+	}
+
+	iRet = wmt_core_func_ctrl_cmd(WMTDRV_TYPE_FM, MTK_WCN_BOOL_TRUE);
+	if (!iRet) {
+		if (co_clock_type)
+			osal_set_bit(WMT_FM_ON, &gGpsFmState);
+	}
+
+	return iRet;
+}
+
+INT32 wmt_func_fm_off(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf)
+{
+	/* return wmt_func_fm_ctrl(FUNC_OFF); */
+	unsigned long ctrlPa1 = 0;
+	unsigned long ctrlPa2 = 0;
+	INT32 iRet = -1;
+	UINT8 co_clock_type = (pConf->co_clock_flag & 0x0f);
+
+	iRet = wmt_core_func_ctrl_cmd(WMTDRV_TYPE_FM, MTK_WCN_BOOL_FALSE);
+
+	if (co_clock_type) {
+		if (osal_test_bit(WMT_GPS_ON, &gGpsFmState)) {
+			WMT_INFO_FUNC("GPS is still on, do not turn off LDO VCN28\n");
+		} else {
+			ctrlPa1 = FM_PALDO;
+			ctrlPa2 = PALDO_OFF;
+			wmt_core_ctrl(WMT_CTRL_SOC_PALDO_CTRL, &ctrlPa1, &ctrlPa2);
+		}
+
+		osal_clear_bit(WMT_FM_ON, &gGpsFmState);
+	}
+
+	return iRet;
+}
+
+#endif
+
+#if CFG_FUNC_WIFI_SUPPORT
+
+/*in soc, wmt turn on wifi directly, no not need operate SDIO*/
+#if 0
+INT32 wmt_func_wifi_ctrl(ENUM_FUNC_STATE funcState)
+{
+	INT32 iRet = 0;
+	unsigned long ctrlPa1 = WMT_SDIO_FUNC_WIFI;
+	unsigned long ctrlPa2 = (FUNC_ON == funcState) ? 1 : 0;	/* turn on Wi-Fi driver */
+
+	iRet = wmt_core_ctrl(WMT_CTRL_SDIO_FUNC, &ctrlPa1, &ctrlPa2);
+	if (iRet) {
+		WMT_ERR_FUNC("WMT-FUNC: turn on WIFI function fail (%d)", iRet);
+		return -1;
+	}
+	return 0;
+}
+#endif
+
+INT32 wmt_func_wifi_on(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf)
+{
+	int iRet = 0;
+	unsigned long ctrlPa1;
+	unsigned long ctrlPa2;
+
+	if (NULL != mtk_wcn_wlan_probe) {
+
+		WMT_WARN_FUNC("WMT-FUNC: wmt wlan func on before wlan probe\n");
+		iRet = (*mtk_wcn_wlan_probe) ();
+		if (iRet) {
+			WMT_ERR_FUNC("WMT-FUNC: wmt call wlan probe fail(%d)\n", iRet);
+			iRet = -1;
+		} else {
+			WMT_WARN_FUNC("WMT-FUNC: wmt call wlan probe ok\n");
+		}
+	} else {
+		WMT_ERR_FUNC("WMT-FUNC: null pointer mtk_wcn_wlan_probe\n");
+		gWifiProbed = 1;
+		iRet = -2;
+	}
+
+	if (!iRet) {
+		osal_set_bit(WMT_WIFI_ON, &gBtWifiGpsState);
+		if (osal_test_bit(WMT_GPS_ON, &gBtWifiGpsState)) {
+			/* send msg to GPS native for sending de-sense CMD */
+			ctrlPa1 = 1;
+			ctrlPa2 = 0;
+			wmt_core_ctrl(WMT_CTRL_BGW_DESENSE_CTRL, &ctrlPa1, &ctrlPa2);
+		}
+	}
+	return iRet;
+#if 0
+	return wmt_func_wifi_ctrl(FUNC_ON);
+#endif
+}
+
+INT32 wmt_func_wifi_off(P_WMT_IC_OPS pOps, P_WMT_GEN_CONF pConf)
+{
+	int iRet = 0;
+
+	unsigned long ctrlPa1 = 0;
+	unsigned long ctrlPa2 = 0;
+
+	if (NULL != mtk_wcn_wlan_remove) {
+
+		WMT_WARN_FUNC("WMT-FUNC: wmt wlan func on before wlan remove\n");
+		iRet = (*mtk_wcn_wlan_remove) ();
+		if (iRet) {
+			WMT_ERR_FUNC("WMT-FUNC: wmt call wlan remove fail(%d)\n", iRet);
+			iRet = -1;
+		} else {
+			WMT_WARN_FUNC("WMT-FUNC: wmt call wlan remove ok\n");
+		}
+	} else {
+		WMT_ERR_FUNC("WMT-FUNC: null pointer mtk_wcn_wlan_remove\n");
+		iRet = -2;
+	}
+
+	if (!iRet) {
+		osal_clear_bit(WMT_WIFI_ON, &gBtWifiGpsState);
+		if ((!osal_test_bit(WMT_BT_ON, &gBtWifiGpsState)) && (osal_test_bit(WMT_GPS_ON, &gBtWifiGpsState))) {
+			/* send msg to GPS native for stopping send de-sense CMD */
+			ctrlPa1 = 0;
+			ctrlPa2 = 0;
+			wmt_core_ctrl(WMT_CTRL_BGW_DESENSE_CTRL, &ctrlPa1, &ctrlPa2);
+		}
+	}
+	return iRet;
+#if 0
+	return wmt_func_wifi_ctrl(FUNC_OFF);
+#endif
+}
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_ic_soc.c b/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_ic_soc.c
new file mode 100644
index 00000000..c07052b
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_ic_soc.c
@@ -0,0 +1,2452 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[WMT-IC]"
+#define CFG_IC_SOC 1
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+#include "osal_typedef.h"
+#include "wmt_ic.h"
+#include "wmt_core.h"
+#include "wmt_lib.h"
+#include "stp_core.h"
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+#define DEFAULT_PATCH_FRAG_SIZE (1000)
+#define WMT_PATCH_FRAG_1ST (0x1)
+#define WMT_PATCH_FRAG_MID (0x2)
+#define WMT_PATCH_FRAG_LAST (0x3)
+
+#define CFG_CHECK_WMT_RESULT (1)
+/* BT Port 2 Feature. this command does not need
+ *  after coex command is downconfirmed by LC,
+ */
+#define CFG_WMT_BT_PORT2 (0)
+
+#define CFG_SET_OPT_REG (0)
+#define CFG_WMT_I2S_DBGUART_SUPPORT (0)
+#define CFG_SET_OPT_REG_SWLA (0)
+#define CFG_SET_OPT_REG_MCUCLK (0)
+#define CFG_SET_OPT_REG_MCUIRQ (0)
+
+#define CFG_SUBSYS_COEX_NEED 0
+
+#define CFG_WMT_COREDUMP_ENABLE 0
+
+#define CFG_WMT_MULTI_PATCH (1)
+
+#define CFG_WMT_CRYSTAL_TIMING_SET (0)
+
+#define CFG_WMT_SDIO_DRIVING_SET (0)
+
+#define CFG_WMT_UART_HIF_USE (0)
+
+#define CFG_WMT_WIFI_5G_SUPPORT (1)
+
+#define CFG_WMT_PATCH_DL_OPTM (1)
+#if CFG_WMT_LTE_COEX_HANDLING
+#define CFG_WMT_FILTER_MODE_SETTING (1)
+#else
+#define CFG_WMT_FILTER_MODE_SETTING (0)
+#endif
+#define MTK_WCN_CMB_MERGE_INTERFACE_SUPPORT (0)
+
+#define CFG_WMT_POWER_ON_DLM  (1)
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+static UINT8 gFullPatchName[NAME_MAX + 1];
+static const WMT_IC_INFO_S *gp_soc_info;
+static WMT_PATCH gp_soc_patch_info;
+static WMT_CO_CLOCK gCoClockEn = WMT_CO_CLOCK_DIS;
+#if 0
+static UINT8 WMT_WAKEUP_DIS_GATE_CMD[] = { 0x1, 0x3, 0x01, 0x00, 0x04 };
+static UINT8 WMT_WAKEUP_DIS_GATE_EVT[] = { 0x2, 0x3, 0x02, 0x0, 0x0, 0x04 };
+
+static UINT8 WMT_WAKEUP_EN_GATE_CMD[] = { 0x1, 0x3, 0x01, 0x00, 0x05 };
+static UINT8 WMT_WAKEUP_EN_GATE_EVT[] = { 0x2, 0x3, 0x02, 0x0, 0x0, 0x05 };
+#endif
+
+#if CFG_WMT_UART_HIF_USE
+static UINT8 WMT_QUERY_BAUD_CMD[] = { 0x01, 0x04, 0x01, 0x00, 0x02 };
+static UINT8 WMT_QUERY_BAUD_EVT_115200[] = { 0x02, 0x04, 0x06, 0x00, 0x00, 0x02, 0x00, 0xC2, 0x01, 0x00 };
+static UINT8 WMT_QUERY_BAUD_EVT_X[] = { 0x02, 0x04, 0x06, 0x00, 0x00, 0x02, 0xAA, 0xAA, 0xAA, 0xBB };
+static UINT8 WMT_SET_BAUD_CMD_X[] = { 0x01, 0x04, 0x05, 0x00, 0x01, 0xAA, 0xAA, 0xAA, 0xBB };
+static UINT8 WMT_SET_BAUD_EVT[] = { 0x02, 0x04, 0x02, 0x00, 0x00, 0x01 };
+static UINT8 WMT_SET_WAKEUP_WAKE_CMD_RAW[] = { 0xFF };
+static UINT8 WMT_SET_WAKEUP_WAKE_EVT[] = { 0x02, 0x03, 0x02, 0x00, 0x00, 0x03 };
+#endif
+static UINT8 WMT_QUERY_STP_CMD[] = { 0x01, 0x04, 0x01, 0x00, 0x04 };
+static UINT8 WMT_QUERY_STP_EVT_DEFAULT[] = { 0x02, 0x04, 0x06, 0x00, 0x00, 0x04, 0x11, 0x00, 0x00, 0x00 };
+static UINT8 WMT_QUERY_STP_EVT[] = { 0x02, 0x04, 0x06, 0x00, 0x00, 0x04, 0xDF, 0x0E, 0x68, 0x01 };
+static UINT8 WMT_PATCH_CMD[] = { 0x01, 0x01, 0x00, 0x00, 0x00 };
+static UINT8 WMT_PATCH_EVT[] = { 0x02, 0x01, 0x01, 0x00, 0x00 };
+static UINT8 WMT_RESET_CMD[] = { 0x01, 0x07, 0x01, 0x00, 0x04 };
+static UINT8 WMT_RESET_EVT[] = { 0x02, 0x07, 0x01, 0x00, 0x00 };
+
+#if CFG_WMT_BT_PORT2
+static UINT8 WMT_BTP2_CMD[] = { 0x01, 0x10, 0x03, 0x00, 0x01, 0x03, 0x01 };
+static UINT8 WMT_BTP2_EVT[] = { 0x02, 0x10, 0x01, 0x00, 0x00 };
+#endif
+
+/*soc patial patch address cmd & evt need firmware owner provide*/
+#if CFG_WMT_MULTI_PATCH
+static UINT8 WMT_PATCH_ADDRESS_CMD[] = {
+		0x01, 0x08, 0x10, 0x00,
+		0x01, 0x01, 0x00, 0x01,
+		0x3c, 0x02, 0x09, 0x02,
+		0x00, 0x00, 0x00, 0x00,
+		0xff, 0xff, 0xff, 0xff
+};
+static UINT8 WMT_PATCH_ADDRESS_EVT[] = { 0x02, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01 };
+
+static UINT8 WMT_PATCH_P_ADDRESS_CMD[] = {
+		0x01, 0x08, 0x10, 0x00,
+		0x01, 0x01, 0x00, 0x01,
+		0xc4, 0x04, 0x09, 0x02,
+		0x00, 0x3f, 0x00, 0x01,
+		0xff, 0xff, 0xff, 0xff
+};
+static UINT8 WMT_PATCH_P_ADDRESS_EVT[] = { 0x02, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01 };
+#endif
+
+/*coex cmd/evt++*/
+static UINT8 WMT_COEX_SETTING_CONFIG_CMD[] = { 0x01, 0x10, 0x02, 0x00, 0x01, 0x00 };
+static UINT8 WMT_COEX_SETTING_CONFIG_EVT[] = { 0x02, 0x10, 0x01, 0x00, 0x00 };
+
+#if CFG_SUBSYS_COEX_NEED
+static UINT8 WMT_BT_COEX_SETTING_CONFIG_CMD[] = { 0x01, 0x10, 0x0B,
+	0x00, 0x02,
+	0x00, 0x00, 0x00, 0x00,
+	0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0xAA
+};
+static UINT8 WMT_BT_COEX_SETTING_CONFIG_EVT[] = { 0x02, 0x10, 0x01, 0x00, 0x00 };
+
+static UINT8 WMT_WIFI_COEX_SETTING_CONFIG_CMD[] = { 0x01, 0x10, 0x0C,
+	0x00, 0x03,
+	0x00, 0x00, 0x00, 0x00, 0x00,
+	0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0xAA
+};
+static UINT8 WMT_WIFI_COEX_SETTING_CONFIG_EVT[] = { 0x02, 0x10, 0x01, 0x00, 0x00 };
+
+static UINT8 WMT_PTA_COEX_SETTING_CONFIG_CMD[] = { 0x01, 0x10, 0x0A,
+	0x00, 0x04,
+	0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xEE, 0xFF, 0xFF, 0xFE
+};
+static UINT8 WMT_PTA_COEX_SETTING_CONFIG_EVT[] = { 0x02, 0x10, 0x01, 0x00, 0x00 };
+
+static UINT8 WMT_MISC_COEX_SETTING_CONFIG_CMD[] = { 0x01, 0x10, 0x09,
+	0x00, 0x05,
+	0xAA, 0xAA, 0xAA, 0xAA,
+	0xBB, 0xBB, 0xBB, 0xBB
+};
+static UINT8 WMT_MISC_COEX_SETTING_CONFIG_EVT[] = { 0x02, 0x10, 0x01, 0x00, 0x00 };
+#endif
+
+/*coex cmd/evt--*/
+static UINT8 WMT_SET_STP_CMD[] = { 0x01, 0x04, 0x05, 0x00, 0x03, 0xDF, 0x0E, 0x68, 0x01 };
+static UINT8 WMT_SET_STP_EVT[] = { 0x02, 0x04, 0x02, 0x00, 0x00, 0x03 };
+static UINT8 WMT_STRAP_CONF_CMD_FM_COMM[] = { 0x01, 0x05, 0x02, 0x00, 0x02, 0x02 };
+static UINT8 WMT_STRAP_CONF_EVT[] = { 0x02, 0x05, 0x02, 0x00, 0x00, 0x02 };
+
+#if 0
+static UINT8 WMT_SET_OSC32K_BYPASS_CMD[] = { 0x01, 0x0A, 0x01, 0x00, 0x05 };
+static UINT8 WMT_SET_OSC32K_BYPASS_EVT[] = { 0x02, 0x0A, 0x01, 0x00, 0x00 };
+#endif
+
+#if 0
+/* to enable dump feature */
+static UINT8 WMT_CORE_DUMP_EN_CMD[] = { 0x01, 0x0F, 0x02, 0x00, 0x03, 0x01 };
+static UINT8 WMT_CORE_DUMP_EN_EVT[] = { 0x02, 0x0F, 0x01, 0x00, 0x00 };
+
+/* to get system stack dump when f/w assert */
+static UINT8 WMT_CORE_DUMP_LEVEL_01_CMD[] = { 0x1, 0x0F, 0x07, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+static UINT8 WMT_CORE_DUMP_LEVEL_01_EVT[] = { 0x2, 0x0F, 0x01, 0x00, 0x00 };
+
+/* to get task and system stack dump when f/w assert */
+static UINT8 WMT_CORE_DUMP_LEVEL_02_CMD[] = { 0x1, 0x0F, 0x07, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+static UINT8 WMT_CORE_DUMP_LEVEL_02_EVT[] = { 0x2, 0x0F, 0x01, 0x00, 0x00 };
+
+/* to get bt related memory dump when f/w assert */
+static UINT8 WMT_CORE_DUMP_LEVEL_03_CMD[] = { 0x1, 0x0F, 0x07, 0x00, 0x03, 0x00, 0x00, 0x09, 0xF0, 0x00, 0x0A };
+static UINT8 WMT_CORE_DUMP_LEVEL_03_EVT[] = { 0x2, 0x0F, 0x01, 0x00, 0x00 };
+#endif
+/* to get full dump when f/w assert */
+static UINT8 WMT_CORE_DUMP_LEVEL_04_CMD[] = { 0x1, 0x0F, 0x07, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+static UINT8 WMT_CORE_DUMP_LEVEL_04_EVT[] = { 0x2, 0x0F, 0x01, 0x00, 0x00 };
+
+static UINT8 WMT_CORE_CO_CLOCK_CMD[] = { 0x1, 0x0A, 0x02, 0x00, 0x08, 0x03 };
+static UINT8 WMT_CORE_CO_CLOCK_EVT[] = { 0x2, 0x0A, 0x01, 0x00, 0x00 };
+
+static UINT8 WMT_CORE_START_RF_CALIBRATION_CMD[] = { 0x1, 0x14, 0x1, 0x00, 0x01 };
+static UINT8 WMT_CORE_START_RF_CALIBRATION_EVT[] = { 0x2, 0x14, 0x02, 0x00, 0x00, 0x01 };
+
+#if (MTK_WCN_CMB_MERGE_INTERFACE_SUPPORT)
+static UINT8 WMT_SET_I2S_SLAVE_REG_CMD[] = { 0x01, 0x08, 0x10, 0x00	/*length */
+	    , 0x01		/* op: w */
+	    , 0x01		/*type: reg */
+	    , 0x00		/*rev */
+	    , 0x01		/*1 registers */
+	    , 0x78, 0x00, 0x05, 0x80	/*addr:0x80050078 */
+	    , 0x00, 0x00, 0x11, 0x01	/*value:0x11010000 */
+	    , 0x00, 0x00, 0x77, 0x07	/*mask:0x07770000 */
+};
+
+static UINT8 WMT_SET_I2S_SLAVE_REG_EVT[] = { 0x02, 0x08, 0x04, 0x00	/*length */
+	    , 0x00		/*S: 0 */
+	    , 0x00		/*type: reg */
+	    , 0x00		/*rev */
+	    , 0x01		/*1 registers */
+};
+
+static UINT8 WMT_SET_DAI_TO_PAD_REG_CMD[] = { 0x01, 0x08, 0x10, 0x00	/*length */
+	    , 0x01		/* op: w */
+	    , 0x01		/*type: reg */
+	    , 0x00		/*rev */
+	    , 0x01		/*1 registers */
+	    , 0x74, 0x00, 0x05, 0x80	/*addr:0x80050074 */
+	    , 0x44, 0x44, 0x00, 0x00	/*value:0x11010000 */
+	    , 0x77, 0x77, 0x00, 0x00	/*mask:0x07770000 */
+};
+
+static UINT8 WMT_SET_DAI_TO_PAD_REG_EVT[] = { 0x02, 0x08, 0x04, 0x00	/*length */
+	    , 0x00		/*S: 0 */
+	    , 0x00		/*type: reg */
+	    , 0x00		/*rev */
+	    , 0x01		/*1 registers */
+};
+
+static UINT8 WMT_SET_DAI_REG_CMD[] = { 0x01, 0x08, 0x10, 0x00	/*length */
+	    , 0x01		/* op: w */
+	    , 0x01		/*type: reg */
+	    , 0x00		/*rev */
+	    , 0x01		/*1 registers */
+	    , 0xA0, 0x00, 0x05, 0x80	/*addr:0x80050074 */
+	    , 0x04, 0x00, 0x00, 0x00	/*value:0x11010000 */
+	    , 0x04, 0x00, 0x00, 0x00	/*mask:0x07770000 */
+};
+
+static UINT8 WMT_SET_DAI_REG_EVT[] = { 0x02, 0x08, 0x04, 0x00	/*length */
+	    , 0x00		/*S: 0 */
+	    , 0x00		/*type: reg */
+	    , 0x00		/*rev */
+	    , 0x01		/*1 registers */
+};
+#endif
+
+#if !(CFG_IC_SOC)		/* For MT6628 no need to set ALLEINT registers, done in f/w */
+/* enable all interrupt */
+static UINT8 WMT_SET_ALLINT_REG_CMD[] = { 0x01, 0x08, 0x10, 0x00	/*length */
+	    , 0x01		/* op: w */
+	    , 0x01		/*type: reg */
+	    , 0x00		/*rev */
+	    , 0x01		/*1 registers */
+	    , 0x00, 0x03, 0x05, 0x80	/*addr:0x80050300 */
+	    , 0x00, 0xC4, 0x00, 0x00	/*value:0x0000C400 */
+	    , 0x00, 0xC4, 0x00, 0x00	/*mask:0x0000C400 */
+};
+
+static UINT8 WMT_SET_ALLINT_REG_EVT[] = { 0x02, 0x08, 0x04, 0x00	/*length */
+	    , 0x00		/*S: 0 */
+	    , 0x00		/*type: reg */
+	    , 0x00		/*rev */
+	    , 0x01		/*1 registers */
+};
+
+#endif
+
+#if CFG_SET_OPT_REG_SWLA	/* enable swla: eesk(7) eecs(8) oscen(19) sck0(24) scs0(25)  */
+static UINT8 WMT_SET_SWLA_REG_CMD[] = { 0x01, 0x08, 0x1C, 0x00	/*length */
+	    , 0x01		/* op: w */
+	    , 0x01		/*type: reg */
+	    , 0x00		/*rev */
+	    , 0x02		/*2 registers */
+	    , 0x10, 0x01, 0x05, 0x80	/*addr:0x80050110 */
+	    , 0x10, 0x10, 0x01, 0x00	/*value:0x00011010 */
+	    , 0xF0, 0xF0, 0x0F, 0x00	/*mask:0x000FF0F0 */
+	    , 0x40, 0x01, 0x05, 0x80	/*addr:0x80050140 */
+	    , 0x00, 0x10, 0x01, 0x00	/*value:0x00011000 */
+	    , 0x00, 0xF0, 0x0F, 0x00	/*mask:0x000FF000 */
+};
+
+static UINT8 WMT_SET_SWLA_REG_EVT[] = { 0x02, 0x08, 0x04, 0x00	/*length */
+	    , 0x00		/*S: 0 */
+	    , 0x00		/*type: reg */
+	    , 0x00		/*rev */
+	    , 0x02		/*2 registers */
+};
+#endif
+
+#if CFG_SET_OPT_REG_MCUCLK	/* enable mcu clk: antsel_4, eedi */
+static UINT8 WMT_SET_MCUCLK_REG_CMD[] = { 0x01, 0x08, (4 + 12 * 4), 0x00	/*length */
+	    , 0x01		/* op: w */
+	    , 0x01		/* type: reg */
+	    , 0x00		/* rev */
+	    , 0x04		/* 4 registers */
+	    , 0x00, 0x04, 0x00, 0x80	/* addr:0x8000 0400 */
+	    , 0x00, 0x14, 0x00, 0x00	/* value:0x0000 1400(osc, hclk), 0x0000 1501(PLL, en) */
+	    , 0xFF, 0xFF, 0x00, 0x00	/* mask:0x0000 FFFF */
+	    , 0x80, 0x01, 0x05, 0x80	/* addr:0x8005 0180 */
+	    , 0x12, 0x13, 0x00, 0x00	/* value:0x0000 1312(osc, hclk), 0x0000 1a19(PLL, en) */
+	    , 0xFF, 0xFF, 0x00, 0x00	/* mask:0x0000 FFFF */
+	    , 0x00, 0x01, 0x05, 0x80	/* addr:0x8005 0100 */
+	    , 0x00, 0x00, 0x02, 0x00	/* value:0x0002 0000 */
+	    , 0x00, 0x00, 0x0F, 0x00	/* mask:0x000F 0000 */
+	    , 0x10, 0x01, 0x05, 0x80	/* addr:0x8005 0110 */
+	    , 0x02, 0x00, 0x00, 0x00	/* value:0x0000 0002 */
+	    , 0x0F, 0x00, 0x00, 0x00	/* mask:0x0000 000F */
+};
+
+static UINT8 WMT_SET_MCUCLK_REG_EVT[] = { 0x02, 0x08, 0x04, 0x00	/*length */
+	    , 0x00		/* S: 0 */
+	    , 0x00		/* type: reg */
+	    , 0x00		/* rev */
+	    , 0x04		/* 4 registers */
+};
+#endif
+
+#if CFG_WMT_I2S_DBGUART_SUPPORT	/* register write for debug uart */
+static UINT8 WMT_SET_DBGUART_REG_CMD[] = { 0x01, 0x08, 0x1C, 0x00	/*length */
+	    , 0x01		/* op: w */
+	    , 0x01		/*type: reg */
+	    , 0x00		/*rev */
+	    , 0x02		/*2 registers */
+	    , 0x30, 0x01, 0x05, 0x80	/*addr:0x80050130 */
+	    , 0x00, 0x00, 0x00, 0x00	/*value:0x00000000 */
+	    , 0xF0, 0x0F, 0x00, 0x00	/*mask:0x00000FF0 */
+	    , 0x40, 0x01, 0x05, 0x80	/*addr:0x80050140 */
+	    , 0x00, 0x01, 0x00, 0x00	/*value:0x00000100 */
+	    , 0x00, 0x01, 0x00, 0x00	/*mask:0x00000100 */
+};
+
+static UINT8 WMT_SET_DBGUART_REG_EVT[] = { 0x02, 0x08, 0x04, 0x00	/*length */
+	    , 0x00		/*S: 0 */
+	    , 0x00		/*type: reg */
+	    , 0x00		/*rev */
+	    , 0x02		/*2 registers */
+};
+#endif
+
+#if CFG_SET_OPT_REG_MCUIRQ	/* enable mcu irq: antsel_4, wlan_act */
+#if 1				/* Ray */
+static UINT8 WMT_SET_MCUIRQ_REG_CMD[] = { 0x01, 0x08, (4 + 12 * 4), 0x00	/*length */
+	    , 0x01		/* op: w */
+	    , 0x01		/* type: reg */
+	    , 0x00		/* rev */
+	    , 0x04		/* 4 registers */
+	    , 0x00, 0x04, 0x00, 0x80	/* addr:0x8000_0400 */
+	    , 0x03, 0x14, 0x00, 0x00	/* value:0x0000_1403 check confg debug flag 3 low word */
+	    , 0xFF, 0xFF, 0x00, 0x00	/* mask:0x0000_FFFF */
+	    /* cirq_int_n */
+	    , 0x10, 0x01, 0x05, 0x80	/* addr:0x8005_0110 */
+	    , 0x02, 0x00, 0x00, 0x00	/* value:0x0000_0002 set EEDI as cirq_int_n debug flag (monitor flag2) */
+	    , 0x07, 0x00, 0x00, 0x00	/* mask:0x0000_0007 */
+	    , 0x00, 0x01, 0x05, 0x80	/* addr:0x8005_0100 */
+	    , 0x00, 0x00, 0x02, 0x00	/* value:0x0002_0000 (ANTSEL4=>monitor flag 0, ahb_x2_gt_ck debug flag) */
+	    , 0x00, 0x00, 0x07, 0x00	/* mask:0x0007_0000 */
+	    /* 1.    ARM irq_b, monitor flag 0 */
+	    , 0x80, 0x01, 0x05, 0x80	/* addr:0x8005_0180 */
+	    , 0x1F, 0x1E, 0x00, 0x00	/* value:0x0000_1E1F check mcusys debug flag */
+	    , 0x7F, 0x7F, 0x00, 0x00	/* mask:0x0000_7F7F */
+};
+
+static UINT8 WMT_SET_MCUIRQ_REG_EVT[] = { 0x02, 0x08, 0x04, 0x00	/*length */
+	    , 0x00		/* S: 0 */
+	    , 0x00		/* type: reg */
+	    , 0x00		/* rev */
+	    , 0x04		/* 5 registers */
+};
+#elif 0				/* KC */
+static UINT8 WMT_SET_MCUIRQ_REG_CMD[] = { 0x01, 0x08, (4 + 12 * 5), 0x00	/*length */
+	    , 0x01		/* op: w */
+	    , 0x01		/* type: reg */
+	    , 0x00		/* rev */
+	    , 0x05		/* 5 registers */
+	    , 0x00, 0x04, 0x00, 0x80	/* addr:0x8000_0400 */
+	    , 0x00, 0x02, 0x00, 0x00	/* value:0x0000_0200 [15:8]=0x2 arm irq_b, 0xA irq_bus[5] bt_timcon_irq_b */
+	    , 0x00, 0xFF, 0x00, 0x00	/* mask:0x0000_FF00 */
+	    /* 1.    ARM irq_b, monitor flag 0 */
+	    , 0x80, 0x01, 0x05, 0x80	/* addr:0x8005_0180 */
+	    , 0x18, 0x00, 0x00, 0x00	/* value:0x0000_0018 [6:0]=001_1000 (monitor flag 0 select, MCUSYS, SEL:8) */
+	    , 0x7F, 0x00, 0x00, 0x00	/* mask:0x0000_007F */
+	    , 0x00, 0x01, 0x05, 0x80	/* addr:0x8005_0100 */
+	    , 0x00, 0x00, 0x02, 0x00	/* value:0x0002_0000 (ANTSEL4=>monitor flag 0) */
+	    , 0x00, 0x00, 0x07, 0x00	/* mask:0x0007_0000 */
+	    /* 2.    irq_bus[5] bt_timcon_irq_b monitor flag 15 */
+	    , 0xB0, 0x01, 0x05, 0x80	/* addr:0x8005_01B0 */
+	    , 0x00, 0x00, 0x00, 0x16	/* value:0x1600_0000 [30:24]=001_0110 (monitor flag 15 select, MCUSYS, SEL:6) */
+	    , 0x00, 0x00, 0x00, 0x7F	/* mask:0x7F00_0000 */
+	    , 0x30, 0x01, 0x05, 0x80	/* addr:0x8005_0130 */
+	    , 0x00, 0x20, 0x00, 0x00	/* value:0x0000_2000 (WLAN_ACT=>monitor flag 15) */
+	    , 0x00, 0x70, 0x00, 0x00	/* mask:0x0000_7000 */
+};
+
+static UINT8 WMT_SET_MCUIRQ_REG_EVT[] = { 0x02, 0x08, 0x04, 0x00	/*length */
+	    , 0x00		/* S: 0 */
+	    , 0x00		/* type: reg */
+	    , 0x00		/* rev */
+	    , 0x05		/* 5 registers */
+};
+#endif
+#endif
+
+#if CFG_WMT_CRYSTAL_TIMING_SET
+static UINT8 WMT_SET_CRYSTAL_TRIMING_CMD[] = { 0x01, 0x12, 0x02, 0x00, 0x01, 0x00 };
+static UINT8 WMT_SET_CRYSTAL_TRIMING_EVT[] = { 0x02, 0x12, 0x02, 0x00, 0x01, 0x00 };
+
+static UINT8 WMT_GET_CRYSTAL_TRIMING_CMD[] = { 0x01, 0x12, 0x02, 0x00, 0x00, 0x00 };
+static UINT8 WMT_GET_CRYSTAL_TRIMING_EVT[] = { 0x02, 0x12, 0x02, 0x00, 0x00, 0x00 };
+#endif
+
+#ifdef CFG_WMT_READ_EFUSE_VCN33
+static UINT8 WMT_GET_EFUSE_VCN33_CMD[] = { 0x01, 0x12, 0x02, 0x00, 0x04, 0x00 };
+static UINT8 WMT_GET_EFUSE_VCN33_EVT[] = { 0x02, 0x12, 0x02, 0x00, 0x04, 0x00 };
+#endif
+
+/* set sdio driving */
+#if CFG_WMT_SDIO_DRIVING_SET
+static UINT8 WMT_SET_SDIO_DRV_REG_CMD[] = { 0x01, 0x08, 0x10, 0x00	/*length */
+	    , 0x01		/* op: w */
+	    , 0x01		/*type: reg */
+	    , 0x00		/*rev */
+	    , 0x01		/*1 registers */
+	    , 0x50, 0x00, 0x05, 0x80	/*addr:0x80050050 */
+	    , 0x44, 0x44, 0x04, 0x00	/*value:0x00044444 */
+	    , 0x77, 0x77, 0x07, 0x00	/*mask:0x00077777 */
+};
+
+static UINT8 WMT_SET_SDIO_DRV_REG_EVT[] = { 0x02, 0x08, 0x04, 0x00	/*length */
+	    , 0x00		/*S: 0 */
+	    , 0x00		/*type: reg */
+	    , 0x00		/*rev */
+	    , 0x01		/*1 registers */
+};
+#endif
+
+#if CFG_WMT_WIFI_5G_SUPPORT
+static UINT8 WMT_GET_SOC_ADIE_CHIPID_CMD[] = { 0x01, 0x13, 0x04, 0x00, 0x02, 0x04, 0x24, 0x00 };
+static UINT8 WMT_GET_SOC_ADIE_CHIPID_EVT[] = {
+		0x02, 0x13, 0x09, 0x00, 0x00, 0x02, 0x04, 0x24,
+		0x00, 0x00, 0x00, 0x00, 0x00
+};
+static UINT8 WMT_GET_SOC_6625_L_CMD[] = { 0x01, 0x13, 0x04, 0x00, 0x02, 0x04, 0x20, 0x01 };
+static UINT8 WMT_GET_SOC_6625_L_EVT[] = {
+		0x02, 0x13, 0x09, 0x00, 0x00, 0x02, 0x04, 0x20,
+		0x01, 0x00, 0x00, 0x00, 0x00
+};
+#endif
+
+#if CFG_WMT_PATCH_DL_OPTM
+static UINT8 WMT_SET_MCU_CLK_EN_CMD[] = {
+		0x01, 0x08, 0x10, 0x00,
+		0x01, 0x01, 0x00, 0x01,
+		0x34, 0x03, 0x00, 0x80,
+		0x00, 0x00, 0x01, 0x00,
+		0xff, 0xff, 0xff, 0xff
+};
+static UINT8 WMT_SET_MCU_CLK_EN_EVT[] = { 0x02, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01 };
+
+static UINT8 WMT_SET_MCU_CLK_138_CMD[] = {
+		0x01, 0x08, 0x10, 0x00,
+		0x01, 0x01, 0x00, 0x01,
+		0x0c, 0x01, 0x00, 0x80,
+		0x59, 0x4d, 0x84, 0x00,
+		0xff, 0xff, 0xff, 0xff
+};
+static UINT8 WMT_SET_MCU_CLK_138_EVT[] = { 0x02, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01 };
+
+static UINT8 WMT_SET_MCU_CLK_26_CMD[] = {
+		0x01, 0x08, 0x10, 0x00,
+		0x01, 0x01, 0x00, 0x01,
+		0x0c, 0x01, 0x00, 0x80,
+		0x00, 0x4d, 0x84, 0x00,
+		0xff, 0xff, 0xff, 0xff
+};
+static UINT8 WMT_SET_MCU_CLK_26_EVT[] = { 0x02, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01 };
+
+static UINT8 WMT_SET_MCU_CLK_DIS_CMD[] = {
+		0x01, 0x08, 0x10, 0x00,
+		0x01, 0x01, 0x00, 0x01,
+		0x34, 0x03, 0x00, 0x80,
+		0x00, 0x00, 0x00, 0x00,
+		0xff, 0xff, 0xff, 0xff
+};
+static UINT8 WMT_SET_MCU_CLK_DIS_EVT[] = { 0x02, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01 };
+
+/*only for 6797,enable high clock frequency*/
+/*CLK EN*/
+static UINT8 WMT_SET_MCU_CLK_EN_6797[] = {
+	0x01, 0x08, 0x10, 0x00, 0x01, 0x01, 0x00, 0x01,
+	0x10, 0x11, 0x02, 0x81, 0x00, 0x00, 0x00, 0x10,
+	0x00, 0x00, 0x00, 0x10
+};
+/*RATIO SET*/
+static UINT8 WMT_SET_MCU_RATIO_SET_6797[] = {
+	0x01, 0x08, 0x10, 0x00, 0x01, 0x01, 0x00, 0x01,
+	0x0c, 0x01, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00,
+	0xc0, 0x00, 0x00, 0x00
+};
+/*DIV SET*/
+static UINT8 WMT_SET_MCU_DIV_SET_6797[] = {
+	0x01, 0x08, 0x10, 0x00, 0x01, 0x01, 0x00, 0x01,
+	0x18, 0x11, 0x02, 0x80, 0x07, 0x00, 0x00, 0x00,
+	0x3f, 0x00, 0x00, 0x00
+};
+/*HCLK SET*/
+static UINT8 WMT_SET_MCU_HCLK_SET_6797[] = {
+	0x01, 0x08, 0x10, 0x00, 0x01, 0x01, 0x00, 0x01,
+	0x00, 0x11, 0x02, 0x81, 0x04, 0x00, 0x00, 0x00,
+	0x07, 0x00, 0x00, 0x00
+};
+
+/*Change clock to 26MHz*/
+/*HCLK DIS*/
+static UINT8 WMT_SET_MCU_HCLK_DIS_6797[] = {
+	0x01, 0x08, 0x10, 0x00, 0x01, 0x01, 0x00, 0x01,
+	0x00, 0x11, 0x02, 0x81, 0x00, 0x00, 0x00, 0x00,
+	0x07, 0x00, 0x00, 0x00
+};
+/*RATIO DIS*/
+static UINT8 WMT_SET_MCU_RATIO_DIS_6797[] = {
+	0x01, 0x08, 0x10, 0x00, 0x01, 0x01, 0x00, 0x01,
+	0x0c, 0x01, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
+	0xc0, 0x00, 0x00, 0x00
+};
+/*CLK DIS*/
+static UINT8 WMT_SET_MCU_CLK_DIS_6797[] = {
+	0x01, 0x08, 0x10, 0x00, 0x01, 0x01, 0x00, 0x01,
+	0x10, 0x11, 0x02, 0x81, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x10
+};
+
+static UINT8 WMT_SET_MCU_CLK_EVT_6797[] = {
+	0x02, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01
+};
+
+#endif
+
+#if CFG_WMT_FILTER_MODE_SETTING
+static UINT8 WMT_COEX_EXT_COMPONENT_CMD[] = {0x01, 0x10, 0x03, 0x00, 0x0d, 0x00, 0x00};
+static UINT8 WMT_COEX_FILTER_SPEC_CMD_TEST[] = {
+		0x01, 0x10, 0x45, 0x00, 0x11, 0x00, 0x00, 0x01,
+		0x00, 0x11, 0x11, 0x16, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x63, 0x63, 0x63, 0x00, 0x39, 0x43, 0x63,
+		0x63, 0x02, 0x02, 0x03, 0x00, 0x01, 0x01, 0x01,
+		0x01, 0x0e, 0x0e, 0x0e, 0x00, 0x0a, 0x0c, 0x0e,
+		0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+static UINT8 WMT_COEX_LTE_FREQ_IDX_TABLE_CMD[] = {
+		0x01, 0x10, 0x21, 0x00, 0x12, 0xfc, 0x08, 0x15,
+		0x09, 0x2e, 0x09, 0x47, 0x09, 0xc4, 0x09, 0xd4,
+		0x09, 0xe3, 0x09, 0x5a, 0x0a, 0x14, 0x09, 0x2d,
+		0x09, 0x46, 0x09, 0x60, 0x09, 0xd3, 0x09, 0xe2,
+		0x09, 0x59, 0x0a, 0x8B, 0x0a};
+static UINT8 WMT_COEX_LTE_CHAN_UNSAFE_CMD[] = { 0x01, 0x10, 0x02, 0x00, 0x13, 0x00 };
+static UINT8 WMT_COEX_IS_LTE_L_CMD[] = { 0x01, 0x10, 0x02, 0x00, 0x21, 0x01 };
+
+#if 0
+static UINT8 WMT_COEX_SPLIT_FILTER_CMD_TEST[] = {
+		0x01, 0x10, 0x19, 0x00, 0x0F, 0x00, 0x00, 0x00,
+		0x00, 0x6c, 0x09, 0x8a, 0x09, 0x8a, 0x09, 0x9e,
+		0x09, 0x01, 0x07, 0x07, 0x0b, 0x07, 0x07, 0x00,
+		0x32, 0x27, 0x4e, 0x27, 0x32
+};
+
+static UINT8 WMT_COEX_FILTER_SPEC_CMD_TEST[] = {
+		0x01, 0x10, 0x45, 0x00, 0x11, 0x00, 0x00, 0x01,
+		0x00, 0x07, 0x07, 0x07, 0x54, 0x54, 0x00, 0x00,
+		0x00, 0x50, 0x50, 0x50, 0x54, 0x54, 0x39, 0x39,
+		0x39, 0x02, 0x02, 0x02, 0x0e, 0x0e, 0x01, 0x01,
+		0x01, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0a, 0x0a,
+		0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00
+};
+
+static UINT8 WMT_COEX_LTE_FREQ_IDX_TABLE_CMD_TEST[] = {
+		0x01, 0x10, 0x21, 0x00, 0x12, 0xfc, 0x08, 0x15,
+		0x09, 0x2e, 0x09, 0x47, 0x09, 0xc4, 0x09, 0xdd,
+		0x09, 0xf6, 0x09, 0x0f, 0xaf, 0x14, 0x09, 0x2d,
+		0x09, 0x46, 0x09, 0x5f, 0x09, 0xdd, 0x09, 0xf5,
+		0x09, 0x0d, 0x0a, 0x27, 0x0a
+};
+static UINT8 WMT_COEX_LTE_CHAN_UNSAFE_CMD_TEST[] = { 0x01, 0x10, 0x02, 0x00, 0x13, 0x00 };
+static UINT8 WMT_COEX_EXT_COMPONENT_CMD_TEST[] = { 0x01, 0x10, 0x03, 0x00, 0x0d, 0x7f, 0x03 };
+#endif
+
+static UINT8 WMT_COEX_FILTER_SPEC_CMD_0[] = {
+		0x01, 0x10, 0x45, 0x00, 0x11, 0x00, 0x00, 0x01,
+		0x00, 0x16, 0x16, 0x16, 0x16, 0x00, 0x00, 0x00,
+		0x00, 0x63, 0x63, 0x63, 0x63, 0x3c, 0x3c, 0x3c,
+		0x3c, 0x04, 0x04, 0x04, 0x04, 0x01, 0x01, 0x01,
+		0x01, 0x0e, 0x0e, 0x0e, 0x0e, 0x0b, 0x0b, 0x0b,
+		0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00
+};
+
+static UINT8 WMT_COEX_LTE_FREQ_IDX_TABLE_CMD_0[] = {
+		0x01, 0x10, 0x21, 0x00, 0x12, 0xfc, 0x08, 0x15,
+		0x09, 0x2e, 0x09, 0x47, 0x09, 0xc4, 0x09, 0xdd,
+		0x09, 0xf6, 0x09, 0x0f, 0x0a, 0x14, 0x09, 0x2d,
+		0x09, 0x46, 0x09, 0x5f, 0x09, 0xdd, 0x09, 0xf5,
+		0x09, 0x0d, 0x0a, 0x27, 0x0a
+};
+static UINT8 WMT_COEX_TDM_REQ_ANTSEL_NUM_CMD[] = { 0x01, 0x10, 0x02, 0x00, 0x14, 0x00 };
+static UINT8 WMT_COEX_IS_LTE_PROJ_CMD[] = { 0x01, 0x10, 0x02, 0x00, 0x15, 0x01 };
+static UINT8 WMT_COEX_SPLIT_MODE_EVT[] = { 0x02, 0x10, 0x01, 0x00, 0x00 };
+
+static UINT8 WMT_COEX_FILTER_SPEC_CMD_6752[] = {
+		0x01, 0x10, 0x45, 0x00, 0x11, 0x00, 0x00, 0x01,
+		0x00, 0x11, 0x11, 0x16, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x63, 0x63, 0x63, 0x00, 0x39, 0x43, 0x63,
+		0x63, 0x02, 0x02, 0x03, 0x00, 0x01, 0x01, 0x01,
+		0x01, 0x0E, 0x0E, 0x0E, 0x00, 0x0A, 0x0C, 0x0E,
+		0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00
+};
+
+static UINT8 WMT_COEX_LTE_FREQ_IDX_TABLE_CMD_6752[] = {
+		0x01, 0x10, 0x21, 0x00, 0x12, 0xFC, 0x08, 0x15,
+		0x09, 0x2E, 0x09, 0x47, 0x09, 0xC4, 0x09, 0xD4,
+		0x09, 0xE3, 0x09, 0x5A, 0x0A, 0x14, 0x09, 0x2D,
+		0x09, 0x46, 0x09, 0x60, 0x09, 0xD3, 0x09, 0xE2,
+		0x09, 0x59, 0x0A, 0x8B, 0x0A
+};
+#endif
+
+#if CFG_WMT_POWER_ON_DLM
+static UINT8 WMT_POWER_CTRL_DLM_CMD1[] = {
+		0x01, 0x08, 0x10, 0x00,
+		0x01, 0x01, 0x00, 0x01,
+		0x60, 0x00, 0x10, 0x80,
+		0x00, 0x00, 0x00, 0x00,
+		0x00, 0x0f, 0x00, 0x00
+};
+
+static UINT8 WMT_POWER_CTRL_DLM_CMD2[] = {
+		0x01, 0x08, 0x10, 0x00,
+		0x01, 0x01, 0x00, 0x01,
+		0x60, 0x00, 0x10, 0x80,
+		0x00, 0x00, 0x00, 0x00,
+		0xf0, 0x00, 0x00, 0x00
+};
+
+static UINT8 WMT_POWER_CTRL_DLM_CMD3[] = {
+		0x01, 0x08, 0x10, 0x00,
+		0x01, 0x01, 0x00, 0x01,
+		0x60, 0x00, 0x10, 0x80,
+		0x00, 0x00, 0x00, 0x00,
+		0x08, 0x00, 0x00, 0x00
+};
+static UINT8 WMT_POWER_CTRL_DLM_EVT[] = { 0x02, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01 };
+#endif
+
+#if (!CFG_IC_SOC)
+
+/* stp sdio init scripts */
+static struct init_script init_table_1_1[] = {
+	/* table_1_1 is only applied to common SDIO interface */
+	INIT_CMD(WMT_SET_ALLINT_REG_CMD, WMT_SET_ALLINT_REG_EVT, "enable all interrupt"),
+	/* applied to MT6628 ? */
+	INIT_CMD(WMT_WAKEUP_DIS_GATE_CMD, WMT_WAKEUP_DIS_GATE_EVT, "disable gating"),
+};
+
+#endif
+
+static struct init_script init_table_1_2[] = {
+	INIT_CMD(WMT_QUERY_STP_CMD, WMT_QUERY_STP_EVT_DEFAULT, "query stp default"),
+};
+
+#if CFG_WMT_UART_HIF_USE
+static struct init_script init_table_2[] = {
+	INIT_CMD(WMT_QUERY_BAUD_CMD, WMT_QUERY_BAUD_EVT_X, "query baud X"),
+};
+#endif
+
+static struct init_script init_table_3[] = {
+	INIT_CMD(WMT_RESET_CMD, WMT_RESET_EVT, "wmt reset"),
+#if CFG_WMT_BT_PORT2
+	INIT_CMD(WMT_BTP2_CMD, WMT_BTP2_EVT, "set bt port2"),
+#endif
+};
+
+#if CFG_WMT_CRYSTAL_TIMING_SET
+static struct init_script set_crystal_timing_script[] = {
+	INIT_CMD(WMT_SET_CRYSTAL_TRIMING_CMD, WMT_SET_CRYSTAL_TRIMING_EVT, "set crystal trim value"),
+};
+
+static struct init_script get_crystal_timing_script[] = {
+	INIT_CMD(WMT_GET_CRYSTAL_TRIMING_CMD, WMT_GET_CRYSTAL_TRIMING_EVT, "get crystal trim value"),
+};
+#endif
+#ifdef CFG_WMT_READ_EFUSE_VCN33
+static struct init_script get_efuse_vcn33_script[] = {
+	INIT_CMD(WMT_GET_EFUSE_VCN33_CMD, WMT_GET_EFUSE_VCN33_EVT, "get efuse vcn33 value"),
+};
+#endif
+
+static struct init_script init_table_4[] = {
+	INIT_CMD(WMT_SET_STP_CMD, WMT_SET_STP_EVT, "set stp"),
+};
+
+static struct init_script init_table_5[] = {
+	INIT_CMD(WMT_QUERY_STP_CMD, WMT_QUERY_STP_EVT, "query stp"),
+};
+
+static struct init_script init_table_5_1[] = {
+	INIT_CMD(WMT_STRAP_CONF_CMD_FM_COMM, WMT_STRAP_CONF_EVT, "configure FM comm"),
+};
+
+static struct init_script init_table_6[] = {
+	INIT_CMD(WMT_CORE_DUMP_LEVEL_04_CMD, WMT_CORE_DUMP_LEVEL_04_EVT, "setup core dump level"),
+};
+
+static struct init_script calibration_table[] = {
+	INIT_CMD(WMT_CORE_START_RF_CALIBRATION_CMD, WMT_CORE_START_RF_CALIBRATION_EVT, "start RF calibration data"),
+};
+
+#if CFG_WMT_PATCH_DL_OPTM
+static struct init_script set_mcuclk_table_1[] = {
+	INIT_CMD(WMT_SET_MCU_CLK_EN_CMD, WMT_SET_MCU_CLK_EN_EVT, "enable set mcu clk"),
+	INIT_CMD(WMT_SET_MCU_CLK_138_CMD, WMT_SET_MCU_CLK_138_EVT, "set mcu clk to 138.67MH"),
+};
+
+static struct init_script set_mcuclk_table_2[] = {
+	INIT_CMD(WMT_SET_MCU_CLK_26_CMD, WMT_SET_MCU_CLK_26_EVT, "set mcu clk to 26MH"),
+	INIT_CMD(WMT_SET_MCU_CLK_DIS_CMD, WMT_SET_MCU_CLK_DIS_EVT, "disable set mcu clk"),
+};
+
+static struct init_script set_mcuclk_table_3[] = {
+	INIT_CMD(WMT_SET_MCU_CLK_EN_6797, WMT_SET_MCU_CLK_EVT_6797, "enable set mcu clk"),
+	INIT_CMD(WMT_SET_MCU_RATIO_SET_6797, WMT_SET_MCU_CLK_EVT_6797, "mcu ratio set"),
+	INIT_CMD(WMT_SET_MCU_DIV_SET_6797, WMT_SET_MCU_CLK_EVT_6797, "mcu div set"),
+	INIT_CMD(WMT_SET_MCU_HCLK_SET_6797, WMT_SET_MCU_CLK_EVT_6797, "set mcu clk to hclk"),
+};
+static struct init_script set_mcuclk_table_4[] = {
+	INIT_CMD(WMT_SET_MCU_HCLK_DIS_6797, WMT_SET_MCU_CLK_EVT_6797, "disable mcu hclk"),
+	INIT_CMD(WMT_SET_MCU_RATIO_DIS_6797, WMT_SET_MCU_CLK_EVT_6797, "disable mcu ratio set"),
+	INIT_CMD(WMT_SET_MCU_CLK_DIS_6797, WMT_SET_MCU_CLK_EVT_6797, "disable mcu clk set"),
+};
+
+#endif
+
+#if CFG_WMT_FILTER_MODE_SETTING
+static struct init_script set_wifi_lte_coex_table_1[] = {
+	INIT_CMD(WMT_COEX_FILTER_SPEC_CMD_6752, WMT_COEX_SPLIT_MODE_EVT, "wifi lte coex filter spec"),
+	INIT_CMD(WMT_COEX_LTE_FREQ_IDX_TABLE_CMD_6752, WMT_COEX_SPLIT_MODE_EVT, "wifi lte freq idx"),
+	INIT_CMD(WMT_COEX_IS_LTE_PROJ_CMD, WMT_COEX_SPLIT_MODE_EVT, "set LTE project"),
+};
+
+static struct init_script set_wifi_lte_coex_table_2[] = {
+	INIT_CMD(WMT_COEX_EXT_COMPONENT_CMD, WMT_COEX_SPLIT_MODE_EVT, "wifi lte ext component"),
+	INIT_CMD(WMT_COEX_FILTER_SPEC_CMD_TEST, WMT_COEX_SPLIT_MODE_EVT, "wifi lte coex filter"),
+	INIT_CMD(WMT_COEX_LTE_FREQ_IDX_TABLE_CMD, WMT_COEX_SPLIT_MODE_EVT, "wifi lte freq id table"),
+	INIT_CMD(WMT_COEX_LTE_CHAN_UNSAFE_CMD, WMT_COEX_SPLIT_MODE_EVT, "wifi lte unsafe channel"),
+	INIT_CMD(WMT_COEX_IS_LTE_L_CMD, WMT_COEX_SPLIT_MODE_EVT, "wifi coex is L branch"),
+};
+
+static struct init_script set_wifi_lte_coex_table_0[] = {
+#if 0
+	INIT_CMD(WMT_COEX_SPLIT_FILTER_CMD_TEST, WMT_COEX_SPLIT_MODE_EVT, "wifi lte coex split filter"),
+	INIT_CMD(WMT_COEX_FILTER_SPEC_CMD_TEST, WMT_COEX_SPLIT_MODE_EVT, "wifi lte coex filter spec"),
+	INIT_CMD(WMT_COEX_LTE_FREQ_IDX_TABLE_CMD_TEST, WMT_COEX_SPLIT_MODE_EVT, "wifi lte freq idx"),
+	INIT_CMD(WMT_COEX_LTE_CHAN_UNSAFE_CMD_TEST, WMT_COEX_SPLIT_MODE_EVT, "wifi lte channel unsafe"),
+	INIT_CMD(WMT_COEX_EXT_COMPONENT_CMD_TEST, WMT_COEX_SPLIT_MODE_EVT, "wifi coex ext component"),
+#endif
+	INIT_CMD(WMT_COEX_FILTER_SPEC_CMD_0, WMT_COEX_SPLIT_MODE_EVT, "def wifi lte coex filter spec"),
+	INIT_CMD(WMT_COEX_LTE_FREQ_IDX_TABLE_CMD_0, WMT_COEX_SPLIT_MODE_EVT, "def wifi lte freq idx"),
+};
+
+static struct init_script get_tdm_req_antsel_num_table[] = {
+	INIT_CMD(WMT_COEX_TDM_REQ_ANTSEL_NUM_CMD, WMT_COEX_SPLIT_MODE_EVT, "get tdm req antsel num"),
+};
+#endif
+
+#if CFG_SET_OPT_REG
+static struct init_script set_registers[] = {
+	/* INIT_CMD(WMT_SET_GPS_REG_CMD, WMT_SET_GPS_REG_EVT, "set wmt registers"), */
+	/* INIT_CMD(WMT_SET_SDIODRV_REG_CMD, WMT_SET_SDIODRV_REG_EVT, "set SDIO driving registers") */
+#if CFG_WMT_I2S_DBGUART_SUPPORT
+	INIT_CMD(WMT_SET_DBGUART_REG_CMD, WMT_SET_DBGUART_REG_EVT, "set debug uart registers"),
+#endif
+#if CFG_SET_OPT_REG_SWLA
+	INIT_CMD(WMT_SET_SWLA_REG_CMD, WMT_SET_SWLA_REG_EVT, "set swla registers"),
+#endif
+#if CFG_SET_OPT_REG_MCUCLK
+	INIT_CMD(WMT_SET_MCUCLK_REG_CMD, WMT_SET_MCUCLK_REG_EVT, "set mcuclk dbg registers"),
+#endif
+#if CFG_SET_OPT_REG_MCUIRQ
+	INIT_CMD(WMT_SET_MCUIRQ_REG_CMD, WMT_SET_MCUIRQ_REG_EVT, "set mcu irq dbg registers"),
+#endif
+};
+#endif
+
+static struct init_script coex_table[] = {
+	INIT_CMD(WMT_COEX_SETTING_CONFIG_CMD, WMT_COEX_SETTING_CONFIG_EVT, "coex_wmt"),
+
+#if CFG_SUBSYS_COEX_NEED
+/* no need in MT6628 */
+	INIT_CMD(WMT_BT_COEX_SETTING_CONFIG_CMD, WMT_BT_COEX_SETTING_CONFIG_EVT, "coex_bt"),
+	INIT_CMD(WMT_WIFI_COEX_SETTING_CONFIG_CMD, WMT_WIFI_COEX_SETTING_CONFIG_EVT, "coex_wifi"),
+	INIT_CMD(WMT_PTA_COEX_SETTING_CONFIG_CMD, WMT_PTA_COEX_SETTING_CONFIG_EVT, "coex_ext_pta"),
+	INIT_CMD(WMT_MISC_COEX_SETTING_CONFIG_CMD, WMT_MISC_COEX_SETTING_CONFIG_EVT, "coex_misc"),
+#endif
+};
+
+static struct init_script osc_type_table[] = {
+	INIT_CMD(WMT_CORE_CO_CLOCK_CMD, WMT_CORE_CO_CLOCK_EVT, "osc_type"),
+};
+
+#if (MTK_WCN_CMB_MERGE_INTERFACE_SUPPORT)
+static struct init_script merge_pcm_table[] = {
+	INIT_CMD(WMT_SET_I2S_SLAVE_REG_CMD, WMT_SET_I2S_SLAVE_REG_EVT, "I2S_Slave"),
+	INIT_CMD(WMT_SET_DAI_TO_PAD_REG_CMD, WMT_SET_DAI_TO_PAD_REG_EVT, "DAI_PAD"),
+	INIT_CMD(WMT_SET_DAI_REG_CMD, WMT_SET_DAI_REG_EVT, "DAI_EVT"),
+};
+#endif
+
+#if CFG_WMT_SDIO_DRIVING_SET
+static struct init_script sdio_driving_table[] = {
+	INIT_CMD(WMT_SET_SDIO_DRV_REG_CMD, WMT_SET_SDIO_DRV_REG_EVT, "sdio_driving"),
+};
+#endif
+
+#if CFG_WMT_POWER_ON_DLM
+static struct init_script wmt_power_on_dlm_table[] = {
+	INIT_CMD(WMT_POWER_CTRL_DLM_CMD1, WMT_POWER_CTRL_DLM_EVT, "power on dlm cmd1"),
+	INIT_CMD(WMT_POWER_CTRL_DLM_CMD2, WMT_POWER_CTRL_DLM_EVT, "power on dlm cmd2"),
+	INIT_CMD(WMT_POWER_CTRL_DLM_CMD3, WMT_POWER_CTRL_DLM_EVT, "power on dlm cmd3")
+};
+#endif
+
+/* SOC Chip Version and Info Table */
+static const WMT_IC_INFO_S mtk_wcn_soc_info_table[] = {
+	{
+	 .u4HwVer = 0x8A00,
+	 .cChipName = WMT_IC_NAME_DEFAULT,
+	 .cChipVersion = WMT_IC_VER_E1,
+	 .cPatchNameExt = WMT_IC_PATCH_E1_EXT,
+	 /* need to refine? */
+	 .eWmtHwVer = WMTHWVER_E1,
+	 .bWorkWithoutPatch = MTK_WCN_BOOL_FALSE,
+	 .bPsmSupport = MTK_WCN_BOOL_TRUE,
+	 },
+	{
+	 .u4HwVer = 0x8A01,
+	 .cChipName = WMT_IC_NAME_DEFAULT,
+	 .cChipVersion = WMT_IC_VER_E2,
+	 .cPatchNameExt = WMT_IC_PATCH_E1_EXT,
+	 .eWmtHwVer = WMTHWVER_E2,
+	 .bWorkWithoutPatch = MTK_WCN_BOOL_FALSE,
+	 .bPsmSupport = MTK_WCN_BOOL_TRUE,
+	 },
+	{
+	 .u4HwVer = 0x8B01,
+	 .cChipName = WMT_IC_NAME_DEFAULT,
+	 .cChipVersion = WMT_IC_VER_E3,
+	 .cPatchNameExt = WMT_IC_PATCH_E1_EXT,
+	 .eWmtHwVer = WMTHWVER_E3,
+	 .bWorkWithoutPatch = MTK_WCN_BOOL_FALSE,
+	 .bPsmSupport = MTK_WCN_BOOL_TRUE,
+	 }
+};
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+static INT32 mtk_wcn_soc_sw_init(P_WMT_HIF_CONF pWmtHifConf);
+
+static INT32 mtk_wcn_soc_sw_deinit(P_WMT_HIF_CONF pWmtHifConf);
+
+static INT32 mtk_wcn_soc_pin_ctrl(WMT_IC_PIN_ID id, WMT_IC_PIN_STATE state, UINT32 flag);
+
+static INT32 mtk_wcn_soc_aif_ctrl(WMT_IC_PIN_STATE state, UINT32 flag);
+
+static INT32 mtk_wcn_soc_ver_check(VOID);
+
+static const WMT_IC_INFO_S *mtk_wcn_soc_find_wmt_ic_info(const UINT32 hw_ver);
+
+static INT32 wmt_stp_init_coex(VOID);
+
+#if CFG_WMT_FILTER_MODE_SETTING
+static INT32 wmt_stp_wifi_lte_coex(VOID);
+#endif
+
+#if CFG_WMT_MULTI_PATCH
+static INT32 mtk_wcn_soc_patch_dwn(UINT32 index);
+static INT32 mtk_wcn_soc_patch_info_prepare(VOID);
+#else
+static INT32 mtk_wcn_soc_patch_dwn(VOID);
+#endif
+
+static INT32 mtk_wcn_soc_co_clock_ctrl(WMT_CO_CLOCK on);
+static WMT_CO_CLOCK mtk_wcn_soc_co_clock_get(VOID);
+
+#if CFG_WMT_CRYSTAL_TIMING_SET
+static INT32 mtk_wcn_soc_crystal_triming_set(VOID);
+#endif
+
+static MTK_WCN_BOOL mtk_wcn_soc_quick_sleep_flag_get(VOID);
+
+static MTK_WCN_BOOL mtk_wcn_soc_aee_dump_flag_get(VOID);
+
+#if CFG_WMT_SDIO_DRIVING_SET
+static INT32 mtk_wcn_soc_set_sdio_driving(void);
+#endif
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+/* SOC Operation Function Table */
+WMT_IC_OPS wmt_ic_ops_soc = {
+	.icId = 0x0000,		/* soc may have mt6572/82/71/83,but they have the same sw init flow */
+	.sw_init = mtk_wcn_soc_sw_init,
+	.sw_deinit = mtk_wcn_soc_sw_deinit,
+	.ic_pin_ctrl = mtk_wcn_soc_pin_ctrl,
+	.ic_ver_check = mtk_wcn_soc_ver_check,
+	.co_clock_ctrl = mtk_wcn_soc_co_clock_ctrl,
+	.is_quick_sleep = mtk_wcn_soc_quick_sleep_flag_get,
+	.is_aee_dump_support = mtk_wcn_soc_aee_dump_flag_get,
+};
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+static INT32 mtk_wcn_soc_sw_init(P_WMT_HIF_CONF pWmtHifConf)
+{
+	INT32 iRet = -1;
+	unsigned long ctrlPa1;
+	unsigned long ctrlPa2;
+	UINT32 hw_ver;
+	WMT_CTRL_DATA ctrlData;
+#ifdef CFG_WMT_READ_EFUSE_VCN33
+	UINT32 efuse_d3_vcn33 = 2; /*default voltage is 3.5V*/
+#endif
+#if CFG_WMT_MULTI_PATCH
+	UINT32 patch_num = 0;
+	UINT32 patch_index = 0;
+#endif
+#if CFG_WMT_WIFI_5G_SUPPORT
+	UINT32 dDieChipid = 0;
+	UINT32 aDieChipid = 0;
+	UINT8 evtbuf[20];
+	UINT32 u4Res;
+	UINT32 pmicChipid = 0;
+#endif
+	WMT_DBG_FUNC(" start\n");
+
+	osal_assert(NULL != gp_soc_info);
+	if ((NULL == gp_soc_info)
+	    || (NULL == pWmtHifConf)
+	    ) {
+		WMT_ERR_FUNC("null pointers: gp_soc_info(0x%p), pWmtHifConf(0x%p)\n", gp_soc_info, pWmtHifConf);
+		return -1;
+	}
+
+	hw_ver = gp_soc_info->u4HwVer;
+
+	/* 4 <3.2> start init for BTIF */
+	if (WMT_HIF_BTIF == pWmtHifConf->hifType) {
+		/* 1. Query chip STP default options (TEST-ONLY) */
+		/* WMT_DBG_FUNC("WMT-CORE: init_table_1_2 set chip baud:%d", pWmtHifConf->au4HifConf[0]); */
+		iRet = wmt_core_init_script(init_table_1_2, osal_array_size(init_table_1_2));
+		if (iRet) {
+			WMT_ERR_FUNC("init_table_1_2 fail(%d)\n", iRet);
+			osal_assert(0);
+			return -2;
+		}
+		/* 2. Set chip STP options */
+		iRet = wmt_core_init_script(init_table_4, osal_array_size(init_table_4));
+		if (iRet) {
+			WMT_ERR_FUNC("init_table_4 fail(%d)\n", iRet);
+			return -3;
+		}
+
+		/* 3. Enable host full mode */
+		ctrlPa1 = WMT_STP_CONF_MODE;
+		ctrlPa2 = MTKSTP_BTIF_FULL_MODE;
+		iRet = wmt_core_ctrl(WMT_CTRL_STP_CONF, &ctrlPa1, &ctrlPa2);
+		ctrlPa1 = WMT_STP_CONF_EN;
+		ctrlPa2 = 1;
+		iRet += wmt_core_ctrl(WMT_CTRL_STP_CONF, &ctrlPa1, &ctrlPa2);
+		if (iRet) {
+			WMT_ERR_FUNC("enable host STP-BTIF-FULL mode fail(%d)\n", iRet);
+			return -4;
+		}
+		WMT_DBG_FUNC("enable host STP-BTIF-FULL mode\n");
+		/*4. wait for 10ms, enough for chip do mechanism switch.(at least 2ms is needed) */
+		osal_sleep_ms(10);
+		/* 5. Query chip STP options (TEST-ONLY) */
+		iRet = wmt_core_init_script(init_table_5, osal_array_size(init_table_5));
+		if (iRet) {
+			WMT_ERR_FUNC("init_table_5 fail(%d)\n", iRet);
+			return -5;
+		}
+	}
+#if CFG_WMT_POWER_ON_DLM
+	iRet = wmt_core_init_script(wmt_power_on_dlm_table, osal_array_size(wmt_power_on_dlm_table));
+	if (iRet)
+		WMT_ERR_FUNC("wmt_power_on_dlm_table fail(%d)\n", iRet);
+	WMT_DBG_FUNC("wmt_power_on_dlm_table ok\n");
+#endif
+	/* 6. download patch */
+#if CFG_WMT_MULTI_PATCH
+	/* 6.1 Let launcher to search patch info */
+	iRet = mtk_wcn_soc_patch_info_prepare();
+	if (iRet) {
+		WMT_ERR_FUNC("patch info perpare fail(%d)\n", iRet);
+		return -6;
+	}
+
+	/* 6.2 Read patch number */
+	ctrlPa1 = 0;
+	ctrlPa2 = 0;
+	wmt_core_ctrl(WMT_CTRL_GET_PATCH_NUM, &ctrlPa1, &ctrlPa2);
+	patch_num = ctrlPa1;
+	WMT_DBG_FUNC("patch total num = [%d]\n", patch_num);
+
+#if CFG_WMT_PATCH_DL_OPTM
+	if (0x0279 == wmt_ic_ops_soc.icId) {
+		iRet = wmt_core_init_script(set_mcuclk_table_3, osal_array_size(set_mcuclk_table_3));
+		if (iRet)
+			WMT_ERR_FUNC("set_mcuclk_table_3 fail(%d)\n", iRet);
+	} else {
+		iRet = wmt_core_init_script(set_mcuclk_table_1, osal_array_size(set_mcuclk_table_1));
+		if (iRet)
+			WMT_ERR_FUNC("set_mcuclk_table_1 fail(%d)\n", iRet);
+	}
+#endif
+	/* 6.3 Multi-patch Patch download */
+	for (patch_index = 0; patch_index < patch_num; patch_index++) {
+		iRet = mtk_wcn_soc_patch_dwn(patch_index);
+		if (iRet) {
+			WMT_ERR_FUNC("patch dwn fail (%d),patch_index(%d)\n", iRet, patch_index);
+			return -7;
+		}
+		iRet = wmt_core_init_script(init_table_3, osal_array_size(init_table_3));
+		if (iRet) {
+			WMT_ERR_FUNC("init_table_3 fail(%d)\n", iRet);
+			return -8;
+		}
+	}
+
+#if CFG_WMT_PATCH_DL_OPTM
+	if (0x0279 == wmt_ic_ops_soc.icId) {
+		iRet = wmt_core_init_script(set_mcuclk_table_4, osal_array_size(set_mcuclk_table_4));
+		if (iRet)
+			WMT_ERR_FUNC("set_mcuclk_table_4 fail(%d)\n", iRet);
+	} else {
+		iRet = wmt_core_init_script(set_mcuclk_table_2, osal_array_size(set_mcuclk_table_2));
+		if (iRet)
+			WMT_ERR_FUNC("set_mcuclk_table_2 fail(%d)\n", iRet);
+	}
+#endif
+
+#else
+	/* 6.3 Patch download */
+	iRet = mtk_wcn_soc_patch_dwn();
+	/* If patch download fail, we just ignore this error and let chip init process goes on */
+	if (iRet)
+		WMT_ERR_FUNC("patch dwn fail (%d), just omit\n", iRet);
+
+	/* 6.4. WMT Reset command */
+	iRet = wmt_core_init_script(init_table_3, osal_array_size(init_table_3));
+	if (iRet) {
+		WMT_ERR_FUNC("init_table_3 fail(%d)\n", iRet);
+		return -8;
+	}
+#endif
+
+#ifdef CFG_WMT_READ_EFUSE_VCN33
+	/*get CrystalTiming value before set it */
+	iRet = wmt_core_tx(get_efuse_vcn33_script[0].cmd, get_efuse_vcn33_script[0].cmdSz, &u4Res,
+			MTK_WCN_BOOL_FALSE);
+	if (iRet || (u4Res != get_efuse_vcn33_script[0].cmdSz)) {
+		WMT_ERR_FUNC("WMT-CORE: write (%s) iRet(%d) cmd len err(%d, %d)\n",
+				 get_efuse_vcn33_script[0].str, iRet, u4Res, get_efuse_vcn33_script[0].cmdSz);
+	}
+	/* EVENT BUF */
+	osal_memset(get_efuse_vcn33_script[0].evt, 0, get_efuse_vcn33_script[0].evtSz);
+	iRet = wmt_core_rx(get_efuse_vcn33_script[0].evt, get_efuse_vcn33_script[0].evtSz, &u4Res);
+	if (iRet || (u4Res != get_efuse_vcn33_script[0].evtSz)) {
+		WMT_ERR_FUNC("WMT-CORE: read (%s) iRet(%d) evt len err(rx:%d, exp:%d)\n",
+				 get_efuse_vcn33_script[0].str, iRet, u4Res, get_efuse_vcn33_script[0].evtSz);
+		mtk_wcn_stp_dbg_dump_package();
+	}
+	efuse_d3_vcn33 = WMT_GET_EFUSE_VCN33_EVT[5] & 0x03;
+	WMT_INFO_FUNC("Read efuse to set PMIC voltage:(%d)\n", efuse_d3_vcn33);
+	wmt_set_pmic_voltage(efuse_d3_vcn33);
+#endif
+
+#if CFG_WMT_FILTER_MODE_SETTING
+	if ((0x6580 == wmt_ic_ops_soc.icId) ||
+	    (0x8163 == wmt_ic_ops_soc.icId) ||
+	    (0x6752 == wmt_ic_ops_soc.icId) ||
+	    (0x6582 == wmt_ic_ops_soc.icId) ||
+	    (0x6592 == wmt_ic_ops_soc.icId) ||
+	    (0x0279 == wmt_ic_ops_soc.icId) ||
+	    (0x0326 == wmt_ic_ops_soc.icId) ||
+	    (0x0321 == wmt_ic_ops_soc.icId) || (0x0335 == wmt_ic_ops_soc.icId) || (0x0337 == wmt_ic_ops_soc.icId)) {
+		wmt_stp_wifi_lte_coex();
+		WMT_DBG_FUNC("wmt_stp_wifi_lte_coex done!\n");
+	}
+	if ((0x6582 == wmt_ic_ops_soc.icId) || (0x6592 == wmt_ic_ops_soc.icId)) {
+		/*get gpio tdm req antsel number */
+		ctrlPa1 = 0;
+		ctrlPa2 = 0;
+		wmt_core_ctrl(WMT_CTRL_GET_TDM_REQ_ANTSEL, &ctrlPa1, &ctrlPa2);
+		WMT_INFO_FUNC("get GPIO TDM REQ ANTSEL number(%d)\n", ctrlPa1);
+		/*set gpio tdm req antsel number to firmware */
+		WMT_COEX_TDM_REQ_ANTSEL_NUM_CMD[5] = ctrlPa1;
+		iRet = wmt_core_init_script(get_tdm_req_antsel_num_table,
+		    osal_array_size(get_tdm_req_antsel_num_table));
+		if (iRet)
+			WMT_ERR_FUNC("get_tdm_req_antsel_num_table fail(%d)\n", iRet);
+	}
+#endif
+	/* 7. start RF calibration data */
+	ctrlPa1 = BT_PALDO;
+	ctrlPa2 = PALDO_ON;
+	iRet = wmt_core_ctrl(WMT_CTRL_SOC_PALDO_CTRL, &ctrlPa1, &ctrlPa2);
+	ctrlPa1 = WIFI_PALDO;
+	ctrlPa2 = PALDO_ON;
+	iRet = wmt_core_ctrl(WMT_CTRL_SOC_PALDO_CTRL, &ctrlPa1, &ctrlPa2);
+
+	iRet = wmt_core_init_script(calibration_table, osal_array_size(calibration_table));
+	if (iRet) {
+		/* pwrap_read(0x0210,&ctrlPa1); */
+		/* pwrap_read(0x0212,&ctrlPa2); */
+		WMT_ERR_FUNC("power status: 210:(%d),212:(%d)!\n", ctrlPa1, ctrlPa2);
+		WMT_ERR_FUNC("calibration_table fail(%d)\n", iRet);
+		return -9;
+	}
+
+	ctrlPa1 = BT_PALDO;
+	ctrlPa2 = PALDO_OFF;
+	iRet = wmt_core_ctrl(WMT_CTRL_SOC_PALDO_CTRL, &ctrlPa1, &ctrlPa2);
+	ctrlPa1 = WIFI_PALDO;
+	ctrlPa2 = PALDO_OFF;
+	iRet = wmt_core_ctrl(WMT_CTRL_SOC_PALDO_CTRL, &ctrlPa1, &ctrlPa2);
+
+	iRet = wmt_stp_init_coex();
+	if (iRet) {
+		WMT_ERR_FUNC("init_coex fail(%d)\n", iRet);
+		return -10;
+	}
+	WMT_DBG_FUNC("init_coex ok\n");
+
+#if CFG_WMT_CRYSTAL_TIMING_SET
+	mtk_wcn_soc_crystal_triming_set();
+#endif
+
+#if CFG_WMT_SDIO_DRIVING_SET
+	mtk_wcn_soc_set_sdio_driving();
+#endif
+
+	if (WMT_CO_CLOCK_EN == mtk_wcn_soc_co_clock_get()) {
+		WMT_INFO_FUNC("co-clock enabled.\n");
+
+		iRet = wmt_core_init_script(osc_type_table, osal_array_size(osc_type_table));
+		if (iRet) {
+			WMT_ERR_FUNC("osc_type_table fail(%d), goes on\n", iRet);
+			return -11;
+		}
+	} else {
+		WMT_WARN_FUNC("co-clock disabled.\n");
+	}
+#if (MTK_WCN_CMB_MERGE_INTERFACE_SUPPORT)
+	iRet = wmt_core_init_script(merge_pcm_table, osal_array_size(merge_pcm_table));
+	if (iRet) {
+		WMT_ERR_FUNC("merge_pcm_table fail(%d), goes on\n", iRet);
+		return -12;
+	}
+#endif
+
+	/* 15. Set FM strap */
+	WMT_STRAP_CONF_CMD_FM_COMM[5] = (UINT8) pWmtHifConf->au4StrapConf[0];
+	WMT_STRAP_CONF_EVT[5] = (UINT8) pWmtHifConf->au4StrapConf[0];
+	iRet = wmt_core_init_script(init_table_5_1, osal_array_size(init_table_5_1));
+	if (iRet) {
+		WMT_ERR_FUNC("init_table_5_1 fm mode(%d) fail(%d)\n", pWmtHifConf->au4StrapConf[0], iRet);
+		return -13;
+	}
+	WMT_DBG_FUNC("set fm mode (%d) ok\n", pWmtHifConf->au4StrapConf[0]);
+
+#if CFG_SET_OPT_REG		/*set registers */
+	iRet = wmt_core_init_script(set_registers, osal_array_size(set_registers));
+	if (iRet) {
+		WMT_ERR_FUNC("set_registers fail(%d)", iRet);
+		return -14;
+	}
+#endif
+
+#if CFG_WMT_COREDUMP_ENABLE
+	/*Open Core Dump Function @QC begin */
+	mtk_wcn_stp_coredump_flag_ctrl(1);
+#endif
+	if (0 != mtk_wcn_stp_coredump_flag_get()) {
+		iRet = wmt_core_init_script(init_table_6, osal_array_size(init_table_6));
+		if (iRet) {
+			WMT_ERR_FUNC("init_table_6 core dump setting fail(%d)\n", iRet);
+			return -15;
+		}
+		WMT_DBG_FUNC("enable soc_consys firmware coredump\n");
+	} else {
+		WMT_DBG_FUNC("disable soc_consys firmware coredump\n");
+	}
+
+#if CFG_WMT_WIFI_5G_SUPPORT
+	dDieChipid = wmt_ic_ops_soc.icId;
+	WMT_DBG_FUNC("current SOC chipid is 0x%x\n", dDieChipid);
+	if (0x6592 == dDieChipid) {
+		/* read A die chipid by wmt cmd */
+		iRet =
+		    wmt_core_tx((PUINT8) &WMT_GET_SOC_ADIE_CHIPID_CMD[0], sizeof(WMT_GET_SOC_ADIE_CHIPID_CMD), &u4Res,
+				MTK_WCN_BOOL_FALSE);
+		if (iRet || (u4Res != sizeof(WMT_GET_SOC_ADIE_CHIPID_CMD))) {
+			WMT_ERR_FUNC("wmt_core:read A die chipid CMD fail(%d),size(%d)\n", iRet, u4Res);
+			return -16;
+		}
+		osal_memset(evtbuf, 0, sizeof(evtbuf));
+		iRet = wmt_core_rx(evtbuf, sizeof(WMT_GET_SOC_ADIE_CHIPID_EVT), &u4Res);
+		if (iRet || (u4Res != sizeof(WMT_GET_SOC_ADIE_CHIPID_EVT))) {
+			WMT_ERR_FUNC("wmt_core:read A die chipid EVT fail(%d),size(%d)\n", iRet, u4Res);
+			return -17;
+		}
+
+		osal_memcpy(&aDieChipid, &evtbuf[u4Res - 2], 2);
+		WMT_INFO_FUNC("get SOC A die chipid(0x%x)\n", aDieChipid);
+
+		if (0x6625 == aDieChipid) {
+			iRet =
+			    wmt_core_tx((PUINT8) &WMT_GET_SOC_6625_L_CMD[0], sizeof(WMT_GET_SOC_6625_L_CMD), &u4Res,
+					MTK_WCN_BOOL_FALSE);
+			if (iRet || (u4Res != sizeof(WMT_GET_SOC_6625_L_CMD)))
+				WMT_ERR_FUNC("wmt_core:read A die efuse CMD fail(%d),size(%d)\n", iRet, u4Res);
+			osal_memset(evtbuf, 0, sizeof(evtbuf));
+			iRet = wmt_core_rx(evtbuf, sizeof(WMT_GET_SOC_6625_L_EVT), &u4Res);
+			if (iRet || (u4Res != sizeof(WMT_GET_SOC_6625_L_EVT)))
+				WMT_ERR_FUNC("wmt_core:read A die efuse EVT fail(%d),size(%d)\n", iRet, u4Res);
+
+			WMT_INFO_FUNC("read SOC Adie Efuse(0x120) value:0x%2x,0x%2x,0x%2x,0x%2x -> %s\n",
+				      evtbuf[u4Res - 4], evtbuf[u4Res - 3], evtbuf[u4Res - 2], evtbuf[u4Res - 1],
+				      evtbuf[u4Res - 2] == 0x31 ? "MT6625L" : "MT6625");
+		}
+		/* get PMIC chipid */
+
+		ctrlData.ctrlId = WMT_CTRL_SOC_PALDO_CTRL;
+		ctrlData.au4CtrlData[0] = PMIC_CHIPID_PALDO;
+		ctrlData.au4CtrlData[1] = 0;
+		iRet = wmt_ctrl(&ctrlData);
+		if (iRet < 0) {
+			WMT_ERR_FUNC("wmt_core: read PMIC chipid fail(%d)\n", iRet);
+			return -18;
+		}
+		pmicChipid = ctrlData.au4CtrlData[2];
+		WMT_INFO_FUNC("current PMIC chipid(0x%x)\n", pmicChipid);
+
+		/* MT6625 & MT6322, write 1 to 0x0414[12] */
+		/* MT6625 & MT6323, assert */
+		/* MT6627 & (MT6322 or MT6323),write 0 to 0x0414[12] */
+
+		switch (aDieChipid) {
+		case 0x6625:
+			if (0x6322 == pmicChipid) {
+				WMT_INFO_FUNC("wmt-core:enable wifi 5G support\n");
+				ctrlPa1 = WIFI_5G_PALDO;
+				ctrlPa2 = PALDO_ON;
+				wmt_core_ctrl(WMT_CTRL_SOC_PALDO_CTRL, &ctrlPa1, &ctrlPa2);
+			} else if (0x6323 == pmicChipid) {
+				osal_assert(0);
+			} else {
+				WMT_WARN_FUNC("wmt-core: unknown PMIC chipid\n");
+			}
+			break;
+		case 0x6627:
+			if ((0x6322 == pmicChipid) || (0x6323 == pmicChipid)) {
+				WMT_INFO_FUNC("wmt-core: disable wifi 5G support\n");
+				ctrlPa1 = WIFI_5G_PALDO;
+				ctrlPa2 = PALDO_OFF;
+				wmt_core_ctrl(WMT_CTRL_SOC_PALDO_CTRL, &ctrlPa1, &ctrlPa2);
+			} else {
+				WMT_WARN_FUNC("wmt-core: unknown PMIC chipid\n");
+			}
+			break;
+		default:
+			WMT_WARN_FUNC("wmt-core: unknown A die chipid(0x%x)\n", aDieChipid);
+			break;
+		}
+	}
+#endif
+
+#if 1
+	ctrlData.ctrlId = WMT_CTRL_SET_STP_DBG_INFO;
+	ctrlData.au4CtrlData[0] = wmt_ic_ops_soc.icId;
+	ctrlData.au4CtrlData[1] = (SIZE_T) gp_soc_info->cChipVersion;
+	ctrlData.au4CtrlData[2] = (SIZE_T) &gp_soc_patch_info;
+	iRet = wmt_ctrl(&ctrlData);
+	if (iRet) {
+		WMT_ERR_FUNC("set dump info fail(%d)\n", iRet);
+		return -19;
+	}
+#endif
+
+#if CFG_WMT_PS_SUPPORT
+	osal_assert(NULL != gp_soc_info);
+	if (NULL != gp_soc_info) {
+		if (MTK_WCN_BOOL_FALSE != gp_soc_info->bPsmSupport)
+			wmt_lib_ps_enable();
+		else
+			wmt_lib_ps_disable();
+	}
+#endif
+
+	return 0;
+}
+
+static INT32 mtk_wcn_soc_sw_deinit(P_WMT_HIF_CONF pWmtHifConf)
+{
+	WMT_DBG_FUNC(" start\n");
+
+#if CFG_WMT_PS_SUPPORT
+	osal_assert(NULL != gp_soc_info);
+	if ((NULL != gp_soc_info)
+	    && (MTK_WCN_BOOL_FALSE != gp_soc_info->bPsmSupport)) {
+		wmt_lib_ps_disable();
+	}
+#endif
+
+	gp_soc_info = NULL;
+
+	return 0;
+}
+
+static INT32 mtk_wcn_soc_aif_ctrl(WMT_IC_PIN_STATE state, UINT32 flag)
+{
+	INT32 ret = -1;
+	UINT32 val;
+
+	if ((flag & WMT_LIB_AIF_FLAG_MASK) == WMT_LIB_AIF_FLAG_SHARE) {
+		WMT_INFO_FUNC("PCM & I2S PIN SHARE\n");
+#if 0
+		switch (state) {
+		case WMT_IC_AIF_0:
+			/* BT_PCM_OFF & FM line in/out */
+			val = 0x00000770;
+			ret = wmt_core_reg_rw_raw(1, 0x80050140, &val, 0x00000FF0);
+			val = 0x00000000;
+			ret += wmt_core_reg_rw_raw(1, 0x80050150, &val, 0x00000800);
+			break;
+
+		case WMT_IC_AIF_1:
+			/* BT_PCM_ON & FM line in/out */
+			val = 0x00000700;
+			ret = wmt_core_reg_rw_raw(1, 0x80050140, &val, 0x00000FF0);
+			val = 0x00000000;
+			ret += wmt_core_reg_rw_raw(1, 0x80050150, &val, 0x00000800);
+			break;
+
+		case WMT_IC_AIF_2:
+			/* BT_PCM_OFF & FM I2S */
+			val = 0x00000710;
+			ret = wmt_core_reg_rw_raw(1, 0x80050140, &val, 0x00000FF0);
+			val = 0x00000800;	/* 800:3-wire, 000: 4-wire */
+			ret += wmt_core_reg_rw_raw(1, 0x80050150, &val, 0x00000800);
+			break;
+		default:
+			WMT_ERR_FUNC("unsupported state (%d)\n", state);
+			ret = -1;
+			break;
+		}
+#else
+		WMT_WARN_FUNC("TBD!!");
+		ret = 0;
+#endif
+	} else {
+		/*PCM & I2S separate */
+		WMT_INFO_FUNC("PCM & I2S PIN SEPARATE\n");
+#if 0
+		switch (state) {
+		case WMT_IC_AIF_0:
+			/* BT_PCM_OFF & FM line in/out */
+			val = 0x00000770;
+			ret = wmt_core_reg_rw_raw(1, 0x80050140, &val, 0x00000FF0);
+			val = 0x00000000;
+			ret += wmt_core_reg_rw_raw(1, 0x80050150, &val, 0x00000800);
+			break;
+
+		case WMT_IC_AIF_1:
+			/* BT_PCM_ON & FM line in/out */
+			val = 0x00000700;
+			ret = wmt_core_reg_rw_raw(1, 0x80050140, &val, 0x00000FF0);
+			val = 0x00000000;
+			ret += wmt_core_reg_rw_raw(1, 0x80050150, &val, 0x00000800);
+			break;
+
+		case WMT_IC_AIF_2:
+			/* BT_PCM_OFF & FM I2S */
+			val = 0x00000070;
+			ret = wmt_core_reg_rw_raw(1, 0x80050140, &val, 0x00000FF0);
+			val = 0x00000800;	/* 800:3-wire, 000: 4-wire */
+			ret += wmt_core_reg_rw_raw(1, 0x80050150, &val, 0x00000800);
+
+			break;
+		case WMT_IC_AIF_3:
+			val = 0x00000000;
+			ret = wmt_core_reg_rw_raw(1, 0x80050140, &val, 0x00000FF0);
+			val = 0x00000800;	/* 800:3-wire, 000: 4-wire */
+			ret += wmt_core_reg_rw_raw(1, 0x80050150, &val, 0x00000800);
+
+			break;
+		default:
+			WMT_ERR_FUNC("unsupported state (%d)\n", state);
+			ret = -1;
+			break;
+		}
+#else
+		switch (state) {
+		case WMT_IC_AIF_0:
+			/* BT_PCM_OFF & FM line in/out */
+			ret = 0;
+			break;
+		case WMT_IC_AIF_1:
+			/* BT_PCM_ON & FM line in/out */
+			ret = 0;
+			break;
+
+		case WMT_IC_AIF_2:
+			/* BT_PCM_OFF & FM I2S */
+			val = 0x01110000;
+			ret = wmt_core_reg_rw_raw(1, 0x80050078, &val, 0x0FFF0000);
+
+			break;
+		case WMT_IC_AIF_3:
+			ret = 0;
+			break;
+
+		default:
+			WMT_ERR_FUNC("unsupported state (%d)\n", state);
+			ret = -1;
+			break;
+		}
+#endif
+	}
+
+	if (!ret)
+		WMT_WARN_FUNC("new state(%d) fail(%d)\n", state, ret);
+	WMT_INFO_FUNC("new state(%d) ok\n", state);
+
+	return ret;
+}
+
+static INT32 mtk_wcn_soc_gps_sync_ctrl(WMT_IC_PIN_STATE state, UINT32 flag)
+{
+	INT32 iRet = -1;
+	UINT32 uVal = 0;
+
+	/* mt6797 can not access reg:0x80050078 and no need to do GPS SYNC */
+	if (0x0279 != wmt_ic_ops_soc.icId) {
+		if (WMT_IC_PIN_MUX == state)
+			uVal = 0x1 << 28;
+		else
+			uVal = 0x5 << 28;
+		iRet = wmt_core_reg_rw_raw(1, 0x80050078, &uVal, 0x7 << 28);
+		if (iRet)
+			WMT_ERR_FUNC("gps_sync pin ctrl failed, iRet(%d)\n", iRet);
+	} else
+		WMT_INFO_FUNC("This chip no need to sync GPS and MODEM!\n");
+
+	/* anyway, we return 0 */
+	return 0;
+}
+
+static INT32 mtk_wcn_soc_pin_ctrl(WMT_IC_PIN_ID id, WMT_IC_PIN_STATE state, UINT32 flag)
+{
+	INT32 ret;
+
+	WMT_DBG_FUNC("ic pin id:%d, state:%d, flag:0x%x\n", id, state, flag);
+
+	ret = -1;
+	switch (id) {
+	case WMT_IC_PIN_AUDIO:
+		ret = mtk_wcn_soc_aif_ctrl(state, flag);
+		break;
+
+	case WMT_IC_PIN_EEDI:
+		WMT_WARN_FUNC("TBD!!");
+		/* We just return 0 here, prevent from WMT-FUNC do other register read/write */
+		ret = 0;
+		break;
+
+	case WMT_IC_PIN_EEDO:
+		WMT_WARN_FUNC("TBD!!");
+		/* We just return 0 here, prevent from WMT-FUNC do other register read/write */
+		ret = 0;
+		break;
+	case WMT_IC_PIN_GSYNC:
+		ret = mtk_wcn_soc_gps_sync_ctrl(state, flag);
+		break;
+	default:
+		break;
+	}
+	WMT_INFO_FUNC("ret = (%d)\n", ret);
+
+	return ret;
+}
+
+INT32 mtk_wcn_soc_co_clock_ctrl(WMT_CO_CLOCK on)
+{
+	INT32 iRet = 0;
+
+	if ((WMT_CO_CLOCK_DIS <= on) && (WMT_CO_CLOCK_MAX > on)) {
+		gCoClockEn = on;
+	} else {
+		WMT_DBG_FUNC("0x%x: error parameter:%d\n", wmt_ic_ops_soc.icId, on);
+		iRet = -1;
+	}
+	WMT_DBG_FUNC("0x%x: Co-clock %s\n", wmt_ic_ops_soc.icId,
+		     (gCoClockEn == WMT_CO_CLOCK_DIS) ? "disabled" : "enabled");
+
+	return iRet;
+}
+
+static MTK_WCN_BOOL mtk_wcn_soc_quick_sleep_flag_get(VOID)
+{
+	return MTK_WCN_BOOL_TRUE;
+}
+
+static MTK_WCN_BOOL mtk_wcn_soc_aee_dump_flag_get(VOID)
+{
+	return MTK_WCN_BOOL_FALSE;
+}
+
+WMT_CO_CLOCK mtk_wcn_soc_co_clock_get(VOID)
+{
+	return gCoClockEn;
+}
+
+static INT32 mtk_wcn_soc_ver_check(VOID)
+{
+	UINT32 hw_ver;
+	UINT32 fw_ver;
+	INT32 iret;
+	const WMT_IC_INFO_S *p_info;
+	unsigned long ctrlPa1;
+	unsigned long ctrlPa2;
+
+	/* 1. identify chip versions: HVR(HW_VER) and FVR(FW_VER) */
+	WMT_LOUD_FUNC("0x%x: before read hw_ver (hw version)\n", wmt_ic_ops_soc.icId);
+	iret = wmt_core_reg_rw_raw(0, GEN_HVR, &hw_ver, GEN_VER_MASK);
+	if (iret) {
+		WMT_ERR_FUNC("0x%x: read hw_ver fail:%d\n", wmt_ic_ops_soc.icId, iret);
+		return -2;
+	}
+	WMT_WARN_FUNC("0x%x: read hw_ver (hw version) (0x%x)\n", wmt_ic_ops_soc.icId, hw_ver);
+
+	WMT_LOUD_FUNC("0x%x: before fw_ver (rom version)\n", wmt_ic_ops_soc.icId);
+	wmt_core_reg_rw_raw(0, GEN_FVR, &fw_ver, GEN_VER_MASK);
+	if (iret) {
+		WMT_ERR_FUNC("0x%x: read fw_ver fail:%d\n", wmt_ic_ops_soc.icId, iret);
+		return -2;
+	}
+	WMT_WARN_FUNC("0x%x: read fw_ver (rom version) (0x%x)\n", wmt_ic_ops_soc.icId, fw_ver);
+
+	p_info = mtk_wcn_soc_find_wmt_ic_info(hw_ver);
+	if (NULL == p_info) {
+		WMT_ERR_FUNC("0x%x: hw_ver(0x%x) find wmt ic info fail\n", wmt_ic_ops_soc.icId);
+		return -3;
+	}
+	WMT_WARN_FUNC("0x%x: ic info: %s.%s (0x%x/0x%x, WMTHWVER:%d, patch_ext:%s)\n",
+		      wmt_ic_ops_soc.icId, p_info->cChipName, p_info->cChipVersion,
+		      hw_ver, fw_ver, p_info->eWmtHwVer, p_info->cPatchNameExt);
+
+	/* hw id & version */
+	ctrlPa1 = (wmt_ic_ops_soc.icId << 16) | (hw_ver & 0x0000FFFF);
+	/* translated hw version & fw rom version */
+	ctrlPa2 = ((UINT32) (p_info->eWmtHwVer) << 16) | (fw_ver & 0x0000FFFF);
+
+	iret = wmt_core_ctrl(WMT_CTRL_HWIDVER_SET, &ctrlPa1, &ctrlPa2);
+	if (iret)
+		WMT_WARN_FUNC("0x%x: WMT_CTRL_HWIDVER_SET fail(%d)\n", wmt_ic_ops_soc.icId, iret);
+
+	gp_soc_info = p_info;
+	return 0;
+}
+
+static const WMT_IC_INFO_S *mtk_wcn_soc_find_wmt_ic_info(const UINT32 hw_ver)
+{
+	/* match chipversion with u4HwVer item in mtk_wcn_soc_info_table */
+	const UINT32 size = osal_array_size(mtk_wcn_soc_info_table);
+	INT32 index = 0;
+
+	/* George: reverse the search order to favor newer version products
+	* TODO:[FixMe][GeorgeKuo] Remove full match once API wmt_lib_get_hwver()
+	* is changed correctly in the future!!
+	* Leave full match here is a workaround for GPS to distinguish E3/E4 ICs.
+	*/
+	index = size - 1;
+	/* full match */
+	while ((0 <= index) && (hw_ver != mtk_wcn_soc_info_table[index].u4HwVer))
+		--index;
+	if (0 <= index) {
+		WMT_DBG_FUNC("found ic info(0x%x) by full match! index:%d\n", hw_ver, index);
+		return &mtk_wcn_soc_info_table[index];
+	}
+
+	WMT_WARN_FUNC("find no ic info for (0x%x) by full match!try major num match!\n", hw_ver);
+
+	/* George: The ONLY CORRECT method to find supported hw table. Match MAJOR
+	 * NUM only can help us support future minor hw ECO, or fab switch, etc.
+	 * FULL matching eliminate such flexibility and software package have to be
+	 * updated EACH TIME even when minor hw ECO or fab switch!!!
+	 */
+	/* George: reverse the search order to favor newer version products */
+	index = size - 1;
+	/* major num match */
+	while ((0 <= index) &&
+		(MAJORNUM(hw_ver) != MAJORNUM(mtk_wcn_soc_info_table[index].u4HwVer))) {
+		--index;
+	}
+	if (0 <= index) {
+		WMT_DBG_FUNC("0x%x: found ic info for hw_ver(0x%x) by major num! index:%d\n",
+			wmt_ic_ops_soc.icId, hw_ver, index);
+		return &mtk_wcn_soc_info_table[index];
+	}
+
+	WMT_ERR_FUNC("0x%x: find no ic info for hw_ver(0x%x) by full match nor major num match!\n",
+			wmt_ic_ops_soc.icId, hw_ver);
+	WMT_ERR_FUNC("Set default chip version: E1!\n");
+	return &mtk_wcn_soc_info_table[0];
+}
+
+#if CFG_WMT_FILTER_MODE_SETTING
+static INT32 wmt_stp_wifi_lte_coex(VOID)
+{
+	INT32 iRet;
+	unsigned long addr;
+	WMT_GEN_CONF *pWmtGenConf;
+
+	/*Get wmt config */
+	iRet = wmt_core_ctrl(WMT_CTRL_GET_WMT_CONF, &addr, 0);
+	if (iRet) {
+		WMT_ERR_FUNC("ctrl GET_WMT_CONF fail(%d)\n", iRet);
+		return -2;
+	}
+	WMT_DBG_FUNC("ctrl GET_WMT_CONF ok(0x%08lx)\n", addr);
+
+	pWmtGenConf = (P_WMT_GEN_CONF) addr;
+
+	/*Check if WMT.cfg exists */
+	if (pWmtGenConf->cfgExist == 0) {
+		WMT_INFO_FUNC("cfgExist == 0, skip config chip\n");
+		/*if WMT.cfg not existed, still return success and adopt the default value */
+		return 0;
+	}
+
+	osal_sleep_ms(5);
+
+	if (pWmtGenConf->coex_wmt_filter_mode == 0) {
+		if ((0x6752 == wmt_ic_ops_soc.icId) ||
+		    (0x6580 == wmt_ic_ops_soc.icId) ||
+		    (0x8163 == wmt_ic_ops_soc.icId) ||
+		    (0x0326 == wmt_ic_ops_soc.icId) ||
+		    (0x0321 == wmt_ic_ops_soc.icId) ||
+		    (0x0335 == wmt_ic_ops_soc.icId) || (0x0337 == wmt_ic_ops_soc.icId)) {
+			iRet =
+			    wmt_core_init_script(set_wifi_lte_coex_table_1, osal_array_size(set_wifi_lte_coex_table_1));
+			WMT_DBG_FUNC("wmt_core:set_wifi_lte_coex_table_1 %s(%d)\n", iRet ? "fail" : "ok", iRet);
+		} else if (0x0279 == wmt_ic_ops_soc.icId) {
+			/* add WMT_COXE_CONFIG_EXT_COMPONENT_OPCODE command for 2G4 eLNA demand*/
+			if (pWmtGenConf->coex_wmt_ext_component) {
+				WMT_INFO_FUNC("coex_wmt_ext_component:0x%x\n", pWmtGenConf->coex_wmt_ext_component);
+				set_wifi_lte_coex_table_2[0].cmd[5] = pWmtGenConf->coex_wmt_ext_component;
+			}
+			iRet =
+			    wmt_core_init_script(set_wifi_lte_coex_table_2, osal_array_size(set_wifi_lte_coex_table_2));
+			WMT_DBG_FUNC("wmt_core:set_wifi_lte_coex_table_2 %s(%d)\n", iRet ? "fail" : "ok", iRet);
+		} else {
+			iRet =
+			    wmt_core_init_script(set_wifi_lte_coex_table_0, osal_array_size(set_wifi_lte_coex_table_0));
+			WMT_DBG_FUNC("wmt_core:set_wifi_lte_coex_table_0 %s(%d)\n", iRet ? "fail" : "ok", iRet);
+		}
+	}
+
+	return iRet;
+}
+#endif
+
+static INT32 wmt_stp_init_coex(VOID)
+{
+	INT32 iRet;
+	unsigned long addr;
+	WMT_GEN_CONF *pWmtGenConf;
+
+#define COEX_WMT  0
+
+#if CFG_SUBSYS_COEX_NEED
+	/* no need for MT6628 */
+#define COEX_BT   1
+#define COEX_WIFI 2
+#define COEX_PTA  3
+#define COEX_MISC 4
+#endif
+	/*Get wmt config */
+	iRet = wmt_core_ctrl(WMT_CTRL_GET_WMT_CONF, &addr, 0);
+	if (iRet) {
+		WMT_ERR_FUNC("ctrl GET_WMT_CONF fail(%d)\n", iRet);
+		return -2;
+	}
+	WMT_INFO_FUNC("ctrl GET_WMT_CONF ok(0x%08lx)\n", addr);
+
+	pWmtGenConf = (P_WMT_GEN_CONF) addr;
+
+	/*Check if WMT.cfg exists */
+	if (pWmtGenConf->cfgExist == 0) {
+		WMT_INFO_FUNC("cfgExist == 0, skip config chip\n");
+		/*if WMT.cfg not existed, still return success and adopt the default value */
+		return 0;
+	}
+
+	/*Dump the coex-related info */
+	WMT_DBG_FUNC("coex_wmt:0x%x\n", pWmtGenConf->coex_wmt_ant_mode);
+#if CFG_SUBSYS_COEX_NEED
+	WMT_DBG_FUNC("coex_bt:0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+		     pWmtGenConf->coex_bt_rssi_upper_limit,
+		     pWmtGenConf->coex_bt_rssi_mid_limit,
+		     pWmtGenConf->coex_bt_rssi_lower_limit,
+		     pWmtGenConf->coex_bt_pwr_high, pWmtGenConf->coex_bt_pwr_mid, pWmtGenConf->coex_bt_pwr_low);
+	WMT_DBG_FUNC("coex_wifi:0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+		     pWmtGenConf->coex_wifi_rssi_upper_limit,
+		     pWmtGenConf->coex_wifi_rssi_mid_limit,
+		     pWmtGenConf->coex_wifi_rssi_lower_limit,
+		     pWmtGenConf->coex_wifi_pwr_high, pWmtGenConf->coex_wifi_pwr_mid, pWmtGenConf->coex_wifi_pwr_low);
+	WMT_DBG_FUNC("coex_ext_pta:0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+		     pWmtGenConf->coex_ext_pta_hi_tx_tag,
+		     pWmtGenConf->coex_ext_pta_hi_rx_tag,
+		     pWmtGenConf->coex_ext_pta_lo_tx_tag,
+		     pWmtGenConf->coex_ext_pta_lo_rx_tag,
+		     pWmtGenConf->coex_ext_pta_sample_t1,
+		     pWmtGenConf->coex_ext_pta_sample_t2, pWmtGenConf->coex_ext_pta_wifi_bt_con_trx);
+	WMT_DBG_FUNC("coex_misc:0x%x 0x%x 0x%x\n",
+		     pWmtGenConf->coex_misc_ext_pta_on, pWmtGenConf->coex_misc_ext_feature_set);
+#endif
+
+	/*command adjustion due to WMT.cfg */
+	coex_table[COEX_WMT].cmd[5] = pWmtGenConf->coex_wmt_ant_mode;
+	if (gWmtDbgLvl >= WMT_LOG_DBG)
+		wmt_core_dump_data(&coex_table[COEX_WMT].cmd[0], coex_table[COEX_WMT].str, coex_table[COEX_WMT].cmdSz);
+
+#if CFG_SUBSYS_COEX_NEED
+	coex_table[COEX_BT].cmd[9] = pWmtGenConf->coex_bt_rssi_upper_limit;
+	coex_table[COEX_BT].cmd[10] = pWmtGenConf->coex_bt_rssi_mid_limit;
+	coex_table[COEX_BT].cmd[11] = pWmtGenConf->coex_bt_rssi_lower_limit;
+	coex_table[COEX_BT].cmd[12] = pWmtGenConf->coex_bt_pwr_high;
+	coex_table[COEX_BT].cmd[13] = pWmtGenConf->coex_bt_pwr_mid;
+	coex_table[COEX_BT].cmd[14] = pWmtGenConf->coex_bt_pwr_low;
+	if (gWmtDbgLvl >= WMT_LOG_DBG)
+		wmt_core_dump_data(&coex_table[COEX_BT].cmd[0], coex_table[COEX_BT].str, coex_table[COEX_BT].cmdSz);
+
+	coex_table[COEX_WIFI].cmd[10] = pWmtGenConf->coex_wifi_rssi_upper_limit;
+	coex_table[COEX_WIFI].cmd[11] = pWmtGenConf->coex_wifi_rssi_mid_limit;
+	coex_table[COEX_WIFI].cmd[12] = pWmtGenConf->coex_wifi_rssi_lower_limit;
+	coex_table[COEX_WIFI].cmd[13] = pWmtGenConf->coex_wifi_pwr_high;
+	coex_table[COEX_WIFI].cmd[14] = pWmtGenConf->coex_wifi_pwr_mid;
+	coex_table[COEX_WIFI].cmd[15] = pWmtGenConf->coex_wifi_pwr_low;
+	if (gWmtDbgLvl >= WMT_LOG_DBG)
+		wmt_core_dump_data(&coex_table[COEX_WIFI].cmd[0],
+				   coex_table[COEX_WIFI].str, coex_table[COEX_WIFI].cmdSz);
+
+	coex_table[COEX_PTA].cmd[5] = pWmtGenConf->coex_ext_pta_hi_tx_tag;
+	coex_table[COEX_PTA].cmd[6] = pWmtGenConf->coex_ext_pta_hi_rx_tag;
+	coex_table[COEX_PTA].cmd[7] = pWmtGenConf->coex_ext_pta_lo_tx_tag;
+	coex_table[COEX_PTA].cmd[8] = pWmtGenConf->coex_ext_pta_lo_rx_tag;
+	coex_table[COEX_PTA].cmd[9] = ((pWmtGenConf->coex_ext_pta_sample_t1 & 0xff00) >> 8);
+	coex_table[COEX_PTA].cmd[10] = ((pWmtGenConf->coex_ext_pta_sample_t1 & 0x00ff) >> 0);
+	coex_table[COEX_PTA].cmd[11] = ((pWmtGenConf->coex_ext_pta_sample_t2 & 0xff00) >> 8);
+	coex_table[COEX_PTA].cmd[12] = ((pWmtGenConf->coex_ext_pta_sample_t2 & 0x00ff) >> 0);
+	coex_table[COEX_PTA].cmd[13] = pWmtGenConf->coex_ext_pta_wifi_bt_con_trx;
+	if (gWmtDbgLvl >= WMT_LOG_DBG)
+		wmt_core_dump_data(&coex_table[COEX_PTA].cmd[0], coex_table[COEX_PTA].str, coex_table[COEX_PTA].cmdSz);
+
+	osal_memcpy(&coex_table[COEX_MISC].cmd[5], &pWmtGenConf->coex_misc_ext_pta_on,
+		    sizeof(pWmtGenConf->coex_misc_ext_pta_on));
+	osal_memcpy(&coex_table[COEX_MISC].cmd[9], &pWmtGenConf->coex_misc_ext_feature_set,
+		    sizeof(pWmtGenConf->coex_misc_ext_feature_set));
+
+	wmt_core_dump_data(&coex_table[COEX_MISC].cmd[0], coex_table[COEX_MISC].str, coex_table[COEX_MISC].cmdSz);
+#endif
+
+	iRet = wmt_core_init_script(coex_table, sizeof(coex_table) / sizeof(coex_table[0]));
+
+	return iRet;
+}
+
+#if CFG_WMT_SDIO_DRIVING_SET
+static INT32 mtk_wcn_soc_set_sdio_driving(void)
+{
+	INT32 ret = 0;
+
+	unsigned long addr;
+	WMT_GEN_CONF *pWmtGenConf;
+	UINT32 drv_val = 0;
+
+	/*Get wmt config */
+	ret = wmt_core_ctrl(WMT_CTRL_GET_WMT_CONF, &addr, 0);
+	if (ret) {
+		WMT_ERR_FUNC("ctrl GET_WMT_CONF fail(%d)\n", ret);
+		return -1;
+	}
+	WMT_INFO_FUNC("ctrl GET_WMT_CONF ok(0x%08lx)\n", addr);
+
+	pWmtGenConf = (P_WMT_GEN_CONF) addr;
+
+	/*Check if WMT.cfg exists */
+	if (pWmtGenConf->cfgExist == 0) {
+		WMT_INFO_FUNC("cfgExist == 0, skip config chip\n");
+		/*if WMT.cfg not existed, still return success and adopt the default value */
+		return 0;
+	}
+
+	drv_val = pWmtGenConf->sdio_driving_cfg;
+
+	/*Dump the sdio driving related info */
+	WMT_INFO_FUNC("sdio driving:0x%x\n", drv_val);
+
+	sdio_driving_table[0].cmd[12] = (UINT8) ((drv_val & 0x00000077UL) >> 0);	/* DAT0 and DAT1 */
+	sdio_driving_table[0].cmd[13] = (UINT8) ((drv_val & 0x00007700UL) >> 8);	/* DAT2 and DAT3 */
+	sdio_driving_table[0].cmd[14] = (UINT8) ((drv_val & 0x00070000UL) >> 16);	/* CMD */
+
+	ret = wmt_core_init_script(sdio_driving_table, sizeof(sdio_driving_table) / sizeof(sdio_driving_table[0]));
+
+	return ret;
+}
+#endif
+
+#if CFG_WMT_CRYSTAL_TIMING_SET
+static INT32 mtk_wcn_soc_crystal_triming_set(VOID)
+{
+	INT32 iRet = 0;
+	PUINT8 pbuf = NULL;
+	UINT32 bufLen = 0;
+	WMT_CTRL_DATA ctrlData;
+	UINT32 uCryTimOffset = 0x6D;
+	MTK_WCN_BOOL bIsNvramExist = MTK_WCN_BOOL_FALSE;
+	INT8 cCrystalTimingOffset = 0x0;
+	UINT8 cCrystalTiming = 0x0;
+	INT32 iCrystalTiming = 0x0;
+	MTK_WCN_BOOL bIsCrysTrimEnabled = MTK_WCN_BOOL_FALSE;
+	UINT32 u4Res;
+
+	bIsNvramExist = MTK_WCN_BOOL_FALSE;
+	 /**/ ctrlData.ctrlId = WMT_CTRL_CRYSTAL_TRIMING_GET;
+	ctrlData.au4CtrlData[0] = (UINT32) "/data/nvram/APCFG/APRDEB/WIFI";
+	ctrlData.au4CtrlData[1] = (UINT32) &pbuf;
+	ctrlData.au4CtrlData[2] = (UINT32) &bufLen;
+
+	iRet = wmt_ctrl(&ctrlData);
+	if (0 != iRet) {
+		WMT_ERR_FUNC("0x%x: WMT_CTRL_CRYSTAL_TRIMING_GET fail:%d\n", wmt_ic_ops_soc.icId, iRet);
+		bIsNvramExist = MTK_WCN_BOOL_FALSE;
+		bIsCrysTrimEnabled = MTK_WCN_BOOL_FALSE;
+		cCrystalTimingOffset = 0x0;
+		cCrystalTiming = 0x0;
+		iRet = -1;
+	} else {
+		WMT_DBG_FUNC("0x%x: nvram pBuf(0x%08x), bufLen(%d)\n", wmt_ic_ops_soc.icId, pbuf, bufLen);
+		if (bufLen < (uCryTimOffset + 1)) {
+			WMT_ERR_FUNC("0x%x: nvram len(%d) too short, crystalTimging value offset(%d)\n",
+				     wmt_ic_ops_soc.icId, bufLen, uCryTimOffset);
+			bIsNvramExist = MTK_WCN_BOOL_FALSE;
+			bIsCrysTrimEnabled = MTK_WCN_BOOL_FALSE;
+			cCrystalTimingOffset = 0x0;
+			cCrystalTiming = 0x0;
+		} else {
+			bIsNvramExist = MTK_WCN_BOOL_TRUE;
+			cCrystalTimingOffset = *(pbuf + uCryTimOffset);
+			if (cCrystalTimingOffset & 0x80) {
+				bIsCrysTrimEnabled = MTK_WCN_BOOL_TRUE;
+				cCrystalTimingOffset = (UINT8) cCrystalTimingOffset & 0x7f;
+			}
+			WMT_DBG_FUNC("cCrystalTimingOffset (%d), bIsCrysTrimEnabled(%d)\n", cCrystalTimingOffset,
+				     bIsCrysTrimEnabled);
+		}
+		ctrlData.ctrlId = WMT_CTRL_CRYSTAL_TRIMING_PUT;
+		ctrlData.au4CtrlData[0] = (UINT32) "/data/nvram/APCFG/APRDEB/WIFI";
+		iRet = wmt_ctrl(&ctrlData);
+		if (0 != iRet) {
+			WMT_ERR_FUNC("0x%x: WMT_CTRL_CRYSTAL_TRIMING_PUT fail:%d\n", wmt_ic_ops_soc.icId, iRet);
+			iRet = -2;
+		} else {
+			WMT_DBG_FUNC("0x%x: WMT_CTRL_CRYSTAL_TRIMING_PUT succeed\n", wmt_ic_ops_soc.icId);
+		}
+	}
+	if ((MTK_WCN_BOOL_TRUE == bIsNvramExist) && (MTK_WCN_BOOL_TRUE == bIsCrysTrimEnabled)) {
+		/*get CrystalTiming value before set it */
+		iRet =
+		    wmt_core_tx(get_crystal_timing_script[0].cmd, get_crystal_timing_script[0].cmdSz, &u4Res,
+				MTK_WCN_BOOL_FALSE);
+		if (iRet || (u4Res != get_crystal_timing_script[0].cmdSz)) {
+			WMT_ERR_FUNC("WMT-CORE: write (%s) iRet(%d) cmd len err(%d, %d)\n",
+				     get_crystal_timing_script[0].str, iRet, u4Res, get_crystal_timing_script[0].cmdSz);
+			iRet = -3;
+			goto done;
+		}
+		/* EVENT BUF */
+		osal_memset(get_crystal_timing_script[0].evt, 0, get_crystal_timing_script[0].evtSz);
+		iRet = wmt_core_rx(get_crystal_timing_script[0].evt, get_crystal_timing_script[0].evtSz, &u4Res);
+		if (iRet || (u4Res != get_crystal_timing_script[0].evtSz)) {
+			WMT_ERR_FUNC("WMT-CORE: read (%s) iRet(%d) evt len err(rx:%d, exp:%d)\n",
+				     get_crystal_timing_script[0].str, iRet, u4Res, get_crystal_timing_script[0].evtSz);
+			mtk_wcn_stp_dbg_dump_package();
+			iRet = -4;
+			goto done;
+		}
+
+		iCrystalTiming = WMT_GET_CRYSTAL_TRIMING_EVT[5] & 0x7f;
+		if (cCrystalTimingOffset & 0x40) {
+			/*nagative offset value */
+			iCrystalTiming = iCrystalTiming + cCrystalTimingOffset - 128;
+		} else {
+			iCrystalTiming += cCrystalTimingOffset;
+		}
+		WMT_DBG_FUNC("iCrystalTiming (0x%x)\n", iCrystalTiming);
+		cCrystalTiming = iCrystalTiming > 0x7f ? 0x7f : iCrystalTiming;
+		cCrystalTiming = iCrystalTiming < 0 ? 0 : iCrystalTiming;
+		WMT_DBG_FUNC("cCrystalTiming (0x%x)\n", cCrystalTiming);
+		/* set_crystal_timing_script */
+		WMT_SET_CRYSTAL_TRIMING_CMD[5] = cCrystalTiming;
+		WMT_GET_CRYSTAL_TRIMING_EVT[5] = cCrystalTiming;
+
+		iRet = wmt_core_init_script(set_crystal_timing_script, osal_array_size(set_crystal_timing_script));
+		if (iRet) {
+			WMT_ERR_FUNC("set_crystal_timing_script fail(%d)\n", iRet);
+			iRet = -5;
+		} else {
+			WMT_DBG_FUNC("set crystal timing value (0x%x) succeed\n", WMT_SET_CRYSTAL_TRIMING_CMD[5]);
+			iRet =
+			    wmt_core_init_script(get_crystal_timing_script, osal_array_size(get_crystal_timing_script));
+			if (iRet) {
+				WMT_ERR_FUNC("get_crystal_timing_script fail(%d)\n", iRet);
+				iRet = -6;
+			} else {
+				WMT_INFO_FUNC("succeed, updated crystal timing value (0x%x)\n",
+					      WMT_GET_CRYSTAL_TRIMING_EVT[5]);
+				iRet = 0x0;
+			}
+		}
+	}
+done:
+	return iRet;
+}
+#endif
+
+#if CFG_WMT_MULTI_PATCH
+static INT32 mtk_wcn_soc_patch_info_prepare(VOID)
+{
+	INT32 iRet = -1;
+	WMT_CTRL_DATA ctrlData;
+
+	ctrlData.ctrlId = WMT_CTRL_PATCH_SEARCH;
+	iRet = wmt_ctrl(&ctrlData);
+
+	return iRet;
+}
+
+static INT32 mtk_wcn_soc_patch_dwn(UINT32 index)
+{
+	INT32 iRet = -1;
+	P_WMT_PATCH patchHdr;
+	PUINT8 pbuf;
+	UINT32 patchSize;
+	UINT32 fragSeq;
+	UINT32 fragNum;
+	UINT16 fragSize = 0;
+	UINT16 cmdLen;
+	UINT32 offset;
+	UINT32 u4Res;
+	UINT8 evtBuf[8];
+	UINT8 addressevtBuf[12];
+	UINT8 addressByte[4];
+	PINT8 cDataTime = NULL;
+	/*PINT8 cPlat = NULL; */
+	UINT16 u2HwVer = 0;
+	UINT16 u2SwVer = 0;
+	UINT32 u4PatchVer = 0;
+	UINT32 patchSizePerFrag = 0;
+	WMT_CTRL_DATA ctrlData;
+
+	/*1.check hardware information */
+	if (NULL == gp_soc_info) {
+		WMT_ERR_FUNC("null gp_soc_info!\n");
+		return -1;
+	}
+
+	osal_memset(gFullPatchName, 0, osal_sizeof(gFullPatchName));
+
+	ctrlData.ctrlId = WMT_CTRL_GET_PATCH_INFO;
+	ctrlData.au4CtrlData[0] = index + 1;
+	ctrlData.au4CtrlData[1] = (SIZE_T) &gFullPatchName;
+	ctrlData.au4CtrlData[2] = (SIZE_T) &addressByte;
+	iRet = wmt_ctrl(&ctrlData);
+	WMT_DBG_FUNC("the %d time valid patch found: (%s)\n", index + 1, gFullPatchName);
+
+	/* <2.2> read patch content */
+	ctrlData.ctrlId = WMT_CTRL_GET_PATCH;
+	ctrlData.au4CtrlData[0] = (SIZE_T) NULL;
+	ctrlData.au4CtrlData[1] = (SIZE_T) &gFullPatchName;
+	ctrlData.au4CtrlData[2] = (SIZE_T) &pbuf;
+	ctrlData.au4CtrlData[3] = (SIZE_T) &patchSize;
+	iRet = wmt_ctrl(&ctrlData);
+	if (iRet) {
+		WMT_ERR_FUNC("wmt_core: WMT_CTRL_GET_PATCH fail:%d\n", iRet);
+		iRet -= 1;
+		goto done;
+	}
+
+	/* |<-BCNT_PATCH_BUF_HEADROOM(8) bytes dummy allocated->|<-patch file->| */
+	pbuf += BCNT_PATCH_BUF_HEADROOM;
+	/* patch file with header:
+	 * |<-patch header: 28 Bytes->|<-patch body: X Bytes ----->|
+	 */
+	patchHdr = (P_WMT_PATCH) pbuf;
+	/* check patch file information */
+
+	cDataTime = patchHdr->ucDateTime;
+	u2HwVer = patchHdr->u2HwVer;
+	u2SwVer = patchHdr->u2SwVer;
+	u4PatchVer = patchHdr->u4PatchVer;
+	/*cPlat = &patchHdr->ucPLat[0]; */
+
+	cDataTime[15] = '\0';
+	if (index == 0) {
+		WMT_DBG_FUNC("===========================================\n");
+		WMT_INFO_FUNC("[Patch]BuiltTime = %s, HVer = 0x%x, SVer = 0x%x, PhVer = 0x%04x,Platform = %c%c%c%c\n",
+		cDataTime, ((u2HwVer & 0x00ff) << 8) | ((u2HwVer & 0xff00) >> 8),
+		((u2SwVer & 0x00ff) << 8) | ((u2SwVer & 0xff00) >> 8),
+		((u4PatchVer & 0xff000000) >> 24) | ((u4PatchVer & 0x00ff0000) >> 16),
+		patchHdr->ucPLat[0], patchHdr->ucPLat[1], patchHdr->ucPLat[2], patchHdr->ucPLat[3]);
+		WMT_DBG_FUNC("[Consys Patch] Hw Ver = 0x%x\n", ((u2HwVer & 0x00ff) << 8) | ((u2HwVer & 0xff00) >> 8));
+		WMT_DBG_FUNC("[Consys Patch] Sw Ver = 0x%x\n", ((u2SwVer & 0x00ff) << 8) | ((u2SwVer & 0xff00) >> 8));
+		WMT_DBG_FUNC("[Consys Patch] Ph Ver = 0x%04x\n",
+			      ((u4PatchVer & 0xff000000) >> 24) | ((u4PatchVer & 0x00ff0000) >> 16));
+		WMT_DBG_FUNC("[Consys Patch] Platform = %c%c%c%c\n", patchHdr->ucPLat[0], patchHdr->ucPLat[1],
+			      patchHdr->ucPLat[2], patchHdr->ucPLat[3]);
+		WMT_DBG_FUNC("===========================================\n");
+	}
+
+	/* remove patch header:
+	 * |<-patch body: X Bytes (X=patchSize)--->|
+	 */
+	patchSize -= sizeof(WMT_PATCH);
+	pbuf += sizeof(WMT_PATCH);
+	patchSizePerFrag = DEFAULT_PATCH_FRAG_SIZE;
+	/* reserve 1st patch cmd space before patch body
+	 *        |<-WMT_CMD: 5Bytes->|<-patch body: X Bytes (X=patchSize)----->|
+	 */
+	/* gp_soc_patch_info = patchHdr; */
+	osal_memcpy(&gp_soc_patch_info, patchHdr, osal_sizeof(WMT_PATCH));
+	pbuf -= sizeof(WMT_PATCH_CMD);
+
+	fragNum = patchSize / patchSizePerFrag;
+	fragNum += ((fragNum * patchSizePerFrag) == patchSize) ? 0 : 1;
+
+	WMT_DBG_FUNC("patch size(%d) fragNum(%d)\n", patchSize, fragNum);
+
+	/*send wmt part patch address command */
+	if (0x6752 == wmt_ic_ops_soc.icId ||
+	    0x8127 == wmt_ic_ops_soc.icId ||
+	    0x7623 == wmt_ic_ops_soc.icId ||
+	    0x6571 == wmt_ic_ops_soc.icId ||
+	    0x0326 == wmt_ic_ops_soc.icId ||
+	    0x0321 == wmt_ic_ops_soc.icId ||
+	    0x0335 == wmt_ic_ops_soc.icId ||
+	    0x0337 == wmt_ic_ops_soc.icId || 0x8163 == wmt_ic_ops_soc.icId || 0x6580 == wmt_ic_ops_soc.icId) {
+		/* MT6571 patch RAM base */
+		WMT_PATCH_ADDRESS_CMD[8] = 0x40;
+		WMT_PATCH_P_ADDRESS_CMD[8] = 0xc8;
+	}
+	/*send wmt part patch address command */
+	if (0x0279 == wmt_ic_ops_soc.icId) {
+		/* MT6797 patch RAM base */
+		WMT_PATCH_ADDRESS_CMD[8] = 0x08;
+		WMT_PATCH_ADDRESS_CMD[9] = 0x05;
+		WMT_PATCH_P_ADDRESS_CMD[8] = 0x2c;
+		WMT_PATCH_P_ADDRESS_CMD[9] = 0x0b;
+	}
+
+	/*send wmt part patch address command */
+	iRet =
+	    wmt_core_tx((PUINT8) &WMT_PATCH_ADDRESS_CMD[0], sizeof(WMT_PATCH_ADDRESS_CMD), &u4Res, MTK_WCN_BOOL_FALSE);
+	if (iRet || (u4Res != sizeof(WMT_PATCH_ADDRESS_CMD))) {
+		WMT_ERR_FUNC("wmt_core:wmt patch address CMD fail(%d),size(%d)\n", iRet, u4Res);
+		iRet -= 1;
+		goto done;
+	}
+	osal_memset(addressevtBuf, 0, sizeof(addressevtBuf));
+	iRet = wmt_core_rx(addressevtBuf, sizeof(WMT_PATCH_ADDRESS_EVT), &u4Res);
+	if (iRet || (u4Res != sizeof(WMT_PATCH_ADDRESS_EVT))) {
+		WMT_ERR_FUNC("wmt_core:wmt patch address EVT fail(%d),size(%d)\n", iRet, u4Res);
+		iRet -= 1;
+		goto done;
+	}
+#if CFG_CHECK_WMT_RESULT
+	if (osal_memcmp(addressevtBuf, WMT_PATCH_ADDRESS_EVT, osal_sizeof(WMT_PATCH_ADDRESS_EVT)) != 0) {
+		WMT_ERR_FUNC("wmt_core: write WMT_PATCH_ADDRESS_CMD status fail\n");
+		iRet -= 1;
+		goto done;
+	}
+#endif
+
+	/*send part patch address command */
+	osal_memcpy(&WMT_PATCH_P_ADDRESS_CMD[12], addressByte, osal_sizeof(addressByte));
+	WMT_DBG_FUNC("4 bytes address command:0x%02x,0x%02x,0x%02x,0x%02x",
+		      WMT_PATCH_P_ADDRESS_CMD[12],
+		      WMT_PATCH_P_ADDRESS_CMD[13], WMT_PATCH_P_ADDRESS_CMD[14], WMT_PATCH_P_ADDRESS_CMD[15]);
+	iRet =
+	    wmt_core_tx((PUINT8) &WMT_PATCH_P_ADDRESS_CMD[0], sizeof(WMT_PATCH_P_ADDRESS_CMD), &u4Res,
+			MTK_WCN_BOOL_FALSE);
+	if (iRet || (u4Res != sizeof(WMT_PATCH_P_ADDRESS_CMD))) {
+		WMT_ERR_FUNC("wmt_core:wmt part patch address CMD fail(%d),size(%d),index(%d)\n", iRet, u4Res, index);
+		iRet -= 1;
+		goto done;
+	}
+	osal_memset(addressevtBuf, 0, sizeof(addressevtBuf));
+	iRet = wmt_core_rx(addressevtBuf, sizeof(WMT_PATCH_P_ADDRESS_EVT), &u4Res);
+	if (iRet || (u4Res != sizeof(WMT_PATCH_P_ADDRESS_EVT))) {
+		WMT_ERR_FUNC("wmt_core:wmt patch address EVT fail(%d),size(%d),index(%d)\n", iRet, u4Res, index);
+		iRet -= 1;
+		goto done;
+	}
+#if CFG_CHECK_WMT_RESULT
+	if (osal_memcmp(addressevtBuf, WMT_PATCH_P_ADDRESS_EVT, osal_sizeof(WMT_PATCH_ADDRESS_EVT)) != 0) {
+		WMT_ERR_FUNC("wmt_core: write WMT_PATCH_ADDRESS_CMD status fail,index(%d)\n", index);
+		iRet -= 1;
+		goto done;
+	}
+#endif
+
+	/* send all fragments */
+	offset = sizeof(WMT_PATCH_CMD);
+	fragSeq = 0;
+	while (fragSeq < fragNum) {
+		WMT_DBG_FUNC("patch size(%d) fragNum(%d)\n", patchSize, fragNum);
+		if (fragSeq == (fragNum - 1)) {
+			/* last fragment */
+			fragSize = patchSize - fragSeq * patchSizePerFrag;
+			WMT_PATCH_CMD[4] = WMT_PATCH_FRAG_LAST;
+		} else {
+			fragSize = patchSizePerFrag;
+			WMT_PATCH_CMD[4] = (fragSeq == 0) ? WMT_PATCH_FRAG_1ST : WMT_PATCH_FRAG_MID;
+		}
+		/* update length field in CMD:flag+frag */
+		cmdLen = 1 + fragSize;
+		osal_memcpy(&WMT_PATCH_CMD[2], &cmdLen, 2);
+		/* copy patch CMD to buf (overwrite last 5-byte in prev frag) */
+		osal_memcpy(pbuf + offset - sizeof(WMT_PATCH_CMD), WMT_PATCH_CMD, sizeof(WMT_PATCH_CMD));
+
+		/* iRet =
+		*(*kal_stp_tx)(pbuf + offset - sizeof(WMT_PATCH_CMD), fragSize + sizeof(WMT_PATCH_CMD),
+		*&u4Res);
+		*/
+		iRet =
+			wmt_core_tx(pbuf + offset - sizeof(WMT_PATCH_CMD), fragSize + sizeof(WMT_PATCH_CMD),
+				&u4Res, MTK_WCN_BOOL_FALSE);
+		if (iRet || (u4Res != fragSize + sizeof(WMT_PATCH_CMD))) {
+			WMT_ERR_FUNC("wmt_core: write fragSeq(%d) size(%d, %d) fail(%d)\n", fragSeq,
+				     fragSize + sizeof(WMT_PATCH_CMD), u4Res, iRet);
+			iRet -= 1;
+			break;
+		}
+		WMT_DBG_FUNC("wmt_core: write fragSeq(%d) size(%d, %d) ok\n",
+			     fragSeq, fragSize + sizeof(WMT_PATCH_CMD), u4Res);
+
+		osal_memset(evtBuf, 0, sizeof(evtBuf));
+		/* iRet = (*kal_stp_rx)(evtBuf, sizeof(WMT_PATCH_EVT), &u4Res); */
+		iRet = wmt_core_rx(evtBuf, sizeof(WMT_PATCH_EVT), &u4Res);
+		if (iRet || (u4Res != sizeof(WMT_PATCH_EVT))) {
+			WMT_ERR_FUNC("wmt_core: read WMT_PATCH_EVT length(%d, %d) fail(%d)\n", sizeof(WMT_PATCH_EVT),
+				     u4Res, iRet);
+			iRet -= 1;
+			break;
+		}
+#if CFG_CHECK_WMT_RESULT
+		if (osal_memcmp(evtBuf, WMT_PATCH_EVT, sizeof(WMT_PATCH_EVT)) != 0) {
+			WMT_ERR_FUNC("wmt_core: compare WMT_PATCH_EVT error rx(%d):[%02X,%02X,%02X,%02X,%02X]\n",
+				u4Res,
+				evtBuf[0],
+				evtBuf[1],
+				evtBuf[2],
+				evtBuf[3],
+				evtBuf[4]);
+			WMT_ERR_FUNC("wmt_core: exp(%d):[%02X,%02X,%02X,%02X,%02X]\n",
+				sizeof(WMT_PATCH_EVT),
+				WMT_PATCH_EVT[0],
+				WMT_PATCH_EVT[1],
+				WMT_PATCH_EVT[2],
+				WMT_PATCH_EVT[3],
+				WMT_PATCH_EVT[4]);
+			iRet -= 1;
+			break;
+		}
+#endif
+		WMT_DBG_FUNC("wmt_core: read WMT_PATCH_EVT length(%d, %d) ok\n", sizeof(WMT_PATCH_EVT), u4Res);
+		offset += patchSizePerFrag;
+		++fragSeq;
+	}
+
+	WMT_WARN_FUNC("wmt_core: patch dwn:%d frag(%d, %d) %s\n",
+		      iRet, fragSeq, fragSize, (!iRet && (fragSeq == fragNum)) ? "ok" : "fail");
+
+	if (fragSeq != fragNum)
+		iRet -= 1;
+done:
+	/* WMT_CTRL_FREE_PATCH always return 0 */
+	/* wmt_core_ctrl(WMT_CTRL_FREE_PATCH, NULL, NULL); */
+	ctrlData.ctrlId = WMT_CTRL_FREE_PATCH;
+	ctrlData.au4CtrlData[0] = index + 1;
+	wmt_ctrl(&ctrlData);
+
+	return iRet;
+}
+
+#else
+static INT32 mtk_wcn_soc_patch_dwn(VOID)
+{
+	INT32 iRet = -1;
+	P_WMT_PATCH patchHdr;
+	PUINT8 pbuf;
+	UINT32 patchSize;
+	UINT32 fragSeq;
+	UINT32 fragNum;
+	UINT16 fragSize = 0;
+	UINT16 cmdLen;
+	UINT32 offset;
+	UINT32 u4Res;
+	UINT8 evtBuf[8];
+	PINT8 cDataTime = NULL;
+	/*PINT8 cPlat = NULL; */
+	UINT16 u2HwVer = 0;
+	UINT16 u2SwVer = 0;
+	UINT32 u4PatchVer = 0;
+	UINT32 patchSizePerFrag = 0;
+	WMT_CTRL_DATA ctrlData;
+
+	/*1.check hardware information */
+	if (NULL == gp_soc_info) {
+		WMT_ERR_FUNC("null gp_soc_info!\n");
+		return -1;
+	}
+	/* <2> search patch and read patch content */
+	/* <2.1> search patch */
+	ctrlData.ctrlId = WMT_CTRL_PATCH_SEARCH;
+	iRet = wmt_ctrl(&ctrlData);
+	if (0 == iRet) {
+		/* patch with correct Hw Ver Major Num found */
+		ctrlData.ctrlId = WMT_CTRL_GET_PATCH_NAME;
+		ctrlData.au4CtrlData[0] = (UINT32) &gFullPatchName;
+		iRet = wmt_ctrl(&ctrlData);
+
+		WMT_INFO_FUNC("valid patch found: (%s)\n", gFullPatchName);
+		/* <2.2> read patch content */
+		ctrlData.ctrlId = WMT_CTRL_GET_PATCH;
+		ctrlData.au4CtrlData[0] = (UINT32) NULL;
+		ctrlData.au4CtrlData[1] = (UINT32) &gFullPatchName;
+
+	} else {
+		iRet -= 1;
+		return iRet;
+	}
+	ctrlData.au4CtrlData[2] = (UINT32) &pbuf;
+	ctrlData.au4CtrlData[3] = (UINT32) &patchSize;
+	iRet = wmt_ctrl(&ctrlData);
+	if (iRet) {
+		WMT_ERR_FUNC("wmt_core: WMT_CTRL_GET_PATCH fail:%d\n", iRet);
+		iRet -= 1;
+		goto done;
+	}
+
+	/* |<-BCNT_PATCH_BUF_HEADROOM(8) bytes dummy allocated->|<-patch file->| */
+	pbuf += BCNT_PATCH_BUF_HEADROOM;
+	/* patch file with header:
+	 * |<-patch header: 28 Bytes->|<-patch body: X Bytes ----->|
+	 */
+	patchHdr = (P_WMT_PATCH) pbuf;
+	/* check patch file information */
+
+	cDataTime = patchHdr->ucDateTime;
+	u2HwVer = patchHdr->u2HwVer;
+	u2SwVer = patchHdr->u2SwVer;
+	u4PatchVer = patchHdr->u4PatchVer;
+	/*cPlat = &patchHdr->ucPLat[0]; */
+
+	cDataTime[15] = '\0';
+	WMT_DBG_FUNC("===========================================\n");
+	WMT_INFO_FUNC("[ConsysPatch]BuiltTime = %s, HVer = 0x%x, SVer = 0x%x, PhVer = 0x%04x,Platform = %c%c%c%c\n",
+	cDataTime, ((u2HwVer & 0x00ff) << 8) | ((u2HwVer & 0xff00) >> 8),
+	((u2SwVer & 0x00ff) << 8) | ((u2SwVer & 0xff00) >> 8),
+	((u4PatchVer & 0xff000000) >> 24) | ((u4PatchVer & 0x00ff0000) >> 16),
+	patchHdr->ucPLat[0], patchHdr->ucPLat[1], patchHdr->ucPLat[2], patchHdr->ucPLat[3]);
+	WMT_DBG_FUNC("[Consys Patch] Hw Ver = 0x%x\n", ((u2HwVer & 0x00ff) << 8) | ((u2HwVer & 0xff00) >> 8));
+	WMT_DBG_FUNC("[Consys Patch] Sw Ver = 0x%x\n", ((u2SwVer & 0x00ff) << 8) | ((u2SwVer & 0xff00) >> 8));
+	WMT_DBG_FUNC("[Consys Patch] Ph Ver = 0x%04x\n",
+		      ((u4PatchVer & 0xff000000) >> 24) | ((u4PatchVer & 0x00ff0000) >> 16));
+	WMT_DBG_FUNC("[Consys Patch] Platform = %c%c%c%c\n", patchHdr->ucPLat[0], patchHdr->ucPLat[1],
+		      patchHdr->ucPLat[2], patchHdr->ucPLat[3]);
+	WMT_DBG_FUNC("===========================================\n");
+
+	/* remove patch header:
+	 * |<-patch body: X Bytes (X=patchSize)--->|
+	 */
+	patchSize -= sizeof(WMT_PATCH);
+	pbuf += sizeof(WMT_PATCH);
+	patchSizePerFrag = DEFAULT_PATCH_FRAG_SIZE;
+	/* reserve 1st patch cmd space before patch body
+	 *        |<-WMT_CMD: 5Bytes->|<-patch body: X Bytes (X=patchSize)----->|
+	 */
+	pbuf -= sizeof(WMT_PATCH_CMD);
+
+	fragNum = patchSize / patchSizePerFrag;
+	fragNum += ((fragNum * patchSizePerFrag) == patchSize) ? 0 : 1;
+
+	WMT_DBG_FUNC("patch size(%d) fragNum(%d)\n", patchSize, fragNum);
+
+	/* send all fragments */
+	offset = sizeof(WMT_PATCH_CMD);
+	fragSeq = 0;
+	while (fragSeq < fragNum) {
+		WMT_DBG_FUNC("patch size(%d) fragNum(%d)\n", patchSize, fragNum);
+		if (fragSeq == (fragNum - 1)) {
+			/* last fragment */
+			fragSize = patchSize - fragSeq * patchSizePerFrag;
+			WMT_PATCH_CMD[4] = WMT_PATCH_FRAG_LAST;
+		} else {
+			fragSize = patchSizePerFrag;
+			WMT_PATCH_CMD[4] = (fragSeq == 0) ? WMT_PATCH_FRAG_1ST : WMT_PATCH_FRAG_MID;
+		}
+		/* update length field in CMD:flag+frag */
+		cmdLen = 1 + fragSize;
+		osal_memcpy(&WMT_PATCH_CMD[2], &cmdLen, 2);
+		/* copy patch CMD to buf (overwrite last 5-byte in prev frag) */
+		osal_memcpy(pbuf + offset - sizeof(WMT_PATCH_CMD), WMT_PATCH_CMD, sizeof(WMT_PATCH_CMD));
+
+		/* iRet =
+		*	(*kal_stp_tx)(pbuf + offset - sizeof(WMT_PATCH_CMD), fragSize + sizeof(WMT_PATCH_CMD),
+		*	&u4Res);
+		*/
+		iRet =
+		    wmt_core_tx(pbuf + offset - sizeof(WMT_PATCH_CMD), fragSize + sizeof(WMT_PATCH_CMD), &u4Res,
+				MTK_WCN_BOOL_FALSE);
+		if (iRet || (u4Res != fragSize + sizeof(WMT_PATCH_CMD))) {
+			WMT_ERR_FUNC("wmt_core: write fragSeq(%d) size(%d, %d) fail(%d)\n", fragSeq,
+				     fragSize + sizeof(WMT_PATCH_CMD), u4Res, iRet);
+			iRet -= 1;
+			break;
+		}
+		WMT_DBG_FUNC("wmt_core: write fragSeq(%d) size(%d, %d) ok\n",
+			     fragSeq, fragSize + sizeof(WMT_PATCH_CMD), u4Res);
+
+		osal_memset(evtBuf, 0, sizeof(evtBuf));
+		/* iRet = (*kal_stp_rx)(evtBuf, sizeof(WMT_PATCH_EVT), &u4Res); */
+		iRet = wmt_core_rx(evtBuf, sizeof(WMT_PATCH_EVT), &u4Res);
+		if (iRet || (u4Res != sizeof(WMT_PATCH_EVT))) {
+			WMT_ERR_FUNC("wmt_core: read WMT_PATCH_EVT length(%d, %d) fail(%d)\n", sizeof(WMT_PATCH_EVT),
+				     u4Res, iRet);
+			iRet -= 1;
+			break;
+		}
+#if CFG_CHECK_WMT_RESULT
+		if (osal_memcmp(evtBuf, WMT_PATCH_EVT, sizeof(WMT_PATCH_EVT)) != 0) {
+			WMT_ERR_FUNC("wmt_core: compare WMT_PATCH_EVT error rx(%d):[%02X,%02X,%02X,%02X,%02X]\n",
+				u4Res,
+				evtBuf[0],
+				evtBuf[1],
+				evtBuf[2],
+				evtBuf[3],
+				evtBuf[4]);
+			WMT_ERR_FUNC("wmt_core: exp(%d):[%02X,%02X,%02X,%02X,%02X]\n",
+				sizeof(WMT_PATCH_EVT),
+				WMT_PATCH_EVT[0],
+				WMT_PATCH_EVT[1],
+				WMT_PATCH_EVT[2],
+				WMT_PATCH_EVT[3],
+				WMT_PATCH_EVT[4]);
+			iRet -= 1;
+			break;
+		}
+#endif
+		WMT_DBG_FUNC("wmt_core: read WMT_PATCH_EVT length(%d, %d) ok\n", sizeof(WMT_PATCH_EVT), u4Res);
+		offset += patchSizePerFrag;
+		++fragSeq;
+	}
+
+	WMT_WARN_FUNC("wmt_core: patch dwn:%d frag(%d, %d) %s\n",
+		      iRet, fragSeq, fragSize, (!iRet && (fragSeq == fragNum)) ? "ok" : "fail");
+
+	if (fragSeq != fragNum)
+		iRet -= 1;
+done:
+	/* WMT_CTRL_FREE_PATCH always return 0 */
+	wmt_core_ctrl(WMT_CTRL_FREE_PATCH, NULL, NULL);
+
+	return iRet;
+}
+
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_lib.c b/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_lib.c
new file mode 100644
index 00000000..747ed64
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_lib.c
@@ -0,0 +1,1938 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[WMT-LIB]"
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+#include "osal_typedef.h"
+
+#include "wmt_dev.h"
+#include "wmt_lib.h"
+#include "wmt_conf.h"
+#include "wmt_core.h"
+#include "wmt_plat.h"
+
+#include "stp_core.h"
+#include "btm_core.h"
+#include "psm_core.h"
+#include "stp_dbg.h"
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/* A table for translation: CMB_STUB_AIF_X=>WMT_IC_PIN_STATE */
+static const WMT_IC_PIN_STATE cmb_aif2pin_stat[] = {
+	[CMB_STUB_AIF_0] = WMT_IC_AIF_0,
+	[CMB_STUB_AIF_1] = WMT_IC_AIF_1,
+	[CMB_STUB_AIF_2] = WMT_IC_AIF_2,
+	[CMB_STUB_AIF_3] = WMT_IC_AIF_3,
+};
+
+#if CFG_WMT_PS_SUPPORT
+static UINT32 gPsIdleTime = STP_PSM_IDLE_TIME_SLEEP;
+static UINT32 gPsEnable = 1;
+static PF_WMT_SDIO_PSOP sdio_own_ctrl;
+#endif
+
+#define WMT_STP_CPUPCR_BUF_SIZE 6144
+static UINT8 g_cpupcr_buf[WMT_STP_CPUPCR_BUF_SIZE] = { 0 };
+
+static UINT32 g_quick_sleep_ctrl = 1;
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+DEV_WMT gDevWmt;
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+#if CFG_WMT_PS_SUPPORT
+static MTK_WCN_BOOL wmt_lib_ps_action(MTKSTP_PSM_ACTION_T action);
+static MTK_WCN_BOOL wmt_lib_ps_do_sleep(VOID);
+static MTK_WCN_BOOL wmt_lib_ps_do_wakeup(VOID);
+static MTK_WCN_BOOL wmt_lib_ps_do_host_awake(VOID);
+static INT32 wmt_lib_ps_handler(MTKSTP_PSM_ACTION_T action);
+#endif
+
+static MTK_WCN_BOOL wmt_lib_put_op(P_OSAL_OP_Q pOpQ, P_OSAL_OP pLxOp);
+
+static P_OSAL_OP wmt_lib_get_op(P_OSAL_OP_Q pOpQ);
+
+static INT32 wmtd_thread(PVOID pvData);
+
+static INT32 wmt_lib_pin_ctrl(WMT_IC_PIN_ID id, WMT_IC_PIN_STATE stat, UINT32 flag);
+static MTK_WCN_BOOL wmt_lib_hw_state_show(VOID);
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+INT32 wmt_lib_idc_lock_aquire(VOID)
+{
+	return osal_lock_sleepable_lock(&gDevWmt.idc_lock);
+}
+
+VOID wmt_lib_idc_lock_release(VOID)
+{
+	osal_unlock_sleepable_lock(&gDevWmt.idc_lock);
+}
+INT32 wmt_lib_psm_lock_aquire(void)
+{
+	return osal_lock_sleepable_lock(&gDevWmt.psm_lock);
+}
+
+void wmt_lib_psm_lock_release(void)
+{
+	osal_unlock_sleepable_lock(&gDevWmt.psm_lock);
+}
+
+INT32 DISABLE_PSM_MONITOR(void)
+{
+	INT32 ret = 0;
+
+	/* osal_lock_sleepable_lock(&gDevWmt.psm_lock); */
+	ret = wmt_lib_psm_lock_aquire();
+	if (ret) {
+		WMT_ERR_FUNC("--->lock psm_lock failed, ret=%d\n", ret);
+		return ret;
+	}
+#if CFG_WMT_PS_SUPPORT
+	ret = wmt_lib_ps_disable();
+	if (ret) {
+		WMT_ERR_FUNC("wmt_lib_ps_disable fail, ret=%d\n", ret);
+		wmt_lib_psm_lock_release();
+	}
+#endif
+
+	return ret;
+}
+
+void ENABLE_PSM_MONITOR(void)
+{
+#if CFG_WMT_PS_SUPPORT
+	wmt_lib_ps_enable();
+#endif
+	/* osal_unlock_sleepable_lock(&gDevWmt.psm_lock); */
+	wmt_lib_psm_lock_release();
+}
+
+INT32 wmt_lib_init(VOID)
+{
+	INT32 iRet;
+	UINT32 i;
+	P_DEV_WMT pDevWmt;
+	P_OSAL_THREAD pThraed;
+
+	/* create->init->start */
+	/* 1. create: static allocation with zero initialization */
+	pDevWmt = &gDevWmt;
+	osal_memset(&gDevWmt, 0, sizeof(gDevWmt));
+
+	iRet = wmt_conf_read_file();
+	if (iRet) {
+		WMT_ERR_FUNC("read wmt config file fail(%d)\n", iRet);
+		return -1;
+	}
+
+	pThraed = &gDevWmt.thread;
+
+	/* Create mtk_wmtd thread */
+	osal_strncpy(pThraed->threadName, "mtk_wmtd", sizeof(pThraed->threadName));
+	pThraed->pThreadData = (VOID *) pDevWmt;
+	pThraed->pThreadFunc = (VOID *) wmtd_thread;
+	iRet = osal_thread_create(pThraed);
+	if (iRet) {
+		WMT_ERR_FUNC("osal_thread_create(0x%p) fail(%d)\n", pThraed, iRet);
+		return -2;
+	}
+
+	/* 2. initialize */
+	/* Initialize wmt_core */
+
+	iRet = wmt_core_init();
+	if (iRet) {
+		WMT_ERR_FUNC("wmt_core_init() fail(%d)\n", iRet);
+		return -1;
+	}
+
+	/* Initialize WMTd Thread Information: Thread */
+	osal_event_init(&pDevWmt->rWmtdWq);
+	osal_sleepable_lock_init(&pDevWmt->psm_lock);
+	osal_sleepable_lock_init(&pDevWmt->idc_lock);
+	osal_sleepable_lock_init(&pDevWmt->rActiveOpQ.sLock);
+	osal_sleepable_lock_init(&pDevWmt->rFreeOpQ.sLock);
+	pDevWmt->state.data = 0;
+
+	/* Initialize op queue */
+	RB_INIT(&pDevWmt->rFreeOpQ, WMT_OP_BUF_SIZE);
+	RB_INIT(&pDevWmt->rActiveOpQ, WMT_OP_BUF_SIZE);
+	/* Put all to free Q */
+	for (i = 0; i < WMT_OP_BUF_SIZE; i++) {
+		osal_signal_init(&(pDevWmt->arQue[i].signal));
+		wmt_lib_put_op(&pDevWmt->rFreeOpQ, &(pDevWmt->arQue[i]));
+	}
+
+	/* initialize stp resources */
+	osal_event_init(&pDevWmt->rWmtRxWq);
+
+	/*function driver callback */
+	for (i = 0; i < WMTDRV_TYPE_WIFI; i++)
+		pDevWmt->rFdrvCb.fDrvRst[i] = NULL;
+
+	pDevWmt->hw_ver = WMTHWVER_MAX;
+	WMT_INFO_FUNC("***********Init, hw->ver = %x\n", pDevWmt->hw_ver);
+
+	/* TODO:[FixMe][GeorgeKuo]: wmt_lib_conf_init */
+	/* initialize default configurations */
+	/* i4Result = wmt_lib_conf_init(VOID); */
+	/* WMT_WARN_FUNC("wmt_drv_conf_init(%d)\n", i4Result); */
+
+	osal_signal_init(&pDevWmt->cmdResp);
+	osal_event_init(&pDevWmt->cmdReq);
+
+	/* initialize platform resources */
+	if (0 != gDevWmt.rWmtGenConf.cfgExist)
+		iRet = wmt_plat_init(gDevWmt.rWmtGenConf.co_clock_flag & 0x0f);
+	else
+		iRet = wmt_plat_init(0);
+
+	if (iRet) {
+		WMT_ERR_FUNC("wmt_plat_init() fail(%d)\n", iRet);
+		return -3;
+	}
+#if CFG_WMT_PS_SUPPORT
+	iRet = wmt_lib_ps_init();
+	if (iRet) {
+		WMT_ERR_FUNC("wmt_lib_ps_init() fail(%d)\n", iRet);
+		return -4;
+	}
+#endif
+
+	/* 3. start: start running mtk_wmtd */
+	iRet = osal_thread_run(pThraed);
+	if (iRet) {
+		WMT_ERR_FUNC("osal_thread_run(0x%p) fail(%d)\n", pThraed, iRet);
+		return -5;
+	}
+
+	/*4. register irq callback to WMT-PLAT */
+	wmt_plat_irq_cb_reg(wmt_lib_ps_irq_cb);
+
+	/*5. register audio if control callback to WMT-PLAT */
+	wmt_plat_aif_cb_reg(wmt_lib_set_aif);
+
+	/*6. register function control callback to WMT-PLAT */
+	wmt_plat_func_ctrl_cb_reg(mtk_wcn_wmt_func_ctrl_for_plat);
+
+	wmt_plat_deep_idle_ctrl_cb_reg(mtk_wcn_consys_stp_btif_dpidle_ctrl);
+	/*7 reset gps/bt state */
+
+	mtk_wcn_wmt_system_state_reset();
+
+#ifdef MTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+	mtk_wcn_wmt_exp_init();
+#endif
+
+#if CFG_WMT_LTE_COEX_HANDLING
+	wmt_idc_init();
+#endif
+	WMT_DBG_FUNC("init success\n");
+	return 0;
+}
+
+INT32 wmt_lib_deinit(VOID)
+{
+	INT32 iRet;
+	P_DEV_WMT pDevWmt;
+	P_OSAL_THREAD pThraed;
+	INT32 i;
+	INT32 iResult;
+
+	pDevWmt = &gDevWmt;
+	pThraed = &gDevWmt.thread;
+	iResult = 0;
+
+	/* stop->deinit->destroy */
+
+	/* 1. stop: stop running mtk_wmtd */
+	iRet = osal_thread_stop(pThraed);
+	if (iRet) {
+		WMT_ERR_FUNC("osal_thread_stop(0x%p) fail(%d)\n", pThraed, iRet);
+		iResult += 1;
+	}
+
+	/* 2. deinit: */
+
+#if CFG_WMT_PS_SUPPORT
+	iRet = wmt_lib_ps_deinit();
+	if (iRet) {
+		WMT_ERR_FUNC("wmt_lib_ps_deinit fail(%d)\n", iRet);
+		iResult += 2;
+	}
+#endif
+
+	iRet = wmt_plat_deinit();
+	if (iRet) {
+		WMT_ERR_FUNC("wmt_plat_deinit fail(%d)\n", iRet);
+		iResult += 4;
+	}
+
+	osal_event_deinit(&pDevWmt->cmdReq);
+	osal_signal_deinit(&pDevWmt->cmdResp);
+
+	/* de-initialize stp resources */
+	osal_event_deinit(&pDevWmt->rWmtRxWq);
+
+	for (i = 0; i < WMT_OP_BUF_SIZE; i++)
+		osal_signal_deinit(&(pDevWmt->arQue[i].signal));
+
+
+	osal_sleepable_lock_deinit(&pDevWmt->rFreeOpQ.sLock);
+	osal_sleepable_lock_deinit(&pDevWmt->rActiveOpQ.sLock);
+	osal_sleepable_lock_deinit(&pDevWmt->idc_lock);
+	osal_sleepable_lock_deinit(&pDevWmt->psm_lock);
+	osal_event_deinit(&pDevWmt->rWmtdWq);
+
+	iRet = wmt_core_deinit();
+	if (iRet) {
+		WMT_ERR_FUNC("wmt_core_deinit fail(%d)\n", iRet);
+		iResult += 8;
+	}
+
+	/* 3. destroy */
+	iRet = osal_thread_destroy(pThraed);
+	if (iRet) {
+		WMT_ERR_FUNC("osal_thread_stop(0x%p) fail(%d)\n", pThraed, iRet);
+		iResult += 16;
+	}
+	osal_memset(&gDevWmt, 0, sizeof(gDevWmt));
+
+#ifdef MTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+	mtk_wcn_wmt_exp_deinit();
+#endif
+
+#if CFG_WMT_LTE_COEX_HANDLING
+	wmt_idc_deinit();
+#endif
+
+	return iResult;
+}
+
+VOID wmt_lib_flush_rx(VOID)
+{
+	mtk_wcn_stp_flush_rx_queue(WMT_TASK_INDX);
+}
+
+INT32 wmt_lib_trigger_cmd_signal(INT32 result)
+{
+	P_OSAL_SIGNAL pSignal = &gDevWmt.cmdResp;
+
+	gDevWmt.cmdResult = result;
+	osal_raise_signal(pSignal);
+	WMT_DBG_FUNC("wakeup cmdResp\n");
+	return 0;
+}
+
+P_OSAL_EVENT wmt_lib_get_cmd_event(VOID)
+{
+	return &gDevWmt.cmdReq;
+}
+
+INT32 wmt_lib_set_patch_name(PUINT8 cPatchName)
+{
+	osal_strncpy(gDevWmt.cPatchName, cPatchName, NAME_MAX);
+	return 0;
+}
+
+INT32 wmt_lib_set_hif(unsigned long hifconf)
+{
+	UINT32 val;
+	P_WMT_HIF_CONF pHif = &gDevWmt.rWmtHifConf;
+
+	val = hifconf & 0xF;
+	if (STP_UART_FULL == val) {
+		pHif->hifType = WMT_HIF_UART;
+		val = (hifconf >> 8);
+		pHif->au4HifConf[0] = val;
+		pHif->au4HifConf[1] = val;
+		mtk_wcn_stp_set_if_tx_type(STP_UART_IF_TX);
+	} else if (STP_SDIO == val) {
+		pHif->hifType = WMT_HIF_SDIO;
+		mtk_wcn_stp_set_if_tx_type(STP_SDIO_IF_TX);
+	} else if (STP_BTIF_FULL == val) {
+		pHif->hifType = WMT_HIF_BTIF;
+		mtk_wcn_stp_set_if_tx_type(STP_BTIF_IF_TX);
+	} else {
+		WMT_WARN_FUNC("invalid stp mode: %u\n", val);
+		mtk_wcn_stp_set_if_tx_type(STP_MAX_IF_TX);
+		return -1;
+	}
+
+	val = (hifconf & 0xF0) >> 4;
+	if (WMT_FM_COMM == val) {
+		pHif->au4StrapConf[0] = WMT_FM_COMM;
+	} else if (WMT_FM_I2C == val) {
+		pHif->au4StrapConf[0] = WMT_FM_I2C;
+	} else {
+		WMT_WARN_FUNC("invalid fm mode: %u\n", val);
+		return -2;
+	}
+
+	WMT_WARN_FUNC("new hifType: %d, fm:%d\n", pHif->hifType, pHif->au4StrapConf[0]);
+	return 0;
+}
+
+P_WMT_HIF_CONF wmt_lib_get_hif(VOID)
+{
+	return &gDevWmt.rWmtHifConf;
+}
+
+PUINT8 wmt_lib_get_cmd(VOID)
+{
+	if (osal_test_and_clear_bit(WMT_STAT_CMD, &gDevWmt.state))
+		return gDevWmt.cCmd;
+
+	return NULL;
+}
+
+MTK_WCN_BOOL wmt_lib_get_cmd_status(VOID)
+{
+	return osal_test_bit(WMT_STAT_CMD, &gDevWmt.state) ? MTK_WCN_BOOL_TRUE : MTK_WCN_BOOL_FALSE;
+}
+
+#if CFG_WMT_PS_SUPPORT
+INT32 wmt_lib_ps_set_idle_time(UINT32 psIdleTime)
+{
+	gPsIdleTime = psIdleTime;
+	return gPsIdleTime;
+}
+
+INT32 wmt_lib_ps_ctrl(UINT32 state)
+{
+	if (0 == state) {
+		wmt_lib_ps_disable();
+		gPsEnable = 0;
+	} else {
+		gPsEnable = 1;
+		wmt_lib_ps_enable();
+	}
+	return 0;
+}
+
+INT32 wmt_lib_ps_enable(VOID)
+{
+	if (gPsEnable)
+		mtk_wcn_stp_psm_enable(gPsIdleTime);
+
+	return 0;
+}
+
+INT32 wmt_lib_ps_disable(VOID)
+{
+	if (gPsEnable)
+		return mtk_wcn_stp_psm_disable();
+
+	return 0;
+}
+
+INT32 wmt_lib_ps_init(VOID)
+{
+	/* mtk_wcn_stp_psm_register_wmt_cb(wmt_lib_ps_stp_cb); */
+	return 0;
+}
+
+INT32 wmt_lib_ps_deinit(VOID)
+{
+	/* mtk_wcn_stp_psm_unregister_wmt_cb(); */
+	return 0;
+}
+
+static MTK_WCN_BOOL wmt_lib_ps_action(MTKSTP_PSM_ACTION_T action)
+{
+	P_OSAL_OP lxop;
+	MTK_WCN_BOOL bRet;
+	UINT32 u4Wait;
+	P_OSAL_SIGNAL pSignal;
+
+	lxop = wmt_lib_get_free_op();
+	if (!lxop) {
+		WMT_WARN_FUNC("get_free_lxop fail\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+	pSignal = &lxop->signal;
+	pSignal->timeoutValue = 0;
+	lxop->op.opId = WMT_OPID_PWR_SV;
+	lxop->op.au4OpData[0] = action;
+	lxop->op.au4OpData[1] = (SIZE_T) mtk_wcn_stp_psm_notify_stp;
+	u4Wait = 0;
+	bRet = wmt_lib_put_act_op(lxop);
+	return bRet;
+}
+
+#if CFG_WMT_LTE_COEX_HANDLING
+MTK_WCN_BOOL wmt_lib_handle_idc_msg(ipc_ilm_t *idc_infor)
+{
+	P_OSAL_OP lxop;
+	MTK_WCN_BOOL bRet = MTK_WCN_BOOL_FALSE;
+	P_OSAL_SIGNAL pSignal;
+	INT32 ret = 0;
+	UINT16 msg_len = 0;
+	static UINT8 msg_local_buffer[1300];
+#if	CFG_WMT_LTE_ENABLE_MSGID_MAPPING
+	MTK_WCN_BOOL unknown_msgid = MTK_WCN_BOOL_FALSE;
+#endif
+	WMT_DBG_FUNC("idc_infor from conn_md is 0x%p\n", idc_infor);
+	ret = wmt_lib_idc_lock_aquire();
+	if (ret) {
+		WMT_ERR_FUNC("--->lock idc_lock failed, ret=%d\n", ret);
+		return MTK_WCN_BOOL_FALSE;
+	}
+	msg_len = idc_infor->local_para_ptr->msg_len - osal_sizeof(local_para_struct);
+	osal_memcpy(&msg_local_buffer[0], &msg_len, osal_sizeof(msg_len));
+	osal_memcpy(&msg_local_buffer[osal_sizeof(msg_len)],
+			&(idc_infor->local_para_ptr->data[0]), msg_len - 1);
+	wmt_lib_idc_lock_release();
+	lxop = wmt_lib_get_free_op();
+	if (!lxop) {
+		WMT_WARN_FUNC("get_free_lxop fail\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+	pSignal = &lxop->signal;
+	pSignal->timeoutValue = MAX_EACH_WMT_CMD;
+	lxop->op.opId = WMT_OPID_IDC_MSG_HANDLING;
+	lxop->op.au4OpData[0] = (size_t) msg_local_buffer;
+	/*msg opcode fill rule is still not clrear,need scott comment */
+	/***********************************************************/
+	WMT_DBG_FUNC("ilm msg id is (0x%08x)\n", idc_infor->msg_id);
+
+#if	CFG_WMT_LTE_ENABLE_MSGID_MAPPING
+	switch (idc_infor->msg_id) {
+	case IPC_MSG_ID_EL1_LTE_DEFAULT_PARAM_IND:
+		lxop->op.au4OpData[1] = WMT_IDC_TX_OPCODE_LTE_PARA;
+		break;
+	case IPC_MSG_ID_EL1_LTE_OPER_FREQ_PARAM_IND:
+		lxop->op.au4OpData[1] = WMT_IDC_TX_OPCODE_LTE_FREQ;
+		break;
+	case IPC_MSG_ID_EL1_WIFI_MAX_PWR_IND:
+		lxop->op.au4OpData[1] = WMT_IDC_TX_OPCODE_WIFI_MAX_POWER;
+		break;
+	case IPC_MSG_ID_EL1_LTE_TX_IND:
+		lxop->op.au4OpData[1] = WMT_IDC_TX_OPCODE_LTE_INDICATION;
+		break;
+	case IPC_MSG_ID_EL1_LTE_CONNECTION_STATUS_IND:
+		lxop->op.au4OpData[1] = WMT_IDC_TX_OPCODE_LTE_CONNECTION_STAS;
+		break;
+	default:
+		unknown_msgid = MTK_WCN_BOOL_TRUE;
+		break;
+	}
+
+	if (MTK_WCN_BOOL_FALSE == unknown_msgid) {
+		/*wake up chip first */
+		if (DISABLE_PSM_MONITOR()) {
+			WMT_ERR_FUNC("wake up failed\n");
+			wmt_lib_put_op_to_free_queue(lxop);
+			return MTK_WCN_BOOL_FALSE;
+		}
+
+		bRet = wmt_lib_put_act_op(lxop);
+		ENABLE_PSM_MONITOR();
+		if (MTK_WCN_BOOL_FALSE == bRet)
+			WMT_WARN_FUNC("WMT_OPID_IDC_MSG_HANDLING fail(%d)\n", bRet);
+		else
+			WMT_DBG_FUNC("OPID(%d) type(%d) ok\n", lxop->op.opId, lxop->op.au4OpData[1]);
+	} else {
+		bRet = MTK_WCN_BOOL_FALSE;
+		wmt_lib_put_op_to_free_queue(lxop);
+		WMT_ERR_FUNC("unknown msgid from LTE(%d)\n", idc_infor->msg_id);
+	}
+#else
+	if ((idc_infor->msg_id >= IPC_EL1_MSG_ID_BEGIN)
+	    && (idc_infor->msg_id <= IPC_EL1_MSG_ID_BEGIN + IPC_EL1_MSG_ID_RANGE)) {
+		lxop->op.au4OpData[1] = idc_infor->msg_id - IPC_EL1_MSG_ID_BEGIN + LTE_MSG_ID_OFFSET - 1;
+
+		WMT_DBG_FUNC("LTE->CONN:(0x%x->0x%zx)\n", idc_infor->msg_id, lxop->op.au4OpData[1]);
+		/*wake up chip first */
+		if (DISABLE_PSM_MONITOR()) {
+			WMT_ERR_FUNC("wake up failed\n");
+			wmt_lib_put_op_to_free_queue(lxop);
+			return MTK_WCN_BOOL_FALSE;
+		}
+
+		bRet = wmt_lib_put_act_op(lxop);
+		ENABLE_PSM_MONITOR();
+		if (MTK_WCN_BOOL_FALSE == bRet) {
+			WMT_WARN_FUNC("WMT_OPID_IDC_MSG_HANDLING fail(%d)\n", bRet);
+		} else {
+			WMT_DBG_FUNC("wmt_lib_handle_idc_msg OPID(%d) type(%d) ok\n",
+				     lxop->op.opId, lxop->op.au4OpData[1]);
+		}
+	} else {
+		wmt_lib_put_op_to_free_queue(lxop);
+		WMT_ERR_FUNC("msgid(%d) out of range,wmt drop it!\n", idc_infor->msg_id);
+	}
+#endif
+
+	return bRet;
+}
+#endif
+
+static MTK_WCN_BOOL wmt_lib_ps_do_sleep(VOID)
+{
+	return wmt_lib_ps_action(SLEEP);
+}
+
+static MTK_WCN_BOOL wmt_lib_ps_do_wakeup(VOID)
+{
+	return wmt_lib_ps_action(WAKEUP);
+}
+
+static MTK_WCN_BOOL wmt_lib_ps_do_host_awake(VOID)
+{
+#if 1
+	return wmt_lib_ps_action(WAKEUP);
+#else
+	return wmt_lib_ps_action(HOST_AWAKE);
+#endif
+}
+
+/* extern int g_block_tx; */
+static INT32 wmt_lib_ps_handler(MTKSTP_PSM_ACTION_T action)
+{
+	INT32 ret;
+
+	ret = 0;		/* TODO:[FixMe][George] initial value or compile warning? */
+	/* if(g_block_tx && (action == SLEEP)) */
+	if ((0 != mtk_wcn_stp_coredump_start_get()) && (action == SLEEP)) {
+		mtk_wcn_stp_psm_notify_stp(SLEEP);
+		return ret;
+	}
+
+	/*MT662x Not Ready */
+	if (!mtk_wcn_stp_is_ready()) {
+		WMT_DBG_FUNC("MT662x Not Ready, Dont Send Sleep/Wakeup Command\n");
+		mtk_wcn_stp_psm_notify_stp(ROLL_BACK);
+		return 0;
+	}
+
+	if (SLEEP == action) {
+		WMT_DBG_FUNC("send op-----------> sleep job\n");
+
+		if (!mtk_wcn_stp_is_sdio_mode()) {
+			ret = wmt_lib_ps_do_sleep();
+			WMT_DBG_FUNC("enable host eirq\n");
+			wmt_plat_eirq_ctrl(PIN_BGF_EINT, PIN_STA_EINT_EN);
+#if CFG_WMT_DUMP_INT_STATUS
+			if (MTK_WCN_BOOL_TRUE == wmt_plat_dump_BGF_irq_status())
+				wmt_plat_BGF_irq_dump_status();
+#endif
+		} else {
+			/* ret = mtk_wcn_stp_sdio_do_own_set(); */
+			if (sdio_own_ctrl) {
+				ret = (*sdio_own_ctrl) (OWN_SET);
+			} else {
+				WMT_ERR_FUNC("sdio_own_ctrl is not registered\n");
+				ret = -1;
+			}
+
+			if (!ret) {
+				mtk_wcn_stp_psm_notify_stp(SLEEP);
+			} else if (ret == -2) {
+				mtk_wcn_stp_psm_notify_stp(ROLL_BACK);
+				WMT_WARN_FUNC("===[SDIO-PS] rollback due to tx busy===%%\n");
+			} else {
+				mtk_wcn_stp_psm_notify_stp(SLEEP);
+				WMT_ERR_FUNC("===[SDIO-PS] set own fails!===%%\n");
+			}
+		}
+
+		WMT_DBG_FUNC("send op<---------- sleep job\n");
+	} else if (WAKEUP == action) {
+		WMT_DBG_FUNC("send op --------> wake job\n");
+
+		if (!mtk_wcn_stp_is_sdio_mode()) {
+			WMT_DBG_FUNC("disable host eirq\n");
+#if CFG_WMT_DUMP_INT_STATUS
+			if (MTK_WCN_BOOL_TRUE == wmt_plat_dump_BGF_irq_status())
+				wmt_plat_BGF_irq_dump_status();
+#endif
+			wmt_plat_eirq_ctrl(PIN_BGF_EINT, PIN_STA_EINT_DIS);
+			ret = wmt_lib_ps_do_wakeup();
+		} else {
+			/* ret = mtk_wcn_stp_sdio_do_own_clr(); */
+
+			if (sdio_own_ctrl) {
+				ret = (*sdio_own_ctrl) (OWN_CLR);
+			} else {
+				WMT_ERR_FUNC("sdio_own_ctrl is not registered\n");
+				ret = -1;
+			}
+
+			if (!ret) {
+				mtk_wcn_stp_psm_notify_stp(WAKEUP);
+			} else {
+				mtk_wcn_stp_psm_notify_stp(WAKEUP);
+				WMT_ERR_FUNC("===[SDIO-PS] set own back fails!===%%\n");
+			}
+		}
+
+		WMT_DBG_FUNC("send op<---------- wake job\n");
+	} else if (HOST_AWAKE == action) {
+		WMT_DBG_FUNC("send op-----------> host awake job\n");
+
+		if (!mtk_wcn_stp_is_sdio_mode()) {
+			WMT_DBG_FUNC("disable host eirq\n");
+			/* IRQ already disabled */
+			/* wmt_plat_eirq_ctrl(PIN_BGF_EINT, PIN_STA_EINT_DIS); */
+#if 0
+			if (MTK_WCN_BOOL_TRUE == wmt_plat_dump_BGF_irq_status())
+				wmt_plat_BGF_irq_dump_status();
+#endif
+			ret = wmt_lib_ps_do_host_awake();
+		} else {
+			WMT_DBG_FUNC("[SDIO-PS] SDIO host awake! ####\n");
+
+			/* ret = mtk_wcn_stp_sdio_do_own_clr(); */
+
+			if (sdio_own_ctrl) {
+				ret = (*sdio_own_ctrl) (OWN_CLR);
+			} else {
+				WMT_ERR_FUNC("sdio_own_ctrl is not registered\n");
+				ret = -1;
+			}
+
+			/* Here we set ret to 0 directly */
+			ret = 0;
+			if (!ret) {
+				mtk_wcn_stp_psm_notify_stp(HOST_AWAKE);
+			} else {
+				mtk_wcn_stp_psm_notify_stp(HOST_AWAKE);
+				WMT_ERR_FUNC("===[SDIO-PS]set own back fails!===%%\n");
+			}
+		}
+
+		WMT_DBG_FUNC("send op<----------- host awake job\n");
+	} else if (EIRQ == action) {
+		WMT_DBG_FUNC("send op -------------> eirq job\n");
+
+		if (!mtk_wcn_stp_is_sdio_mode()) {
+			WMT_DBG_FUNC("disable host eirq\n");
+			/* Disable interrupt */
+			/* wmt_plat_eirq_ctrl(PIN_BGF_EINT, PIN_STA_EINT_DIS); */
+			ret = mtk_wcn_stp_psm_notify_stp(EIRQ);
+		} else {
+			WMT_ERR_FUNC("[SDIO-PS]sdio own-back eirq!######\n");
+			ret = mtk_wcn_stp_psm_notify_stp(EIRQ);
+		}
+
+		WMT_DBG_FUNC("send op<----------- eirq job\n");
+	}
+
+	return ret;
+}
+#endif /* end of CFG_WMT_PS_SUPPORT */
+
+INT32 wmt_lib_ps_stp_cb(MTKSTP_PSM_ACTION_T action)
+{
+#if CFG_WMT_PS_SUPPORT
+	return wmt_lib_ps_handler(action);
+#else
+	WMT_WARN_FUNC("CFG_WMT_PS_SUPPORT is not set\n");
+	return 0;
+#endif
+}
+
+MTK_WCN_BOOL wmt_lib_is_quick_ps_support(VOID)
+{
+	if ((g_quick_sleep_ctrl) && (wmt_dev_get_early_suspend_state() == MTK_WCN_BOOL_TRUE))
+		return wmt_core_is_quick_ps_support();
+	else
+		return MTK_WCN_BOOL_FALSE;
+}
+
+VOID wmt_lib_ps_irq_cb(VOID)
+{
+#if CFG_WMT_PS_SUPPORT
+	wmt_lib_ps_handler(EIRQ);
+#else
+	WMT_DBG_FUNC("CFG_WMT_PS_SUPPORT is not set\n");
+	return;
+#endif
+}
+
+VOID wmt_lib_ps_set_sdio_psop(PF_WMT_SDIO_PSOP own_cb)
+{
+#if CFG_WMT_PS_SUPPORT
+	sdio_own_ctrl = own_cb;
+#endif
+}
+
+UINT32 wmt_lib_wait_event_checker(P_OSAL_THREAD pThread)
+{
+	P_DEV_WMT pDevWmt;
+
+	if (pThread) {
+		pDevWmt = (P_DEV_WMT) (pThread->pThreadData);
+		return !RB_EMPTY(&pDevWmt->rActiveOpQ);
+	}
+	WMT_ERR_FUNC("pThread(NULL)\n");
+	return 0;
+}
+
+static INT32 wmtd_thread(void *pvData)
+{
+	P_DEV_WMT pWmtDev = (P_DEV_WMT) pvData;
+	P_OSAL_EVENT pEvent = NULL;
+	P_OSAL_OP pOp;
+	INT32 iResult;
+
+	if (NULL == pWmtDev) {
+		WMT_ERR_FUNC("pWmtDev(NULL)\n");
+		return -1;
+	}
+	WMT_INFO_FUNC("wmtd thread starts\n");
+
+	pEvent = &(pWmtDev->rWmtdWq);
+
+	for (;;) {
+		pOp = NULL;
+		pEvent->timeoutValue = 0;
+/*        osal_thread_wait_for_event(&pWmtDev->thread, pEvent);*/
+		osal_thread_wait_for_event(&pWmtDev->thread, pEvent, wmt_lib_wait_event_checker);
+
+		if (osal_thread_should_stop(&pWmtDev->thread)) {
+			WMT_INFO_FUNC("wmtd thread should stop now...\n");
+			/* TODO: clean up active opQ */
+			break;
+		}
+
+		/* get Op from activeQ */
+		pOp = wmt_lib_get_op(&pWmtDev->rActiveOpQ);
+		if (!pOp) {
+			WMT_WARN_FUNC("get_lxop activeQ fail\n");
+			continue;
+		}
+#if 0				/* wmt_core_opid_handler will do sanity check on opId, so no usage here */
+		id = lxop_get_opid(pLxOp);
+		if (id >= WMT_OPID_MAX) {
+			WMT_WARN_FUNC("abnormal opid id: 0x%x\n", id);
+			iResult = -1;
+			goto handlerDone;
+		}
+#endif
+
+		if (osal_test_bit(WMT_STAT_RST_ON, &pWmtDev->state)) {
+			/* when whole chip reset, only HW RST and SW RST cmd can execute */
+			if ((pOp->op.opId == WMT_OPID_HW_RST) || (pOp->op.opId == WMT_OPID_SW_RST)
+			    || (pOp->op.opId == WMT_OPID_GPIO_STATE)) {
+				iResult = wmt_core_opid(&pOp->op);
+			} else {
+				iResult = -2;
+				WMT_WARN_FUNC("Whole chip resetting, opid (%d) failed, iRet(%d)\n", pOp->op.opId,
+					      iResult);
+			}
+		} else {
+			wmt_lib_set_current_op(pWmtDev, pOp);
+			iResult = wmt_core_opid(&pOp->op);
+			wmt_lib_set_current_op(pWmtDev, NULL);
+		}
+
+		if (iResult)
+			WMT_WARN_FUNC("opid (%d) failed, iRet(%d)\n", pOp->op.opId, iResult);
+
+		if (osal_op_is_wait_for_signal(pOp)) {
+			osal_op_raise_signal(pOp, iResult);
+		} else {
+			/* put Op back to freeQ */
+			wmt_lib_put_op(&pWmtDev->rFreeOpQ, pOp);
+		}
+
+		if (WMT_OPID_EXIT == pOp->op.opId) {
+			WMT_INFO_FUNC("wmtd thread received exit signal\n");
+			break;
+		}
+	}
+
+	WMT_INFO_FUNC("wmtd thread exits succeed\n");
+
+	return 0;
+};
+
+static MTK_WCN_BOOL wmt_lib_put_op(P_OSAL_OP_Q pOpQ, P_OSAL_OP pOp)
+{
+	INT32 iRet;
+
+	if (!pOpQ || !pOp) {
+		WMT_WARN_FUNC("invalid input param: pOpQ(0x%p), pLxOp(0x%p)\n", pOpQ, pOp);
+		osal_assert(pOpQ);
+		osal_assert(pOp);
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	iRet = osal_lock_sleepable_lock(&pOpQ->sLock);
+	if (iRet) {
+		WMT_WARN_FUNC("osal_lock_sleepable_lock iRet(%d)\n", iRet);
+		return MTK_WCN_BOOL_FALSE;
+	}
+#if 0
+	if (pOpQ == &gDevWmt.rFreeOpQ)
+		WMT_INFO_FUNC("current wmt free queue count is(%d),opid(%d)\n", RB_COUNT(pOpQ), pOp->op.opId);
+#endif
+	/* acquire lock success */
+	if (!RB_FULL(pOpQ))
+		RB_PUT(pOpQ, pOp);
+	else
+		iRet = -1;
+
+	osal_unlock_sleepable_lock(&pOpQ->sLock);
+
+	if (iRet) {
+		WMT_WARN_FUNC("RB_FULL(0x%p)\n", pOpQ);
+		return MTK_WCN_BOOL_FALSE;
+	} else {
+		return MTK_WCN_BOOL_TRUE;
+	}
+}
+
+static P_OSAL_OP wmt_lib_get_op(P_OSAL_OP_Q pOpQ)
+{
+	P_OSAL_OP pOp;
+	INT32 iRet;
+
+	if (NULL == pOpQ) {
+		WMT_ERR_FUNC("pOpQ = NULL\n");
+		osal_assert(pOpQ);
+		return NULL;
+	}
+
+	iRet = osal_lock_sleepable_lock(&pOpQ->sLock);
+	if (iRet) {
+		WMT_ERR_FUNC("osal_lock_sleepable_lock iRet(%d)\n", iRet);
+		return NULL;
+	}
+
+	/* acquire lock success */
+	RB_GET(pOpQ, pOp);
+	osal_unlock_sleepable_lock(&pOpQ->sLock);
+
+	if (NULL == pOp) {
+		WMT_WARN_FUNC("RB_GET return NULL\n");
+		osal_assert(pOp);
+	}
+
+	return pOp;
+}
+
+INT32 wmt_lib_put_op_to_free_queue(P_OSAL_OP pOp)
+{
+	P_DEV_WMT pWmtDev = &gDevWmt;
+
+	if (MTK_WCN_BOOL_FALSE == wmt_lib_put_op(&pWmtDev->rFreeOpQ, pOp))
+		return -1;
+	else
+		return 0;
+}
+
+P_OSAL_OP wmt_lib_get_free_op(VOID)
+{
+	P_OSAL_OP pOp = NULL;
+	P_DEV_WMT pDevWmt = &gDevWmt;
+
+	osal_assert(pDevWmt);
+
+	pOp = wmt_lib_get_op(&pDevWmt->rFreeOpQ);
+	if (pOp)
+		osal_memset(&pOp->op, 0, osal_sizeof(pOp->op));
+	return pOp;
+}
+
+MTK_WCN_BOOL wmt_lib_put_act_op(P_OSAL_OP pOp)
+{
+	P_DEV_WMT pWmtDev = &gDevWmt;
+	MTK_WCN_BOOL bRet = MTK_WCN_BOOL_FALSE;
+	MTK_WCN_BOOL bCleanup = MTK_WCN_BOOL_FALSE;
+	P_OSAL_SIGNAL pSignal = NULL;
+	long waitRet = -1;
+	P_OSAL_THREAD pThread;
+
+	osal_assert(pWmtDev);
+	osal_assert(pOp);
+
+	do {
+		if (!pWmtDev || !pOp) {
+			WMT_ERR_FUNC("pWmtDev(0x%p), pOp(0x%p)\n", pWmtDev, pOp);
+			break;
+		}
+		if ((0 != mtk_wcn_stp_coredump_start_get()) &&
+		    (WMT_OPID_HW_RST != pOp->op.opId) &&
+		    (WMT_OPID_SW_RST != pOp->op.opId) && (WMT_OPID_GPIO_STATE != pOp->op.opId)) {
+			bCleanup = MTK_WCN_BOOL_TRUE;
+			WMT_WARN_FUNC("block tx flag is set\n");
+			break;
+		}
+		pSignal = &pOp->signal;
+/* pOp->u4WaitMs = u4WaitMs; */
+		if (pSignal->timeoutValue) {
+			pOp->result = -9;
+			osal_signal_init(pSignal);
+		}
+
+		/* put to active Q */
+		bRet = wmt_lib_put_op(&pWmtDev->rActiveOpQ, pOp);
+		if (MTK_WCN_BOOL_FALSE == bRet) {
+			WMT_WARN_FUNC("put to active queue fail\n");
+			bCleanup = MTK_WCN_BOOL_TRUE;
+			break;
+		}
+
+		/* wake up wmtd */
+		/* wake_up_interruptible(&pWmtDev->rWmtdWq); */
+		osal_trigger_event(&pWmtDev->rWmtdWq);
+
+		if (0 == pSignal->timeoutValue) {
+			bRet = MTK_WCN_BOOL_TRUE;
+			/* clean it in wmtd */
+			break;
+		}
+		/* wait result, clean it here */
+		bCleanup = MTK_WCN_BOOL_TRUE;
+
+		/* check result */
+		/* wait_ret = wait_for_completion_interruptible_timeout(&pOp->comp, msecs_to_jiffies(u4WaitMs)); */
+		/* wait_ret = wait_for_completion_timeout(&pOp->comp, msecs_to_jiffies(u4WaitMs)); */
+		waitRet = osal_wait_for_signal_timeout(pSignal);
+		WMT_DBG_FUNC("osal_wait_for_signal_timeout:%ld\n", waitRet);
+
+		/* if (unlikely(!wait_ret)) { */
+		if (0 == waitRet) {
+			pThread = &gDevWmt.thread;
+			WMT_ERR_FUNC
+				("wait completion timeout, opId(%d), show wmtd_thread stack!\n", pOp->op.opId);
+			/* TODO: how to handle it? retry? */
+			wcn_wmtd_timeout_collect_ftrace();	/* trigger collect SYS_FTRACE */
+			osal_thread_show_stack(pThread);
+		} else {
+			if (pOp->result)
+				WMT_WARN_FUNC("opId(%d) result:%d\n", pOp->op.opId, pOp->result);
+		}
+		/* op completes, check result */
+		bRet = (pOp->result) ? MTK_WCN_BOOL_FALSE : MTK_WCN_BOOL_TRUE;
+	} while (0);
+
+	if (bCleanup) {
+		/* put Op back to freeQ */
+		wmt_lib_put_op(&pWmtDev->rFreeOpQ, pOp);
+	}
+
+	return bRet;
+}
+
+/* TODO:[ChangeFeature][George] is this function obsoleted? */
+#if 0
+INT32 wmt_lib_reg_rw(UINT32 isWrite, UINT32 offset, PUINT32 pvalue, UINT32 mask)
+{
+	P_WMT_LXOP lxop;
+	MTK_WCN_BOOL bRet;
+	PUINT32 plv = NULL;
+	UINT32 pbuf[2];
+	P_OSAL_EVENT pSignal = NULL;
+
+	if (!pvalue) {
+		WMT_WARN_FUNC("!pvalue\n");
+		return -1;
+	}
+	lxop = wmt_lib_get_free_lxop();
+	if (!lxop) {
+		WMT_WARN_FUNC("get_free_lxop fail\n");
+
+		return -1;
+	}
+
+	plv = (PUINT32) (((UINT32) pbuf + 0x3) & ~0x3UL);
+	*plv = *pvalue;
+	pSignal = &lxop->signal;
+	WMT_DBG_FUNC("OPID_REG_RW isWrite(%d) offset(0x%x) value(0x%x) mask(0x%x)\n", isWrite, offset, *pvalue, mask);
+
+	lxop->op.opId = WMT_OPID_REG_RW;
+	lxop->op.au4OpData[0] = isWrite;
+	lxop->op.au4OpData[1] = offset;
+	lxop->op.au4OpData[2] = (UINT32) plv;
+	lxop->op.au4OpData[3] = mask;
+	pSignal->timeoutValue = MAX_EACH_WMT_CMD;
+
+	DISABLE_PSM_MONITOR();
+	bRet = wmt_lib_put_act_lxop(lxop);
+	ENABLE_PSM_MONITOR();
+
+	if (MTK_WCN_BOOL_FALSE != bRet) {
+		WMT_DBG_FUNC("OPID_REG_RW isWrite(%u) offset(0x%x) value(0x%x) mask(0x%x) ok\n",
+			     isWrite, offset, *plv, mask);
+		if (!isWrite)
+			*pvalue = *plv;
+	} else {
+		WMT_WARN_FUNC("OPID_REG_RW isWrite(%u) offset(0x%x) value(0x%x) mask(0x%x) bRet(%d)\n",
+			      isWrite, offset, *plv, mask, bRet);
+	}
+
+	return bRet;
+}
+#endif
+
+/* TODO:[ChangeFeature][George] is this function obsoleted? */
+#if 0
+static VOID wmt_lib_clear_chip_id(VOID)
+{
+/*
+    gDevWmt.pChipInfo = NULL;
+*/
+	gDevWmt.hw_ver = WMTHWVER_INVALID;
+}
+#endif
+
+/* TODO: [FixMe][GeorgeKuo]: change this API to report real chip id, hw_ver, and */
+/* fw_ver instead of WMT-translated WMTHWVER */
+ENUM_WMTHWVER_TYPE_T wmt_lib_get_hwver(VOID)
+{
+/*
+    P_WMT_CMB_CHIP_INFO_S pChipInfo = NULL;
+    P_DEV_WMT pWmtDev = gpDevWmt;
+       pChipInfo = wmt_lib_get_chip_info(pWmtDev);
+    return pChipInfo != NULL ? pChipInfo->eHwVersion : WMTHWVER_INVALID;
+    */
+	return gDevWmt.eWmtHwVer;
+}
+
+UINT32 wmt_lib_get_icinfo(ENUM_WMT_CHIPINFO_TYPE_T index)
+{
+	if (WMTCHIN_CHIPID == index)
+		return gDevWmt.chip_id;
+	else if (WMTCHIN_HWVER == index)
+		return gDevWmt.hw_ver;
+	else if (WMTCHIN_MAPPINGHWVER == index)
+		return gDevWmt.eWmtHwVer;
+	else if (WMTCHIN_FWVER == index)
+		return gDevWmt.fw_ver;
+
+	return 0;
+
+}
+
+PUINT8 wmt_lib_def_patch_name(VOID)
+{
+	WMT_INFO_FUNC("wmt-lib: use default patch name (%s)\n", gDevWmt.cPatchName);
+	return gDevWmt.cPatchName;
+}
+
+MTK_WCN_BOOL wmt_lib_is_therm_ctrl_support(VOID)
+{
+	MTK_WCN_BOOL bIsSupportTherm = MTK_WCN_BOOL_TRUE;
+	/* TODO:[FixMe][GeorgeKuo]: move IC-dependent checking to ic-implementation file */
+	if (((0x6620 == gDevWmt.chip_id) && (WMTHWVER_E3 > gDevWmt.eWmtHwVer))
+	    || (WMTHWVER_INVALID == gDevWmt.eWmtHwVer)) {
+		WMT_ERR_FUNC("thermal command fail: chip version(WMTHWVER_TYPE:%d) is not valid\n", gDevWmt.eWmtHwVer);
+		bIsSupportTherm = MTK_WCN_BOOL_FALSE;
+	}
+	if (!mtk_wcn_stp_is_ready()) {
+		WMT_ERR_FUNC("thermal command can not be send: STP is not ready\n");
+		bIsSupportTherm = MTK_WCN_BOOL_FALSE;
+	}
+
+	return bIsSupportTherm;
+}
+
+MTK_WCN_BOOL wmt_lib_is_dsns_ctrl_support(VOID)
+{
+	/* TODO:[FixMe][GeorgeKuo]: move IC-dependent checking to ic-implementation file */
+	if (((0x6620 == gDevWmt.chip_id) && (WMTHWVER_E3 > gDevWmt.eWmtHwVer))
+	    || (WMTHWVER_INVALID == gDevWmt.eWmtHwVer)) {
+		WMT_ERR_FUNC("thermal command fail: chip version(WMTHWVER_TYPE:%d) is not valid\n", gDevWmt.eWmtHwVer);
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	return MTK_WCN_BOOL_TRUE;
+}
+
+/*!
+ * \brief Update combo chip pin settings (GPIO)
+ *
+ * An internal library function to support various settings for chip GPIO. It is
+ * updated in a grouping way: configure all required pins in a single call.
+ *
+ * \param id desired pin ID to be controlled
+ * \param stat desired pin states to be set
+ * \param flag supplementary options for this operation
+ *
+ * \retval 0 operation success
+ * \retval -1 invalid id
+ * \retval -2 invalid stat
+ * \retval < 0 error for operation fail
+ */
+static INT32 wmt_lib_pin_ctrl(WMT_IC_PIN_ID id, WMT_IC_PIN_STATE stat, UINT32 flag)
+{
+	P_OSAL_OP pOp;
+	MTK_WCN_BOOL bRet;
+	P_OSAL_SIGNAL pSignal;
+
+	/* input sanity check */
+	if (WMT_IC_PIN_MAX <= id) {
+		WMT_ERR_FUNC("invalid ic pin id(%d)\n", id);
+		return -1;
+	}
+	if (WMT_IC_PIN_STATE_MAX <= stat) {
+		WMT_ERR_FUNC("invalid ic pin state (%d)\n", stat);
+		return -2;
+	}
+
+	pOp = wmt_lib_get_free_op();
+	if (!pOp) {
+		WMT_WARN_FUNC("get_free_lxop fail\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	WMT_DBG_FUNC("call WMT_OPID_GPIO_CTRL (ic pin id:%d, stat:%d, flag:0x%x)\n", id, stat, flag);
+
+	pSignal = &pOp->signal;
+	pOp->op.opId = WMT_OPID_GPIO_CTRL;
+	pOp->op.au4OpData[0] = id;
+	pOp->op.au4OpData[1] = stat;
+	pOp->op.au4OpData[2] = flag;
+	pSignal->timeoutValue = MAX_EACH_WMT_CMD;
+
+	/*wake up chip first */
+	if (DISABLE_PSM_MONITOR()) {
+		WMT_ERR_FUNC("wake up failed\n");
+		wmt_lib_put_op_to_free_queue(pOp);
+		return -1;
+	}
+
+	bRet = wmt_lib_put_act_op(pOp);
+	ENABLE_PSM_MONITOR();
+	if (MTK_WCN_BOOL_FALSE == bRet)
+		WMT_WARN_FUNC("PIN_ID(%d) PIN_STATE(%d) flag(%d) fail\n", id, stat, flag);
+	else
+		WMT_DBG_FUNC("OPID(%d) type(%d) ok\n", pOp->op.opId, pOp->op.au4OpData[0]);
+
+	return 0;
+}
+
+INT32 wmt_lib_reg_rw(UINT32 isWrite, UINT32 offset, PUINT32 pvalue, UINT32 mask)
+{
+	P_OSAL_OP pOp;
+	MTK_WCN_BOOL bRet;
+	UINT32 value;
+	P_OSAL_SIGNAL pSignal;
+
+	if (!pvalue) {
+		WMT_WARN_FUNC("!pvalue\n");
+		return -1;
+	}
+
+	pOp = wmt_lib_get_free_op();
+	if (!pOp) {
+		WMT_WARN_FUNC("get_free_lxop fail\n");
+		return -1;
+	}
+
+	pSignal = &pOp->signal;
+	pSignal->timeoutValue = MAX_EACH_WMT_CMD;
+	value = *pvalue;
+	WMT_DBG_FUNC("OPID_REG_RW isWrite(%u) offset(0x%x) value(0x%x) mask(0x%x)\n\n", isWrite, offset, *pvalue, mask);
+	pOp->op.opId = WMT_OPID_REG_RW;
+	pOp->op.au4OpData[0] = isWrite;
+	pOp->op.au4OpData[1] = offset;
+	pOp->op.au4OpData[2] = (SIZE_T)&value;
+	pOp->op.au4OpData[3] = mask;
+	if (DISABLE_PSM_MONITOR()) {
+		WMT_ERR_FUNC("wake up failed\n");
+		wmt_lib_put_op_to_free_queue(pOp);
+		return -1;
+	}
+
+	bRet = wmt_lib_put_act_op(pOp);
+	ENABLE_PSM_MONITOR();
+
+	if (MTK_WCN_BOOL_FALSE != bRet) {
+		WMT_DBG_FUNC("OPID_REG_RW isWrite(%u) offset(0x%x) value(0x%x) mask(0x%x) ok\n",
+			     isWrite, offset, value, mask);
+		if (!isWrite)
+			*pvalue = value;
+
+		return 0;
+	}
+	WMT_WARN_FUNC("OPID_REG_RW isWrite(%u) offset(0x%x) value(0x%x) mask(0x%x) bRet(%d)\n",
+		      isWrite, offset, value, mask, bRet);
+	return -1;
+}
+
+INT32 wmt_lib_efuse_rw(UINT32 isWrite, UINT32 offset, PUINT32 pvalue, UINT32 mask)
+{
+	P_OSAL_OP pOp;
+	MTK_WCN_BOOL bRet;
+	UINT32 value;
+	P_OSAL_SIGNAL pSignal;
+
+	if (!pvalue) {
+		WMT_WARN_FUNC("!pvalue\n");
+		return -1;
+	}
+
+	pOp = wmt_lib_get_free_op();
+	if (!pOp) {
+		WMT_WARN_FUNC("get_free_lxop fail\n");
+		return -1;
+	}
+
+	pSignal = &pOp->signal;
+	pSignal->timeoutValue = MAX_EACH_WMT_CMD;
+	value = *pvalue;
+	WMT_DBG_FUNC("OPID_EFUSE_RW isWrite(%u) offset(0x%x) value(0x%x) mask(0x%x)\n\n",
+		     isWrite, offset, *pvalue, mask);
+	pOp->op.opId = WMT_OPID_EFUSE_RW;
+	pOp->op.au4OpData[0] = isWrite;
+	pOp->op.au4OpData[1] = offset;
+	pOp->op.au4OpData[2] = (SIZE_T)&value;
+	pOp->op.au4OpData[3] = mask;
+	if (DISABLE_PSM_MONITOR()) {
+		WMT_ERR_FUNC("wake up failed\n");
+		wmt_lib_put_op_to_free_queue(pOp);
+		return -1;
+	}
+
+	bRet = wmt_lib_put_act_op(pOp);
+	ENABLE_PSM_MONITOR();
+
+	if (MTK_WCN_BOOL_FALSE != bRet) {
+		WMT_DBG_FUNC("OPID_EFUSE_RW isWrite(%u) offset(0x%x) value(0x%x) mask(0x%x) ok\n",
+			     isWrite, offset, value, mask);
+		if (!isWrite)
+			*pvalue = value;
+
+		return 0;
+	}
+	WMT_WARN_FUNC("OPID_REG_RW isWrite(%u) offset(0x%x) value(0x%x) mask(0x%x) bRet(%d)\n",
+		      isWrite, offset, value, mask, bRet);
+	return -1;
+
+}
+
+/*!
+ * \brief update combo chip AUDIO Interface (AIF) settings
+ *
+ * A library function to support updating chip AUDIO pin settings. A group of
+ * pins is updated as a whole.
+ *
+ * \param aif desired audio interface state to use
+ * \param flag whether audio pin is shared or not
+ *
+ * \retval 0 operation success
+ * \retval -1 invalid aif
+ * \retval < 0 error for invalid parameters or operation fail
+ */
+INT32 wmt_lib_set_aif(CMB_STUB_AIF_X aif, MTK_WCN_BOOL share)
+{
+	if (CMB_STUB_AIF_MAX <= aif) {
+		WMT_ERR_FUNC("invalid aif (%d)\n", aif);
+		return -1;
+	}
+	WMT_DBG_FUNC("call pin_ctrl for aif:%d, share:%d\n", aif, (MTK_WCN_BOOL_TRUE == share) ? 1 : 0);
+	/* Translate CMB_STUB_AIF_X into WMT_IC_PIN_STATE by array */
+	return wmt_lib_pin_ctrl(WMT_IC_PIN_AUDIO,
+				cmb_aif2pin_stat[aif],
+				(MTK_WCN_BOOL_TRUE == share) ? WMT_LIB_AIF_FLAG_SHARE : WMT_LIB_AIF_FLAG_SEPARATE);
+}
+
+INT32 wmt_lib_host_awake_get(VOID)
+{
+	return wmt_plat_wake_lock_ctrl(WL_OP_GET);
+}
+
+INT32 wmt_lib_host_awake_put(VOID)
+{
+	return wmt_plat_wake_lock_ctrl(WL_OP_PUT);
+}
+
+MTK_WCN_BOOL wmt_lib_btm_cb(MTKSTP_BTM_WMT_OP_T op)
+{
+	MTK_WCN_BOOL bRet = MTK_WCN_BOOL_FALSE;
+
+	if (op == BTM_RST_OP) {
+		/* high priority, not to enqueue into the queue of wmtd */
+		WMT_INFO_FUNC("Invoke whole chip reset from stp_btm!!!\n");
+		wmt_lib_cmb_rst(WMTRSTSRC_RESET_STP);
+		bRet = MTK_WCN_BOOL_TRUE;
+	} else if (op == BTM_DMP_OP) {
+
+		WMT_WARN_FUNC("TBD!!!\n");
+	} else if (op == BTM_GET_AEE_SUPPORT_FLAG) {
+		bRet = wmt_core_get_aee_dump_flag();
+	}
+	return bRet;
+}
+
+MTK_WCN_BOOL wmt_cdev_rstmsg_snd(ENUM_WMTRSTMSG_TYPE_T msg)
+{
+
+	INT32 i = 0;
+	P_DEV_WMT pDevWmt = &gDevWmt;
+	PUINT8 drv_name[] = {
+		"DRV_TYPE_BT",
+		"DRV_TYPE_FM",
+		"DRV_TYPE_GPS",
+		"DRV_TYPE_WIFI"
+	};
+
+	for (i = 0; i <= WMTDRV_TYPE_WIFI; i++) {
+		/* <1> check if reset callback is registered */
+		if (pDevWmt->rFdrvCb.fDrvRst[i]) {
+			/* <2> send the msg to this subfucntion */
+			/*src, dst, msg_type, msg_data, msg_size */
+			pDevWmt->rFdrvCb.fDrvRst[i] (WMTDRV_TYPE_WMT, i, WMTMSG_TYPE_RESET, &msg,
+						     sizeof(ENUM_WMTRSTMSG_TYPE_T));
+			WMT_INFO_FUNC("type = %s, msg sent\n", drv_name[i]);
+		} else {
+			WMT_DBG_FUNC("type = %s, unregistered\n", drv_name[i]);
+		}
+	}
+
+	return MTK_WCN_BOOL_TRUE;
+}
+
+VOID wmt_lib_state_init(VOID)
+{
+	/* UINT32 i = 0; */
+	P_DEV_WMT pDevWmt = &gDevWmt;
+	P_OSAL_OP pOp;
+
+	/* Initialize op queue */
+	/* RB_INIT(&pDevWmt->rFreeOpQ, WMT_OP_BUF_SIZE); */
+	/* RB_INIT(&pDevWmt->rActiveOpQ, WMT_OP_BUF_SIZE); */
+
+	while (!RB_EMPTY(&pDevWmt->rActiveOpQ)) {
+#if 0
+		osal_signal_init(&(pOp->signal));
+		wmt_lib_put_op(&pDevWmt->rFreeOpQ, pOp);
+#endif
+		pOp = wmt_lib_get_op(&pDevWmt->rActiveOpQ);
+		if (pOp) {
+			if (osal_op_is_wait_for_signal(pOp))
+				osal_op_raise_signal(pOp, -1);
+			else
+				wmt_lib_put_op(&pDevWmt->rFreeOpQ, pOp);
+		}
+	}
+
+	/* Put all to free Q */
+	/*
+	   for (i = 0; i < WMT_OP_BUF_SIZE; i++) {
+	   osal_signal_init(&(pDevWmt->arQue[i].signal));
+	   wmt_lib_put_op(&pDevWmt->rFreeOpQ, &(pDevWmt->arQue[i]));
+	   } */
+}
+
+#if 0
+INT32 wmt_lib_sdio_ctrl(UINT32 on)
+{
+
+	P_OSAL_OP pOp;
+	MTK_WCN_BOOL bRet;
+	P_OSAL_SIGNAL pSignal;
+
+	pOp = wmt_lib_get_free_op();
+	if (!pOp) {
+		WMT_WARN_FUNC("get_free_lxop fail\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	WMT_DBG_FUNC("call WMT_OPID_SDIO_CTRL\n");
+
+	pSignal = &pOp->signal;
+	pOp->op.opId = WMT_OPID_SDIO_CTRL;
+	pOp->op.au4OpData[0] = on;
+	pSignal->timeoutValue = MAX_GPIO_CTRL_TIME;
+
+	bRet = wmt_lib_put_act_op(pOp);
+	if (MTK_WCN_BOOL_FALSE == bRet) {
+		WMT_WARN_FUNC("WMT_OPID_SDIO_CTRL failed\n");
+		return -1;
+	}
+	WMT_DBG_FUNC("OPID(WMT_OPID_SDIO_CTRL)ok\n");
+
+	return 0;
+}
+#endif
+
+MTK_WCN_BOOL wmt_lib_hw_state_show(VOID)
+{
+	P_OSAL_OP pOp;
+	MTK_WCN_BOOL bRet;
+	P_OSAL_SIGNAL pSignal;
+
+	pOp = wmt_lib_get_free_op();
+	if (!pOp) {
+		WMT_WARN_FUNC("get_free_lxop fail\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	WMT_DBG_FUNC("call WMT_OPID_HW_STATE_SHOW\n");
+
+	pSignal = &pOp->signal;
+	pOp->op.opId = WMT_OPID_GPIO_STATE;
+	pSignal->timeoutValue = MAX_GPIO_CTRL_TIME;
+
+	bRet = wmt_lib_put_act_op(pOp);
+	if (MTK_WCN_BOOL_FALSE == bRet) {
+		WMT_WARN_FUNC("WMT_OPID_HW_STATE_SHOW failed\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+	WMT_DBG_FUNC("OPID(WMT_OPID_HW_STATE_SHOW)ok\n");
+	return MTK_WCN_BOOL_TRUE;
+}
+
+MTK_WCN_BOOL wmt_lib_hw_rst(VOID)
+{
+
+	P_OSAL_OP pOp;
+	MTK_WCN_BOOL bRet;
+	P_OSAL_SIGNAL pSignal;
+	P_DEV_WMT pDevWmt = &gDevWmt;
+
+	wmt_lib_state_init();
+
+	osal_clear_bit(WMT_STAT_STP_REG, &pDevWmt->state);
+	osal_clear_bit(WMT_STAT_STP_OPEN, &pDevWmt->state);
+	osal_clear_bit(WMT_STAT_STP_EN, &pDevWmt->state);
+	osal_clear_bit(WMT_STAT_STP_RDY, &pDevWmt->state);
+	osal_clear_bit(WMT_STAT_RX, &pDevWmt->state);
+	osal_clear_bit(WMT_STAT_CMD, &pDevWmt->state);
+
+	/*Before do hardware reset, we show GPIO state to check if others modified our pin state accidentially */
+	wmt_lib_hw_state_show();
+	pOp = wmt_lib_get_free_op();
+	if (!pOp) {
+		WMT_WARN_FUNC("get_free_lxop fail\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	WMT_DBG_FUNC("call WMT_OPID_HW_RST\n");
+
+	pSignal = &pOp->signal;
+	pOp->op.opId = WMT_OPID_HW_RST;
+	pSignal->timeoutValue = MAX_GPIO_CTRL_TIME;
+
+	bRet = wmt_lib_put_act_op(pOp);
+	if (MTK_WCN_BOOL_FALSE == bRet) {
+		WMT_WARN_FUNC("WMT_OPID_HW_RST failed\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+	WMT_DBG_FUNC("OPID(WMT_OPID_HW_RST)ok\n");
+	return MTK_WCN_BOOL_TRUE;
+}
+
+MTK_WCN_BOOL wmt_lib_sw_rst(INT32 baudRst)
+{
+
+	P_OSAL_OP pOp;
+	MTK_WCN_BOOL bRet;
+	P_OSAL_SIGNAL pSignal;
+
+	/* <1> wmt state reset */
+	wmt_lib_state_init();
+
+	/* <2> Reset STP data structure */
+	WMT_DBG_FUNC("Cleanup STP context\n");
+	mtk_wcn_stp_flush_context();
+	/* <3> Reset STP-PSM data structure */
+	WMT_DBG_FUNC("Cleanup STP-PSM context\n");
+	mtk_wcn_stp_psm_reset();
+
+	/* <4> do sw reset in wmt-core */
+	pOp = wmt_lib_get_free_op();
+	if (!pOp) {
+		WMT_WARN_FUNC("get_free_lxop fail\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	WMT_DBG_FUNC("call WMT_OPID_SW_RST\n");
+
+	pSignal = &pOp->signal;
+	pSignal->timeoutValue = MAX_FUNC_ON_TIME;
+
+	pOp->op.opId = WMT_OPID_SW_RST;
+	pOp->op.au4OpData[0] = baudRst;
+
+	bRet = wmt_lib_put_act_op(pOp);
+	if (MTK_WCN_BOOL_FALSE == bRet) {
+		WMT_WARN_FUNC("WMT_OPID_SW_RST failed\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+	WMT_DBG_FUNC("OPID(WMT_OPID_SW_RST)ok\n");
+	return MTK_WCN_BOOL_TRUE;
+}
+
+ENUM_WMTRSTRET_TYPE_T wmt_lib_cmb_rst(ENUM_WMTRSTSRC_TYPE_T src)
+{
+#define RETRYTIMES 10
+	MTK_WCN_BOOL bRet;
+	ENUM_WMTRSTRET_TYPE_T retval = WMTRSTRET_MAX;
+	ENUM_WMTRSTMSG_TYPE_T rstMsg = WMTRSTMSG_RESET_MAX;
+	INT32 retries = RETRYTIMES;
+	P_DEV_WMT pDevWmt = &gDevWmt;
+	P_OSAL_OP pOp;
+	PUINT8 srcName[] = { "WMTRSTSRC_RESET_BT",
+		"WMTRSTSRC_RESET_FM",
+		"WMTRSTSRC_RESET_GPS",
+		"WMTRSTSRC_RESET_WIFI",
+		"WMTRSTSRC_RESET_STP",
+		"WMTRSTSRC_RESET_TEST"
+	};
+
+	if (src < WMTRSTSRC_RESET_MAX)
+		WMT_INFO_FUNC("reset source = %s\n", srcName[src]);
+
+	if (WMTRSTSRC_RESET_TEST == src) {
+		pOp = wmt_lib_get_current_op(pDevWmt);
+		if (pOp && ((WMT_OPID_FUNC_ON == pOp->op.opId)
+			    || (WMT_OPID_FUNC_OFF == pOp->op.opId))) {
+			WMT_INFO_FUNC("can't do reset by test src when func on/off\n");
+			return -1;
+		}
+	}
+	/* <1> Consider the multi-context combo_rst case. */
+	if (osal_test_and_set_bit(WMT_STAT_RST_ON, &pDevWmt->state)) {
+		retval = WMTRSTRET_ONGOING;
+		goto rstDone;
+	}
+	/* <2> Block all STP request */
+	mtk_wcn_stp_enable(0);
+
+	/* <3> RESET_START notification */
+	bRet = wmt_cdev_rstmsg_snd(WMTRSTMSG_RESET_START);
+	if (bRet == MTK_WCN_BOOL_FALSE) {
+		WMT_ERR_FUNC("[whole chip reset] fail at wmt_lib_rstmsg_snd!\n");
+		retval = WMTRSTRET_FAIL;
+		goto rstDone;
+	}
+	/* wakeup blocked opid */
+	pOp = wmt_lib_get_current_op(pDevWmt);
+	if (osal_op_is_wait_for_signal(pOp))
+		osal_op_raise_signal(pOp, -1);
+
+	/* wakeup blocked cmd */
+	wmt_dev_rx_event_cb();
+
+	/* <4> retry until reset flow successful */
+	while (retries > 0) {
+		/* <4.1> reset combo hw */
+		bRet = wmt_lib_hw_rst();
+		if (bRet == MTK_WCN_BOOL_FALSE) {
+			WMT_ERR_FUNC("[whole chip reset] fail at wmt_lib_hw_rst!\n");
+			retries--;
+			continue;
+		}
+		/* <4.2> reset driver/combo sw */
+		bRet = wmt_lib_sw_rst(1);
+		if (bRet == MTK_WCN_BOOL_FALSE) {
+			WMT_ERR_FUNC("[whole chip reset] fail at wmt_lib_sw_rst!\n");
+			retries--;
+			continue;
+		}
+		break;
+	}
+
+	osal_clear_bit(WMT_STAT_RST_ON, &pDevWmt->state);
+
+	if (bRet == MTK_WCN_BOOL_FALSE) {
+		rstMsg = WMTRSTMSG_RESET_END_FAIL;
+		WMT_WARN_FUNC("[whole chip reset] fail! retries = %d\n", RETRYTIMES - retries);
+	} else {
+		rstMsg = WMTRSTMSG_RESET_END;
+		WMT_INFO_FUNC("[whole chip reset] ok! retries = %d\n", RETRYTIMES - retries);
+	}
+
+	/* <5> RESET_END notification */
+	bRet = wmt_cdev_rstmsg_snd(rstMsg);
+	if (bRet == MTK_WCN_BOOL_FALSE) {
+		WMT_ERR_FUNC("[whole chip reset] fail at wmt_lib_rstmsg_snd!\n");
+		retval = WMTRSTRET_FAIL;
+	} else {
+		retval = WMTRSTMSG_RESET_END == rstMsg ? WMTRSTRET_SUCCESS : WMTRSTRET_FAIL;
+	}
+	mtk_wcn_stp_coredump_start_ctrl(0);
+	mtk_wcn_stp_set_wmt_evt_err_trg_assert(0);
+rstDone:
+	if (osal_test_and_clear_bit(WMT_STAT_RST_ON, &pDevWmt->state))
+		WMT_WARN_FUNC("[whole chip reset] retval = %d\n", retval);
+
+	return retval;
+}
+
+MTK_WCN_BOOL wmt_lib_msgcb_reg(ENUM_WMTDRV_TYPE_T eType, PF_WMT_CB pCb)
+{
+
+	MTK_WCN_BOOL bRet = MTK_WCN_BOOL_FALSE;
+	P_DEV_WMT pWmtDev = &gDevWmt;
+
+	if (eType >= 0 && eType <= WMTDRV_TYPE_WIFI) {
+		WMT_DBG_FUNC("reg ok!\n");
+		pWmtDev->rFdrvCb.fDrvRst[eType] = pCb;
+		bRet = MTK_WCN_BOOL_TRUE;
+	} else {
+		WMT_WARN_FUNC("reg fail!\n");
+	}
+
+	return bRet;
+}
+
+MTK_WCN_BOOL wmt_lib_msgcb_unreg(ENUM_WMTDRV_TYPE_T eType)
+{
+	MTK_WCN_BOOL bRet = MTK_WCN_BOOL_FALSE;
+	P_DEV_WMT pWmtDev = &gDevWmt;
+
+	if (eType >= 0 && eType <= WMTDRV_TYPE_WIFI) {
+		WMT_DBG_FUNC("unreg ok!\n");
+		pWmtDev->rFdrvCb.fDrvRst[eType] = NULL;
+		bRet = MTK_WCN_BOOL_TRUE;
+	} else {
+		WMT_WARN_FUNC("unreg fail!\n");
+	}
+
+	return bRet;
+}
+
+UINT32 wmt_lib_dbg_level_set(UINT32 level)
+{
+	gWmtDbgLvl = level > WMT_LOG_LOUD ? WMT_LOG_LOUD : level;
+	return 0;
+}
+
+INT32 wmt_lib_set_stp_wmt_last_close(UINT32 value)
+{
+	return mtk_wcn_stp_set_wmt_last_close(value);
+}
+
+INT32 wmt_lib_notify_stp_sleep(void)
+{
+	INT32 iRet = 0x0;
+
+	iRet = wmt_lib_psm_lock_aquire();
+	if (iRet) {
+		WMT_ERR_FUNC("--->lock psm_lock failed, iRet=%d\n", iRet);
+		return iRet;
+	}
+
+	iRet = mtk_wcn_stp_notify_sleep_for_thermal();
+	wmt_lib_psm_lock_release();
+
+	return iRet;
+}
+
+VOID wmt_lib_set_patch_num(UINT32 num)
+{
+	P_DEV_WMT pWmtDev = &gDevWmt;
+
+	pWmtDev->patchNum = num;
+}
+
+VOID wmt_lib_set_patch_info(P_WMT_PATCH_INFO pPatchinfo)
+{
+	P_DEV_WMT pWmtDev = &gDevWmt;
+
+	if (pPatchinfo)
+		pWmtDev->pWmtPatchInfo = pPatchinfo;
+
+}
+
+INT32 wmt_lib_set_current_op(P_DEV_WMT pWmtDev, P_OSAL_OP pOp)
+{
+	if (pWmtDev) {
+		pWmtDev->pCurOP = pOp;
+		WMT_DBG_FUNC("pOp=0x%p\n", pOp);
+		return 0;
+	}
+	WMT_ERR_FUNC("Invalid pointer\n");
+	return -1;
+}
+
+P_OSAL_OP wmt_lib_get_current_op(P_DEV_WMT pWmtDev)
+{
+	if (pWmtDev)
+		return pWmtDev->pCurOP;
+
+	WMT_ERR_FUNC("Invalid pointer\n");
+	return NULL;
+}
+
+UINT8 *wmt_lib_get_fwinfor_from_emi(UINT8 section, UINT32 offset, UINT8 *buf, UINT32 len)
+{
+	UINT8 *pAddr = NULL;
+	UINT32 sublen1 = 0;
+	UINT32 sublen2 = 0;
+	P_CONSYS_EMI_ADDR_INFO p_consys_info;
+
+	p_consys_info = wmt_plat_get_emi_phy_add();
+	osal_assert(p_consys_info);
+
+	if (section == 0) {
+		pAddr = wmt_plat_get_emi_virt_add(0x0);
+		if (len > 1024)
+			len = 1024;
+		if (!pAddr) {
+			WMT_ERR_FUNC("wmt-lib: get EMI virtual base address fail\n");
+		} else {
+			WMT_INFO_FUNC("vir addr(0x%p)\n", pAddr);
+			osal_memcpy(&buf[0], pAddr, len);
+		}
+	} else {
+		if (offset >= 0x7fff)
+			offset = 0x0;
+
+		if (offset + len > 32768) {
+			pAddr = wmt_plat_get_emi_virt_add(offset + p_consys_info->paged_trace_off);
+			if (!pAddr) {
+				WMT_ERR_FUNC("wmt-lib: get part1 EMI virtual base address fail\n");
+			} else {
+				WMT_INFO_FUNC("part1 vir addr(0x%p)\n", pAddr);
+				sublen1 = 0x7fff - offset;
+				osal_memcpy(&buf[0], pAddr, sublen1);
+			}
+			pAddr = wmt_plat_get_emi_virt_add(p_consys_info->paged_trace_off);
+			if (!pAddr) {
+				WMT_ERR_FUNC("wmt-lib: get part2 EMI virtual base address fail\n");
+			} else {
+				WMT_INFO_FUNC("part2 vir addr(0x%p)\n", pAddr);
+				sublen2 = len - sublen1;
+				osal_memcpy(&buf[sublen1], pAddr, sublen2);
+			}
+		} else {
+			pAddr = wmt_plat_get_emi_virt_add(offset + p_consys_info->paged_trace_off);
+			if (!pAddr) {
+				WMT_ERR_FUNC("wmt-lib: get EMI virtual base address fail\n");
+			} else {
+				WMT_INFO_FUNC("vir addr(0x%p)\n", pAddr);
+				osal_memcpy(&buf[0], pAddr, len);
+			}
+		}
+	}
+
+	return 0;
+}
+
+INT32 wmt_lib_poll_cpupcr(UINT32 count, UINT16 sleep, UINT16 toAee)
+{
+	ENUM_STP_FW_ISSUE_TYPE issue_type;
+
+	issue_type = STP_DBG_PROC_TEST;
+
+	stp_dbg_poll_cpupcr(count, sleep, 1);
+
+	if (toAee) {
+		stp_dbg_set_fw_info("STP ProcTest", osal_strlen("STP ProcTest"), issue_type);
+		osal_dbg_assert_aee("[SOC_CONSYS]ProcTest",
+				    "**[WCN_ISSUE_INFO]STP Tx Timeout**\n Polling CPUPCR for FW debug usage\n");
+	} else {
+		WMT_INFO_FUNC("wmt_lib:do not pass cpupcr to AEE\n");
+	}
+	return 0;
+}
+
+UINT8 *wmt_lib_get_cpupcr_xml_format(UINT32 *len)
+{
+	PUINT8 temp;
+	UINT32 i = 0;
+
+	osal_memset(&g_cpupcr_buf[0], 0, WMT_STP_CPUPCR_BUF_SIZE);
+	temp = g_cpupcr_buf;
+	stp_dbg_cpupcr_infor_format(&temp, len);
+
+	pr_debug("print xml buffer,len(%d):\n\n", *len);
+	for (i = 0; i < *len; i++)
+		pr_cont("%c", g_cpupcr_buf[i]);
+
+	return &g_cpupcr_buf[0];
+}
+
+UINT32 wmt_lib_set_host_assert_info(UINT32 type, UINT32 reason, UINT32 en)
+{
+	return stp_dbg_set_host_assert_info(type, reason, en);
+}
+
+INT32 wmt_lib_register_thermal_ctrl_cb(thermal_query_ctrl_cb thermal_ctrl)
+{
+	wmt_plat_thermal_ctrl_cb_reg(thermal_ctrl);
+	return 0;
+}
+
+INT8 wmt_lib_co_clock_get(void)
+{
+	if (gDevWmt.rWmtGenConf.cfgExist)
+		return gDevWmt.rWmtGenConf.co_clock_flag;
+	else
+		return -1;
+}
+
+#if CFG_WMT_PS_SUPPORT
+UINT32 wmt_lib_quick_sleep_ctrl(UINT32 en)
+{
+	WMT_WARN_FUNC("%s quick sleep mode\n", en ? "enable" : "disable");
+	g_quick_sleep_ctrl = en;
+	return 0;
+}
+#endif
+
+#if CONSYS_ENALBE_SET_JTAG
+UINT32 wmt_lib_jtag_flag_set(UINT32 en)
+{
+	return wmt_plat_jtag_flag_ctrl(en);
+}
+#endif
+
+UINT32 wmt_lib_soc_set_wifiver(UINT32 wifiver)
+{
+	return stp_dbg_set_wifiver(wifiver);
+}
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_stp_exp.c b/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_stp_exp.c
new file mode 100644
index 00000000..4fc3144
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/core/wmt_stp_exp.c
@@ -0,0 +1,480 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+#include "osal_typedef.h"
+#include "wmt_stp_exp.h"
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[WMT-STP-EXP]"
+
+#define WMT_STP_EXP_INFO_FUNC(fmt, arg...)   pr_debug(DFT_TAG "[I]%s: "  fmt, __func__ , ##arg)
+#define WMT_STP_EXP_WARN_FUNC(fmt, arg...)   pr_warn(DFT_TAG "[W]%s: "  fmt, __func__ , ##arg)
+#define WMT_STP_EXP_ERR_FUNC(fmt, arg...)    pr_err(DFT_TAG "[E]%s(%d):ERROR! "   fmt, __func__ , __LINE__, ##arg)
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+#ifdef MTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+/*STP exp*/
+MTK_WCN_STP_SEND_DATA mtk_wcn_stp_send_data_f = NULL;
+MTK_WCN_STP_SEND_DATA mtk_wcn_stp_send_data_raw_f = NULL;
+MTK_WCN_STP_PARSER_DATA mtk_wcn_stp_parser_data_f = NULL;
+MTK_WCN_STP_RECV_DATA mtk_wcn_stp_receive_data_f = NULL;
+MTK_WCN_STP_IS_RXQ_EMPTY mtk_wcn_stp_is_rxqueue_empty_f = NULL;
+MTK_WCN_STP_IS_RDY mtk_wcn_stp_is_ready_f = NULL;
+MTK_WCN_STP_SET_BLUEZ mtk_wcn_stp_set_bluez_f = NULL;
+MTK_WCN_STP_REG_IF_TX mtk_wcn_stp_if_tx_f = NULL;
+MTK_WCN_STP_REG_IF_RX mtk_wcn_stp_if_rx_f = NULL;
+MTK_WCN_STP_REG_EVENT_CB mtk_wcn_stp_reg_event_cb_f = NULL;
+MTK_WCN_STP_RGE_TX_EVENT_CB mtk_wcn_stp_reg_tx_event_cb_f = NULL;
+MTK_WCN_STP_COREDUMP_START_GET mtk_wcn_stp_coredump_start_get_f = NULL;
+
+/*WMT exp*/
+MTK_WCN_WMT_FUNC_CTRL mtk_wcn_wmt_func_on_f = NULL;
+MTK_WCN_WMT_FUNC_CTRL mtk_wcn_wmt_func_off_f = NULL;
+MTK_WCN_WMT_THERM_CTRL mtk_wcn_wmt_therm_ctrl_f = NULL;
+MTK_WCN_WMT_HWVER_GET mtk_wcn_wmt_hwver_get_f = NULL;
+MTK_WCN_WMT_DSNS_CTRL mtk_wcn_wmt_dsns_ctrl_f = NULL;
+MTK_WCN_WMT_MSGCB_REG mtk_wcn_wmt_msgcb_reg_f = NULL;
+MTK_WCN_WMT_MSGCB_UNREG mtk_wcn_wmt_msgcb_unreg_f = NULL;
+MTK_WCN_WMT_SDIO_OP_REG mtk_wcn_wmt_sdio_op_reg_f = NULL;
+MTK_WCN_WMT_SDIO_HOST_AWAKE mtk_wcn_wmt_sdio_host_awake_f = NULL;
+MTK_WCN_WMT_ASSERT mtk_wcn_wmt_assert_f = NULL;
+MTK_WCN_WMT_ASSERT_TIMEOUT mtk_wcn_wmt_assert_timeout_f = NULL;
+MTK_WCN_WMT_IC_INFO_GET mtk_wcn_wmt_ic_info_get_f = NULL;
+MTK_WCN_WMT_PSM_CTRL mtk_wcn_wmt_psm_ctrl_f = NULL;
+
+/*******************************************************************************
+*                          F U N C T I O N S
+********************************************************************************
+*/
+
+UINT32 mtk_wcn_stp_exp_cb_reg(P_MTK_WCN_STP_EXP_CB_INFO pStpExpCb)
+{
+	WMT_STP_EXP_INFO_FUNC("call stp exp cb reg\n");
+
+	mtk_wcn_stp_send_data_f = pStpExpCb->stp_send_data_cb;
+	mtk_wcn_stp_send_data_raw_f = pStpExpCb->stp_send_data_raw_cb;
+	mtk_wcn_stp_parser_data_f = pStpExpCb->stp_parser_data_cb;
+	mtk_wcn_stp_receive_data_f = pStpExpCb->stp_receive_data_cb;
+	mtk_wcn_stp_is_rxqueue_empty_f = pStpExpCb->stp_is_rxqueue_empty_cb;
+	mtk_wcn_stp_is_ready_f = pStpExpCb->stp_is_ready_cb;
+	mtk_wcn_stp_set_bluez_f = pStpExpCb->stp_set_bluez_cb;
+	mtk_wcn_stp_if_tx_f = pStpExpCb->stp_if_tx_cb;
+	mtk_wcn_stp_if_rx_f = pStpExpCb->stp_if_rx_cb;
+	mtk_wcn_stp_reg_event_cb_f = pStpExpCb->stp_reg_event_cb;
+	mtk_wcn_stp_reg_tx_event_cb_f = pStpExpCb->stp_reg_tx_event_cb;
+	mtk_wcn_stp_coredump_start_get_f = pStpExpCb->stp_coredump_start_get_cb;
+
+	return 0;
+}
+EXPORT_SYMBOL(mtk_wcn_stp_exp_cb_reg);
+
+UINT32 mtk_wcn_stp_exp_cb_unreg(VOID)
+{
+	WMT_STP_EXP_INFO_FUNC("call stp exp cb unreg\n");
+
+	mtk_wcn_stp_send_data_f = NULL;
+	mtk_wcn_stp_send_data_raw_f = NULL;
+	mtk_wcn_stp_parser_data_f = NULL;
+	mtk_wcn_stp_receive_data_f = NULL;
+	mtk_wcn_stp_is_rxqueue_empty_f = NULL;
+	mtk_wcn_stp_is_ready_f = NULL;
+	mtk_wcn_stp_set_bluez_f = NULL;
+	mtk_wcn_stp_if_tx_f = NULL;
+	mtk_wcn_stp_if_rx_f = NULL;
+	mtk_wcn_stp_reg_event_cb_f = NULL;
+	mtk_wcn_stp_reg_tx_event_cb_f = NULL;
+	mtk_wcn_stp_coredump_start_get_f = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL(mtk_wcn_stp_exp_cb_unreg);
+
+INT32 mtk_wcn_stp_send_data(const PUINT8 buffer, const UINT32 length, const UINT8 type)
+{
+	INT32 ret = -1;
+
+	if (mtk_wcn_stp_send_data_f) {
+		ret = (*mtk_wcn_stp_send_data_f) (buffer, length, type);
+		/* WMT_STP_EXP_INFO_FUNC("mtk_wcn_stp_send_data_f send data(%d)\n",ret); */
+	} else {
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_stp_send_data_f cb is null\n");
+	}
+
+	return ret;
+
+}
+EXPORT_SYMBOL(mtk_wcn_stp_send_data);
+
+INT32 mtk_wcn_stp_send_data_raw(const PUINT8 buffer, const UINT32 length, const UINT8 type)
+{
+	INT32 ret = -1;
+
+	if (mtk_wcn_stp_send_data_raw_f)
+		ret = (*mtk_wcn_stp_send_data_raw_f) (buffer, length, type);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_stp_send_data_raw_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_stp_send_data_raw);
+
+INT32 mtk_wcn_stp_parser_data(PUINT8 buffer, UINT32 length)
+{
+	INT32 ret = -1;
+
+	if (mtk_wcn_stp_parser_data_f)
+		ret = (*mtk_wcn_stp_parser_data_f) (buffer, length);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_stp_parser_data_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_stp_parser_data);
+
+INT32 mtk_wcn_stp_receive_data(PUINT8 buffer, UINT32 length, UINT8 type)
+{
+	INT32 ret = -1;
+
+	if (mtk_wcn_stp_receive_data_f)
+		ret = (*mtk_wcn_stp_receive_data_f) (buffer, length, type);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_stp_receive_data_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_stp_receive_data);
+
+MTK_WCN_BOOL mtk_wcn_stp_is_rxqueue_empty(UINT8 type)
+{
+	MTK_WCN_BOOL ret = MTK_WCN_BOOL_FALSE;
+
+	if (mtk_wcn_stp_is_rxqueue_empty_f)
+		ret = (*mtk_wcn_stp_is_rxqueue_empty_f) (type);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_stp_is_rxqueue_empty_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_stp_is_rxqueue_empty);
+
+MTK_WCN_BOOL mtk_wcn_stp_is_ready(void)
+{
+	MTK_WCN_BOOL ret = MTK_WCN_BOOL_FALSE;
+
+	if (mtk_wcn_stp_is_ready_f)
+		ret = (*mtk_wcn_stp_is_ready_f) ();
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_stp_is_ready_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_stp_is_ready);
+
+void mtk_wcn_stp_set_bluez(MTK_WCN_BOOL flags)
+{
+
+	if (mtk_wcn_stp_set_bluez_f)
+		(*mtk_wcn_stp_set_bluez_f) (flags);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_stp_set_bluez_f cb is null\n");
+
+}
+EXPORT_SYMBOL(mtk_wcn_stp_set_bluez);
+
+INT32 mtk_wcn_stp_register_if_tx(ENUM_STP_TX_IF_TYPE stp_if, MTK_WCN_STP_IF_TX func)
+{
+	INT32 ret = -1;
+
+	if (mtk_wcn_stp_if_tx_f)
+		ret = (*mtk_wcn_stp_if_tx_f) (stp_if, func);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_stp_if_tx_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_stp_register_if_tx);
+
+INT32 mtk_wcn_stp_register_if_rx(MTK_WCN_STP_IF_RX func)
+{
+	INT32 ret = -1;
+
+	if (mtk_wcn_stp_if_rx_f)
+		ret = (*mtk_wcn_stp_if_rx_f) (func);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_stp_if_rx_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_stp_register_if_rx);
+
+INT32 mtk_wcn_stp_register_event_cb(INT32 type, MTK_WCN_STP_EVENT_CB func)
+{
+	INT32 ret = -1;
+
+	if (mtk_wcn_stp_reg_event_cb_f)
+		ret = (*mtk_wcn_stp_reg_event_cb_f) (type, func);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_stp_reg_event_cb_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_stp_register_event_cb);
+
+INT32 mtk_wcn_stp_register_tx_event_cb(INT32 type, MTK_WCN_STP_EVENT_CB func)
+{
+	INT32 ret = -1;
+
+	if (mtk_wcn_stp_reg_tx_event_cb_f)
+		ret = (*mtk_wcn_stp_reg_tx_event_cb_f) (type, func);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_stp_reg_tx_event_cb_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_stp_register_tx_event_cb);
+
+INT32 mtk_wcn_stp_coredump_start_get(VOID)
+{
+	INT32 ret = -1;
+
+	if (mtk_wcn_stp_coredump_start_get_f)
+		ret = (*mtk_wcn_stp_coredump_start_get_f) ();
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_stp_coredump_start_get_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_stp_coredump_start_get);
+
+UINT32 mtk_wcn_wmt_exp_cb_reg(P_MTK_WCN_WMT_EXP_CB_INFO pWmtExpCb)
+{
+	WMT_STP_EXP_INFO_FUNC("call wmt exp cb reg\n");
+
+	mtk_wcn_wmt_func_on_f = pWmtExpCb->wmt_func_on_cb;
+	mtk_wcn_wmt_func_off_f = pWmtExpCb->wmt_func_off_cb;
+	mtk_wcn_wmt_therm_ctrl_f = pWmtExpCb->wmt_therm_ctrl_cb;
+	mtk_wcn_wmt_hwver_get_f = pWmtExpCb->wmt_hwver_get_cb;
+	mtk_wcn_wmt_dsns_ctrl_f = pWmtExpCb->wmt_dsns_ctrl_cb;
+	mtk_wcn_wmt_msgcb_reg_f = pWmtExpCb->wmt_msgcb_reg_cb;
+	mtk_wcn_wmt_msgcb_unreg_f = pWmtExpCb->wmt_msgcb_unreg_cb;
+	mtk_wcn_wmt_sdio_op_reg_f = pWmtExpCb->wmt_sdio_op_reg_cb;
+	mtk_wcn_wmt_sdio_host_awake_f = pWmtExpCb->wmt_sdio_host_awake_cb;
+	mtk_wcn_wmt_assert_f = pWmtExpCb->wmt_assert_cb;
+	mtk_wcn_wmt_assert_timeout_f = pWmtExpCb->wmt_assert_timeout_cb;
+	mtk_wcn_wmt_ic_info_get_f = pWmtExpCb->wmt_ic_info_get_cb;
+	mtk_wcn_wmt_psm_ctrl_f = pWmtExpCb->wmt_psm_ctrl_cb;
+	return 0;
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_exp_cb_reg);
+
+UINT32 mtk_wcn_wmt_exp_cb_unreg(VOID)
+{
+	WMT_STP_EXP_INFO_FUNC("call wmt exp cb unreg\n");
+
+	mtk_wcn_wmt_func_on_f = NULL;
+	mtk_wcn_wmt_func_off_f = NULL;
+	mtk_wcn_wmt_therm_ctrl_f = NULL;
+	mtk_wcn_wmt_hwver_get_f = NULL;
+	mtk_wcn_wmt_dsns_ctrl_f = NULL;
+	mtk_wcn_wmt_msgcb_reg_f = NULL;
+	mtk_wcn_wmt_msgcb_unreg_f = NULL;
+	mtk_wcn_wmt_sdio_op_reg_f = NULL;
+	mtk_wcn_wmt_sdio_host_awake_f = NULL;
+	mtk_wcn_wmt_assert_f = NULL;
+	mtk_wcn_wmt_assert_timeout_f = NULL;
+	mtk_wcn_wmt_ic_info_get_f = NULL;
+	mtk_wcn_wmt_psm_ctrl_f = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_exp_cb_unreg);
+
+MTK_WCN_BOOL mtk_wcn_wmt_func_off(ENUM_WMTDRV_TYPE_T type)
+{
+	MTK_WCN_BOOL ret = MTK_WCN_BOOL_FALSE;
+
+	if (mtk_wcn_wmt_func_off_f)
+		ret = (*mtk_wcn_wmt_func_off_f) (type);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_wmt_func_off_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_func_off);
+
+MTK_WCN_BOOL mtk_wcn_wmt_func_on(ENUM_WMTDRV_TYPE_T type)
+{
+	MTK_WCN_BOOL ret = MTK_WCN_BOOL_FALSE;
+
+	if (mtk_wcn_wmt_func_on_f) {
+		ret = (*mtk_wcn_wmt_func_on_f) (type);
+		WMT_STP_EXP_INFO_FUNC("mtk_wcn_wmt_func_on_f type(%d)\n", type);
+	} else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_wmt_func_on_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_func_on);
+
+INT8 mtk_wcn_wmt_therm_ctrl(ENUM_WMTTHERM_TYPE_T eType)
+{
+	INT32 ret = -1;
+
+	if (mtk_wcn_wmt_therm_ctrl_f)
+		ret = (*mtk_wcn_wmt_therm_ctrl_f) (eType);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_wmt_therm_ctrl_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_therm_ctrl);
+
+ENUM_WMTHWVER_TYPE_T mtk_wcn_wmt_hwver_get(VOID)
+{
+	ENUM_WMTHWVER_TYPE_T ret = WMTHWVER_INVALID;
+
+	if (mtk_wcn_wmt_hwver_get_f)
+		ret = (*mtk_wcn_wmt_hwver_get_f) ();
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_wmt_hwver_get_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_hwver_get);
+
+MTK_WCN_BOOL mtk_wcn_wmt_dsns_ctrl(ENUM_WMTDSNS_TYPE_T eType)
+{
+	MTK_WCN_BOOL ret = MTK_WCN_BOOL_FALSE;
+
+	if (mtk_wcn_wmt_dsns_ctrl_f)
+		ret = (*mtk_wcn_wmt_dsns_ctrl_f) (eType);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_wmt_dsns_ctrl_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_dsns_ctrl);
+
+INT32 mtk_wcn_wmt_msgcb_reg(ENUM_WMTDRV_TYPE_T eType, PF_WMT_CB pCb)
+{
+	INT32 ret = 0;
+
+	if (mtk_wcn_wmt_msgcb_reg_f)
+		ret = (*mtk_wcn_wmt_msgcb_reg_f) (eType, pCb);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_wmt_msgcb_reg_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_msgcb_reg);
+
+INT32 mtk_wcn_wmt_msgcb_unreg(ENUM_WMTDRV_TYPE_T eType)
+{
+	INT32 ret = 0;
+
+	if (mtk_wcn_wmt_msgcb_unreg_f)
+		ret = (*mtk_wcn_wmt_msgcb_unreg_f) (eType);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_wmt_msgcb_unreg_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_msgcb_unreg);
+
+INT32 mtk_wcn_stp_wmt_sdio_op_reg(PF_WMT_SDIO_PSOP own_cb)
+{
+	INT32 ret = -1;
+
+	if (mtk_wcn_wmt_sdio_op_reg_f)
+		ret = (*mtk_wcn_wmt_sdio_op_reg_f) (own_cb);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_wmt_sdio_op_reg_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_stp_wmt_sdio_op_reg);
+
+INT32 mtk_wcn_stp_wmt_sdio_host_awake(VOID)
+{
+	INT32 ret = -1;
+
+	if (mtk_wcn_wmt_sdio_host_awake_f)
+		ret = (*mtk_wcn_wmt_sdio_host_awake_f) ();
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_wmt_sdio_host_awake_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_stp_wmt_sdio_host_awake);
+
+MTK_WCN_BOOL mtk_wcn_wmt_assert(ENUM_WMTDRV_TYPE_T type, UINT32 reason)
+{
+	MTK_WCN_BOOL ret = MTK_WCN_BOOL_FALSE;
+
+	if (mtk_wcn_wmt_assert_f)
+		ret = (*mtk_wcn_wmt_assert_f) (type, reason);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_wmt_assert_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_assert);
+
+MTK_WCN_BOOL mtk_wcn_wmt_assert_timeout(ENUM_WMTDRV_TYPE_T type, UINT32 reason, INT32 timeout)
+{
+	MTK_WCN_BOOL ret = MTK_WCN_BOOL_FALSE;
+
+	if (mtk_wcn_wmt_assert_timeout_f)
+		ret = (*mtk_wcn_wmt_assert_timeout_f)(type, reason, timeout);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_wmt_assert_timeout_f cb is null\n");
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_assert_timeout);
+
+UINT32 mtk_wcn_wmt_ic_info_get(ENUM_WMT_CHIPINFO_TYPE_T type)
+{
+	UINT32 ret = 0;
+
+	if (mtk_wcn_wmt_ic_info_get_f)
+		ret = (*mtk_wcn_wmt_ic_info_get_f) (type);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_wmt_ic_info_get_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_ic_info_get);
+
+INT32 mtk_wcn_wmt_psm_ctrl(MTK_WCN_BOOL flag)
+{
+	UINT32 ret = 0;
+
+	if (mtk_wcn_wmt_psm_ctrl_f)
+		ret = (*mtk_wcn_wmt_psm_ctrl_f)(flag);
+	else
+		WMT_STP_EXP_ERR_FUNC("mtk_wcn_wmt_psm_ctrl_f cb is null\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_psm_ctrl);
+
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/include/stp_exp.h b/drivers/misc/mediatek/connectivity/common/conn_soc/include/stp_exp.h
new file mode 100644
index 00000000..b1b5285
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/include/stp_exp.h
@@ -0,0 +1,252 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _STP_EXP_H_
+#define _STP_EXP_H_
+
+#include "osal_typedef.h"
+#include "osal.h"
+#include "wmt_stp_exp.h"
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+#ifndef MTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+
+#define BT_TASK_INDX        (0)
+#define FM_TASK_INDX        (1)
+#define GPS_TASK_INDX       (2)
+#define WIFI_TASK_INDX      (3)
+#define WMT_TASK_INDX       (4)
+#define STP_TASK_INDX       (5)
+#define INFO_TASK_INDX      (6)
+#define ANT_TASK_INDX       (7)
+#if CFG_WMT_LTE_COEX_HANDLING
+#define COEX_TASK_INDX		(8)
+#define MTKSTP_MAX_TASK_NUM (9)
+#else
+#define MTKSTP_MAX_TASK_NUM	(8)
+#endif
+
+#define MTKSTP_BUFFER_SIZE  (16384)	/* Size of RX Queue */
+
+#define STP_EXP_HID_API_EXPORT 0
+
+#else
+
+#define STP_EXP_HID_API_EXPORT 1
+
+#endif
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+#ifndef MTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+typedef void (*MTK_WCN_STP_EVENT_CB) (void);
+typedef INT32 (*MTK_WCN_STP_IF_TX) (const UINT8 *data, const UINT32 size, UINT32 *written_size);
+/* export for HIF driver */
+typedef void (*MTK_WCN_STP_IF_RX) (const UINT8 *data, INT32 size);
+
+typedef enum {
+	STP_UART_IF_TX = 0,
+	STP_SDIO_IF_TX = 1,
+	STP_BTIF_IF_TX = 2,
+	STP_MAX_IF_TX
+} ENUM_STP_TX_IF_TYPE;
+#endif
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+#ifndef MTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_receive_data
+* DESCRIPTION
+*  receive data from serial protocol engine
+* PARAMETERS
+*  buffer      [IN]        data buffer
+*  length      [IN]        data buffer length
+* RETURNS
+*  INT32    >= 0: size of data received; < 0: error
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_receive_data(UINT8 *buffer, UINT32 length, UINT8 type);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_send_data
+* DESCRIPTION
+*  subfunction send data through STP
+* PARAMETERS
+*  buffer      [IN]        data buffer
+*  length      [IN]        data buffer length
+*  type        [IN]        subfunction type
+* RETURNS
+*  INT32    >= 0: length transmitted; < 0: error
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_send_data(const PUINT8 buffer, const UINT32 length, const UINT8 type);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_is_rxqueue_empty
+* DESCRIPTION
+*  Is certain rx queue empty?
+* PARAMETERS
+*  type        [IN]        subfunction type
+* RETURNS
+*  INT32    0: queue is NOT empyt; !0: queue is empty
+*****************************************************************************/
+extern MTK_WCN_BOOL mtk_wcn_stp_is_rxqueue_empty(UINT8 type);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_is_enable
+* DESCRIPTION
+*  Is STP ready?
+* PARAMETERS
+*  none.
+* RETURNS
+*  MTK_WCN_BOOL    TRUE:ready, FALSE:not ready
+*****************************************************************************/
+extern MTK_WCN_BOOL mtk_wcn_stp_is_ready(void);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_parser_data
+* DESCRIPTION
+*  push data to serial transport protocol parser engine
+* PARAMETERS
+*  buffer      [IN]        data buffer
+*  length      [IN]        data buffer length
+* RETURNS
+*  void
+*****************************************************************************/
+extern int mtk_wcn_stp_parser_data(UINT8 *buffer, UINT32 length);
+
+/*****************************************************************************
+* FUNCTION
+*  set_bluetooth_rx_interface
+* DESCRIPTION
+*  Set bluetooth rx interface
+* PARAMETERS
+*  rx interface type
+* RETURNS
+*  void
+*****************************************************************************/
+extern void mtk_wcn_stp_set_bluez(MTK_WCN_BOOL sdio_flag);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_register_tx_event_cb
+* DESCRIPTION
+*  regiter Tx event callback function
+* PARAMETERS
+*  func
+* RETURNS
+*  int: 0:successful , -1: fail
+*****************************************************************************/
+extern int mtk_wcn_stp_register_tx_event_cb(int type, MTK_WCN_STP_EVENT_CB func);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_register_event_cb
+* DESCRIPTION
+*  regiter Rx event callback function
+* PARAMETERS
+*  func
+* RETURNS
+*  int: 0:successful , -1: fail
+*****************************************************************************/
+extern int mtk_wcn_stp_register_event_cb(int type, MTK_WCN_STP_EVENT_CB func);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_register_if_tx
+* DESCRIPTION
+*  regiter Tx event callback function
+* PARAMETERS
+*  stp_if: SDIO or UART, fnnc: Call back function
+* RETURNS
+*  int: 0:successful , -1: fail
+*****************************************************************************/
+extern int mtk_wcn_stp_register_if_tx(ENUM_STP_TX_IF_TYPE stp_if, MTK_WCN_STP_IF_TX func);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_register_if_rx
+* DESCRIPTION
+*  regiter Rx event callback function
+* PARAMETERS
+*  stp_if: SDIO or UART, fnnc: Call back function
+* RETURNS
+*  int: 0:successful , -1: fail
+*****************************************************************************/
+extern int mtk_wcn_stp_register_if_rx(MTK_WCN_STP_IF_RX func);
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+#else
+extern INT32 _mtk_wcn_stp_receive_data(PUINT8 buffer, UINT32 length, UINT8 type);
+extern INT32 _mtk_wcn_stp_send_data_raw(const PUINT8 buffer, const UINT32 length, const UINT8 type);
+extern INT32 _mtk_wcn_stp_send_data(const PUINT8 buffer, const UINT32 length, const UINT8 type);
+extern MTK_WCN_BOOL _mtk_wcn_stp_is_rxqueue_empty(UINT8 type);
+extern MTK_WCN_BOOL _mtk_wcn_stp_is_ready(void);
+extern INT32 _mtk_wcn_stp_parser_data(UINT8 *buffer, UINT32 length);
+extern void _mtk_wcn_stp_set_bluez(MTK_WCN_BOOL sdio_flag);
+extern INT32 _mtk_wcn_stp_register_tx_event_cb(INT32 type, MTK_WCN_STP_EVENT_CB func);
+extern INT32 _mtk_wcn_stp_register_event_cb(INT32 type, MTK_WCN_STP_EVENT_CB func);
+extern INT32 _mtk_wcn_stp_register_if_tx(ENUM_STP_TX_IF_TYPE stp_if, MTK_WCN_STP_IF_TX func);
+extern INT32 _mtk_wcn_stp_register_if_rx(MTK_WCN_STP_IF_RX func);
+extern INT32 _mtk_wcn_stp_coredump_start_get(VOID);
+
+#endif
+
+#endif /* _WMT_EXP_H_ */
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/include/wmt.h b/drivers/misc/mediatek/connectivity/common/conn_soc/include/wmt.h
new file mode 100644
index 00000000..6d10c3f
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/include/wmt.h
@@ -0,0 +1,19 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _MTKWMT_H_
+#define _MTKWMT_H_
+#include "wmt_core.h"
+
+#endif /*_MTKWMT_H_*/
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/include/wmt_exp.h b/drivers/misc/mediatek/connectivity/common/conn_soc/include/wmt_exp.h
new file mode 100644
index 00000000..06238e0
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/include/wmt_exp.h
@@ -0,0 +1,329 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _WMT_EXP_H_
+#define _WMT_EXP_H_
+
+#include <mtk_wcn_cmb_stub.h>
+#include "osal.h"
+#include "wmt_plat.h"
+#include "wmt_stp_exp.h"
+/* not to reference to internal wmt */
+/* #include "wmt_core.h" */
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+#if 1				/* moved from wmt_lib.h */
+#ifndef DFT_TAG
+#define DFT_TAG         "[WMT-DFT]"
+#endif
+
+#define WMT_LOUD_FUNC(fmt, arg...) \
+do { \
+	if (gWmtDbgLvl >= WMT_LOG_LOUD) \
+		osal_dbg_print(DFT_TAG "[L]%s:"  fmt, __func__ , ##arg); \
+} while (0)
+#define WMT_INFO_FUNC(fmt, arg...)  \
+do { \
+	if (gWmtDbgLvl >= WMT_LOG_INFO) \
+		osal_dbg_print(DFT_TAG "[I]%s:"  fmt, __func__ , ##arg); \
+} while (0)
+#define WMT_WARN_FUNC(fmt, arg...) \
+do { \
+	if (gWmtDbgLvl >= WMT_LOG_WARN) \
+		osal_warn_print(DFT_TAG "[W]%s:"  fmt, __func__ , ##arg); \
+} while (0)
+#define WMT_ERR_FUNC(fmt, arg...) \
+do { \
+	if (gWmtDbgLvl >= WMT_LOG_ERR) \
+		osal_err_print(DFT_TAG "[E]%s(%d):"  fmt, __func__ , __LINE__, ##arg); \
+} while (0)
+#define WMT_DBG_FUNC(fmt, arg...) \
+do { \
+	if (gWmtDbgLvl >= WMT_LOG_DBG) \
+		osal_dbg_print(DFT_TAG "[D]%s:"  fmt, __func__ , ##arg); \
+} while (0)
+#define WMT_TRC_FUNC(f) \
+do { \
+	if (gWmtDbgLvl >= WMT_LOG_DBG) \
+		osal_dbg_print(DFT_TAG "<%s> <%d>\n", __func__, __LINE__); \
+} while (0)
+
+#endif
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+#if 1				/* moved from wmt_lib.h */
+extern UINT32 gWmtDbgLvl;
+#endif
+extern OSAL_BIT_OP_VAR gBtWifiGpsState;
+extern OSAL_BIT_OP_VAR gGpsFmState;
+extern UINT32 gWifiProbed;
+extern MTK_WCN_BOOL g_pwr_off_flag;
+extern UINT32 g_IsNeedDoChipReset;
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+#if 1				/* moved from wmt_lib.h */
+#define WMT_LOG_LOUD    4
+#define WMT_LOG_DBG     3
+#define WMT_LOG_INFO    2
+#define WMT_LOG_WARN    1
+#define WMT_LOG_ERR     0
+#endif
+#define CFG_CORE_INTERNAL_TXRX 0	/*just do TX/RX in host side */
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+#ifndef MTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+typedef enum _ENUM_WMTDRV_TYPE_T {
+	WMTDRV_TYPE_BT = 0,
+	WMTDRV_TYPE_FM = 1,
+	WMTDRV_TYPE_GPS = 2,
+	WMTDRV_TYPE_WIFI = 3,
+	WMTDRV_TYPE_WMT = 4,
+	WMTDRV_TYPE_STP = 5,
+	WMTDRV_TYPE_LPBK = 6,
+	WMTDRV_TYPE_COREDUMP = 7,
+	WMTDRV_TYPE_MAX
+} ENUM_WMTDRV_TYPE_T, *P_ENUM_WMTDRV_TYPE_T;
+
+/* TODO: [ChangeFeature][GeorgeKuo] Reconsider usage of this type */
+/* TODO: how do we extend for new chip and newer revision? */
+/* TODO: This way is hard to extend */
+typedef enum _ENUM_WMTHWVER_TYPE_T {
+	WMTHWVER_E1 = 0x0,
+	WMTHWVER_E2 = 0x1,
+	WMTHWVER_E3 = 0x2,
+	WMTHWVER_E4 = 0x3,
+	WMTHWVER_E5 = 0x4,
+	WMTHWVER_E6 = 0x5,
+	WMTHWVER_MAX,
+	WMTHWVER_INVALID = 0xff
+} ENUM_WMTHWVER_TYPE_T, *P_ENUM_WMTHWVER_TYPE_T;
+
+typedef enum _ENUM_WMTDSNS_TYPE_T {
+	WMTDSNS_FM_DISABLE = 0,
+	WMTDSNS_FM_ENABLE = 1,
+	WMTDSNS_FM_GPS_DISABLE = 2,
+	WMTDSNS_FM_GPS_ENABLE = 3,
+	WMTDSNS_MAX
+} ENUM_WMTDSNS_TYPE_T, *P_ENUM_WMTDSNS_TYPE_T;
+
+typedef enum _ENUM_WMTTHERM_TYPE_T {
+	WMTTHERM_ZERO = 0,
+	WMTTHERM_ENABLE = WMTTHERM_ZERO + 1,
+	WMTTHERM_READ = WMTTHERM_ENABLE + 1,
+	WMTTHERM_DISABLE = WMTTHERM_READ + 1,
+	WMTTHERM_MAX
+} ENUM_WMTTHERM_TYPE_T, *P_ENUM_WMTTHERM_TYPE_T;
+
+typedef enum _ENUM_WMTMSG_TYPE_T {
+	WMTMSG_TYPE_POWER_ON = 0,
+	WMTMSG_TYPE_POWER_OFF = 1,
+	WMTMSG_TYPE_RESET = 2,
+	WMTMSG_TYPE_STP_RDY = 3,
+	WMTMSG_TYPE_HW_FUNC_ON = 4,
+	WMTMSG_TYPE_MAX
+} ENUM_WMTMSG_TYPE_T, *P_ENUM_WMTMSG_TYPE_T;
+
+typedef void (*PF_WMT_CB) (ENUM_WMTDRV_TYPE_T,	/* Source driver type */
+			   ENUM_WMTDRV_TYPE_T,	/* Destination driver type */
+			   ENUM_WMTMSG_TYPE_T,	/* Message type */
+			   VOID *,	/* READ-ONLY buffer. Buffer is allocated and freed by WMT_drv. Client
+					   can't touch this buffer after this function return. */
+			   UINT32	/* Buffer size in unit of byte */
+);
+
+typedef enum _SDIO_PS_OP {
+	OWN_SET = 0,
+	OWN_CLR = 1,
+	OWN_STATE = 2,
+} SDIO_PS_OP;
+
+typedef INT32(*PF_WMT_SDIO_PSOP) (SDIO_PS_OP);
+
+typedef enum _ENUM_WMTCHIN_TYPE_T {
+	WMTCHIN_CHIPID = 0x0,
+	WMTCHIN_HWVER = WMTCHIN_CHIPID + 1,
+	WMTCHIN_MAPPINGHWVER = WMTCHIN_HWVER + 1,
+	WMTCHIN_FWVER = WMTCHIN_MAPPINGHWVER + 1,
+	WMTCHIN_MAX,
+
+} ENUM_WMT_CHIPINFO_TYPE_T, *P_ENUM_WMT_CHIPINFO_TYPE_T;
+
+#endif
+
+typedef enum _ENUM_WMTRSTMSG_TYPE_T {
+	WMTRSTMSG_RESET_START = 0x0,
+	WMTRSTMSG_RESET_END = 0x1,
+	WMTRSTMSG_RESET_END_FAIL = 0x2,
+	WMTRSTMSG_RESET_MAX,
+	WMTRSTMSG_RESET_INVALID = 0xff
+} ENUM_WMTRSTMSG_TYPE_T, *P_ENUM_WMTRSTMSG_TYPE_T;
+
+typedef enum _ENUM_BT_GPS_ONOFF_STATE_T {
+	WMT_BT_ON = 0,
+	WMT_GPS_ON = 1,
+	WMT_WIFI_ON = 2,
+	WMT_FM_ON = 3,
+	WMT_BT_GPS_STATE_MAX,
+	WMT_BT_GPS_STATE_INVALID = 0xff
+} ENUM_BT_GPS_ONOFF_STATE_T, *P_ENUM_BT_GPS_ONOFF_STATE_T;
+
+#if 1				/* moved from wmt_core.h */
+typedef enum {
+	WMT_SDIO_SLOT_INVALID = 0,
+	WMT_SDIO_SLOT_SDIO1 = 1,	/* Wi-Fi dedicated SDIO1 */
+	WMT_SDIO_SLOT_SDIO2 = 2,
+	WMT_SDIO_SLOT_MAX
+} WMT_SDIO_SLOT_NUM;
+
+typedef enum {
+	WMT_SDIO_FUNC_STP = 0,
+	WMT_SDIO_FUNC_WIFI = 1,
+	WMT_SDIO_FUNC_MAX
+} WMT_SDIO_FUNC_TYPE;
+#endif
+
+typedef INT32(*wmt_wlan_probe_cb) (VOID);
+typedef INT32(*wmt_wlan_remove_cb) (VOID);
+typedef INT32(*wmt_wlan_bus_cnt_get_cb) (VOID);
+typedef INT32(*wmt_wlan_bus_cnt_clr_cb) (VOID);
+
+typedef struct _MTK_WCN_WMT_WLAN_CB_INFO {
+	wmt_wlan_probe_cb wlan_probe_cb;
+	wmt_wlan_remove_cb wlan_remove_cb;
+	wmt_wlan_bus_cnt_get_cb wlan_bus_cnt_get_cb;
+	wmt_wlan_bus_cnt_clr_cb wlan_bus_cnt_clr_cb;
+} MTK_WCN_WMT_WLAN_CB_INFO, *P_MTK_WCN_WMT_WLAN_CB_INFO;
+
+#ifdef CONFIG_MTK_COMBO_ANT
+typedef enum _ENUM_WMT_ANT_RAM_CTRL_T {
+	WMT_ANT_RAM_GET_STATUS = 0,
+	WMT_ANT_RAM_DOWNLOAD = WMT_ANT_RAM_GET_STATUS + 1,
+	WMT_ANT_RAM_CTRL_MAX
+} ENUM_WMT_ANT_RAM_CTRL, *P_ENUM_WMT_ANT_RAM_CTRL;
+
+typedef enum _ENUM_WMT_ANT_RAM_SEQ_T {
+	WMT_ANT_RAM_START_PKT = 1,
+	WMT_ANT_RAM_CONTINUE_PKT = WMT_ANT_RAM_START_PKT + 1,
+	WMT_ANT_RAM_END_PKT = WMT_ANT_RAM_CONTINUE_PKT + 1,
+	WMT_ANT_RAM_SEQ_MAX
+} ENUM_WMT_ANT_RAM_SEQ, *P_ENUM_WMT_ANT_RAM_SEQ;
+
+typedef enum _ENUM_WMT_ANT_RAM_STATUS_T {
+	WMT_ANT_RAM_NOT_EXIST = 0,
+	WMT_ANT_RAM_EXIST = WMT_ANT_RAM_NOT_EXIST + 1,
+	WMT_ANT_RAM_DOWN_OK = WMT_ANT_RAM_EXIST + 1,
+	WMT_ANT_RAM_DOWN_FAIL = WMT_ANT_RAM_DOWN_OK + 1,
+	WMT_ANT_RAM_PARA_ERR = WMT_ANT_RAM_DOWN_FAIL + 1,
+	WMT_ANT_RAM_OP_ERR = WMT_ANT_RAM_PARA_ERR + 1,
+	WMT_ANT_RAM_MAX
+} ENUM_WMT_ANT_RAM_STATUS, *P_ENUM_WMT_ANT_RAM_STATUS;
+#endif
+
+extern INT32 mtk_wcn_wmt_wlan_reg(P_MTK_WCN_WMT_WLAN_CB_INFO pWmtWlanCbInfo);
+extern INT32 mtk_wcn_wmt_wlan_unreg(VOID);
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+extern wmt_wlan_probe_cb mtk_wcn_wlan_probe;
+extern wmt_wlan_remove_cb mtk_wcn_wlan_remove;
+extern wmt_wlan_bus_cnt_get_cb mtk_wcn_wlan_bus_tx_cnt;
+extern wmt_wlan_bus_cnt_clr_cb mtk_wcn_wlan_bus_tx_cnt_clr;
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+/*subsystem function ctrl APIs*/
+extern MTK_WCN_BOOL mtk_wcn_wmt_assert(ENUM_WMTDRV_TYPE_T type, UINT32 reason);
+
+#ifndef MTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+#define WMT_EXP_HID_API_EXPORT 0
+
+extern MTK_WCN_BOOL mtk_wcn_wmt_func_off(ENUM_WMTDRV_TYPE_T type);
+
+extern MTK_WCN_BOOL mtk_wcn_wmt_func_on(ENUM_WMTDRV_TYPE_T type);
+
+extern MTK_WCN_BOOL mtk_wcn_wmt_dsns_ctrl(ENUM_WMTDSNS_TYPE_T eType);
+
+extern MTK_WCN_BOOL mtk_wcn_wmt_assert(ENUM_WMTDRV_TYPE_T type, UINT32 reason);
+
+extern INT32 mtk_wcn_wmt_msgcb_reg(ENUM_WMTDRV_TYPE_T eType, PF_WMT_CB pCb);
+
+extern INT32 mtk_wcn_wmt_msgcb_unreg(ENUM_WMTDRV_TYPE_T eType);
+
+extern INT32 mtk_wcn_stp_wmt_sdio_op_reg(PF_WMT_SDIO_PSOP own_cb);
+
+extern INT32 mtk_wcn_stp_wmt_sdio_host_awake(VOID);
+/*
+return value:
+enable/disable thermal sensor function: true(1)/false(0)
+read thermal sensor function: thermal value
+
+*/
+extern INT8 mtk_wcn_wmt_therm_ctrl(ENUM_WMTTHERM_TYPE_T eType);
+
+extern ENUM_WMTHWVER_TYPE_T mtk_wcn_wmt_hwver_get(VOID);
+
+#else
+#define WMT_EXP_HID_API_EXPORT 1
+#endif
+
+#ifdef CONFIG_MTK_COMBO_ANT
+extern ENUM_WMT_ANT_RAM_STATUS mtk_wcn_wmt_ant_ram_ctrl(ENUM_WMT_ANT_RAM_CTRL ctrlId, PUINT8 pBuf,
+							UINT32 length, ENUM_WMT_ANT_RAM_SEQ seq);
+#endif
+extern INT32 wmt_lib_set_aif(CMB_STUB_AIF_X aif, MTK_WCN_BOOL share);	/* set AUDIO interface options */
+extern VOID wmt_lib_ps_irq_cb(VOID);
+
+extern VOID mtk_wcn_wmt_func_ctrl_for_plat(UINT32 on, ENUM_WMTDRV_TYPE_T type);
+
+extern INT32 mtk_wcn_wmt_system_state_reset(VOID);
+extern MTK_WCN_BOOL mtk_wcn_set_connsys_power_off_flag(MTK_WCN_BOOL value);
+#ifdef MTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+extern VOID mtk_wcn_wmt_exp_init(VOID);
+extern VOID mtk_wcn_wmt_exp_deinit(VOID);
+#endif
+extern INT8 mtk_wcn_wmt_co_clock_flag_get(VOID);
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+#endif /* _WMT_EXP_H_ */
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/include/wmt_plat.h b/drivers/misc/mediatek/connectivity/common/conn_soc/include/wmt_plat.h
new file mode 100644
index 00000000..075496c
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/include/wmt_plat.h
@@ -0,0 +1,295 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _WMT_PLAT_H_
+#define _WMT_PLAT_H_
+#include "osal_typedef.h"
+#include "stp_exp.h"
+#include <mtk_wcn_cmb_stub.h>
+
+/* #include "mtk_wcn_consys_hw.h" */
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+#if 1				/* moved from wmt_exp.h */
+#ifndef DFT_TAG
+#define DFT_TAG         "[WMT-DFT]"
+#endif
+
+#define WMT_PLAT_LOG_LOUD                 4
+#define WMT_PLAT_LOG_DBG                  3
+#define WMT_PLAT_LOG_INFO                 2
+#define WMT_PLAT_LOG_WARN                 1
+#define WMT_PLAT_LOG_ERR                  0
+
+extern UINT32 wmtPlatLogLvl;
+
+#define WMT_PLAT_LOUD_FUNC(fmt, arg...) \
+do { \
+	if (wmtPlatLogLvl >= WMT_PLAT_LOG_LOUD) \
+		pr_debug(DFT_TAG "[L]%s:"  fmt, __func__ , ##arg); \
+} while (0)
+#define WMT_PLAT_INFO_FUNC(fmt, arg...) \
+do { \
+	if (wmtPlatLogLvl >= WMT_PLAT_LOG_INFO) \
+		pr_debug(DFT_TAG "[I]%s:"  fmt, __func__ , ##arg); \
+} while (0)
+#define WMT_PLAT_WARN_FUNC(fmt, arg...) \
+do { \
+	if (wmtPlatLogLvl >= WMT_PLAT_LOG_WARN) \
+		pr_warn(DFT_TAG "[W]%s:"  fmt, __func__ , ##arg); \
+} while (0)
+#define WMT_PLAT_ERR_FUNC(fmt, arg...) \
+do { \
+	if (wmtPlatLogLvl >= WMT_PLAT_LOG_ERR) \
+		pr_err(DFT_TAG "[E]%s(%d):"  fmt, __func__ , __LINE__, ##arg); \
+} while (0)
+#define WMT_PLAT_DBG_FUNC(fmt, arg...) \
+do { \
+	if (wmtPlatLogLvl >= WMT_PLAT_LOG_DBG) \
+		pr_debug(DFT_TAG "[D]%s:"  fmt, __func__ , ##arg); \
+} while (0)
+
+#endif
+
+#define CFG_WMT_PS_SUPPORT 1	/* moved from wmt_exp.h */
+
+#define CFG_WMT_DUMP_INT_STATUS 0
+#define CONSYS_ENALBE_SET_JTAG 1
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+typedef enum _ENUM_FUNC_STATE_ {
+	FUNC_ON = 0,
+	FUNC_OFF = 1,
+	FUNC_RST = 2,
+	FUNC_STAT = 3,
+	FUNC_CTRL_MAX,
+} ENUM_FUNC_STATE, *P_ENUM_FUNC_STATE;
+
+typedef enum _ENUM_PIN_ID_ {
+	PIN_BGF_EINT = 0,
+	PIN_I2S_GRP = 1,
+	PIN_GPS_SYNC = 2,
+	PIN_GPS_LNA = 3,
+#if CFG_WMT_LTE_COEX_HANDLING
+	PIN_TDM_REQ = 4,
+#endif
+	PIN_ID_MAX
+} ENUM_PIN_ID, *P_ENUM_PIN_ID;
+
+typedef enum _ENUM_PIN_STATE_ {
+	PIN_STA_INIT = 0,
+	PIN_STA_OUT_L = 1,
+	PIN_STA_OUT_H = 2,
+	PIN_STA_IN_L = 3,
+	PIN_STA_MUX = 4,
+	PIN_STA_EINT_EN = 5,
+	PIN_STA_EINT_DIS = 6,
+	PIN_STA_DEINIT = 7,
+	PIN_STA_SHOW = 8,
+	PIN_STA_MAX
+} ENUM_PIN_STATE, *P_ENUM_PIN_STATE;
+
+typedef enum _CMB_IF_TYPE_ {
+	CMB_IF_UART = 0,
+	CMB_IF_WIFI_SDIO = 1,
+	CMB_IF_BGF_SDIO = 2,
+	CMB_IF_BGWF_SDIO = 3,
+	CMB_IF_TYPE_MAX
+} CMB_IF_TYPE, *P_CMB_IF_TYPE;
+
+typedef INT32(*fp_set_pin) (ENUM_PIN_STATE);
+
+typedef enum _ENUM_WL_OP_ {
+	WL_OP_GET = 0,
+	WL_OP_PUT = 1,
+	WL_OP_MAX
+} ENUM_WL_OP, *P_ENUM_WL_OP;
+
+typedef enum _ENUM_PALDO_TYPE_ {
+	BT_PALDO = 0,
+	WIFI_PALDO = 1,
+	FM_PALDO = 2,
+	GPS_PALDO = 3,
+	PMIC_CHIPID_PALDO = 4,
+	WIFI_5G_PALDO = 5,
+	PALDO_TYPE_MAX
+} ENUM_PALDO_TYPE, *P_ENUM_PALDO_TYPE;
+
+typedef enum _ENUM_PALDO_OP_ {
+	PALDO_OFF = 0,
+	PALDO_ON = 1,
+	PALDO_OP_MAX
+} ENUM_PALDO_OP, *P_ENUM_PALDO_OP;
+
+typedef enum _ENUM_HOST_DUMP_STATE_T {
+	STP_HOST_DUMP_NOT_START = 0,
+	STP_HOST_DUMP_GET = 1,
+	STP_HOST_DUMP_GET_DONE = 2,
+	STP_HOST_DUMP_END = 3,
+	STP_HOST_DUMP_MAX
+} ENUM_HOST_DUMP_STATE, *P_ENUM_HOST_DUMP_STATE_T;
+
+typedef enum _ENUM_FORCE_TRG_ASSERT_T {
+	STP_FORCE_TRG_ASSERT_EMI = 0,
+	STP_FORCE_TRG_ASSERT_DEBUG_PIN = 1,
+	STP_FORCE_TRG_ASSERT_MAX = 2
+} ENUM_FORCE_TRG_ASSERT_T, *P_ENUM_FORCE_TRG_ASSERT_T;
+
+typedef enum _ENUM_CHIP_DUMP_STATE_T {
+	STP_CHIP_DUMP_NOT_START = 0,
+	STP_CHIP_DUMP_PUT = 1,
+	STP_CHIP_DUMP_PUT_DONE = 2,
+	STP_CHIP_DUMP_END = 3,
+	STP_CHIP_DUMP_MAX
+} ENUM_CHIP_DUMP_STATE, *P_ENUM_CHIP_DUMP_STATE_T;
+
+typedef struct _EMI_CTRL_STATE_OFFSET_ {
+	UINT32 emi_apmem_ctrl_state;
+	UINT32 emi_apmem_ctrl_host_sync_state;
+	UINT32 emi_apmem_ctrl_host_sync_num;
+	UINT32 emi_apmem_ctrl_chip_sync_state;
+	UINT32 emi_apmem_ctrl_chip_sync_num;
+	UINT32 emi_apmem_ctrl_chip_sync_addr;
+	UINT32 emi_apmem_ctrl_chip_sync_len;
+	UINT32 emi_apmem_ctrl_chip_print_buff_start;
+	UINT32 emi_apmem_ctrl_chip_print_buff_len;
+	UINT32 emi_apmem_ctrl_chip_print_buff_idx;
+	UINT32 emi_apmem_ctrl_chip_int_status;
+	UINT32 emi_apmem_ctrl_chip_paded_dump_end;
+	UINT32 emi_apmem_ctrl_host_outband_assert_w1;
+	UINT32 emi_apmem_ctrl_chip_page_dump_num;
+} EMI_CTRL_STATE_OFFSET, *P_EMI_CTRL_STATE_OFFSET;
+
+typedef struct _BGF_IRQ_BALANCE_ {
+	UINT32 counter;
+	unsigned long flags;
+	spinlock_t lock;
+} BGF_IRQ_BALANCE, *P_BGF_IRQ_BALANCE;
+
+typedef struct _CONSYS_EMI_ADDR_INFO_ {
+	UINT32 emi_phy_addr;
+	UINT32 paged_trace_off;
+	UINT32 paged_dump_off;
+	UINT32 full_dump_off;
+	P_EMI_CTRL_STATE_OFFSET p_ecso;
+} CONSYS_EMI_ADDR_INFO, *P_CONSYS_EMI_ADDR_INFO;
+
+typedef struct _GPIO_TDM_REQ_INFO_ {
+	UINT32 ant_sel_index;
+	UINT32 gpio_number;
+	UINT32 cr_address;
+} GPIO_TDM_REQ_INFO, *P_GPIO_TDM_REQ_INFO;
+
+typedef VOID(*irq_cb) (VOID);
+typedef INT32(*device_audio_if_cb) (CMB_STUB_AIF_X aif, MTK_WCN_BOOL share);
+typedef VOID(*func_ctrl_cb) (UINT32 on, UINT32 type);
+typedef long (*thermal_query_ctrl_cb) (VOID);
+typedef INT32(*deep_idle_ctrl_cb) (UINT32);
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+extern UINT32 gWmtDbgLvl;
+extern struct device *wmt_dev;
+#ifdef CFG_WMT_READ_EFUSE_VCN33
+extern INT32 wmt_set_pmic_voltage(UINT32 level);
+#endif
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+INT32 wmt_plat_init(UINT32 co_clock_type);
+
+INT32 wmt_plat_deinit(VOID);
+
+INT32 wmt_plat_pwr_ctrl(ENUM_FUNC_STATE state);
+
+INT32 wmt_plat_gpio_ctrl(ENUM_PIN_ID id, ENUM_PIN_STATE state);
+
+INT32 wmt_plat_eirq_ctrl(ENUM_PIN_ID id, ENUM_PIN_STATE state);
+
+INT32 wmt_plat_wake_lock_ctrl(ENUM_WL_OP opId);
+
+INT32 wmt_plat_audio_ctrl(CMB_STUB_AIF_X state, CMB_STUB_AIF_CTRL ctrl);
+
+VOID wmt_plat_irq_cb_reg(irq_cb bgf_irq_cb);
+VOID wmt_plat_aif_cb_reg(device_audio_if_cb aif_ctrl_cb);
+VOID wmt_plat_func_ctrl_cb_reg(func_ctrl_cb subsys_func_ctrl);
+VOID wmt_plat_thermal_ctrl_cb_reg(thermal_query_ctrl_cb thermal_query_ctrl);
+VOID wmt_plat_deep_idle_ctrl_cb_reg(deep_idle_ctrl_cb deep_idle_ctrl);
+
+INT32 wmt_plat_soc_paldo_ctrl(ENUM_PALDO_TYPE ePt, ENUM_PALDO_OP ePo);
+UINT8 *wmt_plat_get_emi_virt_add(UINT32 offset);
+#if CONSYS_ENALBE_SET_JTAG
+UINT32 wmt_plat_jtag_flag_ctrl(UINT32 en);
+#endif
+#if CFG_WMT_DUMP_INT_STATUS
+VOID wmt_plat_BGF_irq_dump_status(VOID);
+MTK_WCN_BOOL wmt_plat_dump_BGF_irq_status(VOID);
+#endif
+P_CONSYS_EMI_ADDR_INFO wmt_plat_get_emi_phy_add(VOID);
+UINT32 wmt_plat_read_cpupcr(VOID);
+UINT32 wmt_plat_read_dmaregs(UINT32);
+INT32 wmt_plat_set_host_dump_state(ENUM_HOST_DUMP_STATE state);
+UINT32 wmt_plat_force_trigger_assert(ENUM_FORCE_TRG_ASSERT_T type);
+INT32 wmt_plat_update_host_sync_num(VOID);
+INT32 wmt_plat_get_dump_info(UINT32 offset);
+UINT32 wmt_plat_get_soc_chipid(VOID);
+INT32 wmt_plat_set_dbg_mode(UINT32 flag);
+VOID wmt_plat_set_dynamic_dumpmem(UINT32 *buf);
+#if CFG_WMT_LTE_COEX_HANDLING
+INT32 wmt_plat_get_tdm_antsel_index(VOID);
+#endif
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+#endif /* _WMT_PLAT_H_ */
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/include/wmt_stp_exp.h b/drivers/misc/mediatek/connectivity/common/conn_soc/include/wmt_stp_exp.h
new file mode 100644
index 00000000..b7efdd4
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/include/wmt_stp_exp.h
@@ -0,0 +1,610 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _WMT_STP_EXP_H_
+#define _WMT_STP_EXP_H_
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <asm/current.h>
+#include <asm/uaccess.h>
+#include <linux/proc_fs.h>
+#include <linux/workqueue.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/vmalloc.h>
+#include <linux/firmware.h>
+#include <linux/kthread.h>
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+#include <mtk_wcn_cmb_stub.h>
+#include "osal_typedef.h"
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+#ifndef MTK_WCN_CMB_FOR_SDIO_1V_AUTOK
+#define MTK_WCN_CMB_FOR_SDIO_1V_AUTOK 0
+#endif
+
+#ifdef MTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+
+/*#if (WMT_IDC_SUPPORT)
+#define CFG_WMT_LTE_COEX_HANDLING 1
+#define CFG_WMT_LTE_ENABLE_MSGID_MAPPING 0
+#else*/
+#define CFG_WMT_LTE_COEX_HANDLING 0
+//#endif
+
+/*from stp_exp.h*/
+#define BT_TASK_INDX        (0)
+#define FM_TASK_INDX        (1)
+#define GPS_TASK_INDX       (2)
+#define WIFI_TASK_INDX      (3)
+#define WMT_TASK_INDX       (4)
+#define STP_TASK_INDX       (5)
+#define INFO_TASK_INDX      (6)
+#define ANT_TASK_INDX       (7)
+#if CFG_WMT_LTE_COEX_HANDLING
+#define COEX_TASK_INDX		(8)
+#define MTKSTP_MAX_TASK_NUM (9)
+#else
+#define MTKSTP_MAX_TASK_NUM	(8)
+#endif
+
+#define MTKSTP_BUFFER_SIZE  (16384)	/* Size of RX Queue */
+/*end from stp_exp.h*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************/
+
+/*moved from stp_exp.h*/
+typedef void (*MTK_WCN_STP_EVENT_CB) (void);
+typedef INT32(*MTK_WCN_STP_IF_TX) (const PUINT8 data, const UINT32 size, PUINT32 written_size);
+/* export for HIF driver */
+typedef void (*MTK_WCN_STP_IF_RX) (const PUINT8 data, INT32 size);
+
+typedef enum {
+	STP_UART_IF_TX = 0,
+	STP_SDIO_IF_TX = 1,
+	STP_BTIF_IF_TX = 2,
+	STP_MAX_IF_TX
+} ENUM_STP_TX_IF_TYPE;
+
+/*end moved from stp_exp.h*/
+
+typedef INT32(*MTK_WCN_STP_SEND_DATA) (const PUINT8 buffer, const UINT32 length, const UINT8 type);
+typedef INT32(*MTK_WCN_STP_PARSER_DATA) (PUINT8 buffer, UINT32 length);
+typedef INT32(*MTK_WCN_STP_RECV_DATA) (PUINT8 buffer, UINT32 length, UINT8 type);
+typedef MTK_WCN_BOOL(*MTK_WCN_STP_IS_RXQ_EMPTY) (UINT8 type);
+typedef MTK_WCN_BOOL(*MTK_WCN_STP_IS_RDY) (VOID);
+typedef VOID(*MTK_WCN_STP_SET_BLUEZ) (MTK_WCN_BOOL flags);
+typedef INT32(*MTK_WCN_STP_REG_IF_TX) (ENUM_STP_TX_IF_TYPE stp_if, MTK_WCN_STP_IF_TX func);
+typedef INT32(*MTK_WCN_STP_REG_IF_RX) (MTK_WCN_STP_IF_RX func);
+typedef INT32(*MTK_WCN_STP_REG_EVENT_CB) (INT32 type, MTK_WCN_STP_EVENT_CB func);
+typedef INT32(*MTK_WCN_STP_RGE_TX_EVENT_CB) (INT32 type, MTK_WCN_STP_EVENT_CB func);
+typedef INT32(*MTK_WCN_STP_COREDUMP_START_GET)(VOID);
+
+typedef struct _MTK_WCN_STP_EXP_CB_INFO_ {
+	MTK_WCN_STP_SEND_DATA stp_send_data_cb;
+	MTK_WCN_STP_SEND_DATA stp_send_data_raw_cb;
+	MTK_WCN_STP_PARSER_DATA stp_parser_data_cb;
+	MTK_WCN_STP_RECV_DATA stp_receive_data_cb;
+	MTK_WCN_STP_IS_RXQ_EMPTY stp_is_rxqueue_empty_cb;
+	MTK_WCN_STP_IS_RDY stp_is_ready_cb;
+	MTK_WCN_STP_SET_BLUEZ stp_set_bluez_cb;
+	MTK_WCN_STP_REG_IF_TX stp_if_tx_cb;
+	MTK_WCN_STP_REG_IF_RX stp_if_rx_cb;
+	MTK_WCN_STP_REG_EVENT_CB stp_reg_event_cb;
+	MTK_WCN_STP_RGE_TX_EVENT_CB stp_reg_tx_event_cb;
+	MTK_WCN_STP_COREDUMP_START_GET stp_coredump_start_get_cb;
+} MTK_WCN_STP_EXP_CB_INFO, *P_MTK_WCN_STP_EXP_CB_INFO;
+
+/*moved from wmt_exp.h*/
+
+typedef enum _ENUM_WMTDRV_TYPE_T {
+	WMTDRV_TYPE_BT = 0,
+	WMTDRV_TYPE_FM = 1,
+	WMTDRV_TYPE_GPS = 2,
+	WMTDRV_TYPE_WIFI = 3,
+	WMTDRV_TYPE_WMT = 4,
+	WMTDRV_TYPE_ANT = 5,
+	WMTDRV_TYPE_STP = 6,
+	WMTDRV_TYPE_SDIO1 = 7,
+	WMTDRV_TYPE_SDIO2 = 8,
+	WMTDRV_TYPE_LPBK = 9,
+	WMTDRV_TYPE_COREDUMP = 10,
+#if MTK_WCN_CMB_FOR_SDIO_1V_AUTOK
+	WMTDRV_TYPE_AUTOK = 11,
+#endif
+	WMTDRV_TYPE_MAX
+} ENUM_WMTDRV_TYPE_T, *P_ENUM_WMTDRV_TYPE_T;
+
+typedef enum _ENUM_WMTDSNS_TYPE_T {
+	WMTDSNS_FM_DISABLE = 0,
+	WMTDSNS_FM_ENABLE = 1,
+	WMTDSNS_FM_GPS_DISABLE = 2,
+	WMTDSNS_FM_GPS_ENABLE = 3,
+	WMTDSNS_MAX
+} ENUM_WMTDSNS_TYPE_T, *P_ENUM_WMTDSNS_TYPE_T;
+
+typedef enum _ENUM_WMTHWVER_TYPE_T {
+	WMTHWVER_E1 = 0x0,
+	WMTHWVER_E2 = 0x1,
+	WMTHWVER_E3 = 0x2,
+	WMTHWVER_E4 = 0x3,
+	WMTHWVER_E5 = 0x4,
+	WMTHWVER_E6 = 0x5,
+	WMTHWVER_E7 = 0x6,
+	WMTHWVER_MAX,
+	WMTHWVER_INVALID = 0xff
+} ENUM_WMTHWVER_TYPE_T, *P_ENUM_WMTHWVER_TYPE_T;
+
+typedef enum _ENUM_WMTTHERM_TYPE_T {
+	WMTTHERM_ZERO = 0,
+	WMTTHERM_ENABLE = WMTTHERM_ZERO + 1,
+	WMTTHERM_READ = WMTTHERM_ENABLE + 1,
+	WMTTHERM_DISABLE = WMTTHERM_READ + 1,
+	WMTTHERM_MAX
+} ENUM_WMTTHERM_TYPE_T, *P_ENUM_WMTTHERM_TYPE_T;
+
+typedef enum _ENUM_WMTMSG_TYPE_T {
+	WMTMSG_TYPE_POWER_ON = 0,
+	WMTMSG_TYPE_POWER_OFF = 1,
+	WMTMSG_TYPE_RESET = 2,
+	WMTMSG_TYPE_STP_RDY = 3,
+	WMTMSG_TYPE_HW_FUNC_ON = 4,
+	WMTMSG_TYPE_MAX
+} ENUM_WMTMSG_TYPE_T, *P_ENUM_WMTMSG_TYPE_T;
+
+typedef void (*PF_WMT_CB) (ENUM_WMTDRV_TYPE_T,	/* Source driver type */
+			   ENUM_WMTDRV_TYPE_T,	/* Destination driver type */
+			   ENUM_WMTMSG_TYPE_T,	/* Message type */
+			   VOID *,	/* READ-ONLY buffer. Buffer is allocated and freed by WMT_drv. Client
+					   can't touch this buffer after this function return. */
+			   UINT32	/* Buffer size in unit of byte */
+);
+
+typedef enum _SDIO_PS_OP {
+	OWN_SET = 0,
+	OWN_CLR = 1,
+	OWN_STATE = 2,
+} SDIO_PS_OP;
+
+typedef INT32(*PF_WMT_SDIO_PSOP) (SDIO_PS_OP);
+
+typedef enum _ENUM_WMTCHIN_TYPE_T {
+	WMTCHIN_CHIPID = 0x0,
+	WMTCHIN_HWVER = WMTCHIN_CHIPID + 1,
+	WMTCHIN_MAPPINGHWVER = WMTCHIN_HWVER + 1,
+	WMTCHIN_FWVER = WMTCHIN_MAPPINGHWVER + 1,
+	WMTCHIN_MAX,
+
+} ENUM_WMT_CHIPINFO_TYPE_T, *P_ENUM_WMT_CHIPINFO_TYPE_T;
+
+/*end moved from wmt_exp.h*/
+
+typedef MTK_WCN_BOOL(*MTK_WCN_WMT_FUNC_CTRL) (ENUM_WMTDRV_TYPE_T type);
+typedef INT8(*MTK_WCN_WMT_THERM_CTRL) (ENUM_WMTTHERM_TYPE_T eType);
+typedef ENUM_WMTHWVER_TYPE_T(*MTK_WCN_WMT_HWVER_GET) (VOID);
+typedef MTK_WCN_BOOL(*MTK_WCN_WMT_DSNS_CTRL) (ENUM_WMTDSNS_TYPE_T eType);
+typedef INT32(*MTK_WCN_WMT_MSGCB_REG) (ENUM_WMTDRV_TYPE_T eType, PF_WMT_CB pCb);
+typedef INT32(*MTK_WCN_WMT_MSGCB_UNREG) (ENUM_WMTDRV_TYPE_T eType);
+typedef INT32(*MTK_WCN_WMT_SDIO_OP_REG) (PF_WMT_SDIO_PSOP own_cb);
+typedef INT32(*MTK_WCN_WMT_SDIO_HOST_AWAKE) (VOID);
+typedef MTK_WCN_BOOL(*MTK_WCN_WMT_ASSERT) (ENUM_WMTDRV_TYPE_T type, UINT32 reason);
+typedef MTK_WCN_BOOL(*MTK_WCN_WMT_ASSERT_TIMEOUT)(ENUM_WMTDRV_TYPE_T type,
+		UINT32 reason, INT32 timeout);
+typedef UINT32(*MTK_WCN_WMT_IC_INFO_GET) (ENUM_WMT_CHIPINFO_TYPE_T type);
+typedef INT32 (*MTK_WCN_WMT_PSM_CTRL)(MTK_WCN_BOOL flag);
+
+typedef struct _MTK_WCN_WMT_EXP_CB_INFO_ {
+	MTK_WCN_WMT_FUNC_CTRL wmt_func_on_cb;
+	MTK_WCN_WMT_FUNC_CTRL wmt_func_off_cb;
+	MTK_WCN_WMT_THERM_CTRL wmt_therm_ctrl_cb;
+	MTK_WCN_WMT_HWVER_GET wmt_hwver_get_cb;
+	MTK_WCN_WMT_DSNS_CTRL wmt_dsns_ctrl_cb;
+	MTK_WCN_WMT_MSGCB_REG wmt_msgcb_reg_cb;
+	MTK_WCN_WMT_MSGCB_UNREG wmt_msgcb_unreg_cb;
+	MTK_WCN_WMT_SDIO_OP_REG wmt_sdio_op_reg_cb;
+	MTK_WCN_WMT_SDIO_HOST_AWAKE wmt_sdio_host_awake_cb;
+	MTK_WCN_WMT_ASSERT wmt_assert_cb;
+	MTK_WCN_WMT_ASSERT_TIMEOUT wmt_assert_timeout_cb;
+	MTK_WCN_WMT_IC_INFO_GET wmt_ic_info_get_cb;
+	MTK_WCN_WMT_PSM_CTRL wmt_psm_ctrl_cb;
+} MTK_WCN_WMT_EXP_CB_INFO, *P_MTK_WCN_WMT_EXP_CB_INFO;
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+/*exp for WMT/STP register callback*/
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_exp_cb_reg
+* DESCRIPTION
+*  stp driver reigster exp symbols
+* PARAMETERS
+*  pStpExpCb      [IN]        stp callback structure pointer
+* RETURNS
+*  UINT32    = 0: OK
+*****************************************************************************/
+UINT32 mtk_wcn_stp_exp_cb_reg(P_MTK_WCN_STP_EXP_CB_INFO pStpExpCb);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_exp_cb_unreg
+* DESCRIPTION
+*  stp driver unreigster exp symbols
+* PARAMETERS
+*  VOID
+* RETURNS
+*  UINT32    = 0: OK
+*****************************************************************************/
+UINT32 mtk_wcn_stp_exp_cb_unreg(VOID);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_wmt_exp_cb_reg
+* DESCRIPTION
+*  WMT driver reigster exp symbols
+* PARAMETERS
+*  pStpExpCb      [IN]       wmt callback structure pointer
+* RETURNS
+*  UINT32    = 0: OK
+*****************************************************************************/
+UINT32 mtk_wcn_wmt_exp_cb_reg(P_MTK_WCN_WMT_EXP_CB_INFO pWmtExpCb);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_exp_cb_unreg
+* DESCRIPTION
+*  wmt driver unreigster exp symbols
+* PARAMETERS
+*  VOID
+* RETURNS
+*  UINT32    = 0: OK
+*****************************************************************************/
+UINT32 mtk_wcn_wmt_exp_cb_unreg(VOID);
+
+/*stp exp symbols*/
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_send_data
+* DESCRIPTION
+*  subfunction send data through STP
+* PARAMETERS
+*  buffer      [IN]        data buffer
+*  length      [IN]        data buffer length
+*  type        [IN]        subfunction type
+* RETURNS
+*  INT32    >= 0: length transmitted; < 0: error
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_send_data(const PUINT8 buffer, const UINT32 length, const UINT8 type);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_send_data_raw
+* DESCRIPTION
+*  subfunction send data through STP without seq/ack
+* PARAMETERS
+*  buffer      [IN]        data buffer
+*  length      [IN]        data buffer length
+*  type        [IN]        subfunction type
+* RETURNS
+*  INT32    >= 0: length transmitted; < 0: error
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_send_data_raw(const PUINT8 buffer, const UINT32 length, const UINT8 type);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_parser_data
+* DESCRIPTION
+*  push data to serial transport protocol parser engine
+* PARAMETERS
+*  buffer      [IN]        data buffer
+*  length      [IN]        data buffer length
+* RETURNS
+*  void
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_parser_data(PUINT8 buffer, UINT32 length);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_receive_data
+* DESCRIPTION
+*  receive data from serial protocol engine
+* PARAMETERS
+*  buffer      [IN]        data buffer
+*  length      [IN]        data buffer length
+* RETURNS
+*  INT32    >= 0: size of data received; < 0: error
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_receive_data(PUINT8 buffer, UINT32 length, UINT8 type);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_is_rxqueue_empty
+* DESCRIPTION
+*  Is certain rx queue empty?
+* PARAMETERS
+*  type        [IN]        subfunction type
+* RETURNS
+*  INT32    0: queue is NOT empyt; !0: queue is empty
+*****************************************************************************/
+extern MTK_WCN_BOOL mtk_wcn_stp_is_rxqueue_empty(UINT8 type);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_is_enable
+* DESCRIPTION
+*  Is STP ready?
+* PARAMETERS
+*  none.
+* RETURNS
+*  MTK_WCN_BOOL    TRUE:ready, FALSE:not ready
+*****************************************************************************/
+extern MTK_WCN_BOOL mtk_wcn_stp_is_ready(void);
+
+/*****************************************************************************
+* FUNCTION
+*  set_bluetooth_rx_interface
+* DESCRIPTION
+*  Set bluetooth rx interface
+* PARAMETERS
+*  rx interface type
+* RETURNS
+*  void
+*****************************************************************************/
+extern void mtk_wcn_stp_set_bluez(MTK_WCN_BOOL flags);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_register_if_tx
+* DESCRIPTION
+*  regiter Tx event callback function
+* PARAMETERS
+*  stp_if: SDIO or UART, fnnc: Call back function
+* RETURNS
+*  INT32: 0:successful , -1: fail
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_register_if_tx(ENUM_STP_TX_IF_TYPE stp_if, MTK_WCN_STP_IF_TX func);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_register_if_rx
+* DESCRIPTION
+*  regiter Rx event callback function
+* PARAMETERS
+*  stp_if: SDIO or UART, fnnc: Call back function
+* RETURNS
+*  INT32: 0:successful , -1: fail
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_register_if_rx(MTK_WCN_STP_IF_RX func);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_register_event_cb
+* DESCRIPTION
+*  regiter Rx event callback function
+* PARAMETERS
+*  func
+* RETURNS
+*  INT32: 0:successful , -1: fail
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_register_event_cb(INT32 type, MTK_WCN_STP_EVENT_CB func);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_register_tx_event_cb
+* DESCRIPTION
+*  regiter Tx event callback function
+* PARAMETERS
+*  func
+* RETURNS
+*  INT32: 0:successful , -1: fail
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_register_tx_event_cb(INT32 type, MTK_WCN_STP_EVENT_CB func);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_coredump_start_get
+* DESCRIPTION
+*  get coredump flag is set or not
+* PARAMETERS
+*  VOID
+* RETURNS
+*  INT32: 0:coredump flag is not set , 1: coredump flag is set
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_coredump_start_get(VOID);
+
+/*wmt exp symbols*/
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_wmt_func_off
+* DESCRIPTION
+*  wmt turn off subsystem
+* PARAMETERS
+*  type [IN] subsystem type
+* RETURNS
+*  MTK_WCN_BOOL_TRUE: OK; MTK_WCN_BOOL_FALSE:error
+*****************************************************************************/
+extern MTK_WCN_BOOL mtk_wcn_wmt_func_off(ENUM_WMTDRV_TYPE_T type);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_wmt_func_on
+* DESCRIPTION
+*  wmt turn on subsystem
+* PARAMETERS
+*  type [IN] subsystem type
+* RETURNS
+*  MTK_WCN_BOOL_TRUE: OK; MTK_WCN_BOOL_FALSE:error
+*****************************************************************************/
+extern MTK_WCN_BOOL mtk_wcn_wmt_func_on(ENUM_WMTDRV_TYPE_T type);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_wmt_therm_ctrl
+* DESCRIPTION
+*  query chip temperature by WMT CMD
+* PARAMETERS
+*  eType [IN] thermal ctrl type
+* RETURNS
+*  >=0: chip temperature; 0xff:error
+*****************************************************************************/
+extern INT8 mtk_wcn_wmt_therm_ctrl(ENUM_WMTTHERM_TYPE_T eType);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_wmt_hwver_get
+* DESCRIPTION
+*  get chip hardware version
+* PARAMETERS
+*  VOID
+* RETURNS
+*  >=0: chip hw version; 0xff:error
+*****************************************************************************/
+extern ENUM_WMTHWVER_TYPE_T mtk_wcn_wmt_hwver_get(VOID);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_wmt_ic_info_get
+* DESCRIPTION
+*  get chip hardware version or f/w version
+* PARAMETERS
+*  type : which kind of information is needed
+* RETURNS
+*  f/w version or hw version information
+*****************************************************************************/
+extern UINT32 mtk_wcn_wmt_ic_info_get(ENUM_WMT_CHIPINFO_TYPE_T type);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_wmt_dsns_ctrl
+* DESCRIPTION
+*  fm dsns cmd ctrl
+* PARAMETERS
+*  eType [IN] fm dsns ctrl type
+* RETURNS
+*  MTK_WCN_BOOL_TRUE: OK; MTK_WCN_BOOL_FALSE:error
+*****************************************************************************/
+extern MTK_WCN_BOOL mtk_wcn_wmt_dsns_ctrl(ENUM_WMTDSNS_TYPE_T eType);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_wmt_msgcb_reg
+* DESCRIPTION
+*  used for subsystem register chip reset callback for received wmt reset msg.
+* PARAMETERS
+*  eType [IN] subsystem type
+*  pCb   [IN] rst callback
+* RETURNS
+*  1: OK; 0:error
+*****************************************************************************/
+extern INT32 mtk_wcn_wmt_msgcb_reg(ENUM_WMTDRV_TYPE_T eType, PF_WMT_CB pCb);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_wmt_msgcb_unreg
+* DESCRIPTION
+*  used for subsystem unregister chip reset callback for received wmt reset msg.
+* PARAMETERS
+*  eType [IN] subsystem type
+* RETURNS
+*  1: OK; 0:error
+*****************************************************************************/
+extern INT32 mtk_wcn_wmt_msgcb_unreg(ENUM_WMTDRV_TYPE_T eType);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_wmt_sdio_op_reg
+* DESCRIPTION
+*  used to register callback for set sdio ownership.
+* PARAMETERS
+*  own_cb [IN] set owner ship callback
+* RETURNS
+*  always return 0;
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_wmt_sdio_op_reg(PF_WMT_SDIO_PSOP own_cb);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_stp_wmt_sdio_host_awake
+* DESCRIPTION
+*  handing host awake when link is stp sdio?
+* PARAMETERS
+*  VOID
+* RETURNS
+*  always return 0;
+*****************************************************************************/
+extern INT32 mtk_wcn_stp_wmt_sdio_host_awake(VOID);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_wmt_assert
+* DESCRIPTION
+*  host trigger firmware assert
+* PARAMETERS
+*  type   [IN] subsystem driver type
+*  reason [IN] trigger assert reason
+* RETURNS
+*  MTK_WCN_BOOL_TRUE: OK; MTK_WCN_BOOL_FALSE:error
+*****************************************************************************/
+extern MTK_WCN_BOOL mtk_wcn_wmt_assert(ENUM_WMTDRV_TYPE_T type, UINT32 reason);
+
+/*****************************************************************************
+ * * FUNCTION
+ * *  mtk_wcn_wmt_assert_timeout
+ * * DESCRIPTION
+ * *  host trigger firmware assert
+ * * PARAMETERS
+ * *  type   [IN] subsystem driver type
+ * *  reason [IN] trigger assert reason
+ * *  timeout [IN] trigger assert timeout data
+ * * RETURNS
+ * *  MTK_WCN_BOOL_TRUE: OK; MTK_WCN_BOOL_FALSE:error
+ * *****************************************************************************/
+extern MTK_WCN_BOOL mtk_wcn_wmt_assert_timeout(ENUM_WMTDRV_TYPE_T type,
+		UINT32 reason, INT32 timeout);
+
+/*****************************************************************************
+* FUNCTION
+*  mtk_wcn_wmt_psm_ctrl
+* DESCRIPTION
+*  disable/enable psm
+* PARAMETERS
+*  flag [IN] disable:0, enable:1
+* RETURNS
+*  always return 0;
+*****************************************************************************/
+extern INT32 mtk_wcn_wmt_psm_ctrl(MTK_WCN_BOOL flag);
+
+#endif
+
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/Makefile b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/Makefile
new file mode 100644
index 00000000..dfb1e52
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/Makefile
@@ -0,0 +1,6 @@
+ifeq ($(CONFIG_MTK_COMBO), y)
+
+obj-y += pub/
+obj-y += pri/
+
+endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/include/bgw_desense.h b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/include/bgw_desense.h
new file mode 100644
index 00000000..95d1ab0
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/include/bgw_desense.h
@@ -0,0 +1,74 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __BGW_DESENSE_H_
+#define __BGW_DESENSE_H_
+
+#ifdef MSG
+#undef MSG
+#endif
+
+#ifdef ERR
+#undef ERR
+#endif
+
+#define PFX1                         "[BWG] "
+#define MSG(fmt, arg ...) pr_debug(PFX1 "[D]%s: "  fmt, __func__ , ##arg)
+#define ERR(fmt, arg ...) pr_debug(PFX1 "[D]%s: "  fmt, __func__ , ##arg)
+
+#ifdef NETLINK_TEST
+#undef NETLINK_TEST
+#endif
+
+#define NETLINK_TEST 17
+
+#ifdef MAX_NL_MSG_LEN
+#undef MAX_NL_MSG_LEN
+#endif
+
+#define MAX_NL_MSG_LEN 1024
+
+
+#ifdef ON
+#undef ON
+#endif
+#ifdef OFF
+#undef OFF
+#endif
+#ifdef ACK
+#undef ACK
+#endif
+
+#define ON 1
+#define OFF 0
+#define ACK 2
+
+/*
+used send command to native process
+
+parameter: command could be macro ON: enable co-exist; OFF: disable co-exist;
+ACK: after get native process init message send ACK
+
+*/
+extern void send_command_to_daemon(const int command);
+
+/*
+before use kernel socket, please call init socket first
+return value: 0: ok; -1: fail
+*/
+extern int bgw_init_socket(void);
+
+extern void bgw_destroy_netlink_kernel(void);
+
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/include/osal.h b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/include/osal.h
new file mode 100644
index 00000000..27ca759
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/include/osal.h
@@ -0,0 +1,345 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _OSAL_H_
+#define _OSAL_H_
+
+#include <osal_typedef.h>
+#include <linux/sched/debug.h>
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+#define OS_BIT_OPS_SUPPORT 1
+
+#define _osal_inline_ inline
+
+#define MAX_THREAD_NAME_LEN 16
+#define MAX_WAKE_LOCK_NAME_LEN 16
+#define OSAL_OP_BUF_SIZE    64
+
+#if (defined(CONFIG_MTK_GMO_RAM_OPTIMIZE) && !defined(CONFIG_MT_ENG_BUILD))
+#define OSAL_OP_DATA_SIZE   8
+#else
+#define OSAL_OP_DATA_SIZE   32
+#endif
+
+#define DBG_LOG_STR_SIZE    256
+
+#define osal_sizeof(x) sizeof(x)
+
+#define osal_array_size(x) (sizeof(x)/sizeof(x[0]))
+
+#ifndef NAME_MAX
+#define NAME_MAX 256
+#endif
+
+#define WMT_OP_BIT(x) (0x1UL << x)
+#define WMT_OP_HIF_BIT WMT_OP_BIT(0)
+
+#define RB_SIZE(prb) ((prb)->size)
+#define RB_MASK(prb) (RB_SIZE(prb) - 1)
+#define RB_COUNT(prb) ((prb)->write - (prb)->read)
+#define RB_FULL(prb) (RB_COUNT(prb) >= RB_SIZE(prb))
+#define RB_EMPTY(prb) ((prb)->write == (prb)->read)
+
+#define RB_INIT(prb, qsize) \
+do { \
+	(prb)->read = (prb)->write = 0; \
+	(prb)->size = (qsize); \
+} while (0)
+
+#define RB_PUT(prb, value) \
+do { \
+	if (!RB_FULL(prb)) { \
+		(prb)->queue[(prb)->write & RB_MASK(prb)] = value; \
+		++((prb)->write); \
+	} \
+	else { \
+		osal_assert(!RB_FULL(prb)); \
+	} \
+} while (0)
+
+#define RB_GET(prb, value) \
+do { \
+	if (!RB_EMPTY(prb)) { \
+		value = (prb)->queue[(prb)->read & RB_MASK(prb)]; \
+		++((prb)->read); \
+		if (RB_EMPTY(prb)) { \
+			(prb)->read = (prb)->write = 0; \
+		} \
+	} \
+	else { \
+		value = NULL; \
+		osal_assert(!RB_EMPTY(prb)); \
+	} \
+} while (0)
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+//typedef VOID(*P_TIMEOUT_HANDLER) (unsigned long);
+typedef VOID(*P_TIMEOUT_HANDLER) (struct timer_list *t);
+typedef INT32(*P_COND) (VOID *);
+
+typedef struct _OSAL_TIMER_ {
+	struct timer_list timer;
+	P_TIMEOUT_HANDLER timeoutHandler;
+	unsigned long timeroutHandlerData;
+} OSAL_TIMER, *P_OSAL_TIMER;
+
+typedef struct _OSAL_UNSLEEPABLE_LOCK_ {
+	spinlock_t lock;
+	unsigned long flag;
+} OSAL_UNSLEEPABLE_LOCK, *P_OSAL_UNSLEEPABLE_LOCK;
+
+typedef struct _OSAL_SLEEPABLE_LOCK_ {
+	struct mutex lock;
+} OSAL_SLEEPABLE_LOCK, *P_OSAL_SLEEPABLE_LOCK;
+
+typedef struct _OSAL_SIGNAL_ {
+	struct completion comp;
+	UINT32 timeoutValue;
+} OSAL_SIGNAL, *P_OSAL_SIGNAL;
+
+typedef struct _OSAL_EVENT_ {
+	wait_queue_head_t waitQueue;
+/* VOID *pWaitQueueData; */
+	UINT32 timeoutValue;
+	INT32 waitFlag;
+
+} OSAL_EVENT, *P_OSAL_EVENT;
+
+typedef struct _OSAL_THREAD_ {
+	struct task_struct *pThread;
+	VOID *pThreadFunc;
+	VOID *pThreadData;
+	char threadName[MAX_THREAD_NAME_LEN];
+} OSAL_THREAD, *P_OSAL_THREAD;
+
+typedef struct _OSAL_FIFO_ {
+	/*fifo definition */
+	VOID *pFifoBody;
+	spinlock_t fifoSpinlock;
+	/*fifo operations */
+	 INT32 (*FifoInit)(struct _OSAL_FIFO_ *pFifo, UINT8 *buf, UINT32);
+	 INT32 (*FifoDeInit)(struct _OSAL_FIFO_ *pFifo);
+	 INT32 (*FifoReset)(struct _OSAL_FIFO_ *pFifo);
+	 INT32 (*FifoSz)(struct _OSAL_FIFO_ *pFifo);
+	 INT32 (*FifoAvailSz)(struct _OSAL_FIFO_ *pFifo);
+	 INT32 (*FifoLen)(struct _OSAL_FIFO_ *pFifo);
+	 INT32 (*FifoIsEmpty)(struct _OSAL_FIFO_ *pFifo);
+	 INT32 (*FifoIsFull)(struct _OSAL_FIFO_ *pFifo);
+	 INT32 (*FifoDataIn)(struct _OSAL_FIFO_ *pFifo, const VOID *buf, UINT32 len);
+	 INT32 (*FifoDataOut)(struct _OSAL_FIFO_ *pFifo, void *buf, UINT32 len);
+} OSAL_FIFO, *P_OSAL_FIFO;
+
+typedef struct firmware osal_firmware;
+
+typedef struct _OSAL_OP_DAT {
+	UINT32 opId;		/* Event ID */
+	UINT32 u4InfoBit;	/* Reserved */
+	SIZE_T au4OpData[OSAL_OP_DATA_SIZE];	/* OP Data */
+} OSAL_OP_DAT, *P_OSAL_OP_DAT;
+
+typedef struct _OSAL_LXOP_ {
+	OSAL_OP_DAT op;
+	OSAL_SIGNAL signal;
+	INT32 result;
+} OSAL_OP, *P_OSAL_OP;
+
+typedef struct _OSAL_LXOP_Q {
+	OSAL_SLEEPABLE_LOCK sLock;
+	UINT32 write;
+	UINT32 read;
+	UINT32 size;
+	P_OSAL_OP queue[OSAL_OP_BUF_SIZE];
+} OSAL_OP_Q, *P_OSAL_OP_Q;
+
+typedef struct _OSAL_WAKE_LOCK_ {
+	struct wakeup_source *wake_lock;
+	UINT8 name[MAX_WAKE_LOCK_NAME_LEN];
+} OSAL_WAKE_LOCK, *P_OSAL_WAKE_LOCK;
+#if 1
+typedef struct _OSAL_BIT_OP_VAR_ {
+	unsigned long data;
+	OSAL_UNSLEEPABLE_LOCK opLock;
+} OSAL_BIT_OP_VAR, *P_OSAL_BIT_OP_VAR;
+#else
+#define OSAL_BIT_OP_VAR unsigned long
+#define P_OSAL_BIT_OP_VAR unsigned long *
+
+#endif
+typedef UINT32(*P_OSAL_EVENT_CHECKER) (P_OSAL_THREAD pThread);
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+extern UINT32 osal_strlen(const char *str);
+extern INT32 osal_strcmp(const char *dst, const char *src);
+extern INT32 osal_strncmp(const char *dst, const char *src, UINT32 len);
+extern char *osal_strcpy(char *dst, const char *src);
+extern char *osal_strncpy(char *dst, const char *src, UINT32 len);
+extern char *osal_strcat(char *dst, const char *src);
+extern char *osal_strncat(char *dst, const char *src, UINT32 len);
+extern char *osal_strchr(const char *str, UINT8 c);
+extern char *osal_strsep(char **str, const char *c);
+extern int osal_strtol(const char *str, UINT32 adecimal, long *res);
+extern INT32 osal_snprintf(char *buf, UINT32 len, const char *fmt, ...);
+extern char *osal_strstr(char *str1, const char *str2);
+
+extern INT32 osal_err_print(const char *str, ...);
+extern INT32 osal_dbg_print(const char *str, ...);
+extern INT32 osal_warn_print(const char *str, ...);
+
+extern INT32 osal_dbg_assert(INT32 expr, const char *file, INT32 line);
+extern INT32 osal_sprintf(char *str, const char *format, ...);
+extern VOID *osal_malloc(UINT32 size);
+extern VOID osal_free(const VOID *dst);
+extern VOID *osal_memset(VOID *buf, INT32 i, UINT32 len);
+extern VOID *osal_memcpy(VOID *dst, const VOID *src, UINT32 len);
+extern INT32 osal_memcmp(const VOID *buf1, const VOID *buf2, UINT32 len);
+
+extern INT32 osal_sleep_ms(UINT32 ms);
+extern INT32 osal_udelay(UINT32 us);
+extern INT32 osal_timer_create(P_OSAL_TIMER);
+extern INT32 osal_timer_start(P_OSAL_TIMER, UINT32);
+extern INT32 osal_timer_stop(P_OSAL_TIMER);
+extern INT32 osal_timer_stop_sync(P_OSAL_TIMER pTimer);
+extern INT32 osal_timer_modify(P_OSAL_TIMER, UINT32);
+extern INT32 osal_timer_delete(P_OSAL_TIMER);
+
+extern INT32 osal_fifo_init(P_OSAL_FIFO pFifo, UINT8 *buffer, UINT32 size);
+extern VOID osal_fifo_deinit(P_OSAL_FIFO pFifo);
+extern INT32 osal_fifo_reset(P_OSAL_FIFO pFifo);
+extern UINT32 osal_fifo_in(P_OSAL_FIFO pFifo, PUINT8 buffer, UINT32 size);
+extern UINT32 osal_fifo_out(P_OSAL_FIFO pFifo, PUINT8 buffer, UINT32 size);
+extern UINT32 osal_fifo_len(P_OSAL_FIFO pFifo);
+extern UINT32 osal_fifo_sz(P_OSAL_FIFO pFifo);
+extern UINT32 osal_fifo_avail(P_OSAL_FIFO pFifo);
+extern UINT32 osal_fifo_is_empty(P_OSAL_FIFO pFifo);
+extern UINT32 osal_fifo_is_full(P_OSAL_FIFO pFifo);
+
+extern INT32 osal_wake_lock_init(P_OSAL_WAKE_LOCK plock);
+extern INT32 osal_wake_lock(P_OSAL_WAKE_LOCK plock);
+extern INT32 osal_wake_unlock(P_OSAL_WAKE_LOCK plock);
+extern INT32 osal_wake_lock_count(P_OSAL_WAKE_LOCK plock);
+extern INT32 osal_wake_lock_deinit(P_OSAL_WAKE_LOCK plock);
+
+#if defined(CONFIG_PROVE_LOCKING)
+#define osal_unsleepable_lock_init(l) { spin_lock_init(&((l)->lock)); }
+#else
+extern INT32 osal_unsleepable_lock_init(P_OSAL_UNSLEEPABLE_LOCK);
+#endif
+extern INT32 osal_lock_unsleepable_lock(P_OSAL_UNSLEEPABLE_LOCK);
+extern INT32 osal_unlock_unsleepable_lock(P_OSAL_UNSLEEPABLE_LOCK);
+extern INT32 osal_unsleepable_lock_deinit(P_OSAL_UNSLEEPABLE_LOCK);
+
+#if defined(CONFIG_PROVE_LOCKING)
+#define osal_sleepable_lock_init(l) { mutex_init(&((l)->lock)); }
+#else
+extern INT32 osal_sleepable_lock_init(P_OSAL_SLEEPABLE_LOCK);
+#endif
+extern INT32 osal_lock_sleepable_lock(P_OSAL_SLEEPABLE_LOCK);
+extern INT32 osal_unlock_sleepable_lock(P_OSAL_SLEEPABLE_LOCK);
+extern INT32 osal_sleepable_lock_deinit(P_OSAL_SLEEPABLE_LOCK);
+
+extern INT32 osal_signal_init(P_OSAL_SIGNAL);
+extern INT32 osal_wait_for_signal(P_OSAL_SIGNAL);
+extern INT32 osal_wait_for_signal_timeout(P_OSAL_SIGNAL);
+extern INT32 osal_raise_signal(P_OSAL_SIGNAL);
+extern INT32 osal_signal_deinit(P_OSAL_SIGNAL);
+
+extern INT32 osal_event_init(P_OSAL_EVENT);
+extern INT32 osal_wait_for_event(P_OSAL_EVENT, P_COND, void *);
+extern INT32 osal_wait_for_event_timeout(P_OSAL_EVENT, P_COND, void *);
+extern INT32 osal_trigger_event(P_OSAL_EVENT);
+
+extern INT32 osal_event_deinit(P_OSAL_EVENT);
+
+extern INT32 osal_thread_create(P_OSAL_THREAD);
+extern INT32 osal_thread_run(P_OSAL_THREAD);
+extern INT32 osal_thread_should_stop(P_OSAL_THREAD);
+extern INT32 osal_thread_stop(P_OSAL_THREAD);
+/*extern INT32 osal_thread_wait_for_event(P_OSAL_THREAD, P_OSAL_EVENT);*/
+extern INT32 osal_thread_wait_for_event(P_OSAL_THREAD, P_OSAL_EVENT, P_OSAL_EVENT_CHECKER);
+/*check pOsalLxOp and OSAL_THREAD_SHOULD_STOP*/
+extern INT32 osal_thread_destroy(P_OSAL_THREAD);
+
+extern INT32 osal_clear_bit(UINT32 bitOffset, P_OSAL_BIT_OP_VAR pData);
+extern INT32 osal_set_bit(UINT32 bitOffset, P_OSAL_BIT_OP_VAR pData);
+extern INT32 osal_test_bit(UINT32 bitOffset, P_OSAL_BIT_OP_VAR pData);
+extern INT32 osal_test_and_clear_bit(UINT32 bitOffset, P_OSAL_BIT_OP_VAR pData);
+extern INT32 osal_test_and_set_bit(UINT32 bitOffset, P_OSAL_BIT_OP_VAR pData);
+
+extern INT32 osal_dbg_assert_aee(const char *module, const char *detail_description);
+extern INT32 osal_gettimeofday(PINT32 sec, PINT32 usec);
+extern INT32 osal_printtimeofday(const PUINT8 prefix);
+
+extern VOID osal_buffer_dump(const UINT8 *buf, const UINT8 *title, UINT32 len, UINT32 limit);
+
+extern UINT32 osal_op_get_id(P_OSAL_OP pOp);
+extern MTK_WCN_BOOL osal_op_is_wait_for_signal(P_OSAL_OP pOp);
+extern VOID osal_op_raise_signal(P_OSAL_OP pOp, INT32 result);
+extern VOID osal_set_op_result(P_OSAL_OP pOp, INT32 result);
+extern UINT16 osal_crc16(const UINT8 *buffer, const UINT32 length);
+extern VOID osal_thread_show_stack(P_OSAL_THREAD pThread);
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+#define osal_assert(condition) \
+do { \
+	if (!(condition)) \
+		osal_err_print("%s, %d, (%s)\n", __FILE__, __LINE__, #condition); \
+} while (0)
+
+#endif /* _OSAL_H_ */
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/include/osal_typedef.h b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/include/osal_typedef.h
new file mode 100644
index 00000000..7b13e6b
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/include/osal_typedef.h
@@ -0,0 +1,86 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _OSAL_TYPEDEF_H_
+#define _OSAL_TYPEDEF_H_
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <asm/current.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <linux/proc_fs.h>
+#include <linux/workqueue.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/vmalloc.h>
+#include <linux/firmware.h>
+#include <linux/kthread.h>
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#ifdef CONFIG_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#else
+#include <linux/fb.h>
+#endif
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#ifdef WMT_PLAT_ALPS
+#include <aee.h>
+#endif
+#include <linux/kfifo.h>
+#include <linux/pm_wakeup.h>
+#include <linux/log2.h>
+
+#ifndef _TYPEDEFS_H		/*fix redifine */
+typedef char INT8;
+#endif
+
+typedef void VOID, *PVOID, **PPVOID;
+typedef char *PINT8, **PPINT8;
+typedef short INT16, *PINT16, **PPINT16;
+typedef int INT32, *PINT32, **PPINT32;
+typedef long long INT64, *PINT64, **PPINT64;
+
+typedef unsigned char UINT8, *PUINT8, **PPUINT8;
+typedef unsigned short UINT16, *PUINT16, **PPUINT16;
+typedef unsigned int UINT32, *PUINT32, **PPUINT32;
+typedef unsigned long long UINT64, *PUINT64, **PPUINT64;
+
+typedef size_t SIZE_T;
+
+typedef int MTK_WCN_BOOL;
+#ifndef MTK_WCN_BOOL_TRUE
+#define MTK_WCN_BOOL_FALSE               ((MTK_WCN_BOOL) 0)
+#define MTK_WCN_BOOL_TRUE                ((MTK_WCN_BOOL) 1)
+#endif
+
+#endif /*_OSAL_TYPEDEF_H_*/
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/include/wmt_idc.h b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/include/wmt_idc.h
new file mode 100644
index 00000000..17be778
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/include/wmt_idc.h
@@ -0,0 +1,97 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _WMT_IDC_H_
+#define _WMT_IDC_H_
+
+#include "osal_typedef.h"
+#include "osal.h"
+#include "wmt_stp_exp.h"
+
+#if CFG_WMT_LTE_COEX_HANDLING
+
+#include "wmt_stp_exp.h"
+#include "conn_md_exp.h"
+
+#define LTE_IDC_BUFFER_MAX_SIZE 1024
+/*comment from firmware owner,max pckage num is 5,but should not happened*/
+#define WMT_IDC_RX_MAX_LEN 384
+#define LTE_MSG_ID_OFFSET 0x30
+
+typedef enum {
+	WMT_IDC_TX_OPCODE_MIN = 0,
+	WMT_IDC_TX_OPCODE_LTE_PARA = 0x0a,
+	WMT_IDC_TX_OPCODE_LTE_FREQ = 0x0b,
+	WMT_IDC_TX_OPCODE_WIFI_MAX_POWER = 0x0c,
+	WMT_IDC_TX_OPCODE_DEBUG_MONITOR = 0x0e,
+	WMT_IDC_TX_OPCODE_SPLIT_FILTER = 0x0f,
+	WMT_IDC_TX_OPCODE_LTE_CONNECTION_STAS = 0x16,
+	WMT_IDC_TX_OPCODE_LTE_HW_IF_INDICATION = 0x17,
+	WMT_IDC_TX_OPCODE_LTE_INDICATION = 0x20,
+	WMT_IDC_TX_OPCODE_MAX
+} WMT_IDC_TX_OPCODE;
+
+typedef enum {
+	WMT_IDC_RX_OPCODE_BTWF_DEF_PARA = 0x0,
+	WMT_IDC_RX_OPCODE_BTWF_CHAN_RAN = 0x1,
+	/* WMT_IDC_RX_OPCODE_TDM_REQ = 0x10, */
+	WMT_IDC_RX_OPCODE_DEBUG_MONITOR = 0x02,
+	WMT_IDC_RX_OPCODE_LTE_FREQ_IDX_TABLE = 0x03,
+	WMT_IDC_RX_OPCODE_BTWF_PROFILE_IND = 0x04,
+	WMT_IDC_RX_OPCODE_UART_PIN_SEL = 0x05,
+	WMT_IDC_RX_OPCODE_MAX
+} WMT_IDC_RX_OPCODE;
+
+#if (CFG_WMT_LTE_ENABLE_MSGID_MAPPING == 0)
+typedef enum {
+	IPC_L4C_MSG_ID_INVALID = IPC_L4C_MSG_ID_BEGIN,
+	IPC_L4C_MSG_ID_END,
+	IPC_EL1_MSG_ID_INVALID = IPC_EL1_MSG_ID_BEGIN,
+	/* below are EL1 IPC messages sent from AP */
+	IPC_MSG_ID_EL1_LTE_TX_ALLOW_IND,
+	IPC_MSG_ID_EL1_WIFIBT_OPER_DEFAULT_PARAM_IND,
+	IPC_MSG_ID_EL1_WIFIBT_OPER_FREQ_IND,
+	IPC_MSG_ID_EL1_WIFIBT_FREQ_IDX_TABLE_IND,
+	IPC_MSG_ID_EL1_WIFIBT_PROFILE_IND,
+
+	/* below are EL1 messages sent to AP */
+	IPC_MSG_ID_EL1_LTE_DEFAULT_PARAM_IND,
+	IPC_MSG_ID_EL1_LTE_OPER_FREQ_PARAM_IND,
+	IPC_MSG_ID_EL1_WIFI_MAX_PWR_IND,
+	IPC_MSG_ID_EL1_LTE_TX_IND,
+	IPC_MSG_ID_EL1_LTE_CONNECTION_STATUS_IND,
+	IPC_MSG_ID_EL1_PIN_TYPE_IND,
+	IPC_MSG_ID_EL1_LTE_HW_INTERFACE_IND,
+	IPC_MSG_ID_EL1_DUMMY13_IND,
+	IPC_MSG_ID_EL1_DUMMY14_IND,
+	IPC_MSG_ID_EL1_DUMMY15_IND,
+	IPC_EL1_MSG_ID_END,
+} IPC_MSG_ID_CODE;
+#endif
+
+typedef struct _MTK_WCN_WMT_IDC_INFO_ {
+	ipc_ilm_t iit;
+	CONN_MD_BRIDGE_OPS ops;
+	UINT8 buffer[LTE_IDC_BUFFER_MAX_SIZE];
+} MTK_WCN_WMT_IDC_INFO, *P_MTK_WCN_WMT_IDC_INFO;
+
+extern INT32 wmt_idc_init(VOID);
+extern INT32 wmt_idc_deinit(VOID);
+extern INT32 wmt_idc_msg_from_lte_handing(ipc_ilm_t *ilm);
+extern INT32 wmt_idc_msg_to_lte_handing(VOID);
+extern UINT32 wmt_idc_msg_to_lte_handing_for_test(UINT8 *p_buf, UINT32 len);
+
+#endif /* endif CFG_WMT_LTE_COEX_HANDLING */
+
+#endif /* _WMT_IDC_H_ */
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/Makefile b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/Makefile
new file mode 100644
index 00000000..12af2eb
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/Makefile
@@ -0,0 +1,21 @@
+ifeq ($(CONFIG_MTK_COMBO), y)
+
+ccflags-y += \
+	-I$(srctree)/$(src)/../../linux/include \
+	-I$(srctree)/$(src)/../../linux/pri/include \
+	-I$(srctree)/$(src)/../../core/include \
+	-I$(srctree)/$(src)/../../include \
+	-I$(srctree)/$(src)/../include \
+	-I$(srctree)/$(src)/../../../common_detect \
+	-I$(srctree)/drivers/misc/mediatek/btif/common/inc \
+	-I$(srctree)/drivers/misc/mediatek/mach/$(MTK_PLATFORM)/include/mach
+
+ccflags-y += -DWMT_CREATE_NODE_DYNAMIC=1
+
+obj-y += stp_btif.o \
+         stp_dbg.o \
+         stp_exp.o \
+         wmt_dev.o \
+         wmt_exp.o
+
+endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/include/stp_btif.h b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/include/stp_btif.h
new file mode 100644
index 00000000..3730fbb
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/include/stp_btif.h
@@ -0,0 +1,31 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _STP_BTIF_H_
+#define _STP_BTIF_H_
+
+#include "osal_typedef.h"
+#include "mtk_btif_exp.h"
+
+extern INT32 mtk_wcn_consys_stp_btif_open(VOID);
+extern INT32 mtk_wcn_consys_stp_btif_close(VOID);
+extern INT32 mtk_wcn_consys_stp_btif_rx_cb_register(MTK_WCN_BTIF_RX_CB rx_cb);
+extern INT32 mtk_wcn_consys_stp_btif_tx(const UINT8 *pBuf, const UINT32 len, UINT32 *written_len);
+extern INT32 mtk_wcn_consys_stp_btif_wakeup(VOID);
+extern INT32 mtk_wcn_consys_stp_btif_dpidle_ctrl(ENUM_BTIF_DPIDLE_CTRL en_flag);
+extern INT32 mtk_wcn_consys_stp_btif_lpbk_ctrl(ENUM_BTIF_LPBK_MODE mode);
+extern INT32 mtk_wcn_consys_stp_btif_logger_ctrl(ENUM_BTIF_DBG_ID flag);
+extern MTK_WCN_BOOL mtk_wcn_consys_stp_btif_parser_wmt_evt(const UINT8 *str, UINT32 len);
+
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/include/stp_dbg.h b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/include/stp_dbg.h
new file mode 100644
index 00000000..de5684a1
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/include/stp_dbg.h
@@ -0,0 +1,316 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _STP_DEBUG_H_
+#define _STP_DEBUG_H_
+
+#include <linux/time.h>
+#include "osal.h"
+
+#define CONFIG_LOG_STP_INTERNAL
+
+#if 1				/* #ifndef CONFIG_LOG_STP_INTERNAL */
+#define STP_PKT_SZ  16
+#define STP_DMP_SZ 2048
+#define STP_PKT_NO 2048
+
+#define STP_DBG_LOG_ENTRY_NUM 60
+#define STP_DBG_LOG_ENTRY_SZ  64
+
+#else
+
+#define STP_PKT_SZ  16
+#define STP_DMP_SZ 16
+#define STP_PKT_NO 16
+
+#define STP_DBG_LOG_ENTRY_NUM 28
+#define STP_DBG_LOG_ENTRY_SZ 64
+
+#endif
+
+typedef enum {
+	STP_DBG_EN = 0,
+	STP_DBG_PKT = 1,
+	STP_DBG_DR = 2,
+	STP_DBG_FW_ASSERT = 3,
+	STP_DBG_FW_LOG = 4,
+	STP_DBG_FW_DMP = 5,
+	STP_DBG_MAX
+} STP_DBG_OP_T;
+
+typedef enum {
+	STP_DBG_PKT_FIL_ALL = 0,
+	STP_DBG_PKT_FIL_BT = 1,
+	STP_DBG_PKT_FIL_GPS = 2,
+	STP_DBG_PKT_FIL_FM = 3,
+	STP_DBG_PKT_FIL_WMT = 4,
+	STP_DBG_PKT_FIL_MAX
+} STP_DBG_PKT_FIL_T;
+
+static char *const gStpDbgType[] = {
+	"< BT>",
+	"< FM>",
+	"<GPS>",
+	"<WiFi>",
+	"<WMT>",
+	"<STP>",
+	"<DBG>",
+	"<WAKEINT>",
+	"<UNKNOWN>"
+};
+
+typedef enum {
+	STP_DBG_DR_MAX = 0,
+} STP_DBG_DR_FIL_T;
+
+typedef enum {
+	STP_DBG_FW_MAX = 0,
+} STP_DBG_FW_FIL_T;
+
+typedef enum {
+	PKT_DIR_RX = 0,
+	PKT_DIR_TX
+} STP_DBG_PKT_DIR_T;
+
+/*simple log system ++*/
+
+typedef struct {
+	/*type: 0. pkt trace 1. fw info
+	* 2. assert info 3. trace32 dump .
+	* -1. linked to the the previous
+	*/
+	int id;
+	int len;
+	char buffer[STP_DBG_LOG_ENTRY_SZ];
+} MTKSTP_LOG_ENTRY_T;
+
+typedef struct log_sys {
+	MTKSTP_LOG_ENTRY_T queue[STP_DBG_LOG_ENTRY_NUM];
+	unsigned int size;
+	unsigned int in;
+	unsigned int out;
+	spinlock_t lock;
+} MTKSTP_LOG_SYS_T;
+/*--*/
+
+typedef struct stp_dbg_pkt_hdr {
+	/* packet information */
+	unsigned int sec;
+	unsigned int usec;
+	unsigned int dbg_type;
+	unsigned int dmy;
+	unsigned int no;
+	unsigned int dir;
+
+	/* packet content */
+	unsigned int type;
+	unsigned int len;
+	unsigned int ack;
+	unsigned int seq;
+	unsigned int chs;
+	unsigned int crc;
+} STP_DBG_HDR_T;
+
+typedef struct stp_dbg_pkt {
+	struct stp_dbg_pkt_hdr hdr;
+	unsigned char raw[STP_DMP_SZ];
+} STP_PACKET_T;
+
+typedef struct mtkstp_dbg_t {
+	/*log_sys */
+	int pkt_trace_no;
+	void *btm;
+	int is_enable;
+	MTKSTP_LOG_SYS_T *logsys;
+} MTKSTP_DBG_T;
+
+/* extern void aed_combo_exception(const int *, int, const int *, int, const char *); */
+
+#define STP_CORE_DUMP_TIMEOUT (5*60*1000)	/* default 5minutes */
+#define STP_OJB_NAME_SZ 20
+#define STP_CORE_DUMP_INFO_SZ 500
+#define STP_CORE_DUMP_INIT_SIZE 1
+typedef enum wcn_compress_algorithm_t {
+	GZIP = 0,
+	BZIP2 = 1,
+	RAR = 2,
+	LMA = 3,
+	MAX
+} WCN_COMPRESS_ALG_T;
+
+typedef INT32 (*COMPRESS_HANDLER) (void *worker, UINT8 *in_buf, INT32 in_sz, UINT8 *out_buf, INT32 *out_sz,
+				  INT32 finish);
+typedef struct wcn_compressor_t {
+	/* current object name */
+	UINT8 name[STP_OJB_NAME_SZ + 1];
+
+	/* buffer for raw data, named L1 */
+	PUINT8 L1_buf;
+	INT32 L1_buf_sz;
+	INT32 L1_pos;
+
+	/* target buffer, named L2 */
+	PUINT8 L2_buf;
+	INT32 L2_buf_sz;
+	INT32 L2_pos;
+
+	/* compress state */
+	UINT8 f_done;
+	UINT16 reserved;
+	UINT32 uncomp_size;
+	UINT32 crc32;
+
+	/* compress algorithm */
+	UINT8 f_compress_en;
+	WCN_COMPRESS_ALG_T compress_type;
+	void *worker;
+	COMPRESS_HANDLER handler;
+} WCN_COMPRESSOR_T, *P_WCN_COMPRESSOR_T;
+
+P_WCN_COMPRESSOR_T wcn_compressor_init(PUINT8 name, INT32 L1_buf_sz, INT32 L2_buf_sz);
+INT32 wcn_compressor_deinit(P_WCN_COMPRESSOR_T compressor);
+INT32 wcn_compressor_in(P_WCN_COMPRESSOR_T compressor, PUINT8 buf, INT32 len, INT32 finish);
+INT32 wcn_compressor_out(P_WCN_COMPRESSOR_T compressor, PUINT8 *pbuf, PINT32 len);
+INT32 wcn_compressor_reset(P_WCN_COMPRESSOR_T compressor, UINT8 enable, WCN_COMPRESS_ALG_T type);
+
+typedef enum core_dump_state_t {
+	CORE_DUMP_INIT = 0,
+	CORE_DUMP_DOING,
+	CORE_DUMP_TIMEOUT,
+	CORE_DUMP_DONE,
+	CORE_DUMP_MAX
+} CORE_DUMP_STA;
+
+typedef struct core_dump_t {
+	/* compress dump data and buffered */
+	P_WCN_COMPRESSOR_T compressor;
+
+	/* timer for monitor timeout */
+	OSAL_TIMER dmp_timer;
+	UINT32 timeout;
+
+	OSAL_SLEEPABLE_LOCK dmp_lock;
+
+	/* state machine for core dump flow */
+	CORE_DUMP_STA sm;
+
+	/* dump info */
+	INT8 info[STP_CORE_DUMP_INFO_SZ + 1];
+} WCN_CORE_DUMP_T, *P_WCN_CORE_DUMP_T;
+
+typedef enum _ENUM_STP_FW_ISSUE_TYPE_ {
+	STP_FW_ISSUE_TYPE_INVALID = 0x0,
+	STP_FW_ASSERT_ISSUE = 0x1,
+	STP_FW_NOACK_ISSUE = 0x2,
+	STP_FW_WARM_RST_ISSUE = 0x3,
+	STP_DBG_PROC_TEST = 0x4,
+	STP_HOST_TRIGGER_FW_ASSERT = 0x5,
+	STP_HOST_TRIGGER_ASSERT_TIMEOUT = 0x6,
+	STP_FW_ISSUE_TYPE_MAX
+} ENUM_STP_FW_ISSUE_TYPE, *P_ENUM_STP_FW_ISSUE_TYPE;
+
+/* this was added for support dmareg's issue */
+typedef enum _ENUM_DMA_ISSUE_TYPE_ {
+	CONNSYS_CLK_GATE_STATUS = 0x00,
+	CONSYS_EMI_STATUS,
+	SYSRAM1,
+	SYSRAM2,
+	SYSRAM3,
+	DMA_REGS_MAX
+} ENUM_DMA_ISSUE_TYPE;
+#define STP_PATCH_TIME_SIZE 12
+#define STP_DBG_CPUPCR_NUM 512
+#define STP_DBG_DMAREGS_NUM 16
+#define STP_PATCH_BRANCH_SZIE 8
+#define STP_ASSERT_INFO_SIZE 64
+#define STP_DBG_ROM_VER_SIZE 4
+#define STP_ASSERT_TYPE_SIZE 32
+
+typedef struct stp_dbg_host_assert_t {
+	UINT32 drv_type;
+	UINT32 reason;
+	UINT32 assert_from_host;
+} STP_DBG_HOST_ASSERT_T, *P_STP_DBG_HOST_ASSERT_T;
+
+typedef struct stp_dbg_cpupcr_t {
+	UINT32 chipId;
+	UINT8 romVer[STP_DBG_ROM_VER_SIZE];
+	UINT8 patchVer[STP_PATCH_TIME_SIZE];
+	UINT8 branchVer[STP_PATCH_BRANCH_SZIE];
+	UINT32 wifiVer;
+	UINT32 count;
+	UINT32 stop_flag;
+	UINT32 buffer[STP_DBG_CPUPCR_NUM];
+	UINT8 assert_info[STP_ASSERT_INFO_SIZE];
+	UINT32 fwTaskId;
+	UINT32 fwRrq;
+	UINT32 fwIsr;
+	STP_DBG_HOST_ASSERT_T host_assert_info;
+	UINT8 assert_type[STP_ASSERT_TYPE_SIZE];
+	ENUM_STP_FW_ISSUE_TYPE issue_type;
+	OSAL_SLEEPABLE_LOCK lock;
+} STP_DBG_CPUPCR_T, *P_STP_DBG_CPUPCR_T;
+
+typedef struct stp_dbg_dmaregs_t {
+	UINT32 count;
+	UINT32 dmaIssue[DMA_REGS_MAX][STP_DBG_DMAREGS_NUM];
+	OSAL_SLEEPABLE_LOCK lock;
+} STP_DBG_DMAREGS_T, *P_STP_DBG_DMAREGS_T;
+
+typedef enum _ENUM_ASSERT_INFO_PARSER_TYPE_ {
+	STP_DBG_ASSERT_INFO = 0x0,
+	STP_DBG_FW_TASK_ID = 0x1,
+	STP_DBG_FW_ISR = 0x2,
+	STP_DBG_FW_IRQ = 0x3,
+	STP_DBG_ASSERT_TYPE = 0x4,
+	STP_DBG_PARSER_TYPE_MAX
+} ENUM_ASSERT_INFO_PARSER_TYPE, *P_ENUM_ASSERT_INFO_PARSER_TYPE;
+
+P_WCN_CORE_DUMP_T wcn_core_dump_init(UINT32 packet_num, UINT32 timeout);
+INT32 wcn_core_dump_deinit(P_WCN_CORE_DUMP_T dmp);
+INT32 wcn_core_dump_in(P_WCN_CORE_DUMP_T dmp, PUINT8 buf, INT32 len);
+INT32 wcn_core_dump_out(P_WCN_CORE_DUMP_T dmp, PUINT8 *pbuf, PINT32 len);
+INT32 wcn_core_dump_reset(P_WCN_CORE_DUMP_T dmp, UINT32 timeout);
+INT32 wcn_core_dump_timeout(void);
+INT32 wcn_wmtd_timeout_collect_ftrace(void);
+
+extern INT32 wcn_core_dump_init_gcoredump(UINT32 packet_num, UINT32 timeout);
+extern INT32 wcn_core_dump_deinit_gcoredump(VOID);
+extern INT32 wcn_core_dump_flush(INT32 rst, MTK_WCN_BOOL is_coredump_timeout);
+extern int stp_dbg_enable(MTKSTP_DBG_T *stp_dbg);
+extern int stp_dbg_disable(MTKSTP_DBG_T *stp_dbg);
+extern MTKSTP_DBG_T *stp_dbg_init(void *);
+extern int stp_dbg_deinit(MTKSTP_DBG_T *stp_dbg);
+extern int stp_dbg_dmp_out_ex(char *buf, int *len);
+extern int stp_dbg_dmp_out(MTKSTP_DBG_T *stp_dbg, char *buf, int *len);
+extern int stp_dbg_dmp_printk(MTKSTP_DBG_T *stp_dbg);
+extern char stp_dbg_nl_send(PINT8 aucMsg, UINT8 cmd, INT32 len);
+
+extern INT32 stp_dbg_aee_send(unsigned char *aucMsg, INT32 len, INT32 cmd);
+extern INT32 _stp_btm_put_emi_dump_to_nl(PUINT8 data_buf, INT32 dump_len);
+extern int
+stp_dbg_log_pkt(MTKSTP_DBG_T *stp_dbg,
+		int dbg_type, int type, int ack_no, int seq_no, int crc, int dir, int len, const unsigned char *body);
+extern int stp_dbg_log_ctrl(unsigned int on);
+extern INT32 stp_dbg_poll_cpupcr(UINT32 times, UINT32 sleep, UINT32 cmd);
+extern INT32 stp_dbg_poll_dmaregs(UINT32 times, UINT32 sleep);
+extern INT32 stp_dbg_poll_cuppcr_ctrl(UINT32 en);
+extern INT32 stp_dbg_set_version_info(UINT32 chipid, PUINT8 pRomVer, PUINT8 pPatchVer,
+				      PUINT8 pPatchBrh);
+extern INT32 stp_dbg_set_wifiver(UINT32 wifiver);
+extern INT32 stp_dbg_cpupcr_infor_format(PPUINT8 buf, PUINT32 len);
+extern INT32 stp_dbg_set_fw_info(PUINT8 assert_info, UINT32 len, ENUM_STP_FW_ISSUE_TYPE issue_type);
+extern INT32 stp_dbg_set_host_assert_info(UINT32 drv_type, UINT32 reason, UINT32 en);
+extern UINT32 stp_dbg_get_host_trigger_assert(VOID);
+#endif /* end of _STP_DEBUG_H_ */
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/include/wmt_dev.h b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/include/wmt_dev.h
new file mode 100644
index 00000000..5788eb3
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/include/wmt_dev.h
@@ -0,0 +1,71 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _WMT_DEV_H_
+#define _WMT_DEV_H_
+
+#include "osal.h"
+
+#define STP_UART_FULL 0x01
+#define STP_UART_MAND 0x02
+#define STP_BTIF_FULL 0x03
+#define STP_SDIO      0x04
+
+#define CFG_WMT_DBG_SUPPORT 1	/* support wmt_dbg or not */
+#define CFG_WMT_PROC_FOR_AEE 1
+
+extern VOID wmt_dev_rx_event_cb(VOID);
+extern INT32 wmt_dev_rx_timeout(P_OSAL_EVENT pEvent);
+extern INT32 wmt_dev_patch_get(PUINT8 pPatchName, osal_firmware **ppPatch, INT32 padSzBuf);
+extern INT32 wmt_dev_patch_put(osal_firmware **ppPatch);
+extern VOID wmt_dev_patch_info_free(VOID);
+extern VOID wmt_dev_send_cmd_to_daemon(UINT32 cmd);
+extern MTK_WCN_BOOL wmt_dev_get_early_suspend_state(VOID);
+
+#if CFG_WMT_DBG_SUPPORT
+typedef struct _COEX_BUF {
+	UINT8 buffer[128];
+	INT32 availSize;
+} COEX_BUF, *P_COEX_BUF;
+
+typedef enum _ENUM_CMD_TYPE_T {
+	WMTDRV_CMD_ASSERT = 0,
+	WMTDRV_CMD_EXCEPTION = 1,
+	WMTDRV_CMD_COEXDBG_00 = 2,
+	WMTDRV_CMD_COEXDBG_01 = 3,
+	WMTDRV_CMD_COEXDBG_02 = 4,
+	WMTDRV_CMD_COEXDBG_03 = 5,
+	WMTDRV_CMD_COEXDBG_04 = 6,
+	WMTDRV_CMD_COEXDBG_05 = 7,
+	WMTDRV_CMD_COEXDBG_06 = 8,
+	WMTDRV_CMD_COEXDBG_07 = 9,
+	WMTDRV_CMD_COEXDBG_08 = 10,
+	WMTDRV_CMD_COEXDBG_09 = 11,
+	WMTDRV_CMD_COEXDBG_10 = 12,
+	WMTDRV_CMD_COEXDBG_11 = 13,
+	WMTDRV_CMD_COEXDBG_12 = 14,
+	WMTDRV_CMD_COEXDBG_13 = 15,
+	WMTDRV_CMD_COEXDBG_14 = 16,
+	WMTDRV_CMD_COEXDBG_15 = 17,
+	WMTDRV_CMD_NOACK_TEST = 18,
+	WMTDRV_CMD_WARNRST_TEST = 19,
+	WMTDRV_CMD_FWTRACE_TEST = 20,
+	WMTDRV_CMD_MAX
+} ENUM_WMTDRV_CMD_T, *P_ENUM_WMTDRV_CMD_T;
+
+#endif
+
+typedef INT32(*WMT_DEV_DBG_FUNC) (INT32 par1, INT32 par2, INT32 par3);
+
+#endif /*_WMT_DEV_H_*/
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/stp_btif.c b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/stp_btif.c
new file mode 100644
index 00000000..76debb4
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/stp_btif.c
@@ -0,0 +1,279 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*file: stp_btif, mainly control stp & btif interaction*/
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG "[STP-BTIF]"
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+#include "osal_typedef.h"
+#include "wmt_exp.h"
+#include "stp_exp.h"
+#include "stp_btif.h"
+
+#include <asm/current.h>
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+#define BTIF_OWNER_NAME "CONSYS_STP"
+
+#define STP_MAX_PACKAGE_ALLOWED (2000)
+
+#define STP_BTIF_TX_RTY_LMT (10)
+#define STP_BTIF_TX_RTY_DLY (5)
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+unsigned long stpBtifId = 0;
+unsigned long *pBtifRef = &stpBtifId;
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+INT32 mtk_wcn_consys_stp_btif_open(VOID)
+{
+	INT32 iRet = -1;
+
+	iRet = mtk_wcn_btif_open(BTIF_OWNER_NAME, pBtifRef);
+	if (iRet) {
+		WMT_WARN_FUNC("STP open btif fail(%d)\n", iRet);
+		return -1;
+	}
+	WMT_DBG_FUNC("STP open bitf OK\n");
+
+	mtk_wcn_stp_register_if_tx(STP_BTIF_IF_TX, (MTK_WCN_STP_IF_TX) mtk_wcn_consys_stp_btif_tx);
+
+	return 0;
+}
+
+INT32 mtk_wcn_consys_stp_btif_close(VOID)
+{
+	INT32 iRet = 0;
+
+	if (!stpBtifId) {
+		WMT_WARN_FUNC("NULL BTIF ID reference!\n");
+		iRet = -1;
+	} else {
+		iRet = mtk_wcn_btif_close(stpBtifId);
+		if (iRet) {
+			WMT_WARN_FUNC("STP close btif fail(%d)\n", iRet);
+			iRet = -2;
+		} else {
+			stpBtifId = 0;
+			WMT_DBG_FUNC("STP close btif OK\n");
+		}
+	}
+	return iRet;
+}
+
+INT32 mtk_wcn_consys_stp_btif_rx_cb_register(MTK_WCN_BTIF_RX_CB rx_cb)
+{
+	INT32 iRet = 0;
+
+	if (!stpBtifId) {
+		WMT_WARN_FUNC("NULL BTIF ID reference\n!");
+		iRet = -1;
+	} else {
+		iRet = mtk_wcn_btif_rx_cb_register(stpBtifId, rx_cb);
+		if (iRet) {
+			WMT_WARN_FUNC("STP register rxcb to btif fail(%d)\n", iRet);
+			iRet = -2;
+		} else {
+			WMT_DBG_FUNC("STP register rxcb to  btif OK\n");
+		}
+	}
+	return iRet;
+}
+
+INT32 mtk_wcn_consys_stp_btif_tx(const UINT8 *pBuf, const UINT32 len, UINT32 *written_len)
+{
+	INT32 retry_left = STP_BTIF_TX_RTY_LMT;
+	INT32 wr_count = 0;
+	INT32 written = 0;
+
+	if (!stpBtifId) {
+		WMT_WARN_FUNC("NULL BTIF ID reference!\n");
+		return -1;
+	}
+
+	if (len == 0) {
+		*written_len = 0;
+		WMT_INFO_FUNC("special case for STP-CORE,pbuf(%p)\n", pBuf);
+		return 0;
+	}
+
+	*written_len = 0;
+
+	if (len > STP_MAX_PACKAGE_ALLOWED) {
+		WMT_WARN_FUNC("abnormal pacage length,len(%d),pid[%d/%s]\n", len, current->pid, current->comm);
+		return -2;
+	}
+	wr_count = mtk_wcn_btif_write(stpBtifId, pBuf, len);
+
+	if (wr_count < 0) {
+		WMT_ERR_FUNC("mtk_wcn_btif_write err(%d)\n", wr_count);
+		*written_len = 0;
+		return -3;
+	}
+	if (wr_count == len) {
+		/*perfect case */
+		*written_len = wr_count;
+		return wr_count;
+	}
+
+	while ((retry_left--) && (wr_count < len)) {
+		osal_sleep_ms(STP_BTIF_TX_RTY_DLY);
+		written = mtk_wcn_btif_write(stpBtifId, pBuf + wr_count, len - wr_count);
+		if (written < 0) {
+			WMT_ERR_FUNC("mtk_wcn_btif_write err(%d)when do recovered\n", written);
+			break;
+		}
+		wr_count += written;
+	}
+
+	if (wr_count == len) {
+		WMT_INFO_FUNC("recovered,len(%d),retry_left(%d)\n", len, retry_left);
+		/*recovered case */
+		*written_len = wr_count;
+		return wr_count;
+	}
+
+	WMT_ERR_FUNC("stp btif write fail,len(%d),written(%d),retry_left(%d),pid[%d/%s]\n",
+		     len, wr_count, retry_left, current->pid, current->comm);
+	*written_len = 0;
+	return -wr_count;
+}
+
+INT32 mtk_wcn_consys_stp_btif_rx(UINT8 *pBuf, UINT32 len)
+{
+	return 0;
+}
+
+INT32 mtk_wcn_consys_stp_btif_wakeup(VOID)
+{
+	INT32 iRet = 0;
+
+	if (!stpBtifId) {
+		WMT_WARN_FUNC("NULL BTIF ID reference!\n");
+		iRet = -1;
+	} else {
+		iRet = mtk_wcn_btif_wakeup_consys(stpBtifId);
+		if (iRet) {
+			WMT_WARN_FUNC("STP btif wakeup consys fail(%d)\n", iRet);
+			iRet = -2;
+		} else {
+			WMT_DBG_FUNC("STP btif wakeup consys ok\n");
+		}
+	}
+
+	return iRet;
+}
+
+INT32 mtk_wcn_consys_stp_btif_dpidle_ctrl(ENUM_BTIF_DPIDLE_CTRL en_flag)
+{
+	INT32 iRet = 0;
+
+	if (!stpBtifId) {
+		WMT_WARN_FUNC("NULL BTIF ID reference!\n");
+		iRet = -1;
+	} else {
+		mtk_wcn_btif_dpidle_ctrl(stpBtifId, en_flag);
+		WMT_DBG_FUNC("stp btif dpidle ctrl done,en_flag(%d)\n", en_flag);
+	}
+
+	return iRet;
+}
+
+INT32 mtk_wcn_consys_stp_btif_lpbk_ctrl(ENUM_BTIF_LPBK_MODE mode)
+{
+	INT32 iRet = 0;
+
+	if (!stpBtifId) {
+		WMT_WARN_FUNC("NULL BTIF ID reference!\n");
+		iRet = -1;
+	} else {
+		iRet = mtk_wcn_btif_loopback_ctrl(stpBtifId, mode);
+		if (iRet) {
+			WMT_WARN_FUNC("STP btif lpbk ctrl fail(%d)\n", iRet);
+			iRet = -2;
+		} else {
+			WMT_INFO_FUNC("stp btif lpbk ctrl ok,mode(%d)\n", mode);
+		}
+	}
+
+	return iRet;
+}
+
+INT32 mtk_wcn_consys_stp_btif_logger_ctrl(ENUM_BTIF_DBG_ID flag)
+{
+	INT32 iRet = 0;
+
+	if (!stpBtifId) {
+		WMT_WARN_FUNC("NULL BTIF ID reference!\n");
+		iRet = -1;
+	} else {
+		iRet = mtk_wcn_btif_dbg_ctrl(stpBtifId, flag);
+		if (iRet) {
+			WMT_WARN_FUNC("STP btif log dbg ctrl fail(%d)\n", iRet);
+			iRet = -2;
+		} else {
+			WMT_INFO_FUNC("stp btif log dbg ctrl ok,flag(%d)\n", flag);
+		}
+	}
+
+	return iRet;
+}
+
+INT32 mtk_wcn_consys_stp_btif_parser_wmt_evt(const UINT8 *str, UINT32 len)
+{
+	if (!stpBtifId) {
+		WMT_WARN_FUNC("NULL BTIF ID reference!\n");
+		return -1;
+	} else {
+		return (INT32) mtk_wcn_btif_parser_wmt_evt(stpBtifId, str, len);
+	}
+}
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/stp_dbg.c b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/stp_dbg.c
new file mode 100644
index 00000000..f2c8a68
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/stp_dbg.c
@@ -0,0 +1,2060 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+#include <linux/kernel.h>	/* GFP_KERNEL */
+#include <linux/timer.h>	/* init_timer, add_time, del_timer_sync */
+#include <linux/time.h>		/* gettimeofday */
+#include <linux/delay.h>
+#include <linux/slab.h>		/* kzalloc */
+#include <linux/sched.h>	/* task's status */
+#include <linux/vmalloc.h>
+#include <linux/err.h>
+#include <linux/workqueue.h>
+#include <asm/atomic.h>
+
+#include <net/sock.h>
+#include <net/netlink.h>
+#include <linux/skbuff.h>
+#include <net/genetlink.h>
+
+#include <linux/zlib.h>
+#include <linux/uaccess.h>
+#include <linux/crc32.h>
+
+#include "osal_typedef.h"
+#include "stp_dbg.h"
+/* #include "stp_btm.h" */
+#include "btm_core.h"
+#include "wmt_plat.h"
+
+#define PFX_STP_DBG                      "[STPDbg]"
+#define STP_DBG_LOG_LOUD                 4
+#define STP_DBG_LOG_DBG                  3
+#define STP_DBG_LOG_INFO                 2
+#define STP_DBG_LOG_WARN                 1
+#define STP_DBG_LOG_ERR                  0
+
+unsigned int gStpDbgDbgLevel = STP_DBG_LOG_INFO;
+unsigned int gStpDbgLogOut = 0;
+
+#define STP_DBG_LOUD_FUNC(fmt, arg...) \
+do { \
+	if (gStpDbgDbgLevel >= STP_DBG_LOG_LOUD) \
+		pr_debug(PFX_STP_DBG "%s: "  fmt, __func__ , ##arg); \
+} while (0)
+#define STP_DBG_DBG_FUNC(fmt, arg...) \
+do { \
+	if (gStpDbgDbgLevel >= STP_DBG_LOG_DBG) \
+		pr_debug(PFX_STP_DBG "%s: "  fmt, __func__ , ##arg); \
+} while (0)
+#define STP_DBG_INFO_FUNC(fmt, arg...) \
+do { \
+	if (gStpDbgDbgLevel >= STP_DBG_LOG_INFO) \
+		pr_debug(PFX_STP_DBG "%s: "  fmt, __func__ , ##arg); \
+} while (0)
+#define STP_DBG_WARN_FUNC(fmt, arg...) \
+do { \
+	if (gStpDbgDbgLevel >= STP_DBG_LOG_WARN) \
+		pr_warn(PFX_STP_DBG "%s: "  fmt, __func__ , ##arg); \
+} while (0)
+#define STP_DBG_ERR_FUNC(fmt, arg...) \
+do { \
+	if (gStpDbgDbgLevel >= STP_DBG_LOG_ERR) \
+		pr_err(PFX_STP_DBG "%s: "   fmt, __func__ , ##arg); \
+} while (0)
+#define STP_DBG_TRC_FUNC(f) \
+do { \
+	if (gStpDbgDbgLevel >= STP_DBG_LOG_DBG) \
+		pr_debug(PFX_STP_DBG "<%s> <%d>\n", __func__, __LINE__); \
+} while (0)
+
+MTKSTP_DBG_T *g_stp_dbg = NULL;
+
+#define STP_DBG_FAMILY_NAME        "STP_DBG"
+#define MAX_BIND_PROCESS    (4)
+#ifdef WMT_PLAT_ALPS
+#define STP_DBG_AEE_EXP_API (1)
+#else
+#define STP_DBG_AEE_EXP_API (0)
+#endif
+enum {
+	__STP_DBG_ATTR_INVALID,
+	STP_DBG_ATTR_MSG,
+	__STP_DBG_ATTR_MAX,
+};
+#define STP_DBG_ATTR_MAX       (__STP_DBG_ATTR_MAX - 1)
+
+enum {
+	__STP_DBG_COMMAND_INVALID,
+	STP_DBG_COMMAND_BIND,
+	STP_DBG_COMMAND_RESET,
+	__STP_DBG_COMMAND_MAX,
+};
+#define MTK_WIFI_COMMAND_MAX    (__STP_DBG_COMMAND_MAX - 1)
+
+/* attribute policy */
+static struct nla_policy stp_dbg_genl_policy[STP_DBG_ATTR_MAX + 1] = {
+	[STP_DBG_ATTR_MSG] = {.type = NLA_NUL_STRING},
+};
+
+static struct genl_family stp_dbg_gnl_family = {
+	.id = GENL_ID_GENERATE,
+	.hdrsize = 0,
+	.name = STP_DBG_FAMILY_NAME,
+	.version = 1,
+	.maxattr = STP_DBG_ATTR_MAX,
+	.policy = stp_dbg_genl_policy,
+};
+
+static void stp_dbg_nl_init(void);
+static void stp_dbg_nl_deinit(void);
+static int stp_dbg_nl_bind(struct sk_buff *skb, struct genl_info *info);
+static int stp_dbg_nl_reset(struct sk_buff *skb, struct genl_info *info);
+
+/* operation definition */
+#if 0
+static struct genl_ops stp_dbg_gnl_ops_bind = {
+	.cmd = STP_DBG_COMMAND_BIND,
+	.flags = 0,
+	.policy = stp_dbg_genl_policy,
+	.doit = stp_dbg_nl_bind,
+	.dumpit = NULL,
+};
+
+static struct genl_ops stp_dbg_gnl_ops_reset = {
+	.cmd = STP_DBG_COMMAND_RESET,
+	.flags = 0,
+	.policy = stp_dbg_genl_policy,
+	.doit = stp_dbg_nl_reset,
+	.dumpit = NULL,
+};
+#endif
+static struct genl_ops stp_dbg_gnl_ops_array[] = {
+	{
+		.cmd = STP_DBG_COMMAND_BIND,
+		.flags = 0,
+		.doit = stp_dbg_nl_bind,
+		.dumpit = NULL,
+	},
+	{
+		.cmd = STP_DBG_COMMAND_RESET,
+		.flags = 0,
+		.doit = stp_dbg_nl_reset,
+		.dumpit = NULL,
+	},
+};
+
+#if 0
+#define E2S(x) #x
+static char *dmaRegsStr[] = {
+	E2S(CONNSYS_CLK_GATE_STATUS),
+	E2S(CONSYS_EMI_STATUS),
+	E2S(SYSRAM1),
+	E2S(SYSRAM2),
+	E2S(SYSRAM3)
+};
+#endif
+static unsigned int stp_dbg_seqnum;
+static int num_bind_process;
+static pid_t bind_pid[MAX_BIND_PROCESS];
+
+static P_WCN_CORE_DUMP_T g_core_dump;
+
+static P_STP_DBG_CPUPCR_T g_stp_dbg_cpupcr;
+
+/* just show in log at present */
+static P_STP_DBG_DMAREGS_T g_stp_dbg_dmaregs;
+
+/* core_dump_timeout_handler - handler of coredump timeout
+ * @ data - core dump object's pointer
+ *
+ * No return value
+ */
+static void core_dump_timeout_handler(/*unsigned long data*/struct timer_list *t)
+{
+	//P_WCN_CORE_DUMP_T dmp = (P_WCN_CORE_DUMP_T) data;
+	P_WCN_CORE_DUMP_T dmp = from_timer(dmp,t,dmp_timer.timer);
+
+	STP_DBG_INFO_FUNC(" start\n");
+
+	stp_btm_notify_coredump_timeout_wq(g_stp_dbg->btm);
+
+	STP_DBG_INFO_FUNC(" end\n");
+
+	if (dmp)
+		dmp->sm = CORE_DUMP_TIMEOUT;
+}
+
+/* wcn_core_dump_init - create core dump sys
+ * @ timeout - core dump time out value
+ *
+ * Return object pointer if success, else NULL
+ */
+P_WCN_CORE_DUMP_T wcn_core_dump_init(UINT32 packet_num, UINT32 timeout)
+{
+#define KBYTES (1024*sizeof(char))
+#define L1_BUF_SIZE (32*KBYTES)
+
+	P_WCN_CORE_DUMP_T core_dmp = NULL;
+
+	core_dmp = (P_WCN_CORE_DUMP_T) osal_malloc(sizeof(WCN_CORE_DUMP_T));
+	if (!core_dmp) {
+		STP_DBG_ERR_FUNC("alloc mem failed!\n");
+		goto fail;
+	}
+
+	osal_memset(core_dmp, 0, sizeof(WCN_CORE_DUMP_T));
+
+	core_dmp->compressor = wcn_compressor_init("core_dump_compressor", L1_BUF_SIZE, 18*packet_num*KBYTES);
+	if (!core_dmp->compressor) {
+		STP_DBG_ERR_FUNC("create compressor failed!\n");
+		goto fail;
+	}
+	wcn_compressor_reset(core_dmp->compressor, 1, GZIP);
+
+	core_dmp->dmp_timer.timeoutHandler = core_dump_timeout_handler;
+	core_dmp->dmp_timer.timeroutHandlerData = (unsigned long)core_dmp;
+	osal_timer_create(&core_dmp->dmp_timer);
+	core_dmp->timeout = timeout;
+
+	osal_sleepable_lock_init(&core_dmp->dmp_lock);
+
+	core_dmp->sm = CORE_DUMP_INIT;
+	STP_DBG_INFO_FUNC("create coredump object OK!\n");
+
+	return core_dmp;
+
+fail:
+	if (core_dmp && core_dmp->compressor) {
+		wcn_compressor_deinit(core_dmp->compressor);
+		core_dmp->compressor = NULL;
+	}
+	if (core_dmp)
+		osal_free(core_dmp);
+
+	return NULL;
+}
+INT32 wcn_core_dump_init_gcoredump(UINT32 packet_num, UINT32 timeout)
+{
+	INT32 Ret = 0;
+
+	g_core_dump = wcn_core_dump_init(packet_num, timeout);
+	if (g_core_dump == NULL)
+		Ret = -1;
+	return Ret;
+}
+
+/* wcn_core_dump_deinit - destroy core dump object
+ * @ dmp - pointer of object
+ *
+ * Retunr 0 if success, else error code
+ */
+INT32 wcn_core_dump_deinit(P_WCN_CORE_DUMP_T dmp)
+{
+	if (dmp && dmp->compressor) {
+		wcn_compressor_deinit(dmp->compressor);
+		dmp->compressor = NULL;
+	}
+
+	if (dmp) {
+		osal_sleepable_lock_deinit(&dmp->dmp_lock);
+		osal_timer_stop(&dmp->dmp_timer);
+		osal_free(dmp);
+	}
+
+	return 0;
+}
+
+INT32 wcn_core_dump_deinit_gcoredump(VOID)
+{
+	wcn_core_dump_deinit(g_core_dump);
+	return 0;
+}
+
+static INT32 wcn_core_dump_check_end(PUINT8 buf, INT32 len)
+{
+	if (strnstr(buf, "coredump end", len))
+		return 1;
+	else
+		return 0;
+}
+
+/* wcn_core_dump_in - add a packet to compressor buffer
+ * @ dmp - pointer of object
+ * @ buf - input buffer
+ * @ len - data length
+ *
+ * Retunr 0 if success; return 1 if find end string; else error code
+ */
+INT32 wcn_core_dump_in(P_WCN_CORE_DUMP_T dmp, PUINT8 buf, INT32 len)
+{
+	INT32 ret = 0;
+	INT32 tmp;
+
+#define INFO_HEAD ";SOC_CONSYS FW CORE, "
+
+	if ((!dmp) || (!buf)) {
+		STP_DBG_ERR_FUNC("invalid pointer!\n");
+		return -1;
+	}
+
+	ret = osal_lock_sleepable_lock(&dmp->dmp_lock);
+	if (ret) {
+		STP_DBG_ERR_FUNC("--->lock dmp->dmp_lock failed, ret=%d\n", ret);
+		return ret;
+	}
+
+	switch (dmp->sm) {
+	case CORE_DUMP_INIT:
+		wcn_compressor_reset(dmp->compressor, 1, GZIP);
+		osal_timer_start(&dmp->dmp_timer, STP_CORE_DUMP_TIMEOUT);
+
+		/* first package, copy to info buffer */
+		osal_strcpy(&dmp->info[0], INFO_HEAD);
+
+		if (NULL == (strnstr(buf, "<ASSERT>", 32))) {
+			osal_memcpy(&dmp->info[osal_strlen(INFO_HEAD)], "Fw warm reset exception...",
+				    osal_strlen("Fw warm reset exception..."));
+			dmp->info[osal_strlen(INFO_HEAD) + osal_strlen("Fw warm reset exception...") + 1] = '\0';
+		} else {
+			char *pStr = buf;
+			char *pDtr = NULL;
+
+			pDtr = osal_strchr(pStr, '-');
+			if (NULL != pDtr) {
+				tmp = pDtr - pStr;
+				osal_memcpy(&dmp->info[osal_strlen(INFO_HEAD)], buf, tmp);
+				dmp->info[osal_strlen(dmp->info) + 1] = '\0';
+			} else {
+				tmp = STP_CORE_DUMP_INFO_SZ - osal_strlen(INFO_HEAD);
+				tmp = (len > tmp) ? tmp : len;
+				osal_memcpy(&dmp->info[osal_strlen(INFO_HEAD)], buf, tmp);
+				dmp->info[STP_CORE_DUMP_INFO_SZ] = '\0';
+			}
+
+		}
+		/* show coredump start info on UI */
+		/* osal_dbg_assert_aee("MT662x f/w coredump start", "MT662x firmware coredump start"); */
+#if STP_DBG_AEE_EXP_API
+		aee_kernel_dal_show("SOC_CONSYS coredump start ....\n");
+#endif
+		/* parsing data, and check end srting */
+		ret = wcn_core_dump_check_end(buf, len);
+		if (ret == 1) {
+			STP_DBG_INFO_FUNC("core dump end!\n");
+			dmp->sm = CORE_DUMP_DONE;
+			wcn_compressor_in(dmp->compressor, buf, len, 0);
+		} else {
+			dmp->sm = CORE_DUMP_DOING;
+			wcn_compressor_in(dmp->compressor, buf, len, 0);
+		}
+		break;
+
+	case CORE_DUMP_DOING:
+		/* parsing data, and check end srting */
+		ret = wcn_core_dump_check_end(buf, len);
+		if (ret == 1) {
+			STP_DBG_INFO_FUNC("core dump end!\n");
+			dmp->sm = CORE_DUMP_DONE;
+			wcn_compressor_in(dmp->compressor, buf, len, 0);
+		} else {
+			dmp->sm = CORE_DUMP_DOING;
+			wcn_compressor_in(dmp->compressor, buf, len, 0);
+		}
+		break;
+
+	case CORE_DUMP_DONE:
+		wcn_compressor_reset(dmp->compressor, 1, GZIP);
+		osal_timer_start(&dmp->dmp_timer, STP_CORE_DUMP_TIMEOUT);
+		wcn_compressor_in(dmp->compressor, buf, len, 0);
+		dmp->sm = CORE_DUMP_DOING;
+		break;
+
+	case CORE_DUMP_TIMEOUT:
+		break;
+	default:
+		break;
+	}
+
+	osal_unlock_sleepable_lock(&dmp->dmp_lock);
+
+	return ret;
+}
+
+/* wcn_core_dump_out - get compressed data from compressor buffer
+ * @ dmp - pointer of object
+ * @ pbuf - target buffer's pointer
+ * @ len - data length
+ *
+ * Retunr 0 if success;  else error code
+ */
+INT32 wcn_core_dump_out(P_WCN_CORE_DUMP_T dmp, PUINT8 *pbuf, PINT32 plen)
+{
+	INT32 ret = 0;
+
+	if ((!dmp) || (!pbuf) || (!plen)) {
+		STP_DBG_ERR_FUNC("invalid pointer!\n");
+		return -1;
+	}
+
+	ret = osal_lock_sleepable_lock(&dmp->dmp_lock);
+	if (ret) {
+		STP_DBG_ERR_FUNC("--->lock dmp->dmp_lock failed, ret=%d\n", ret);
+		return ret;
+	}
+
+	ret = wcn_compressor_out(dmp->compressor, pbuf, plen);
+
+	osal_unlock_sleepable_lock(&dmp->dmp_lock);
+
+	return ret;
+}
+
+/* wcn_core_dump_reset - reset core dump sys
+ * @ dmp - pointer of object
+ * @ timeout - core dump time out value
+ *
+ * Retunr 0 if success, else error code
+ */
+INT32 wcn_core_dump_reset(P_WCN_CORE_DUMP_T dmp, UINT32 timeout)
+{
+	if (!dmp) {
+		STP_DBG_ERR_FUNC("invalid pointer!\n");
+		return -1;
+	}
+
+	dmp->sm = CORE_DUMP_INIT;
+	dmp->timeout = timeout;
+	osal_timer_stop(&dmp->dmp_timer);
+	wcn_compressor_reset(dmp->compressor, 1, GZIP);
+	osal_memset(dmp->info, 0, STP_CORE_DUMP_INFO_SZ + 1);
+
+	wcn_core_dump_deinit(dmp);
+	g_core_dump = wcn_core_dump_init(STP_CORE_DUMP_INIT_SIZE, STP_CORE_DUMP_TIMEOUT);
+
+	return 0;
+}
+
+/* wcn_wmtd_timeout_collect_ftrace - wmtd timeout ,this func can collect SYS_FTRACE
+ *
+ * Retunr 0 if success
+ */
+#define WMTD_TIMEOUT_INFO_HEAD "Wait wmtd complation timeout ,just collect SYS_FTRACE to DB"
+INT32 wcn_wmtd_timeout_collect_ftrace(void)
+{
+	PUINT8 pbuf;
+	INT32 len;
+
+	pbuf = "Wait wmtd complation timeout";
+	len = osal_strlen("Wait wmtd complation timeout");
+	osal_strcpy(&g_core_dump->info[0], WMTD_TIMEOUT_INFO_HEAD);
+#ifdef WMT_PLAT_ALPS
+	aed_combo_exception(NULL, 0, (const int *)pbuf, len, (const char *)g_core_dump->info);
+#endif
+	return 0;
+}
+/* wcn_psm_flag_trigger_collect_ftrace - wmtd timeout ,this func can collect SYS_FTRACE
+ *
+ * Retunr 0 if success
+ */
+#define PSM_ABNORMAL_FLAG_INFO_HEAD "Abnormal PSM flag be set ,just collect SYS_FTRACE to DB"
+INT32 wcn_psm_flag_trigger_collect_ftrace(void)
+{
+	PUINT8 pbuf;
+	INT32 len;
+
+	pbuf = "Abnormal PSM flag be set";
+	len = osal_strlen("Abnormal PSM flag be set");
+	osal_strcpy(&g_core_dump->info[0], PSM_ABNORMAL_FLAG_INFO_HEAD);
+#ifdef WMT_PLAT_ALPS
+	aed_combo_exception(NULL, 0, (const int *)pbuf, len, (const char *)g_core_dump->info);
+#endif
+	return 0;
+}
+#if BTIF_RXD_BE_BLOCKED_DETECT
+MTK_WCN_BOOL is_btif_rxd_be_blocked(void)
+{
+	MTK_WCN_BOOL flag = MTK_WCN_BOOL_FALSE;
+
+	if (mtk_btif_rxd_be_blocked_flag_get())
+		flag = MTK_WCN_BOOL_TRUE;
+	return flag;
+}
+/* wcn_btif_rxd_blocked_collect_ftrace - btif rxd be blocked,this func can collect SYS_FTRACE
+ *
+ * Retunr 0 if success
+ */
+#define BTIF_RXD_BLOCKED_INFO_HEAD "Btif_rxd thread be blocked too long,just collect SYS_FTRACE to DB"
+INT32 wcn_btif_rxd_blocked_collect_ftrace(void)
+{
+	PUINT8 pbuf;
+	INT32 len;
+
+	pbuf = "Btif_rxd thread be blocked too long";
+	len = osal_strlen("Btif_rxd thread be blocked too long");
+	osal_strcpy(&g_core_dump->info[0], BTIF_RXD_BLOCKED_INFO_HEAD);
+#ifdef WMT_PLAT_ALPS
+	aed_combo_exception(NULL, 0, (const int *)pbuf, len, (const char *)g_core_dump->info);
+#endif
+	return 0;
+}
+#endif
+/* wcn_core_dump_timeout - wait for FW assert info timeout ,this func can collect SYS_FTRACE
+ *
+ * Retunr 0 if success
+ */
+#define TIMEOUT_INFO_HEAD "Trigger assert timeout ,just collect SYS_FTRACE to DB"
+INT32 wcn_core_dump_timeout(void)
+{
+	PUINT8 pbuf;
+	INT32 len;
+
+	pbuf = "Trigger assert timeout";
+	len = osal_strlen("Trigger assert timeout");
+	osal_strcpy(&g_core_dump->info[0], TIMEOUT_INFO_HEAD);
+#ifdef WMT_PLAT_ALPS
+	aed_combo_exception(NULL, 0, (const int *)pbuf, len, (const char *)g_core_dump->info);
+#endif
+	return 0;
+}
+
+#define ENABLE_F_TRACE 0
+/* wcn_core_dump_flush - Fulsh dump data and reset core dump sys
+ *
+ * Retunr 0 if success, else error code
+ */
+INT32 wcn_core_dump_flush(INT32 rst, MTK_WCN_BOOL coredump_is_timeout)
+{
+	PUINT8 pbuf = NULL;
+	INT32 len = 0;
+
+	if (!g_core_dump) {
+		STP_DBG_ERR_FUNC("invalid pointer!\n");
+		return -1;
+	}
+
+	wcn_core_dump_out(g_core_dump, &pbuf, &len);
+	STP_DBG_INFO_FUNC("buf 0x%zx, len %d\n", (SIZE_T) pbuf, len);
+#ifdef WMT_PLAT_ALPS
+	/* show coredump end info on UI */
+	/* osal_dbg_assert_aee("MT662x f/w coredump end", "MT662x firmware coredump ends"); */
+#if STP_DBG_AEE_EXP_API
+	if (coredump_is_timeout)
+		aee_kernel_dal_show("++ SOC_CONSYS coredump tiemout ,pass received coredump to AEE ++\n");
+	else
+		aee_kernel_dal_show("++ SOC_CONSYS coredump get successfully ++\n");
+	/* call AEE driver API */
+#if ENABLE_F_TRACE
+	aed_combo_exception_api(NULL, 0, (const int *)pbuf, len, (const char *)g_core_dump->info, DB_OPT_FTRACE);
+#else
+	aed_combo_exception(NULL, 0, (const int *)pbuf, len, (const char *)g_core_dump->info);
+#endif
+
+#endif
+
+#endif  // WMT_PLAT_ALPS
+
+	/* reset */
+	wcn_core_dump_reset(g_core_dump, STP_CORE_DUMP_TIMEOUT);
+
+	return 0;
+}
+
+static INT32 wcn_gzip_compressor(void *worker, UINT8 *in_buf, INT32 in_sz, UINT8 *out_buf, INT32 *out_sz,
+				 INT32 finish)
+{
+	INT32 ret = 0;
+	z_stream *stream = NULL;
+	INT32 tmp = *out_sz;
+
+	STP_DBG_INFO_FUNC("need to compressor :buf 0x%zx, size %d\n", (SIZE_T) in_buf, in_sz);
+	STP_DBG_INFO_FUNC("before compressor,avalible buf: 0x%zx, size %d\n", (SIZE_T) out_buf, tmp);
+
+	stream = (z_stream *) worker;
+	if (!stream) {
+		STP_DBG_ERR_FUNC("invalid workspace!\n");
+		return -1;
+	}
+
+	if (in_sz > 0) {
+#if 0
+		ret = zlib_deflateReset(stream);
+		if (ret != Z_OK) {
+			STP_DBG_ERR_FUNC("reset failed!\n");
+			return -2;
+		}
+#endif
+
+		stream->next_in = in_buf;
+		stream->avail_in = in_sz;
+		stream->next_out = out_buf;
+		stream->avail_out = tmp;
+
+		zlib_deflate(stream, Z_FULL_FLUSH);
+
+		if (finish) {
+			while (1) {
+				int val = zlib_deflate(stream, Z_FINISH);
+
+				if (val == Z_OK)
+					continue;
+				else if (val == Z_STREAM_END)
+					break;
+				STP_DBG_ERR_FUNC("finish operation failed %d\n", val);
+				return -3;
+			}
+		}
+
+		*out_sz = tmp - stream->avail_out;
+	}
+
+	STP_DBG_INFO_FUNC("after compressor,avalible buf: 0x%zx, compress rate %d -> %d\n", (SIZE_T) out_buf, in_sz,
+			  *out_sz);
+
+	return ret;
+}
+
+/* wcn_compressor_init - create a compressor and do init
+ * @ name - compressor's name
+ * @ L1_buf_sz - L1 buffer size
+ * @ L2_buf_sz - L2 buffer size
+ *
+ * Retunr object's pointer if success, else NULL
+ */
+P_WCN_COMPRESSOR_T wcn_compressor_init(PUINT8 name, INT32 L1_buf_sz, INT32 L2_buf_sz)
+{
+	z_stream *pstream = NULL;
+	P_WCN_COMPRESSOR_T compress = NULL;
+
+	compress = (P_WCN_COMPRESSOR_T) osal_malloc(sizeof(WCN_COMPRESSOR_T));
+	if (!compress) {
+		STP_DBG_ERR_FUNC("alloc compressor failed!\n");
+		goto fail;
+	}
+
+	osal_memset(compress, 0, sizeof(WCN_COMPRESSOR_T));
+	osal_memcpy(compress->name, name, STP_OJB_NAME_SZ);
+
+	compress->f_compress_en = 0;
+	compress->compress_type = GZIP;
+
+	if (compress->compress_type == GZIP) {
+		compress->worker = osal_malloc(sizeof(z_stream));
+		if (!compress->worker) {
+			STP_DBG_ERR_FUNC("alloc stream failed!\n");
+			goto fail;
+		}
+		pstream = (z_stream *) compress->worker;
+
+		pstream->workspace = osal_malloc(zlib_deflate_workspacesize(MAX_WBITS, MAX_MEM_LEVEL));
+		if (!pstream->workspace) {
+			STP_DBG_ERR_FUNC("alloc workspace failed!\n");
+			goto fail;
+		}
+		zlib_deflateInit2(pstream, Z_DEFAULT_COMPRESSION, Z_DEFLATED, -MAX_WBITS,
+				  DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
+	}
+
+	compress->handler = wcn_gzip_compressor;
+	compress->L1_buf_sz = L1_buf_sz;
+	compress->L2_buf_sz = L2_buf_sz;
+	compress->L1_pos = 0;
+	compress->L2_pos = 0;
+	compress->uncomp_size = 0;
+	compress->crc32 = 0xffffffffUL;
+
+	compress->L1_buf = osal_malloc(compress->L1_buf_sz);
+	if (!compress->L1_buf) {
+		STP_DBG_ERR_FUNC("alloc %d bytes for L1 buf failed!\n", compress->L1_buf_sz);
+		goto fail;
+	}
+
+	compress->L2_buf = osal_malloc(compress->L2_buf_sz);
+	if (!compress->L2_buf) {
+		STP_DBG_ERR_FUNC("alloc %d bytes for L2 buf failed!\n", compress->L2_buf_sz);
+		goto fail;
+	}
+
+	STP_DBG_INFO_FUNC("create compressor OK! L1 %d bytes, L2 %d bytes\n", L1_buf_sz, L2_buf_sz);
+	return compress;
+
+fail:
+	if (compress) {
+		if (compress->L2_buf) {
+			osal_free(compress->L2_buf);
+			compress->L2_buf = NULL;
+		}
+
+		if (compress->L1_buf) {
+			osal_free(compress->L1_buf);
+			compress->L1_buf = NULL;
+		}
+
+		if (compress->worker) {
+			pstream = (z_stream *) compress->worker;
+			if ((compress->compress_type == GZIP) && pstream->workspace) {
+				zlib_deflateEnd(pstream);
+				osal_free(pstream->workspace);
+			}
+			osal_free(compress->worker);
+			compress->worker = NULL;
+		}
+
+		if (compress->worker) {
+			osal_free(compress->worker);
+			compress->worker = NULL;
+		}
+
+		osal_free(compress);
+		compress = NULL;
+	}
+
+	STP_DBG_ERR_FUNC("init failed!\n");
+
+	return NULL;
+}
+
+/* wcn_compressor_deinit - distroy a compressor
+ * @ cprs - compressor's pointer
+ *
+ * Retunr 0 if success, else NULL
+ */
+INT32 wcn_compressor_deinit(P_WCN_COMPRESSOR_T cprs)
+{
+	z_stream *pstream = NULL;
+
+	if (cprs) {
+		if (cprs->L2_buf) {
+			osal_free(cprs->L2_buf);
+			cprs->L2_buf = NULL;
+		}
+
+		if (cprs->L1_buf) {
+			osal_free(cprs->L1_buf);
+			cprs->L1_buf = NULL;
+		}
+
+		if (cprs->worker) {
+			pstream = (z_stream *) cprs->worker;
+			if ((cprs->compress_type == GZIP) && pstream->workspace) {
+				zlib_deflateEnd(pstream);
+				osal_free(pstream->workspace);
+			}
+			osal_free(cprs->worker);
+			cprs->worker = NULL;
+		}
+
+		cprs->handler = NULL;
+
+		osal_free(cprs);
+	}
+
+	STP_DBG_INFO_FUNC("destroy OK\n");
+
+	return 0;
+}
+
+/* wcn_compressor_in - put in a raw data, and compress L1 buffer if need
+ * @ cprs - compressor's pointer
+ * @ buf - raw data buffer
+ * @ len - raw data length
+ * @ finish - core dump finish or not, 1: finished; 0: not finish
+ *
+ * Retunr 0 if success, else NULL
+ */
+INT32 wcn_compressor_in(P_WCN_COMPRESSOR_T cprs, PUINT8 buf, INT32 len, INT32 finish)
+{
+	INT32 tmp_len = 0;
+	INT32 ret = 0;
+
+	if (!cprs) {
+		STP_DBG_ERR_FUNC("invalid para!\n");
+		return -1;
+	}
+
+	cprs->uncomp_size += len;
+
+	/* check L1 buf valid space */
+	if (len > (cprs->L1_buf_sz - cprs->L1_pos)) {
+		STP_DBG_INFO_FUNC("L1 buffer full\n");
+
+		if (cprs->f_compress_en && cprs->handler) {
+			/* need compress */
+			/* compress L1 buffer, and put result to L2 buffer */
+			tmp_len = cprs->L2_buf_sz - cprs->L2_pos;
+			ret =
+			    cprs->handler(cprs->worker, cprs->L1_buf, cprs->L1_pos, &cprs->L2_buf[cprs->L2_pos],
+					  &tmp_len, finish);
+			if (!ret) {
+				cprs->crc32 = (crc32(cprs->crc32, cprs->L1_buf, cprs->L1_pos));
+				cprs->L2_pos += tmp_len;
+				if (cprs->L2_pos > cprs->L2_buf_sz)
+					STP_DBG_ERR_FUNC("coredump size too large(%d), L2 buf overflow\n",
+					cprs->L2_pos);
+
+				if (finish) {
+					/* Add 8 byte suffix
+					   ===
+					   32 bits UNCOMPRESS SIZE
+					   32 bits CRC
+					 */
+					*(uint32_t *) (&cprs->L2_buf[cprs->L2_pos]) = (cprs->crc32 ^ 0xffffffffUL);
+					*(uint32_t *) (&cprs->L2_buf[cprs->L2_pos + 4]) = cprs->uncomp_size;
+					cprs->L2_pos += 8;
+				}
+				STP_DBG_INFO_FUNC("compress OK!\n");
+			} else
+				STP_DBG_ERR_FUNC("compress error!\n");
+		} else {
+			/* no need compress */
+			/* Flush L1 buffer to L2 buffer */
+			STP_DBG_INFO_FUNC("No need do compress, Put to L2 buf\n");
+
+			tmp_len = cprs->L2_buf_sz - cprs->L2_pos;
+			tmp_len = (cprs->L1_pos > tmp_len) ? tmp_len : cprs->L1_pos;
+			osal_memcpy(&cprs->L2_buf[cprs->L2_pos], cprs->L1_buf, tmp_len);
+			cprs->L2_pos += tmp_len;
+		}
+
+		/* reset L1 buf pos */
+		cprs->L1_pos = 0;
+
+		/* put curren data to L1 buf */
+		if (len > cprs->L1_buf_sz) {
+			STP_DBG_ERR_FUNC("len=%d, too long err!\n", len);
+		} else {
+			STP_DBG_INFO_FUNC("L1 Flushed, and Put %d bytes to L1 buf\n", len);
+			osal_memcpy(&cprs->L1_buf[cprs->L1_pos], buf, len);
+			cprs->L1_pos += len;
+		}
+	} else {
+		/* put to L1 buffer */
+		STP_DBG_INFO_FUNC("Put %d bytes to L1 buf\n", len);
+
+		osal_memcpy(&cprs->L1_buf[cprs->L1_pos], buf, len);
+		cprs->L1_pos += len;
+	}
+
+	return ret;
+}
+
+/* wcn_compressor_out - get the result data from L2 buffer
+ * @ cprs - compressor's pointer
+ * @ pbuf - point to L2 buffer
+ * @ plen - out len
+ *
+ * Retunr 0 if success, else NULL
+ */
+INT32 wcn_compressor_out(P_WCN_COMPRESSOR_T cprs, PUINT8 *pbuf, PINT32 plen)
+{
+	INT32 ret = 0;
+	INT32 tmp_len = 0;
+
+	if ((!cprs) || (!pbuf) || (!plen)) {
+		STP_DBG_ERR_FUNC("invalid para!\n");
+		return -1;
+	}
+	/* check if there's L1 data need flush to L2 buffer */
+	if (cprs->L1_pos > 0) {
+		tmp_len = cprs->L2_buf_sz - cprs->L2_pos;
+
+		if (cprs->f_compress_en && cprs->handler) {
+			/* need compress */
+			ret =
+			    cprs->handler(cprs->worker, cprs->L1_buf, cprs->L1_pos, &cprs->L2_buf[cprs->L2_pos],
+					  &tmp_len, 1);
+
+			if (!ret) {
+				cprs->crc32 = (crc32(cprs->crc32, cprs->L1_buf, cprs->L1_pos));
+				cprs->L2_pos += tmp_len;
+
+				/* Add 8 byte suffix
+				   ===
+				   32 bits UNCOMPRESS SIZE
+				   32 bits CRC
+				 */
+				*(uint32_t *) (&cprs->L2_buf[cprs->L2_pos]) = (cprs->crc32 ^ 0xffffffffUL);
+				*(uint32_t *) (&cprs->L2_buf[cprs->L2_pos + 4]) = cprs->uncomp_size;
+				cprs->L2_pos += 8;
+
+				STP_DBG_INFO_FUNC("compress OK!\n");
+			} else {
+				STP_DBG_ERR_FUNC("compress error!\n");
+			}
+		} else {
+			/* no need compress */
+			tmp_len = (cprs->L1_pos > tmp_len) ? tmp_len : cprs->L1_pos;
+			osal_memcpy(&cprs->L2_buf[cprs->L2_pos], cprs->L1_buf, tmp_len);
+			cprs->L2_pos += tmp_len;
+		}
+
+		cprs->L1_pos = 0;
+	}
+
+	*pbuf = cprs->L2_buf;
+	*plen = cprs->L2_pos;
+
+	STP_DBG_INFO_FUNC("0x%zx, len %d\n", (SIZE_T)*pbuf, *plen);
+
+	return 0;
+}
+
+/* wcn_compressor_reset - reset compressor
+ * @ cprs - compressor's pointer
+ * @ enable - enable/disable compress
+ * @ type - compress algorithm
+ *
+ * Retunr 0 if success, else NULL
+ */
+INT32 wcn_compressor_reset(P_WCN_COMPRESSOR_T cprs, UINT8 enable, WCN_COMPRESS_ALG_T type)
+{
+	if (!cprs) {
+		STP_DBG_ERR_FUNC("invalid para!\n");
+		return -1;
+	}
+
+	cprs->f_compress_en = enable;
+	/* cprs->f_compress_en = 0; // disable compress for test */
+	cprs->compress_type = type;
+	cprs->L1_pos = 0;
+	cprs->L2_pos = 0;
+	cprs->uncomp_size = 0;
+	cprs->crc32 = 0xffffffffUL;
+
+	/* zlib_deflateEnd((z_stream*)cprs->worker); */
+
+	STP_DBG_INFO_FUNC("OK! compress algorithm %d\n", type);
+
+	return 0;
+}
+
+static void stp_dbg_dump_data(unsigned char *pBuf, char *title, int len)
+{
+	int k = 0;
+
+	pr_debug(" %s-len:%d\n", title, len);
+
+	for (k = 0; k < len; k++) {
+		if (k % 16 == 0 && k != 0)
+			pr_cont("\n    ");
+		pr_cont("0x%02x ", pBuf[k]);
+	}
+	pr_debug("--end\n");
+}
+
+static int _stp_dbg_enable(MTKSTP_DBG_T *stp_dbg)
+{
+
+	unsigned long flags;
+
+	spin_lock_irqsave(&(stp_dbg->logsys->lock), flags);
+	stp_dbg->pkt_trace_no = 0;
+	stp_dbg->is_enable = 1;
+	spin_unlock_irqrestore(&(stp_dbg->logsys->lock), flags);
+
+	return 0;
+}
+
+static int _stp_dbg_disable(MTKSTP_DBG_T *stp_dbg)
+{
+
+	unsigned long flags;
+
+	spin_lock_irqsave(&(stp_dbg->logsys->lock), flags);
+	stp_dbg->pkt_trace_no = 0;
+	memset(stp_dbg->logsys, 0, sizeof(MTKSTP_LOG_SYS_T));
+	stp_dbg->is_enable = 0;
+	spin_unlock_irqrestore(&(stp_dbg->logsys->lock), flags);
+
+	return 0;
+}
+
+static int _stp_dbg_dmp_in(MTKSTP_DBG_T *stp_dbg, char *buf, int len)
+{
+	unsigned long flags;
+	STP_DBG_HDR_T *pHdr = NULL;
+	char *pBuf = NULL;
+	unsigned int length = 0;
+	unsigned int internalFlag = stp_dbg->logsys->size < STP_DBG_LOG_ENTRY_NUM;
+	/* #ifdef CONFIG_LOG_STP_INTERNAL */
+	/* Here we record log in this circle buffer, if buffer is full ,
+	select to overlap earlier log, logic should be okay */
+	internalFlag = 1;
+	/* #endif */
+	spin_lock_irqsave(&(stp_dbg->logsys->lock), flags);
+
+	if (internalFlag) {
+		stp_dbg->logsys->queue[stp_dbg->logsys->in].id = 0;
+		stp_dbg->logsys->queue[stp_dbg->logsys->in].len = len;
+		memset(&(stp_dbg->logsys->queue[stp_dbg->logsys->in].buffer[0]),
+		       0, ((len >= STP_DBG_LOG_ENTRY_SZ) ? (STP_DBG_LOG_ENTRY_SZ) : (len)));
+		memcpy(&(stp_dbg->logsys->queue[stp_dbg->logsys->in].buffer[0]),
+		       buf, ((len >= STP_DBG_LOG_ENTRY_SZ) ? (STP_DBG_LOG_ENTRY_SZ) : (len)));
+
+		stp_dbg->logsys->size++;
+		stp_dbg->logsys->size =
+		    (stp_dbg->logsys->size > STP_DBG_LOG_ENTRY_NUM) ? STP_DBG_LOG_ENTRY_NUM : stp_dbg->logsys->size;
+
+		if (0 != gStpDbgLogOut) {
+			pHdr = (STP_DBG_HDR_T *) &(stp_dbg->logsys->queue[stp_dbg->logsys->in].buffer[0]);
+			pBuf = (char *)&(stp_dbg->logsys->queue[stp_dbg->logsys->in].buffer[0]) + sizeof(STP_DBG_HDR_T);
+			length = stp_dbg->logsys->queue[stp_dbg->logsys->in].len - sizeof(STP_DBG_HDR_T);
+			pr_debug("STP-DBG:%d.%ds, %s:pT%sn(%d)l(%d)s(%d)a(%d)\n",
+			       pHdr->sec,
+			       pHdr->usec,
+			       pHdr->dir == PKT_DIR_TX ? "Tx" : "Rx",
+			       gStpDbgType[pHdr->type], pHdr->no, pHdr->len, pHdr->seq, pHdr->ack);
+			if (0 < length)
+				stp_dbg_dump_data(pBuf, pHdr->dir == PKT_DIR_TX ? "Tx" : "Rx", length);
+		}
+		stp_dbg->logsys->in =
+		    (stp_dbg->logsys->in >= (STP_DBG_LOG_ENTRY_NUM - 1)) ? (0) : (stp_dbg->logsys->in + 1);
+		STP_DBG_DBG_FUNC("logsys size = %d, in = %d\n", stp_dbg->logsys->size, stp_dbg->logsys->in);
+	} else {
+		STP_DBG_WARN_FUNC("logsys FULL!\n");
+	}
+
+	spin_unlock_irqrestore(&(stp_dbg->logsys->lock), flags);
+
+	return 0;
+}
+
+int stp_gdb_notify_btm_dmp_wq(MTKSTP_DBG_T *stp_dbg)
+{
+	int retval = 0;
+/* #ifndef CONFIG_LOG_STP_INTERNAL */
+
+	if (stp_dbg->btm != NULL)
+		retval += stp_btm_notify_wmt_dmp_wq((MTKSTP_BTM_T *) stp_dbg->btm);
+/* #endif */
+
+	return retval;
+}
+
+int stp_dbg_log_ctrl(unsigned int on)
+{
+	if (on != 0) {
+		gStpDbgLogOut = 1;
+		pr_debug("STP-DBG: enable pkt log dump out.\n");
+	} else {
+		gStpDbgLogOut = 0;
+		pr_debug("STP-DBG: disable pkt log dump out.\n");
+	}
+	return 0;
+}
+
+int stp_dbg_dmp_in(MTKSTP_DBG_T *stp_dbg, char *buf, int len)
+{
+	return _stp_dbg_dmp_in(stp_dbg, buf, len);
+}
+
+int stp_dbg_dmp_printk(MTKSTP_DBG_T *stp_dbg)
+{
+#define MAX_DMP_NUM 80
+	unsigned long flags;
+	char *pBuf = NULL;
+	int len = 0;
+	STP_DBG_HDR_T *pHdr = NULL;
+	UINT32 dumpSize = 0;
+	UINT32 inIndex = 0;
+	UINT32 outIndex = 0;
+
+	spin_lock_irqsave(&(stp_dbg->logsys->lock), flags);
+	/* Not to dequeue from loging system */
+	inIndex = stp_dbg->logsys->in;
+	dumpSize = stp_dbg->logsys->size;
+	if (STP_DBG_LOG_ENTRY_NUM == dumpSize)
+		outIndex = inIndex;
+	else
+		outIndex = ((inIndex + STP_DBG_LOG_ENTRY_NUM) - dumpSize) % STP_DBG_LOG_ENTRY_NUM;
+
+	if (dumpSize > MAX_DMP_NUM) {
+
+		outIndex += (dumpSize - MAX_DMP_NUM);
+		outIndex %= STP_DBG_LOG_ENTRY_NUM;
+		dumpSize = MAX_DMP_NUM;
+
+	}
+	STP_DBG_INFO_FUNC("loged packet size = %d, in(%d), out(%d)\n", dumpSize, inIndex, outIndex);
+	while (dumpSize > 0) {
+		pHdr = (STP_DBG_HDR_T *) &(stp_dbg->logsys->queue[outIndex].buffer[0]);
+		pBuf = &(stp_dbg->logsys->queue[outIndex].buffer[0]) + sizeof(STP_DBG_HDR_T);
+		len = stp_dbg->logsys->queue[outIndex].len - sizeof(STP_DBG_HDR_T);
+		len = len > STP_PKT_SZ ? STP_PKT_SZ : len;
+		pr_debug("STP-DBG:%d.%ds, %s:pT%sn(%d)l(%d)s(%d)a(%d)\n",
+		       pHdr->sec,
+		       pHdr->usec,
+		       pHdr->dir == PKT_DIR_TX ? "Tx" : "Rx",
+		       gStpDbgType[pHdr->type], pHdr->no, pHdr->len, pHdr->seq, pHdr->ack);
+
+		if (0 < len)
+			stp_dbg_dump_data(pBuf, pHdr->dir == PKT_DIR_TX ? "Tx" : "Rx", len);
+		outIndex = (outIndex >= (STP_DBG_LOG_ENTRY_NUM - 1)) ? (0) : (outIndex + 1);
+		dumpSize--;
+
+	}
+
+	spin_unlock_irqrestore(&(stp_dbg->logsys->lock), flags);
+
+	return 0;
+}
+
+int stp_dbg_dmp_out_ex(char *buf, int *len)
+{
+	return stp_dbg_dmp_out(g_stp_dbg, buf, len);
+}
+
+int stp_dbg_dmp_out(MTKSTP_DBG_T *stp_dbg, char *buf, int *len)
+{
+
+	unsigned long flags;
+	int remaining = 0;
+	*len = 0;
+	spin_lock_irqsave(&(stp_dbg->logsys->lock), flags);
+
+	if (stp_dbg->logsys->size > 0) {
+		memcpy(buf, &(stp_dbg->logsys->queue[stp_dbg->logsys->out].buffer[0]),
+		       stp_dbg->logsys->queue[stp_dbg->logsys->out].len);
+
+		(*len) = stp_dbg->logsys->queue[stp_dbg->logsys->out].len;
+		stp_dbg->logsys->out =
+		    (stp_dbg->logsys->out >= (STP_DBG_LOG_ENTRY_NUM - 1)) ? (0) : (stp_dbg->logsys->out + 1);
+		stp_dbg->logsys->size--;
+
+		STP_DBG_DBG_FUNC("logsys size = %d, out = %d\n", stp_dbg->logsys->size, stp_dbg->logsys->out);
+	} else {
+		STP_DBG_LOUD_FUNC("logsys EMPTY!\n");
+	}
+
+	remaining = (stp_dbg->logsys->size == 0) ? (0) : (1);
+
+	spin_unlock_irqrestore(&(stp_dbg->logsys->lock), flags);
+
+	return remaining;
+}
+
+static int stp_dbg_fill_hdr(struct stp_dbg_pkt_hdr *hdr, int type, int ack, int seq, int crc, int dir, int len,
+			    int dbg_type)
+{
+
+	struct timeval now;
+
+	if (!hdr) {
+		STP_DBG_ERR_FUNC("function invalid\n");
+		return -EINVAL;
+	}
+	do_gettimeofday(&now);
+	hdr->dbg_type = dbg_type;
+	hdr->ack = ack;
+	hdr->seq = seq;
+	hdr->sec = now.tv_sec;
+	hdr->usec = now.tv_usec;
+	hdr->crc = crc;
+	hdr->dir = dir;	/* rx */
+	hdr->dmy = 0xffffffff;
+	hdr->len = len;
+	hdr->type = type;
+	return 0;
+
+}
+
+static int stp_dbg_add_pkt(MTKSTP_DBG_T *stp_dbg, struct stp_dbg_pkt_hdr *hdr, const unsigned char *body)
+{
+	/* fix the frame size large issues. */
+	static struct stp_dbg_pkt stp_pkt;
+	uint32_t hdr_sz = sizeof(struct stp_dbg_pkt_hdr);
+	uint32_t body_sz = 0;
+
+	BUG_ON(!stp_dbg);
+
+	if (hdr->dbg_type == STP_DBG_PKT)
+		body_sz = (hdr->len <= STP_PKT_SZ) ? (hdr->len) : (STP_PKT_SZ);
+	else
+		body_sz = (hdr->len <= STP_DMP_SZ) ? (hdr->len) : (STP_DMP_SZ);
+
+	hdr->no = stp_dbg->pkt_trace_no++;
+	memcpy((uint8_t *) &stp_pkt.hdr, (uint8_t *) hdr, hdr_sz);
+	if (body != NULL)
+		memcpy((uint8_t *) &stp_pkt.raw[0], body, body_sz);
+
+	_stp_dbg_dmp_in(stp_dbg, (char *)&stp_pkt, hdr_sz + body_sz);
+	/* Only FW DMP MSG should inform BTM-CORE to dump packet to native process */
+	if (hdr->dbg_type == STP_DBG_FW_DMP)
+		stp_gdb_notify_btm_dmp_wq(stp_dbg);
+
+	return 0;
+}
+
+int stp_dbg_log_pkt(MTKSTP_DBG_T *stp_dbg, int dbg_type,
+		    int type, int ack_no, int seq_no, int crc, int dir, int len, const unsigned char *body)
+{
+
+	struct stp_dbg_pkt_hdr hdr;
+
+	if (stp_dbg->is_enable == 0) {
+		/*dbg is disable,and not to log */
+	} else {
+		hdr.no = 0;
+		hdr.chs = 0;
+		stp_dbg_fill_hdr(&hdr,
+				 (int)type, (int)ack_no, (int)seq_no, (int)crc, (int)dir, (int)len, (int)dbg_type);
+
+		stp_dbg_add_pkt(stp_dbg, &hdr, body);
+	}
+
+	return 0;
+}
+
+int stp_dbg_enable(MTKSTP_DBG_T *stp_dbg)
+{
+	return _stp_dbg_enable(stp_dbg);
+}
+
+int stp_dbg_disable(MTKSTP_DBG_T *stp_dbg)
+{
+	return _stp_dbg_disable(stp_dbg);
+}
+
+static void stp_dbg_nl_init(void)
+{
+#if 0
+	if (genl_register_family(&stp_dbg_gnl_family) != 0) {
+		STP_DBG_ERR_FUNC("%s(): GE_NELINK family registration fail\n", __func__);
+	} else {
+		if (genl_register_ops(&stp_dbg_gnl_family, &stp_dbg_gnl_ops_bind) != 0)
+			STP_DBG_ERR_FUNC("%s(): BIND operation registration fail\n", __func__);
+
+		if (genl_register_ops(&stp_dbg_gnl_family, &stp_dbg_gnl_ops_reset) != 0)
+			STP_DBG_ERR_FUNC("%s(): RESET operation registration fail\n", __func__);
+
+	}
+#endif
+	if (genl_register_family_with_ops(&stp_dbg_gnl_family, stp_dbg_gnl_ops_array) != 0)
+		STP_DBG_ERR_FUNC("%s(): GE_NELINK family registration fail\n", __func__);
+}
+
+static void stp_dbg_nl_deinit(void)
+{
+	genl_unregister_family(&stp_dbg_gnl_family);
+}
+
+static int stp_dbg_nl_bind(struct sk_buff *skb, struct genl_info *info)
+{
+	struct nlattr *na;
+	char *mydata;
+
+	if (info == NULL)
+		goto out;
+
+	STP_DBG_INFO_FUNC("%s():->\n", __func__);
+
+	na = info->attrs[STP_DBG_ATTR_MSG];
+
+	if (na)
+		mydata = (char *)nla_data(na);
+
+	if (num_bind_process < MAX_BIND_PROCESS) {
+		bind_pid[num_bind_process] = info->snd_portid;
+		num_bind_process++;
+		STP_DBG_INFO_FUNC("%s():-> pid  = %d\n", __func__, info->snd_portid);
+	} else {
+		STP_DBG_ERR_FUNC("%s(): exceeding binding limit %d\n", __func__, MAX_BIND_PROCESS);
+	}
+
+out:
+	return 0;
+}
+
+static int stp_dbg_nl_reset(struct sk_buff *skb, struct genl_info *info)
+{
+	STP_DBG_ERR_FUNC("%s(): should not be invoked\n", __func__);
+
+	return 0;
+}
+
+INT8 stp_dbg_nl_send(PINT8 aucMsg, UINT8 cmd, INT32 len)
+{
+	struct sk_buff *skb = NULL;
+	void *msg_head = NULL;
+	int rc = -1;
+	int i;
+
+	if (num_bind_process == 0) {
+		/* no listening process */
+		STP_DBG_ERR_FUNC("%s(): the process is not invoked\n", __func__);
+		return 0;
+	}
+
+	for (i = 0; i < num_bind_process; i++) {
+		skb = genlmsg_new(2048, GFP_KERNEL);
+
+		if (skb) {
+			msg_head = genlmsg_put(skb, 0, stp_dbg_seqnum++, &stp_dbg_gnl_family, 0, cmd);
+			if (msg_head == NULL) {
+				nlmsg_free(skb);
+				STP_DBG_ERR_FUNC("%s(): genlmsg_put fail...\n", __func__);
+				return -1;
+			}
+
+			rc = nla_put(skb, STP_DBG_ATTR_MSG, len, aucMsg);
+			if (rc != 0) {
+				nlmsg_free(skb);
+				STP_DBG_ERR_FUNC("%s(): nla_put_string fail...%d\n", __func__, rc);
+				return -1;
+			}
+
+			/* finalize the message */
+			genlmsg_end(skb, msg_head);
+
+			/* sending message */
+			rc = genlmsg_unicast(&init_net, skb, bind_pid[i]);
+			if (rc != 0) {
+				STP_DBG_ERR_FUNC("%s(): genlmsg_unicast fail...\n", __func__);
+				return -1;
+			}
+		} else {
+			STP_DBG_ERR_FUNC("%s(): genlmsg_new fail...\n", __func__);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+INT32 stp_dbg_aee_send(unsigned char *aucMsg, INT32 len, INT32 cmd)
+{
+	INT32 ret = 0;
+
+	/* buffered to compressor */
+	ret = wcn_core_dump_in(g_core_dump, aucMsg, len);
+	if (ret == 1)
+		wcn_core_dump_flush(0, MTK_WCN_BOOL_FALSE);
+
+	return ret;
+}
+
+UINT8 *_stp_dbg_id_to_task(UINT32 id)
+{
+	UINT8 *taskStr[] = {
+		"Task_WMT",
+		"Task_BT",
+		"Task_Wifi",
+		"Task_Tst",
+		"Task_FM",
+		"Task_Idle",
+		"Task_DrvStp",
+		"Task_DrvBtif",
+		"Task_NatBt"
+	};
+	return taskStr[id];
+}
+
+INT32 _stp_dbg_parser_assert_str(PINT8 str, ENUM_ASSERT_INFO_PARSER_TYPE type)
+{
+	char *pStr = NULL;
+	char *pDtr = NULL;
+	char *pTemp = NULL;
+	char *pTemp2 = NULL;
+	char tempBuf[64] = { 0 };
+	UINT32 len = 0;
+	long res;
+	INT32 ret;
+
+	PUINT8 parser_sub_string[] = {
+		"<ASSERT> ",
+		"id=",
+		"isr=",
+		"irq=",
+		"rc="
+	};
+
+	if (!str) {
+		STP_DBG_ERR_FUNC("NULL string source\n");
+		return -1;
+	}
+
+	if (!g_stp_dbg_cpupcr) {
+		STP_DBG_ERR_FUNC("NULL pointer\n");
+		return -2;
+	}
+
+	pStr = str;
+	STP_DBG_DBG_FUNC("source infor:%s\n", pStr);
+	switch (type) {
+	case STP_DBG_ASSERT_INFO:
+		pDtr = osal_strstr(pStr, parser_sub_string[type]);
+		if (NULL != pDtr) {
+			pDtr += osal_strlen(parser_sub_string[type]);
+			pTemp = osal_strchr(pDtr, ' ');
+		} else {
+			STP_DBG_ERR_FUNC("parser str is NULL,substring(%s)\n", parser_sub_string[type]);
+			return -3;
+		}
+		len = pTemp - pDtr;
+		osal_memcpy(&g_stp_dbg_cpupcr->assert_info[0], "assert@", osal_strlen("assert@"));
+		osal_memcpy(&g_stp_dbg_cpupcr->assert_info[osal_strlen("assert@")], pDtr, len);
+		g_stp_dbg_cpupcr->assert_info[osal_strlen("assert@") + len] = '_';
+
+		pTemp = osal_strchr(pDtr, '#');
+		pTemp += 1;
+
+		pTemp2 = osal_strchr(pTemp, ' ');
+		osal_memcpy(&g_stp_dbg_cpupcr->assert_info[osal_strlen("assert@") + len + 1], pTemp, pTemp2 - pTemp);
+		g_stp_dbg_cpupcr->assert_info[osal_strlen("assert@") + len + 1 + pTemp2 - pTemp] = '\0';
+		STP_DBG_INFO_FUNC("assert info:%s\n", &g_stp_dbg_cpupcr->assert_info[0]);
+		break;
+	case STP_DBG_FW_TASK_ID:
+		pDtr = osal_strstr(pStr, parser_sub_string[type]);
+		if (NULL != pDtr) {
+			pDtr += osal_strlen(parser_sub_string[type]);
+			pTemp = osal_strchr(pDtr, ' ');
+		} else {
+			STP_DBG_ERR_FUNC("parser str is NULL,substring(%s)\n", parser_sub_string[type]);
+			return -3;
+		}
+		len = pTemp - pDtr;
+		osal_memcpy(&tempBuf[0], pDtr, len);
+		tempBuf[len] = '\0';
+		ret = osal_strtol(tempBuf, 16, &res);
+		if (ret) {
+			STP_DBG_ERR_FUNC("get fw task id fail(%d)\n", ret);
+			return -4;
+		}
+		g_stp_dbg_cpupcr->fwTaskId = (UINT32)res;
+
+		STP_DBG_INFO_FUNC("fw task id :%x\n", (UINT32)res);
+		break;
+	case STP_DBG_FW_ISR:
+		pDtr = osal_strstr(pStr, parser_sub_string[type]);
+		if (NULL != pDtr) {
+			pDtr += osal_strlen(parser_sub_string[type]);
+			pTemp = osal_strchr(pDtr, ',');
+		} else {
+			STP_DBG_ERR_FUNC("parser str is NULL,substring(%s)\n", parser_sub_string[type]);
+			return -3;
+		}
+		len = pTemp - pDtr;
+		osal_memcpy(&tempBuf[0], pDtr, len);
+		tempBuf[len] = '\0';
+		ret = osal_strtol(tempBuf, 16, &res);
+		if (ret) {
+			STP_DBG_ERR_FUNC("get fw isr id fail(%d)\n", ret);
+			return -4;
+		}
+		g_stp_dbg_cpupcr->fwIsr = (UINT32)res;
+
+		STP_DBG_INFO_FUNC("fw isr str:%x\n", (UINT32)res);
+		break;
+	case STP_DBG_FW_IRQ:
+		pDtr = osal_strstr(pStr, parser_sub_string[type]);
+		if (NULL != pDtr) {
+			pDtr += osal_strlen(parser_sub_string[type]);
+			pTemp = osal_strchr(pDtr, ',');
+		} else {
+			STP_DBG_ERR_FUNC("parser str is NULL,substring(%s)\n", parser_sub_string[type]);
+			return -3;
+		}
+		len = pTemp - pDtr;
+		osal_memcpy(&tempBuf[0], pDtr, len);
+		tempBuf[len] = '\0';
+		ret = osal_strtol(tempBuf, 16, &res);
+		if (ret) {
+			STP_DBG_ERR_FUNC("get fw irq id fail(%d)\n", ret);
+			return -4;
+		}
+		g_stp_dbg_cpupcr->fwRrq = (UINT32)res;
+
+		STP_DBG_INFO_FUNC("fw irq value:%x\n", (UINT32)res);
+		break;
+	case STP_DBG_ASSERT_TYPE:
+		pDtr = osal_strstr(pStr, parser_sub_string[type]);
+		if (NULL != pDtr) {
+			pDtr += osal_strlen(parser_sub_string[type]);
+			pTemp = osal_strchr(pDtr, ',');
+		} else {
+			STP_DBG_ERR_FUNC("parser str is NULL,substring(%s)\n", parser_sub_string[type]);
+			return -3;
+		}
+		len = pTemp - pDtr;
+		osal_memcpy(&tempBuf[0], pDtr, len);
+		tempBuf[len] = '\0';
+
+		if (0 == osal_memcmp(tempBuf, "*", len))
+			osal_memcpy(&g_stp_dbg_cpupcr->assert_type[0], "general assert", osal_strlen("general assert"));
+		if (0 == osal_memcmp(tempBuf, "Watch Dog Timeout", len))
+			osal_memcpy(&g_stp_dbg_cpupcr->assert_type[0], "wdt", osal_strlen("wdt"));
+		if (0 == osal_memcmp(tempBuf, "RB_FULL", osal_strlen("RB_FULL"))) {
+			osal_memcpy(&g_stp_dbg_cpupcr->assert_type[0], tempBuf, len);
+
+			pDtr = osal_strstr(&g_stp_dbg_cpupcr->assert_type[0], "RB_FULL(");
+			if (NULL != pDtr) {
+				pDtr += osal_strlen("RB_FULL(");
+				pTemp = osal_strchr(pDtr, ')');
+			} else {
+				STP_DBG_ERR_FUNC("parser str is NULL,substring(RB_FULL()\n");
+				return -4;
+			}
+			len = pTemp - pDtr;
+			osal_memcpy(&tempBuf[0], pDtr, len);
+			tempBuf[len] = '\0';
+			ret = osal_strtol(tempBuf, 16, &res);
+			if (ret) {
+				STP_DBG_ERR_FUNC("get fw task id fail(%d)\n", ret);
+				return -5;
+			}
+			g_stp_dbg_cpupcr->fwTaskId = (UINT32)res;
+
+			STP_DBG_INFO_FUNC("update fw task id :%x\n", (UINT32)res);
+		}
+
+		STP_DBG_INFO_FUNC("fw asert type:%s\n", g_stp_dbg_cpupcr->assert_type);
+		break;
+	default:
+		STP_DBG_ERR_FUNC("unknown parser type\n");
+		break;
+	}
+
+	return 0;
+}
+
+P_STP_DBG_CPUPCR_T stp_dbg_cpupcr_init(VOID)
+{
+	P_STP_DBG_CPUPCR_T pSdCpupcr = NULL;
+
+	pSdCpupcr = (P_STP_DBG_CPUPCR_T) osal_malloc(osal_sizeof(STP_DBG_CPUPCR_T));
+	if (!pSdCpupcr) {
+		STP_DBG_ERR_FUNC("stp dbg cpupcr allocate memory fail!\n");
+		return NULL;
+	}
+
+	osal_memset(pSdCpupcr, 0, osal_sizeof(STP_DBG_CPUPCR_T));
+
+	osal_sleepable_lock_init(&pSdCpupcr->lock);
+
+	return pSdCpupcr;
+}
+
+P_STP_DBG_DMAREGS_T stp_dbg_dmaregs_init(VOID)
+{
+	P_STP_DBG_DMAREGS_T pDmaRegs = NULL;
+
+	pDmaRegs = (P_STP_DBG_DMAREGS_T) osal_malloc(osal_sizeof(STP_DBG_DMAREGS_T));
+	if (!pDmaRegs) {
+		STP_DBG_ERR_FUNC("stp dbg dmareg allocate memory fail!\n");
+		return NULL;
+	}
+
+	osal_memset(pDmaRegs, 0, osal_sizeof(STP_DBG_DMAREGS_T));
+
+	osal_sleepable_lock_init(&pDmaRegs->lock);
+
+	return pDmaRegs;
+}
+
+VOID stp_dbg_cpupcr_deinit(P_STP_DBG_CPUPCR_T pCpupcr)
+{
+	if (pCpupcr) {
+		osal_sleepable_lock_deinit(&pCpupcr->lock);
+		osal_free(pCpupcr);
+		pCpupcr = NULL;
+	}
+}
+
+VOID stp_dbg_dmaregs_deinit(P_STP_DBG_DMAREGS_T pDmaRegs)
+{
+	if (pDmaRegs) {
+		osal_sleepable_lock_deinit(&pDmaRegs->lock);
+		osal_free(pDmaRegs);
+		pDmaRegs = NULL;
+	}
+}
+
+INT32 stp_dbg_poll_cpupcr(UINT32 times, UINT32 sleep, UINT32 cmd)
+{
+	INT32 i = 0;
+
+	if (!g_stp_dbg_cpupcr) {
+		STP_DBG_ERR_FUNC("NULL reference pointer\n");
+		return -1;
+	}
+
+	if (!cmd) {
+		if (g_stp_dbg_cpupcr->count + times > STP_DBG_CPUPCR_NUM)
+			times = STP_DBG_CPUPCR_NUM - g_stp_dbg_cpupcr->count;
+
+		osal_lock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+
+		for (i = 0; i < times; i++) {
+			STP_DBG_INFO_FUNC("i:%d,cpupcr:%08x\n", i, wmt_plat_read_cpupcr());
+			/* osal_memcpy(
+			* &g_stp_dbg_cpupcr->buffer[i],
+			* (UINT8*)(CONSYS_REG_READ(CONSYS_CPUPCR_REG)),
+			* osal_sizeof(UINT32));
+			*/
+			g_stp_dbg_cpupcr->buffer[g_stp_dbg_cpupcr->count + i] = wmt_plat_read_cpupcr();
+			osal_sleep_ms(sleep);
+		}
+		g_stp_dbg_cpupcr->count += times;
+
+		osal_unlock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+	} else {
+		STP_DBG_INFO_FUNC("stp-dbg: for proc test polling cpupcr\n");
+		if (times > STP_DBG_CPUPCR_NUM)
+			times = STP_DBG_CPUPCR_NUM;
+
+		osal_lock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+		g_stp_dbg_cpupcr->count = 0;
+		for (i = 0; i < times; i++) {
+			STP_DBG_INFO_FUNC("i:%d,cpupcr:%08x\n", i, wmt_plat_read_cpupcr());
+			/* osal_memcpy(
+			* &g_stp_dbg_cpupcr->buffer[i],
+			* (UINT8*)(CONSYS_REG_READ(CONSYS_CPUPCR_REG)),
+			* osal_sizeof(UINT32));
+			*/
+			g_stp_dbg_cpupcr->buffer[i] = wmt_plat_read_cpupcr();
+			osal_sleep_ms(sleep);
+		}
+		g_stp_dbg_cpupcr->count = times;
+
+		osal_unlock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+
+	}
+	return 0;
+}
+
+INT32 stp_dbg_poll_dmaregs(UINT32 times, UINT32 sleep)
+{
+#if 0
+	INT32 i = 0;
+
+	if (!g_stp_dbg_dmaregs) {
+		STP_DBG_ERR_FUNC("NULL reference pointer\n");
+		return -1;
+	}
+
+	osal_lock_sleepable_lock(&g_stp_dbg_dmaregs->lock);
+
+	if (g_stp_dbg_dmaregs->count + times > STP_DBG_DMAREGS_NUM) {
+		if (g_stp_dbg_dmaregs->count > STP_DBG_DMAREGS_NUM) {
+			STP_DBG_ERR_FUNC("g_stp_dbg_dmaregs->count:%d must less than STP_DBG_DMAREGS_NUM:%d\n",
+				g_stp_dbg_dmaregs->count, STP_DBG_DMAREGS_NUM);
+			g_stp_dbg_dmaregs->count = 0;
+			STP_DBG_ERR_FUNC("g_stp_dbg_dmaregs->count be set default value 0\n");
+		}
+		times = STP_DBG_DMAREGS_NUM - g_stp_dbg_dmaregs->count;
+	}
+	if (times > STP_DBG_DMAREGS_NUM) {
+		STP_DBG_ERR_FUNC("times overflow, set default value:0\n");
+		times = 0;
+	}
+	STP_DBG_WARN_FUNC("---------Now Polling DMA relative Regs -------------\n");
+	for (i = 0; i < times; i++) {
+		INT32 k = 0;
+
+		for (; k < DMA_REGS_MAX; k++) {
+			STP_DBG_WARN_FUNC("times:%d,i:%d reg: %s, regs:%08x\n", times, i, dmaRegsStr[k],
+					  wmt_plat_read_dmaregs(k));
+			/* g_stp_dbg_dmaregs->dmaIssue[k][g_stp_dbg_dmaregs->count + i] = wmt_plat_read_dmaregs(k); */
+		}
+		osal_sleep_ms(sleep);
+	}
+	STP_DBG_WARN_FUNC("---------Polling DMA relative Regs End-------------\n");
+	g_stp_dbg_dmaregs->count += times;
+
+	osal_unlock_sleepable_lock(&g_stp_dbg_dmaregs->lock);
+#else
+	return 0;
+#endif
+}
+
+INT32 stp_dbg_poll_cuppcr_ctrl(UINT32 en)
+{
+
+	STP_DBG_INFO_FUNC("%s polling cpupcr\n", en == 0 ? "start" : "stop");
+
+	osal_lock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+	g_stp_dbg_cpupcr->stop_flag = en;
+	osal_unlock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+	return 0;
+}
+
+INT32 stp_dbg_set_version_info(UINT32 chipid, UINT8 *pRomVer, UINT8 *pPatchVer, UINT8 *pPatchBrh)
+{
+	if (g_stp_dbg_cpupcr) {
+		osal_lock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+		g_stp_dbg_cpupcr->chipId = chipid;
+
+		if (pRomVer)
+			osal_memcpy(g_stp_dbg_cpupcr->romVer, pRomVer, 2);
+		if (pPatchVer)
+			osal_memcpy(g_stp_dbg_cpupcr->patchVer, pPatchVer, 8);
+		if (pPatchBrh)
+			osal_memcpy(g_stp_dbg_cpupcr->branchVer, pPatchBrh, 4);
+
+		osal_unlock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+	} else {
+		STP_DBG_ERR_FUNC("NULL pointer\n");
+		return -1;
+	}
+	STP_DBG_INFO_FUNC("chipid(0x%x),romver(%s),patchver(%s),branchver(%s)\n", g_stp_dbg_cpupcr->chipId,
+		&g_stp_dbg_cpupcr->romVer[0], &g_stp_dbg_cpupcr->patchVer[0], &g_stp_dbg_cpupcr->branchVer[0]);
+	return 0;
+}
+INT32 stp_dbg_set_wifiver(UINT32 wifiver)
+{
+	if (g_stp_dbg_cpupcr) {
+		osal_lock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+		g_stp_dbg_cpupcr->wifiVer = wifiver;
+		osal_unlock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+	} else {
+		STP_DBG_ERR_FUNC("NULL pointer\n");
+		return -1;
+	}
+	STP_DBG_INFO_FUNC("wifiver(%x)\n", g_stp_dbg_cpupcr->wifiVer);
+	return 0;
+}
+
+INT32 stp_dbg_set_host_assert_info(UINT32 drv_type, UINT32 reason, UINT32 en)
+{
+	osal_lock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+
+	g_stp_dbg_cpupcr->host_assert_info.assert_from_host = en;
+	g_stp_dbg_cpupcr->host_assert_info.drv_type = drv_type;
+	g_stp_dbg_cpupcr->host_assert_info.reason = reason;
+
+	osal_unlock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+
+	return 0;
+}
+
+UINT32 stp_dbg_get_host_trigger_assert(VOID)
+{
+	return g_stp_dbg_cpupcr->host_assert_info.assert_from_host;
+}
+
+INT32 stp_dbg_set_fw_info(UINT8 *issue_info, UINT32 len, ENUM_STP_FW_ISSUE_TYPE issue_type)
+{
+	ENUM_ASSERT_INFO_PARSER_TYPE type_index;
+	PUINT8 tempbuf = NULL;
+	UINT32 i = 0;
+	INT32 iRet = 0;
+
+	if (NULL == issue_info) {
+		STP_DBG_ERR_FUNC("null issue infor\n");
+		return -1;
+	}
+	STP_DBG_INFO_FUNC("issue type(%d)\n", issue_type);
+	g_stp_dbg_cpupcr->issue_type = issue_type;
+	osal_memset(&g_stp_dbg_cpupcr->assert_info[0], 0, STP_ASSERT_INFO_SIZE);
+
+	/*print patch version when assert happened */
+	STP_DBG_INFO_FUNC("=======================================\n");
+	STP_DBG_INFO_FUNC("[consys patch]patch version:%s\n", g_stp_dbg_cpupcr->patchVer);
+	STP_DBG_INFO_FUNC("[consys patch]ALPS branch:%s\n", g_stp_dbg_cpupcr->branchVer);
+	STP_DBG_INFO_FUNC("=======================================\n");
+
+	if ((STP_FW_ASSERT_ISSUE == issue_type) ||
+	    (STP_HOST_TRIGGER_FW_ASSERT == issue_type) || (STP_HOST_TRIGGER_ASSERT_TIMEOUT == issue_type)) {
+		if ((STP_FW_ASSERT_ISSUE == issue_type) || (STP_HOST_TRIGGER_FW_ASSERT == issue_type)) {
+			tempbuf = osal_malloc(len + 1);
+			if (!tempbuf)
+				return -2;
+
+			osal_memcpy(&tempbuf[0], issue_info, len);
+
+			for (i = 0; i < len; i++) {
+				if (tempbuf[i] == '\0')
+					tempbuf[i] = '?';
+			}
+
+			tempbuf[len] = '\0';
+
+			for (type_index = STP_DBG_ASSERT_INFO; type_index < STP_DBG_PARSER_TYPE_MAX; type_index++)
+				iRet += _stp_dbg_parser_assert_str(&tempbuf[0], type_index);
+
+			if (iRet)
+				STP_DBG_ERR_FUNC("passert assert infor fail(%d)\n", iRet);
+
+		}
+		if ((STP_HOST_TRIGGER_FW_ASSERT == issue_type) || (STP_HOST_TRIGGER_ASSERT_TIMEOUT == issue_type)) {
+			switch (g_stp_dbg_cpupcr->host_assert_info.drv_type) {
+			case 0:
+				STP_DBG_INFO_FUNC("BT trigger assert\n");
+				osal_lock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+				if (31 != g_stp_dbg_cpupcr->host_assert_info.reason)
+					/*BT firmware trigger assert */
+				{
+					g_stp_dbg_cpupcr->fwTaskId = 1;
+
+				} else
+					/*BT stack trigger assert */
+				{
+					g_stp_dbg_cpupcr->fwTaskId = 8;
+				}
+
+				g_stp_dbg_cpupcr->host_assert_info.assert_from_host = 0;
+				/* g_stp_dbg_cpupcr->host_assert_info.drv_type = 0; */
+				/* g_stp_dbg_cpupcr->host_assert_info.reason = 0; */
+
+				osal_unlock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+
+				break;
+			case 4:
+				STP_DBG_INFO_FUNC("WMT trigger assert\n");
+				osal_lock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+				if (STP_HOST_TRIGGER_ASSERT_TIMEOUT == issue_type)
+					osal_memcpy(&g_stp_dbg_cpupcr->assert_info[0], issue_info, len);
+
+				if ((38 == g_stp_dbg_cpupcr->host_assert_info.reason) ||
+				    (39 == g_stp_dbg_cpupcr->host_assert_info.reason) ||
+				    (40 == g_stp_dbg_cpupcr->host_assert_info.reason))
+					g_stp_dbg_cpupcr->fwTaskId = 6;	/* HOST schedule reason trigger */
+				else
+					g_stp_dbg_cpupcr->fwTaskId = 0;	/* Must be firmware reason */
+				g_stp_dbg_cpupcr->host_assert_info.assert_from_host = 0;
+				osal_unlock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+				break;
+			default:
+				break;
+			}
+
+		}
+		osal_free(tempbuf);
+	} else if (STP_FW_NOACK_ISSUE == issue_type) {
+		osal_lock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+		osal_memcpy(&g_stp_dbg_cpupcr->assert_info[0], issue_info, len);
+		g_stp_dbg_cpupcr->fwTaskId = 6;
+		g_stp_dbg_cpupcr->fwRrq = 0;
+		g_stp_dbg_cpupcr->fwIsr = 0;
+		osal_unlock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+	} else if (STP_DBG_PROC_TEST == issue_type) {
+		osal_lock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+		osal_memcpy(&g_stp_dbg_cpupcr->assert_info[0], issue_info, len);
+		g_stp_dbg_cpupcr->fwTaskId = 0;
+		g_stp_dbg_cpupcr->fwRrq = 0;
+		g_stp_dbg_cpupcr->fwIsr = 0;
+		osal_unlock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+	} else if (STP_FW_WARM_RST_ISSUE == issue_type) {
+		osal_lock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+		osal_memcpy(&g_stp_dbg_cpupcr->assert_info[0], issue_info, len);
+		g_stp_dbg_cpupcr->fwTaskId = 0;
+		g_stp_dbg_cpupcr->fwRrq = 0;
+		g_stp_dbg_cpupcr->fwIsr = 0;
+		osal_unlock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+	} else {
+		STP_DBG_ERR_FUNC("invalid issue type(%d)\n", issue_type);
+		return -3;
+	}
+
+	return iRet;
+}
+
+INT32 stp_dbg_cpupcr_infor_format(PPUINT8 buf, PUINT32 str_len)
+{
+	UINT32 len = 0;
+	UINT32 i = 0;
+
+	if (!g_stp_dbg_cpupcr) {
+		STP_DBG_ERR_FUNC("NULL pointer\n");
+		return -1;
+	}
+
+	/*format common information about issue */
+	len = osal_sprintf(*buf, "<main>\n\t");
+	len += osal_sprintf(*buf + len, "<chipid>\n\t\tMT%x\n\t</chipid>\n\t", g_stp_dbg_cpupcr->chipId);
+	len += osal_sprintf(*buf + len, "<version>\n\t\t");
+	len += osal_sprintf(*buf + len, "<rom>%s</rom>\n\t\t", g_stp_dbg_cpupcr->romVer);
+	if (!(osal_memcmp(g_stp_dbg_cpupcr->branchVer, "ALPS", strlen("ALPS"))))
+		len += osal_sprintf(*buf + len, "<branch>Internal Dev</branch>\n\t\t", g_stp_dbg_cpupcr->branchVer);
+	else
+		len += osal_sprintf(*buf + len, "<branch>W%sMP</branch>\n\t\t", g_stp_dbg_cpupcr->branchVer);
+
+	len += osal_sprintf(*buf + len, "<patch>%s</patch>\n\t\t", g_stp_dbg_cpupcr->patchVer);
+
+	if (0 == g_stp_dbg_cpupcr->wifiVer)
+		len += osal_sprintf(*buf + len, "<wifi>NULL</wifi>\n\t");
+	else
+		len += osal_sprintf(*buf + len, "<wifi>0x%X.%X</wifi>\n\t",
+		(UINT8)((g_stp_dbg_cpupcr->wifiVer & 0xFF00)>>8), (UINT8)(g_stp_dbg_cpupcr->wifiVer & 0xFF));
+
+	len += osal_sprintf(*buf + len, "</version>\n\t");
+
+	/*format issue information: no ack, assert */
+	len += osal_sprintf(*buf + len, "<issue>\n\t\t<classification>\n\t\t\t");
+	if ((STP_FW_NOACK_ISSUE == g_stp_dbg_cpupcr->issue_type) ||
+	    (STP_DBG_PROC_TEST == g_stp_dbg_cpupcr->issue_type) ||
+	    (STP_FW_WARM_RST_ISSUE == g_stp_dbg_cpupcr->issue_type)) {
+		len +=
+		    osal_sprintf(*buf + len, "%s\n\t\t</classification>\n\t\t<rc>\n\t\t\t",
+				 g_stp_dbg_cpupcr->assert_info);
+		len += osal_sprintf(*buf + len, "NULL\n\t\t</rc>\n\t</issue>\n\t");
+		len += osal_sprintf(*buf + len, "<hint>\n\t\t<time_align>NULL</time_align>\n\t\t");
+		len += osal_sprintf(*buf + len, "<host>NULL</host>\n\t\t");
+		len +=
+		    osal_sprintf(*buf + len, "<client>\n\t\t\t<task>%s</task>\n\t\t\t",
+				 _stp_dbg_id_to_task(g_stp_dbg_cpupcr->fwTaskId));
+		len += osal_sprintf(*buf + len, "<irqx>IRQ_0x%x</irqx>\n\t\t\t", g_stp_dbg_cpupcr->fwRrq);
+		len += osal_sprintf(*buf + len, "<isr>0x%x</isr>\n\t\t\t", g_stp_dbg_cpupcr->fwIsr);
+		len += osal_sprintf(*buf + len, "<drv_type>NULL</drv_type>\n\t\t\t");
+		len += osal_sprintf(*buf + len, "<reason>NULL</reason>\n\t\t\t");
+	} else if ((STP_FW_ASSERT_ISSUE == g_stp_dbg_cpupcr->issue_type) ||
+		   (STP_HOST_TRIGGER_FW_ASSERT == g_stp_dbg_cpupcr->issue_type) ||
+		   (STP_HOST_TRIGGER_ASSERT_TIMEOUT == g_stp_dbg_cpupcr->issue_type)) {
+		len +=
+		    osal_sprintf(*buf + len, "%s\n\t\t</classification>\n\t\t<rc>\n\t\t\t",
+				 g_stp_dbg_cpupcr->assert_info);
+		len += osal_sprintf(*buf + len, "%s\n\t\t</rc>\n\t</issue>\n\t", g_stp_dbg_cpupcr->assert_type);
+		len += osal_sprintf(*buf + len, "<hint>\n\t\t<time_align>NULL</time_align>\n\t\t");
+		len += osal_sprintf(*buf + len, "<host>NULL</host>\n\t\t");
+		len +=
+		    osal_sprintf(*buf + len, "<client>\n\t\t\t<task>%s</task>\n\t\t\t",
+				 _stp_dbg_id_to_task(g_stp_dbg_cpupcr->fwTaskId));
+		if (32 == g_stp_dbg_cpupcr->host_assert_info.reason || 33 == g_stp_dbg_cpupcr->host_assert_info.reason
+		    || 34 == g_stp_dbg_cpupcr->host_assert_info.reason
+		    || 35 == g_stp_dbg_cpupcr->host_assert_info.reason
+		    || 36 == g_stp_dbg_cpupcr->host_assert_info.reason
+		    || 37 == g_stp_dbg_cpupcr->host_assert_info.reason
+		    || 38 == g_stp_dbg_cpupcr->host_assert_info.reason
+		    || 39 == g_stp_dbg_cpupcr->host_assert_info.reason
+		    || 40 == g_stp_dbg_cpupcr->host_assert_info.reason) {
+			/*handling wmt turn on/off bt cmd has ack but no evt issue */
+			/*one of both the irqx and irs is nULL, then use task to find MOF */
+			len += osal_sprintf(*buf + len, "<irqx>NULL</irqx>\n\t\t\t");
+		} else {
+			len += osal_sprintf(*buf + len, "<irqx>IRQ_0x%x</irqx>\n\t\t\t", g_stp_dbg_cpupcr->fwRrq);
+		}
+		len += osal_sprintf(*buf + len, "<isr>0x%x</isr>\n\t\t\t", g_stp_dbg_cpupcr->fwIsr);
+
+		if (STP_FW_ASSERT_ISSUE == g_stp_dbg_cpupcr->issue_type) {
+			len += osal_sprintf(*buf + len, "<drv_type>NULL</drv_type>\n\t\t\t");
+			len += osal_sprintf(*buf + len, "<reason>NULL</reason>\n\t\t\t");
+		}
+
+		if ((STP_HOST_TRIGGER_FW_ASSERT == g_stp_dbg_cpupcr->issue_type) ||
+		    (STP_HOST_TRIGGER_ASSERT_TIMEOUT == g_stp_dbg_cpupcr->issue_type)) {
+			len +=
+			    osal_sprintf(*buf + len, "<drv_type>%d</drv_type>\n\t\t\t",
+					 g_stp_dbg_cpupcr->host_assert_info.drv_type);
+			len +=
+			    osal_sprintf(*buf + len, "<reason>%d</reason>\n\t\t\t",
+					 g_stp_dbg_cpupcr->host_assert_info.reason);
+		}
+	} else {
+		len += osal_sprintf(*buf + len, "NULL\n\t\t</classification>\n\t\t<rc>\n\t\t\t");
+		len += osal_sprintf(*buf + len, "NULL\n\t\t</rc>\n\t</issue>\n\t");
+		len += osal_sprintf(*buf + len, "<hint>\n\t\t<time_align>NULL</time_align>\n\t\t");
+		len += osal_sprintf(*buf + len, "<host>NULL</host>\n\t\t");
+		len += osal_sprintf(*buf + len, "<client>\n\t\t\t<task>NULL</task>\n\t\t\t");
+		len += osal_sprintf(*buf + len, "<irqx>NULL</irqx>\n\t\t\t");
+		len += osal_sprintf(*buf + len, "<isr>NULL</isr>\n\t\t\t");
+		len += osal_sprintf(*buf + len, "<drv_type>NULL</drv_type>\n\t\t\t");
+		len += osal_sprintf(*buf + len, "<reason>NULL</reason>\n\t\t\t");
+	}
+
+	len += osal_sprintf(*buf + len, "<pctrace>");
+	STP_DBG_INFO_FUNC("stp-dbg:sub len1 for debug(%d)\n", len);
+
+	if (!g_stp_dbg_cpupcr->count)
+		len += osal_sprintf(*buf + len, "NULL");
+	else {
+		for (i = 0; i < g_stp_dbg_cpupcr->count; i++)
+			len += osal_sprintf(*buf + len, "%08x,", g_stp_dbg_cpupcr->buffer[i]);
+	}
+	STP_DBG_INFO_FUNC("stp-dbg:sub len2 for debug(%d)\n", len);
+	len += osal_sprintf(*buf + len, "</pctrace>\n\t\t\t");
+	len += osal_sprintf(*buf + len, "<extension>NULL</extension>\n\t\t</client>\n\t</hint>\n</main>\n");
+	STP_DBG_INFO_FUNC("buffer len[%d]\n", len);
+	/* STP_DBG_INFO_FUNC("Format infor:\n%s\n",*buf); */
+	*str_len = len;
+
+	osal_lock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+	osal_memset(&g_stp_dbg_cpupcr->buffer[0], 0, STP_DBG_CPUPCR_NUM);
+	g_stp_dbg_cpupcr->count = 0;
+	g_stp_dbg_cpupcr->host_assert_info.reason = 0;
+	g_stp_dbg_cpupcr->host_assert_info.drv_type = 0;
+	osal_unlock_sleepable_lock(&g_stp_dbg_cpupcr->lock);
+
+	return 0;
+
+}
+
+MTKSTP_DBG_T *stp_dbg_init(void *btm_half)
+{
+
+	MTKSTP_DBG_T *stp_dbg = NULL;
+
+	STP_DBG_INFO_FUNC("stp-dbg init\n");
+
+	stp_dbg = kzalloc(sizeof(MTKSTP_DBG_T), GFP_KERNEL);
+	if (stp_dbg == NULL)
+		goto ERR_EXIT1;
+	if (IS_ERR(stp_dbg)) {
+		STP_DBG_ERR_FUNC("-ENOMEM\n");
+		goto ERR_EXIT1;
+	}
+
+	stp_dbg->logsys = vmalloc(sizeof(MTKSTP_LOG_SYS_T));
+	if (stp_dbg->logsys == NULL)
+		goto ERR_EXIT2;
+	if (IS_ERR(stp_dbg->logsys)) {
+		STP_DBG_ERR_FUNC("-ENOMEM stp_gdb->logsys\n");
+		goto ERR_EXIT2;
+	}
+	memset(stp_dbg->logsys, 0, sizeof(MTKSTP_LOG_SYS_T));
+	spin_lock_init(&(stp_dbg->logsys->lock));
+	stp_dbg->pkt_trace_no = 0;
+	stp_dbg->is_enable = 0;
+	g_stp_dbg = stp_dbg;
+
+	if (btm_half != NULL)
+		stp_dbg->btm = btm_half;
+	else
+		stp_dbg->btm = NULL;
+
+
+	/* bind to netlink */
+	stp_dbg_nl_init();
+	g_core_dump = wcn_core_dump_init(STP_CORE_DUMP_INIT_SIZE, STP_CORE_DUMP_TIMEOUT);
+	g_stp_dbg_cpupcr = stp_dbg_cpupcr_init();
+	g_stp_dbg_dmaregs = stp_dbg_dmaregs_init();
+
+	return stp_dbg;
+
+ERR_EXIT2:
+	kfree(stp_dbg);
+	return NULL;
+
+ERR_EXIT1:
+	kfree(stp_dbg);
+	return NULL;
+}
+
+int stp_dbg_deinit(MTKSTP_DBG_T *stp_dbg)
+{
+
+	STP_DBG_INFO_FUNC("stp-dbg deinit\n");
+
+	wcn_core_dump_deinit(g_core_dump);
+
+	stp_dbg_cpupcr_deinit(g_stp_dbg_cpupcr);
+	stp_dbg_dmaregs_deinit(g_stp_dbg_dmaregs);
+	/* unbind with netlink */
+	stp_dbg_nl_deinit();
+
+	if (stp_dbg->logsys)
+		vfree(stp_dbg->logsys);
+
+	kfree(stp_dbg);
+
+	return 0;
+}
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/stp_exp.c b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/stp_exp.c
new file mode 100644
index 00000000..f7f4aff
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/stp_exp.c
@@ -0,0 +1,279 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*******************************************************************************
+*                E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+#include <linux/types.h>
+#include <linux/major.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/fcntl.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/timer.h>
+#include <linux/ctype.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/bitops.h>
+#include <linux/audit.h>
+#include <linux/file.h>
+#include <linux/module.h>
+
+#include <linux/spinlock.h>
+#include <linux/delay.h>	/* udelay() */
+
+#include <asm/uaccess.h>
+
+
+#include "osal_typedef.h"
+#include "stp_core.h"
+#include "stp_exp.h"
+
+/*******************************************************************************
+*                          C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                         D A T A   T Y P E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                        P U B L I C   D A T A
+********************************************************************************
+*/
+/*******************************************************************************
+*                       P R I V A T E   D A T A
+********************************************************************************
+*/
+static MTK_WCN_STP_IF_TX stp_uart_if_tx;
+static MTK_WCN_STP_IF_TX stp_sdio_if_tx;
+static MTK_WCN_STP_IF_TX stp_btif_if_tx;
+static ENUM_STP_TX_IF_TYPE g_stp_if_type = STP_MAX_IF_TX;
+static MTK_WCN_STP_IF_RX stp_if_rx;
+static MTK_WCN_STP_EVENT_CB event_callback_tbl[MTKSTP_MAX_TASK_NUM] = { 0x0 };
+static MTK_WCN_STP_EVENT_CB tx_event_callback_tbl[MTKSTP_MAX_TASK_NUM] = { 0x0 };
+
+/******************************************************************************
+*                   F U N C T I O N   D E C L A R A T I O N S
+*******************************************************************************
+*/
+
+/*******************************************************************************
+*                          F U N C T I O N S
+********************************************************************************
+*/
+
+INT32 mtk_wcn_sys_if_rx(UINT8 *data, INT32 size)
+{
+	if (stp_if_rx == 0x0)
+		return -1;
+
+	(*stp_if_rx) (data, size);
+	return 0;
+}
+
+static INT32 mtk_wcn_sys_if_tx(const PUINT8 data, const UINT32 size, PUINT32 written_size)
+{
+
+	if (STP_UART_IF_TX == g_stp_if_type)
+		return stp_uart_if_tx != NULL ? (*stp_uart_if_tx) (data, size, written_size) : -1;
+	else if (STP_SDIO_IF_TX == g_stp_if_type)
+		return stp_sdio_if_tx != NULL ? (*stp_sdio_if_tx) (data, size, written_size) : -1;
+	else if (STP_BTIF_IF_TX == g_stp_if_type)
+		return stp_btif_if_tx != NULL ? (*stp_btif_if_tx) (data, size, written_size) : -1;
+	/*if (g_stp_if_type >= STP_MAX_IF_TX) *//* George: remove ALWAYS TRUE condition */
+	return -1;
+}
+
+static INT32 mtk_wcn_sys_event_set(UINT8 function_type)
+{
+	if ((function_type < MTKSTP_MAX_TASK_NUM) && (event_callback_tbl[function_type] != 0x0)) {
+		(*event_callback_tbl[function_type]) ();
+	} else {
+		/* FIXME: error handling */
+		pr_err("[%s] STP set event fail. It seems the function is not active.\n", __func__);
+	}
+
+	return 0;
+}
+
+static INT32 mtk_wcn_sys_event_tx_resume(UINT8 winspace)
+{
+	int type = 0;
+
+	for (type = 0; type < MTKSTP_MAX_TASK_NUM; type++) {
+		if (tx_event_callback_tbl[type])
+			tx_event_callback_tbl[type] ();
+	}
+
+	return 0;
+}
+
+static INT32 mtk_wcn_sys_check_function_status(UINT8 type, UINT8 op)
+{
+
+	/* op == FUNCTION_ACTIVE, to check if funciton[type] is active ? */
+	if (!(type < MTKSTP_MAX_TASK_NUM))
+		return STATUS_FUNCTION_INVALID;
+
+	if (op == OP_FUNCTION_ACTIVE) {
+		if (event_callback_tbl[type] != 0x0)
+			return STATUS_FUNCTION_ACTIVE;
+		else
+			return STATUS_FUNCTION_INACTIVE;
+
+	}
+	/* you can define more operation here ..., to queury function's status/information */
+
+	return STATUS_OP_INVALID;
+}
+
+#if STP_EXP_HID_API_EXPORT
+INT32 _mtk_wcn_stp_register_if_rx(MTK_WCN_STP_IF_RX func)
+#else
+INT32 mtk_wcn_stp_register_if_rx(MTK_WCN_STP_IF_RX func)
+#endif
+{
+	stp_if_rx = func;
+
+	return 0;
+}
+#if !STP_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_stp_register_if_rx);
+#endif
+
+VOID mtk_wcn_stp_set_if_tx_type(ENUM_STP_TX_IF_TYPE stp_if_type)
+{
+	static const char * const ifType[] = {
+		"UART",
+		"SDIO",
+		"BTIF",
+		"UNKNOWN"
+	};
+	g_stp_if_type = stp_if_type;
+	pr_debug("[%s] set STP_IF_TX to %s.\n", __func__, ifType[stp_if_type]);
+}
+
+#if STP_EXP_HID_API_EXPORT
+INT32 _mtk_wcn_stp_register_if_tx(ENUM_STP_TX_IF_TYPE stp_if, MTK_WCN_STP_IF_TX func)
+#else
+INT32 mtk_wcn_stp_register_if_tx(ENUM_STP_TX_IF_TYPE stp_if, MTK_WCN_STP_IF_TX func)
+#endif
+{
+	if (STP_UART_IF_TX == stp_if) {
+		stp_uart_if_tx = func;
+	} else if (STP_SDIO_IF_TX == stp_if) {
+		stp_sdio_if_tx = func;
+	} else if (STP_BTIF_IF_TX == stp_if) {
+		stp_btif_if_tx = func;
+	} else {
+		pr_debug("[%s] STP_IF_TX(%d) out of boundary.\n", __func__, stp_if);
+		return -1;
+	}
+
+	return 0;
+}
+#if !STP_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_stp_register_if_tx);
+#endif
+
+#if STP_EXP_HID_API_EXPORT
+INT32 _mtk_wcn_stp_register_event_cb(INT32 type, MTK_WCN_STP_EVENT_CB func)
+#else
+INT32 mtk_wcn_stp_register_event_cb(INT32 type, MTK_WCN_STP_EVENT_CB func)
+#endif
+{
+	if (type < MTKSTP_MAX_TASK_NUM) {
+		event_callback_tbl[type] = func;
+
+		/*clear rx queue */
+		pr_debug("Flush type = %d Rx Queue\n", type);
+		mtk_wcn_stp_flush_rx_queue(type);
+	}
+
+	return 0;
+}
+#if !STP_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_stp_register_event_cb);
+#endif
+
+#if STP_EXP_HID_API_EXPORT
+INT32 _mtk_wcn_stp_register_tx_event_cb(INT32 type, MTK_WCN_STP_EVENT_CB func)
+#else
+INT32 mtk_wcn_stp_register_tx_event_cb(INT32 type, MTK_WCN_STP_EVENT_CB func)
+#endif
+{
+	if (type < MTKSTP_MAX_TASK_NUM)
+		tx_event_callback_tbl[type] = func;
+	else
+		BUG_ON(0);
+
+	return 0;
+}
+#if !STP_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_stp_register_tx_event_cb);
+#endif
+
+INT32 stp_drv_init(VOID)
+{
+	INT32 ret = 0;
+
+	mtkstp_callback cb = {
+		.cb_if_tx = mtk_wcn_sys_if_tx,
+		.cb_event_set = mtk_wcn_sys_event_set,
+		.cb_event_tx_resume = mtk_wcn_sys_event_tx_resume,
+		.cb_check_funciton_status = mtk_wcn_sys_check_function_status
+	};
+
+#ifdef MTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+	MTK_WCN_STP_EXP_CB_INFO stpExpCb = {
+		.stp_send_data_cb = _mtk_wcn_stp_send_data,
+		.stp_send_data_raw_cb = _mtk_wcn_stp_send_data_raw,
+		.stp_parser_data_cb = _mtk_wcn_stp_parser_data,
+		.stp_receive_data_cb = _mtk_wcn_stp_receive_data,
+		.stp_is_rxqueue_empty_cb = _mtk_wcn_stp_is_rxqueue_empty,
+		.stp_is_ready_cb = _mtk_wcn_stp_is_ready,
+		.stp_set_bluez_cb = _mtk_wcn_stp_set_bluez,
+		.stp_if_tx_cb = _mtk_wcn_stp_register_if_tx,
+		.stp_if_rx_cb = _mtk_wcn_stp_register_if_rx,
+		.stp_reg_event_cb = _mtk_wcn_stp_register_event_cb,
+		.stp_reg_tx_event_cb = _mtk_wcn_stp_register_tx_event_cb,
+		.stp_coredump_start_get_cb = _mtk_wcn_stp_coredump_start_get,
+	};
+#endif
+
+	ret = mtk_wcn_stp_init(&cb);
+#ifdef MTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+	mtk_wcn_stp_exp_cb_reg(&stpExpCb);
+#endif
+	return ret;
+}
+
+VOID stp_drv_exit(VOID)
+{
+	mtk_wcn_stp_deinit();
+
+#ifdef MTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+	mtk_wcn_stp_exp_cb_unreg();
+#endif
+
+}
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/wmt_dev.c b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/wmt_dev.c
new file mode 100644
index 00000000..83a50e2
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/wmt_dev.c
@@ -0,0 +1,2566 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief brief description
+
+    Detailed descriptions here.
+
+*/
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[WMT-DEV]"
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+#include "osal_typedef.h"
+#include "osal.h"
+#include "wmt_dev.h"
+#include "wmt_core.h"
+#include "wmt_exp.h"
+#include "wmt_lib.h"
+#include "wmt_conf.h"
+#include "psm_core.h"
+#include "stp_core.h"
+#include "stp_exp.h"
+#include "bgw_desense.h"
+#include <mtk_wcn_cmb_stub.h>
+#include "wmt_idc.h"
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+#if WMT_CREATE_NODE_DYNAMIC
+#include <linux/device.h>
+#endif
+#define BUF_LEN_MAX 384
+#include <linux/proc_fs.h>
+#ifdef CONFIG_COMPAT
+#define COMPAT_WMT_IOCTL_SET_PATCH_NAME		_IOW(WMT_IOC_MAGIC, 4, compat_uptr_t)
+#define COMPAT_WMT_IOCTL_LPBK_TEST			_IOWR(WMT_IOC_MAGIC, 8, compat_uptr_t)
+#define COMPAT_WMT_IOCTL_SET_PATCH_INFO		_IOW(WMT_IOC_MAGIC, 15, compat_uptr_t)
+#define COMPAT_WMT_IOCTL_PORT_NAME			_IOWR(WMT_IOC_MAGIC, 20, compat_uptr_t)
+#define COMPAT_WMT_IOCTL_WMT_CFG_NAME			_IOWR(WMT_IOC_MAGIC, 21, compat_uptr_t)
+#define COMPAT_WMT_IOCTL_SEND_BGW_DS_CMD		_IOW(WMT_IOC_MAGIC, 25, compat_uptr_t)
+#define COMPAT_WMT_IOCTL_ADIE_LPBK_TEST		_IOWR(WMT_IOC_MAGIC, 26, compat_uptr_t)
+#endif
+
+#define WMT_IOC_MAGIC        0xa0
+#define WMT_IOCTL_SET_PATCH_NAME		_IOW(WMT_IOC_MAGIC, 4, char*)
+#define WMT_IOCTL_SET_STP_MODE			_IOW(WMT_IOC_MAGIC, 5, int)
+#define WMT_IOCTL_FUNC_ONOFF_CTRL		_IOW(WMT_IOC_MAGIC, 6, int)
+#define WMT_IOCTL_LPBK_POWER_CTRL		_IOW(WMT_IOC_MAGIC, 7, int)
+#define WMT_IOCTL_LPBK_TEST				_IOWR(WMT_IOC_MAGIC, 8, char*)
+#define WMT_IOCTL_GET_CHIP_INFO			_IOR(WMT_IOC_MAGIC, 12, int)
+#define WMT_IOCTL_SET_LAUNCHER_KILL		_IOW(WMT_IOC_MAGIC, 13, int)
+#define WMT_IOCTL_SET_PATCH_NUM			_IOW(WMT_IOC_MAGIC, 14, int)
+#define WMT_IOCTL_SET_PATCH_INFO		_IOW(WMT_IOC_MAGIC, 15, char*)
+#define WMT_IOCTL_PORT_NAME			_IOWR(WMT_IOC_MAGIC, 20, char*)
+#define WMT_IOCTL_WMT_CFG_NAME			_IOWR(WMT_IOC_MAGIC, 21, char*)
+#define WMT_IOCTL_WMT_QUERY_CHIPID	_IOR(WMT_IOC_MAGIC, 22, int)
+#define WMT_IOCTL_WMT_TELL_CHIPID	_IOW(WMT_IOC_MAGIC, 23, int)
+#define WMT_IOCTL_WMT_COREDUMP_CTRL     _IOW(WMT_IOC_MAGIC, 24, int)
+#define WMT_IOCTL_SEND_BGW_DS_CMD		_IOW(WMT_IOC_MAGIC, 25, char*)
+#define WMT_IOCTL_ADIE_LPBK_TEST		_IOWR(WMT_IOC_MAGIC, 26, char*)
+#define WMT_IOCTL_FW_DBGLOG_CTRL		_IOR(WMT_IOC_MAGIC, 29, int)
+#define WMT_IOCTL_DYNAMIC_DUMP_CTRL     _IOR(WMT_IOC_MAGIC, 30, char*)
+
+#define MTK_WMT_VERSION  "SOC Consys WMT Driver - v1.0"
+#define MTK_WMT_DATE     "2013/01/20"
+#define WMT_DEV_MAJOR 190	/* never used number */
+#define WMT_DEV_NUM 1
+#define WMT_DEV_INIT_TO_MS (2 * 1000)
+#define DYNAMIC_DUMP_BUF 109
+
+#if CFG_WMT_DBG_SUPPORT
+#define WMT_DBG_PROCNAME "driver/wmt_dbg"
+#endif
+
+#define WMT_DRIVER_NAME "mtk_stp_wmt"
+
+P_OSAL_EVENT gpRxEvent = NULL;
+
+UINT32 u4RxFlag = 0x0;
+static atomic_t gRxCount = ATOMIC_INIT(0);
+
+/* Linux UINT8 device */
+static int gWmtMajor = WMT_DEV_MAJOR;
+static struct cdev gWmtCdev;
+static atomic_t gWmtRefCnt = ATOMIC_INIT(0);
+/* WMT driver information */
+static UINT8 gLpbkBuf[1024+5] = { 0 };
+
+static UINT32 gLpbkBufLog;	/* George LPBK debug */
+static INT32 gWmtInitDone;
+static wait_queue_head_t gWmtInitWq;
+
+P_WMT_PATCH_INFO pPatchInfo = NULL;
+UINT32 pAtchNum = 0;
+
+#if (defined(CONFIG_MTK_GMO_RAM_OPTIMIZE) && !defined(CONFIG_MT_ENG_BUILD))
+#define WMT_EMI_DEBUG_BUF_SIZE (8*1024)
+#else
+#define WMT_EMI_DEBUG_BUF_SIZE (32*1024)
+#endif
+
+static UINT8 gEmiBuf[WMT_EMI_DEBUG_BUF_SIZE];
+UINT8 *buf_emi;
+
+#if CFG_WMT_PROC_FOR_AEE
+static struct proc_dir_entry *gWmtAeeEntry;
+#define WMT_AEE_PROCNAME "driver/wmt_aee"
+#define WMT_PROC_AEE_SIZE 3072
+static UINT32 g_buf_len;
+static UINT8 *pBuf;
+#endif
+
+#if WMT_CREATE_NODE_DYNAMIC
+struct class *wmt_class = NULL;
+struct device *wmt_dev = NULL;
+#endif
+
+#if CFG_WMT_DBG_SUPPORT
+static struct proc_dir_entry *gWmtDbgEntry;
+COEX_BUF gCoexBuf;
+
+static INT32 wmt_dbg_psm_ctrl(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_quick_sleep_ctrl(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_dsns_ctrl(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_hwver_get(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_inband_rst(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_chip_rst(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_func_ctrl(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_raed_chipid(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_wmt_dbg_level(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_stp_dbg_level(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_reg_read(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_reg_write(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_coex_test(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_assert_test(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_cmd_test_api(ENUM_WMTDRV_CMD_T cmd);
+static INT32 wmt_dbg_rst_ctrl(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_ut_test(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_efuse_read(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_efuse_write(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_sdio_ctrl(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_stp_dbg_ctrl(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_stp_dbg_log_ctrl(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_wmt_assert_ctrl(INT32 par1, INT32 par2, INT32 par3);
+
+#if CFG_CORE_INTERNAL_TXRX
+static INT32 wmt_dbg_internal_lpbk_test(INT32 par1, INT32 par2, INT32 par3);
+#endif
+static INT32 wmt_dbg_fwinfor_from_emi(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_set_mcu_clock(INT32 par1, INT32 par2, INT32 par3);
+static INT32 wmt_dbg_poll_cpupcr(INT32 par1, INT32 par2, INT32 par3);
+#if CONSYS_ENALBE_SET_JTAG
+static INT32 wmt_dbg_jtag_flag_ctrl(INT32 par1, INT32 par2, INT32 par3);
+#endif
+#if CFG_WMT_LTE_COEX_HANDLING
+static INT32 wmt_dbg_lte_coex_test(INT32 par1, INT32 par2, INT32 par3);
+#endif
+#endif
+static void wmt_dbg_fwinfor_print_buff(UINT32 len)
+{
+	UINT32 i = 0;
+	UINT32 idx = 0;
+
+	for (i = 0; i < len; i++) {
+					buf_emi[idx] = gEmiBuf[i];
+					if (gEmiBuf[i] == '\n') {
+						pr_cont("%s", buf_emi);
+						osal_memset(buf_emi, 0, BUF_LEN_MAX);
+						idx = 0;
+					} else {
+						idx++;
+					}
+					if (idx == BUF_LEN_MAX-1) {
+						buf_emi[idx] = '\0';
+						pr_cont("%s", buf_emi);
+						osal_memset(buf_emi, 0, BUF_LEN_MAX);
+						idx = 0;
+					}
+				}
+}
+
+/*LCM on/off ctrl for wmt varabile*/
+static struct work_struct gPwrOnOffWork;
+UINT32 g_es_lr_flag_for_quick_sleep = 1;	/* for ctrl quick sleep flag */
+UINT32 g_es_lr_flag_for_lpbk_onoff = 0;	/* for ctrl lpbk on off */
+OSAL_SLEEPABLE_LOCK g_es_lr_lock;
+
+#ifdef CONFIG_EARLYSUSPEND
+
+static void wmt_dev_early_suspend(struct early_suspend *h)
+{
+	osal_lock_sleepable_lock(&g_es_lr_lock);
+	g_es_lr_flag_for_quick_sleep = 1;
+	g_es_lr_flag_for_lpbk_onoff = 0;
+	osal_unlock_sleepable_lock(&g_es_lr_lock);
+
+	WMT_WARN_FUNC("@@@@@@@@@@wmt enter early suspend@@@@@@@@@@@@@@\n");
+
+	schedule_work(&gPwrOnOffWork);
+}
+
+static void wmt_dev_late_resume(struct early_suspend *h)
+{
+	osal_lock_sleepable_lock(&g_es_lr_lock);
+	g_es_lr_flag_for_quick_sleep = 0;
+	g_es_lr_flag_for_lpbk_onoff = 1;
+	osal_unlock_sleepable_lock(&g_es_lr_lock);
+
+	WMT_WARN_FUNC("@@@@@@@@@@wmt enter late resume@@@@@@@@@@@@@@\n");
+
+	schedule_work(&gPwrOnOffWork);
+
+}
+
+struct early_suspend wmt_early_suspend_handler = {
+	.suspend = wmt_dev_early_suspend,
+	.resume = wmt_dev_late_resume,
+};
+
+#else
+
+static struct notifier_block wmt_fb_notifier;
+static int wmt_fb_notifier_callback(struct notifier_block *self, unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	INT32 blank;
+
+	WMT_DBG_FUNC("wmt_fb_notifier_callback\n");
+
+	/* If we aren't interested in this event, skip it immediately ... */
+	if (event != FB_EVENT_BLANK)
+		return 0;
+
+	blank = *(INT32 *)evdata->data;
+	WMT_DBG_FUNC("fb_notify(blank=%d)\n", blank);
+
+	switch (blank) {
+	case FB_BLANK_UNBLANK:
+		osal_lock_sleepable_lock(&g_es_lr_lock);
+		g_es_lr_flag_for_quick_sleep = 0;
+		g_es_lr_flag_for_lpbk_onoff = 1;
+		osal_unlock_sleepable_lock(&g_es_lr_lock);
+		WMT_WARN_FUNC("@@@@@@@@@@wmt enter UNBLANK @@@@@@@@@@@@@@\n");
+		schedule_work(&gPwrOnOffWork);
+		break;
+	case FB_BLANK_POWERDOWN:
+		osal_lock_sleepable_lock(&g_es_lr_lock);
+		g_es_lr_flag_for_quick_sleep = 1;
+		g_es_lr_flag_for_lpbk_onoff = 0;
+		osal_unlock_sleepable_lock(&g_es_lr_lock);
+		WMT_WARN_FUNC("@@@@@@@@@@wmt enter early POWERDOWN @@@@@@@@@@@@@@\n");
+		schedule_work(&gPwrOnOffWork);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+#endif
+/*******************************************************************************
+*                          F U N C T I O N S
+********************************************************************************
+*/
+
+static void wmt_pwr_on_off_handler(struct work_struct *work)
+{
+	INT32 retryCounter = 1;
+
+	WMT_DBG_FUNC("wmt_pwr_on_off_handler start to run\n");
+
+	osal_lock_sleepable_lock(&g_es_lr_lock);
+
+	if (g_es_lr_flag_for_lpbk_onoff) {
+		do {
+			if (MTK_WCN_BOOL_FALSE == mtk_wcn_wmt_func_on(WMTDRV_TYPE_LPBK)) {
+				WMT_WARN_FUNC("WMT turn on LPBK fail, retrying, retryCounter left:%d!\n", retryCounter);
+				retryCounter--;
+				osal_sleep_ms(1000);
+			} else {
+				WMT_INFO_FUNC("WMT turn on LPBK suceed\n");
+				break;
+			}
+		} while (retryCounter > 0);
+	} else {
+		if (MTK_WCN_BOOL_FALSE == mtk_wcn_wmt_func_off(WMTDRV_TYPE_LPBK))
+			WMT_WARN_FUNC("WMT turn off LPBK fail\n");
+		else
+			WMT_DBG_FUNC("WMT turn off LPBK suceed\n");
+
+	}
+
+	osal_unlock_sleepable_lock(&g_es_lr_lock);
+
+}
+
+
+MTK_WCN_BOOL wmt_dev_get_early_suspend_state(void)
+{
+	MTK_WCN_BOOL bRet = (0 == g_es_lr_flag_for_quick_sleep) ? MTK_WCN_BOOL_FALSE : MTK_WCN_BOOL_TRUE;
+	/* WMT_INFO_FUNC("bRet:%d\n", bRet); */
+	return bRet;
+}
+
+#if CFG_WMT_DBG_SUPPORT
+
+static const WMT_DEV_DBG_FUNC wmt_dev_dbg_func[] = {
+	[0] = wmt_dbg_psm_ctrl,
+	[1] = wmt_dbg_quick_sleep_ctrl,
+	[2] = wmt_dbg_dsns_ctrl,
+	[3] = wmt_dbg_hwver_get,
+	[4] = wmt_dbg_assert_test,
+	[5] = wmt_dbg_inband_rst,
+	[6] = wmt_dbg_chip_rst,
+	[7] = wmt_dbg_func_ctrl,
+	[8] = wmt_dbg_raed_chipid,
+	[9] = wmt_dbg_wmt_dbg_level,
+	[0xa] = wmt_dbg_stp_dbg_level,
+	[0xb] = wmt_dbg_reg_read,
+	[0xc] = wmt_dbg_reg_write,
+	[0xd] = wmt_dbg_coex_test,
+	[0xe] = wmt_dbg_rst_ctrl,
+	[0xf] = wmt_dbg_ut_test,
+	[0x10] = wmt_dbg_efuse_read,
+	[0x11] = wmt_dbg_efuse_write,
+	[0x12] = wmt_dbg_sdio_ctrl,
+	[0x13] = wmt_dbg_stp_dbg_ctrl,
+	[0x14] = wmt_dbg_stp_dbg_log_ctrl,
+	[0x15] = wmt_dbg_wmt_assert_ctrl,
+	[0x16] = wmt_dbg_fwinfor_from_emi,
+	[0x17] = wmt_dbg_set_mcu_clock,
+	[0x18] = wmt_dbg_poll_cpupcr,
+	[0x19] = wmt_dbg_jtag_flag_ctrl,
+#if CFG_WMT_LTE_COEX_HANDLING
+	[0x20] = wmt_dbg_lte_coex_test,
+#endif
+};
+
+INT32 wmt_dbg_psm_ctrl(INT32 par1, INT32 par2, INT32 par3)
+{
+#if CFG_WMT_PS_SUPPORT
+	if (0 == par2) {
+		wmt_lib_ps_ctrl(0);
+		WMT_INFO_FUNC("disable PSM\n");
+	} else {
+		par2 = (1 > par2 || 20000 < par2) ? STP_PSM_IDLE_TIME_SLEEP : par2;
+		wmt_lib_ps_set_idle_time(par2);
+		wmt_lib_ps_ctrl(1);
+		WMT_WARN_FUNC("enable PSM, idle to sleep time = %d ms\n", par2);
+	}
+#else
+	WMT_INFO_FUNC("WMT PS not supported\n");
+#endif
+	return 0;
+}
+
+INT32 wmt_dbg_quick_sleep_ctrl(INT32 par1, INT32 par2, INT32 par3)
+{
+#if CFG_WMT_PS_SUPPORT
+	UINT32 en_flag = par2;
+
+	wmt_lib_quick_sleep_ctrl(en_flag);
+#else
+	WMT_WARN_FUNC("WMT PS not supported\n");
+#endif
+	return 0;
+}
+
+INT32 wmt_dbg_dsns_ctrl(INT32 par1, INT32 par2, INT32 par3)
+{
+	if (WMTDSNS_FM_DISABLE <= par2 && WMTDSNS_MAX > par2) {
+		WMT_INFO_FUNC("DSNS type (%d)\n", par2);
+		mtk_wcn_wmt_dsns_ctrl(par2);
+	} else {
+		WMT_WARN_FUNC("invalid DSNS type\n");
+	}
+	return 0;
+}
+
+INT32 wmt_dbg_hwver_get(INT32 par1, INT32 par2, INT32 par3)
+{
+	WMT_INFO_FUNC("query chip version\n");
+	mtk_wcn_wmt_hwver_get();
+	return 0;
+}
+
+INT32 wmt_dbg_assert_test(INT32 par1, INT32 par2, INT32 par3)
+{
+	if (0 == par3) {
+		/* par2 = 0:  send assert command */
+		/* par2 != 0: send exception command */
+		return wmt_dbg_cmd_test_api(0 == par2 ? 0 : 1);
+	} else if (1 == par3) {
+		/* send noack command */
+		return wmt_dbg_cmd_test_api(18);
+	} else if (2 == par3) {
+		/* warn reset test */
+		return wmt_dbg_cmd_test_api(19);
+	} else if (3 == par3) {
+		/* firmware trace test */
+		return wmt_dbg_cmd_test_api(20);
+	}
+	{
+		INT32 sec = 8;
+		INT32 times = 0;
+
+		times = par3;
+		do {
+			WMT_INFO_FUNC("Send Assert Command per 8 secs!!\n");
+			wmt_dbg_cmd_test_api(0);
+			osal_sleep_ms(sec * 1000);
+		} while (--times);
+	}
+	return 0;
+}
+
+INT32 wmt_dbg_cmd_test_api(ENUM_WMTDRV_CMD_T cmd)
+{
+
+	P_OSAL_OP pOp = NULL;
+	MTK_WCN_BOOL bRet = MTK_WCN_BOOL_FALSE;
+	P_OSAL_SIGNAL pSignal;
+
+	pOp = wmt_lib_get_free_op();
+	if (!pOp) {
+		WMT_WARN_FUNC("get_free_lxop fail\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	pSignal = &pOp->signal;
+
+	pOp->op.opId = WMT_OPID_CMD_TEST;
+
+	pSignal->timeoutValue = MAX_EACH_WMT_CMD;
+	/*this test command should be run with usb cable connected, so no host awake is needed */
+	/* wmt_lib_host_awake_get(); */
+	switch (cmd) {
+	case WMTDRV_CMD_ASSERT:
+		pOp->op.au4OpData[0] = 0;
+		break;
+	case WMTDRV_CMD_EXCEPTION:
+		pOp->op.au4OpData[0] = 1;
+		break;
+	case WMTDRV_CMD_NOACK_TEST:
+		pOp->op.au4OpData[0] = 3;
+		break;
+	case WMTDRV_CMD_WARNRST_TEST:
+		pOp->op.au4OpData[0] = 4;
+		break;
+	case WMTDRV_CMD_FWTRACE_TEST:
+		pOp->op.au4OpData[0] = 5;
+		break;
+	default:
+		if (WMTDRV_CMD_COEXDBG_00 <= cmd && WMTDRV_CMD_COEXDBG_15 >= cmd) {
+			pOp->op.au4OpData[0] = 2;
+			pOp->op.au4OpData[1] = cmd - 2;
+		} else {
+			pOp->op.au4OpData[0] = 0xff;
+			pOp->op.au4OpData[1] = 0xff;
+		}
+		pOp->op.au4OpData[2] = (SIZE_T) gCoexBuf.buffer;
+		pOp->op.au4OpData[3] = osal_sizeof(gCoexBuf.buffer);
+		break;
+	}
+	WMT_INFO_FUNC("CMD_TEST, opid(%d), par(%d, %d)\n", pOp->op.opId, pOp->op.au4OpData[0], pOp->op.au4OpData[1]);
+	/*wake up chip first */
+	if (DISABLE_PSM_MONITOR()) {
+		WMT_ERR_FUNC("wake up failed\n");
+		wmt_lib_put_op_to_free_queue(pOp);
+		return -1;
+	}
+	bRet = wmt_lib_put_act_op(pOp);
+	ENABLE_PSM_MONITOR();
+	if ((cmd != WMTDRV_CMD_ASSERT) &&
+	    (cmd != WMTDRV_CMD_EXCEPTION) &&
+	    (cmd != WMTDRV_CMD_NOACK_TEST) && (cmd != WMTDRV_CMD_WARNRST_TEST) && (cmd != WMTDRV_CMD_FWTRACE_TEST)) {
+		if (MTK_WCN_BOOL_FALSE == bRet) {
+			gCoexBuf.availSize = 0;
+		} else {
+			gCoexBuf.availSize = pOp->op.au4OpData[3];
+			WMT_INFO_FUNC("gCoexBuf.availSize = %d\n", gCoexBuf.availSize);
+		}
+	}
+	/* wmt_lib_host_awake_put(); */
+	WMT_INFO_FUNC("CMD_TEST, opid (%d), par(%d, %d), ret(%d), result(%s)\n",
+		      pOp->op.opId,
+		      pOp->op.au4OpData[0],
+		      pOp->op.au4OpData[1], bRet, MTK_WCN_BOOL_FALSE == bRet ? "failed" : "succeed");
+
+	return 0;
+}
+
+INT32 wmt_dbg_inband_rst(INT32 par1, INT32 par2, INT32 par3)
+{
+	if (0 == par2) {
+		WMT_INFO_FUNC("inband reset test!!\n");
+		mtk_wcn_stp_inband_reset();
+	} else {
+		WMT_INFO_FUNC("STP context reset in host side!!\n");
+		mtk_wcn_stp_flush_context();
+	}
+
+	return 0;
+}
+
+INT32 wmt_dbg_chip_rst(INT32 par1, INT32 par2, INT32 par3)
+{
+	if (0 == par2) {
+		if (mtk_wcn_stp_is_ready()) {
+			WMT_INFO_FUNC("whole chip reset test\n");
+			wmt_lib_cmb_rst(WMTRSTSRC_RESET_TEST);
+		} else {
+			WMT_INFO_FUNC("STP not ready , not to launch whole chip reset test\n");
+		}
+	} else if (1 == par2) {
+		WMT_INFO_FUNC("chip hardware reset test\n");
+		wmt_lib_hw_rst();
+	} else {
+		WMT_INFO_FUNC("chip software reset test\n");
+		wmt_lib_sw_rst(1);
+	}
+	return 0;
+}
+
+INT32 wmt_dbg_func_ctrl(INT32 par1, INT32 par2, INT32 par3)
+{
+	if (WMTDRV_TYPE_WMT > par2 || WMTDRV_TYPE_LPBK == par2) {
+		if (0 == par3) {
+			WMT_INFO_FUNC("function off test, type(%d)\n", par2);
+			mtk_wcn_wmt_func_off(par2);
+		} else {
+			WMT_INFO_FUNC("function on test, type(%d)\n", par2);
+			mtk_wcn_wmt_func_on(par2);
+		}
+	} else {
+		WMT_INFO_FUNC("function ctrl test, invalid type(%d)\n", par2);
+	}
+	return 0;
+}
+
+INT32 wmt_dbg_raed_chipid(INT32 par1, INT32 par2, INT32 par3)
+{
+	WMT_INFO_FUNC("chip version = %d\n", wmt_lib_get_icinfo(WMTCHIN_MAPPINGHWVER));
+	return 0;
+}
+
+INT32 wmt_dbg_wmt_dbg_level(INT32 par1, INT32 par2, INT32 par3)
+{
+	par2 = (WMT_LOG_ERR <= par2 && WMT_LOG_LOUD >= par2) ? par2 : WMT_LOG_INFO;
+	wmt_lib_dbg_level_set(par2);
+	WMT_INFO_FUNC("set wmt log level to %d\n", par2);
+	return 0;
+}
+
+INT32 wmt_dbg_stp_dbg_level(INT32 par1, INT32 par2, INT32 par3)
+{
+	par2 = (0 <= par2 && 4 >= par2) ? par2 : 2;
+	mtk_wcn_stp_dbg_level(par2);
+	WMT_INFO_FUNC("set stp log level to %d\n", par2);
+	return 0;
+
+}
+
+INT32 wmt_dbg_reg_read(INT32 par1, INT32 par2, INT32 par3)
+{
+	/* par2-->register address */
+	/* par3-->register mask */
+	UINT32 value = 0x0;
+	UINT32 iRet = -1;
+#if 0
+	DISABLE_PSM_MONITOR();
+	iRet = wmt_core_reg_rw_raw(0, par2, &value, par3);
+	ENABLE_PSM_MONITOR();
+#endif
+	iRet = wmt_lib_reg_rw(0, par2, &value, par3);
+	WMT_INFO_FUNC("read combo chip register (0x%08x) with mask (0x%08x) %s, value = 0x%08x\n",
+		      par2, par3, iRet != 0 ? "failed" : "succeed", iRet != 0 ? -1 : value);
+	return 0;
+}
+
+INT32 wmt_dbg_reg_write(INT32 par1, INT32 par2, INT32 par3)
+{
+	/* par2-->register address */
+	/* par3-->value to set */
+	UINT32 iRet = -1;
+#if 0
+	DISABLE_PSM_MONITOR();
+	iRet = wmt_core_reg_rw_raw(1, par2, &par3, 0xffffffff);
+	ENABLE_PSM_MONITOR();
+#endif
+	iRet = wmt_lib_reg_rw(1, par2, &par3, 0xffffffff);
+	WMT_INFO_FUNC("write combo chip register (0x%08x) with value (0x%08x) %s\n",
+		      par2, par3, iRet != 0 ? "failed" : "succeed");
+	return 0;
+}
+
+INT32 wmt_dbg_efuse_read(INT32 par1, INT32 par2, INT32 par3)
+{
+	/* par2-->efuse address */
+	/* par3-->register mask */
+	UINT32 value = 0x0;
+	UINT32 iRet = -1;
+
+	iRet = wmt_lib_efuse_rw(0, par2, &value, par3);
+	WMT_INFO_FUNC("read combo chip efuse (0x%08x) with mask (0x%08x) %s, value = 0x%08x\n",
+		      par2, par3, iRet != 0 ? "failed" : "succeed", iRet != 0 ? -1 : value);
+	return 0;
+}
+
+INT32 wmt_dbg_efuse_write(INT32 par1, INT32 par2, INT32 par3)
+{
+	/* par2-->efuse address */
+	/* par3-->value to set */
+	UINT32 iRet = -1;
+
+	iRet = wmt_lib_efuse_rw(1, par2, &par3, 0xffffffff);
+	WMT_INFO_FUNC("write combo chip efuse (0x%08x) with value (0x%08x) %s\n",
+		      par2, par3, iRet != 0 ? "failed" : "succeed");
+	return 0;
+}
+
+INT32 wmt_dbg_sdio_ctrl(INT32 par1, INT32 par2, INT32 par3)
+{
+/*remove sdio card detect/remove control because of btif is used*/
+#if 0
+	INT32 iRet = -1;
+
+	iRet = wmt_lib_sdio_ctrl(0 != par2 ? 1 : 0);
+	WMT_INFO_FUNC("ctrl SDIO function %s\n", 0 == iRet ? "succeed" : "failed");
+#endif
+	return 0;
+}
+
+INT32 wmt_dbg_stp_dbg_ctrl(INT32 par1, INT32 par2, INT32 par3)
+{
+	if (1 < par2) {
+		mtk_wcn_stp_dbg_dump_package();
+		return 0;
+	}
+	WMT_INFO_FUNC("%s stp debug function\n", 0 == par2 ? "disable" : "enable");
+	if (0 == par2)
+		mtk_wcn_stp_dbg_disable();
+	else if (1 == par2)
+		mtk_wcn_stp_dbg_enable();
+
+	return 0;
+}
+
+INT32 wmt_dbg_stp_dbg_log_ctrl(INT32 par1, INT32 par2, INT32 par3)
+{
+	mtk_wcn_stp_dbg_log_ctrl(0 != par2 ? 1 : 0);
+	return 0;
+}
+
+INT32 wmt_dbg_wmt_assert_ctrl(INT32 par1, INT32 par2, INT32 par3)
+{
+	mtk_wcn_stp_coredump_flag_ctrl(0 != par2 ? 1 : 0);
+	return 0;
+}
+
+INT32 wmt_dbg_fwinfor_from_emi(INT32 par1, INT32 par2, INT32 par3)
+{
+	UINT32 offset = 0;
+	UINT32 len = 0;
+	UINT32 *pAddr = NULL;
+	UINT32 cur_idx_pagedtrace;
+	static UINT32 prev_idx_pagedtrace;
+	MTK_WCN_BOOL isBreak = MTK_WCN_BOOL_TRUE;
+
+	offset = par2;
+	len = par3;
+
+	buf_emi = kmalloc(sizeof(UINT8) * BUF_LEN_MAX, GFP_KERNEL);
+	if (!buf_emi) {
+			WMT_ERR_FUNC("buf kmalloc memory fail\n");
+			return 0;
+		}
+	osal_memset(buf_emi, 0, BUF_LEN_MAX);
+	osal_memset(&gEmiBuf[0], 0, WMT_EMI_DEBUG_BUF_SIZE);
+	wmt_lib_get_fwinfor_from_emi(0, offset, &gEmiBuf[0], 0x100);
+
+	if (offset == 1) {
+		do {
+			pAddr = (PUINT32) wmt_plat_get_emi_virt_add(0x24);
+			cur_idx_pagedtrace = *pAddr;
+
+			if (cur_idx_pagedtrace > prev_idx_pagedtrace) {
+				len = cur_idx_pagedtrace - prev_idx_pagedtrace;
+				wmt_lib_get_fwinfor_from_emi(1, prev_idx_pagedtrace, &gEmiBuf[0], len);
+				wmt_dbg_fwinfor_print_buff(len);
+				prev_idx_pagedtrace = cur_idx_pagedtrace;
+			}
+
+			if (cur_idx_pagedtrace < prev_idx_pagedtrace) {
+				if (prev_idx_pagedtrace >= 0x8000) {
+					pr_debug("++ prev_idx_pagedtrace invalid ...++\n\\n");
+					prev_idx_pagedtrace = 0x8000 - 1;
+					continue;
+				}
+
+				len = 0x8000 - prev_idx_pagedtrace - 1;
+				wmt_lib_get_fwinfor_from_emi(1, prev_idx_pagedtrace, &gEmiBuf[0], len);
+				pr_debug("\n\n -- CONNSYS paged trace ascii output (cont...) --\n\n");
+				wmt_dbg_fwinfor_print_buff(len);
+
+				len = cur_idx_pagedtrace;
+				wmt_lib_get_fwinfor_from_emi(1, 0x0, &gEmiBuf[0], len);
+				pr_debug("\n\n -- CONNSYS paged trace ascii output (end) --\n\n");
+				wmt_dbg_fwinfor_print_buff(len);
+				prev_idx_pagedtrace = cur_idx_pagedtrace;
+			}
+			msleep(100);
+		} while (isBreak);
+	}
+
+	pr_debug("\n\n -- control word --\n\n");
+	wmt_dbg_fwinfor_print_buff(256);
+	if (len > 1024 * 4)
+		len = 1024 * 4;
+
+	WMT_WARN_FUNC("get fw infor from emi at offset(0x%x),len(0x%x)\n", offset, len);
+	osal_memset(&gEmiBuf[0], 0, WMT_EMI_DEBUG_BUF_SIZE);
+	wmt_lib_get_fwinfor_from_emi(1, offset, &gEmiBuf[0], len);
+
+	pr_debug("\n\n -- paged trace hex output --\n\n");
+	wmt_dbg_fwinfor_print_buff(len);
+	pr_debug("\n\n -- paged trace ascii output --\n\n");
+	wmt_dbg_fwinfor_print_buff(len);
+	kfree(buf_emi);
+	return 0;
+}
+
+INT32 wmt_dbg_coex_test(INT32 par1, INT32 par2, INT32 par3)
+{
+	WMT_INFO_FUNC("coexistance test cmd!!\n");
+	return wmt_dbg_cmd_test_api(par2 + WMTDRV_CMD_COEXDBG_00);
+}
+
+INT32 wmt_dbg_rst_ctrl(INT32 par1, INT32 par2, INT32 par3)
+{
+	WMT_INFO_FUNC("%s audo rst\n", 0 == par2 ? "disable" : "enable");
+	mtk_wcn_stp_set_auto_rst(0 == par2 ? 0 : 1);
+	return 0;
+}
+
+INT32 wmt_dbg_ut_test(INT32 par1, INT32 par2, INT32 par3)
+{
+
+	INT32 i = 0;
+	INT32 j = 0;
+	INT32 iRet = 0;
+
+	i = 20;
+	while ((i--) > 0) {
+		WMT_INFO_FUNC("#### UT WMT and STP Function On/Off .... %d\n", i);
+		j = 10;
+		while ((j--) > 0) {
+			WMT_INFO_FUNC("#### BT  On .... (%d, %d)\n", i, j);
+			iRet = mtk_wcn_wmt_func_on(WMTDRV_TYPE_BT);
+			if (iRet == MTK_WCN_BOOL_FALSE)
+				break;
+
+			WMT_INFO_FUNC("#### GPS On .... (%d, %d)\n", i, j);
+			iRet = mtk_wcn_wmt_func_on(WMTDRV_TYPE_GPS);
+			if (iRet == MTK_WCN_BOOL_FALSE)
+				break;
+
+			WMT_INFO_FUNC("#### FM  On .... (%d, %d)\n", i, j);
+			iRet = mtk_wcn_wmt_func_on(WMTDRV_TYPE_FM);
+			if (iRet == MTK_WCN_BOOL_FALSE)
+				break;
+
+			WMT_INFO_FUNC("#### WIFI On .... (%d, %d)\n", i, j);
+			iRet = mtk_wcn_wmt_func_on(WMTDRV_TYPE_WIFI);
+			if (iRet == MTK_WCN_BOOL_FALSE)
+				break;
+
+			WMT_INFO_FUNC("#### BT  Off .... (%d, %d)\n", i, j);
+			iRet = mtk_wcn_wmt_func_off(WMTDRV_TYPE_BT);
+			if (iRet == MTK_WCN_BOOL_FALSE)
+				break;
+
+			WMT_INFO_FUNC("#### GPS  Off ....(%d, %d)\n", i, j);
+			iRet = mtk_wcn_wmt_func_off(WMTDRV_TYPE_GPS);
+			if (iRet == MTK_WCN_BOOL_FALSE)
+				break;
+
+			WMT_INFO_FUNC("#### FM  Off .... (%d, %d)\n", i, j);
+			iRet = mtk_wcn_wmt_func_off(WMTDRV_TYPE_FM);
+			if (iRet == MTK_WCN_BOOL_FALSE)
+				break;
+
+			WMT_INFO_FUNC("#### WIFI  Off ....(%d, %d)\n", i, j);
+			iRet = mtk_wcn_wmt_func_off(WMTDRV_TYPE_WIFI);
+			if (iRet == MTK_WCN_BOOL_FALSE)
+				break;
+
+		}
+		if (iRet == MTK_WCN_BOOL_FALSE)
+			break;
+
+	}
+	if (iRet == MTK_WCN_BOOL_FALSE)
+		WMT_INFO_FUNC("#### UT FAIL!!\n");
+	else
+		WMT_INFO_FUNC("#### UT PASS!!\n");
+
+	return iRet;
+}
+
+#if CFG_CORE_INTERNAL_TXRX
+
+struct lpbk_package {
+	long payload_length;
+	unsigned char out_payload[2048];
+	unsigned char in_payload[2048];
+};
+
+static INT32 wmt_internal_loopback(INT32 count, INT32 max)
+{
+	int ret = 0;
+	int loop;
+	int offset;
+	struct lpbk_package lpbk_buffer;
+	P_OSAL_OP pOp;
+	P_OSAL_SIGNAL pSignal = NULL;
+
+	for (loop = 0; loop < count; loop++) {
+		/* <1> init buffer */
+		osal_memset((void *)&lpbk_buffer, 0, sizeof(struct lpbk_package));
+		lpbk_buffer.payload_length = max;
+		for (offset = 0; offset < max; offset++)
+			lpbk_buffer.out_payload[offset] = (offset + 1) /*for test use: begin from 1 */ & 0xFF;
+
+
+		memcpy(&gLpbkBuf[0], &lpbk_buffer.out_payload[0], max);
+
+		pOp = wmt_lib_get_free_op();
+		if (!pOp) {
+			WMT_WARN_FUNC("get_free_lxop fail\n");
+			ret = -1;
+			break;
+		}
+		pSignal = &pOp->signal;
+		pOp->op.opId = WMT_OPID_LPBK;
+		pOp->op.au4OpData[0] = lpbk_buffer.payload_length;	/* packet length */
+		pOp->op.au4OpData[1] = (UINT32) &gLpbkBuf[0];
+		pSignal->timeoutValue = MAX_EACH_WMT_CMD;
+		WMT_INFO_FUNC("OPID(%d) type(%d) start\n", pOp->op.opId, pOp->op.au4OpData[0]);
+		if (DISABLE_PSM_MONITOR()) {
+			WMT_ERR_FUNC("wake up failed,OPID(%d) type(%d) abort\n", pOp->op.opId, pOp->op.au4OpData[0]);
+			wmt_lib_put_op_to_free_queue(pOp);
+			ret = -2;
+		}
+
+		ret = wmt_lib_put_act_op(pOp);
+		ENABLE_PSM_MONITOR();
+		if (MTK_WCN_BOOL_FALSE == ret) {
+			WMT_WARN_FUNC("OPID(%d) type(%d)fail\n", pOp->op.opId, pOp->op.au4OpData[0]);
+			ret = -3;
+			break;
+		}
+		WMT_INFO_FUNC("OPID(%d) length(%d) ok\n", pOp->op.opId, pOp->op.au4OpData[0]);
+
+		memcpy(&lpbk_buffer.in_payload[0], &gLpbkBuf[0], max);
+
+		ret = pOp->op.au4OpData[0];
+		/*<3> compare result */
+		if (memcmp(lpbk_buffer.in_payload, lpbk_buffer.out_payload, lpbk_buffer.payload_length)) {
+			WMT_INFO_FUNC("[%s] WMT_TEST_LPBK_CMD payload compare error\n", __func__);
+			ret = -4;
+			break;
+		}
+		WMT_ERR_FUNC("[%s] exec WMT_TEST_LPBK_CMD succeed(loop = %d, size = %ld)\n", __func__, loop,
+			     lpbk_buffer.payload_length);
+
+	}
+
+	if (loop != count)
+		WMT_ERR_FUNC("fail at loop(%d) buf_length(%d)\n", loop, max);
+
+
+	return ret;
+}
+
+INT32 wmt_dbg_internal_lpbk_test(INT32 par1, INT32 par2, INT32 par3)
+{
+	UINT32 count;
+	UINT32 length;
+
+	count = par1;
+	length = par2;
+
+	WMT_INFO_FUNC("count[%d],length[%d]\n", count, length);
+
+	wmt_core_lpbk_do_stp_init();
+
+	wmt_internal_loopback(count, length);
+
+	wmt_core_lpbk_do_stp_deinit();
+	return 0;
+}
+#endif
+
+static INT32 wmt_dbg_set_mcu_clock(INT32 par1, INT32 par2, INT32 par3)
+{
+	int ret = 0;
+	P_OSAL_OP pOp;
+	P_OSAL_SIGNAL pSignal = NULL;
+	UINT32 kind = 0;
+
+	kind = par2;
+	pOp = wmt_lib_get_free_op();
+	if (!pOp) {
+		WMT_WARN_FUNC("get_free_lxop fail\n");
+		return -1;
+	}
+	pSignal = &pOp->signal;
+	pOp->op.opId = WMT_OPID_SET_MCU_CLK;
+	pOp->op.au4OpData[0] = kind;
+	pSignal->timeoutValue = MAX_EACH_WMT_CMD;
+
+	WMT_INFO_FUNC("OPID(%d) kind(%d) start\n", pOp->op.opId, pOp->op.au4OpData[0]);
+	if (DISABLE_PSM_MONITOR()) {
+		WMT_ERR_FUNC("wake up failed,OPID(%d) kind(%d) abort\n", pOp->op.opId, pOp->op.au4OpData[0]);
+		wmt_lib_put_op_to_free_queue(pOp);
+		return -2;
+	}
+
+	ret = wmt_lib_put_act_op(pOp);
+	ENABLE_PSM_MONITOR();
+	if (MTK_WCN_BOOL_FALSE == ret) {
+		WMT_WARN_FUNC("OPID(%d) kind(%d)fail(%d)\n", pOp->op.opId, pOp->op.au4OpData[0], ret);
+		return -3;
+	}
+	WMT_INFO_FUNC("OPID(%d) kind(%d) ok\n", pOp->op.opId, pOp->op.au4OpData[0]);
+
+	return ret;
+}
+
+static INT32 wmt_dbg_poll_cpupcr(INT32 par1, INT32 par2, INT32 par3)
+{
+	UINT32 count = 0;
+	UINT16 sleep = 0;
+	UINT16 toAee = 0;
+
+	count = par2;
+	sleep = (par3 & 0xF0) >> 4;
+	toAee = (par3 & 0x0F);
+
+	WMT_INFO_FUNC("polling count[%d],polling sleep[%d],toaee[%d]\n", count, sleep, toAee);
+	wmt_lib_poll_cpupcr(count, sleep, toAee);
+
+	return 0;
+}
+
+#if CONSYS_ENALBE_SET_JTAG
+static INT32 wmt_dbg_jtag_flag_ctrl(INT32 par1, INT32 par2, INT32 par3)
+{
+	UINT32 en_flag = par2;
+
+	wmt_lib_jtag_flag_set(en_flag);
+	return 0;
+}
+#endif
+
+#if CFG_WMT_LTE_COEX_HANDLING
+static INT32 wmt_dbg_lte_to_wmt_test(UINT32 opcode, UINT32 msg_len)
+{
+	ipc_ilm_t ilm;
+	local_para_struct *p_buf_str;
+	INT32 i = 0;
+	INT32 iRet = -1;
+
+	WMT_INFO_FUNC("opcode(0x%02x),msg_len(%d)\n", opcode, msg_len);
+	p_buf_str = osal_malloc(osal_sizeof(local_para_struct) + msg_len);
+	if (NULL == p_buf_str) {
+		WMT_ERR_FUNC("kmalloc for local para ptr structure failed.\n");
+		return -1;
+	}
+	p_buf_str->msg_len = msg_len;
+	for (i = 0; i < msg_len; i++)
+		p_buf_str->data[i] = i;
+
+	ilm.local_para_ptr = p_buf_str;
+	ilm.msg_id = opcode;
+
+	iRet = wmt_lib_handle_idc_msg(&ilm);
+	osal_free(p_buf_str);
+	return iRet;
+
+}
+
+static INT32 wmt_dbg_lte_coex_test(INT32 par1, INT32 par2, INT32 par3)
+{
+	UINT8 *local_buffer = NULL;
+	UINT32 handle_len;
+	INT32 iRet = -1;
+	static UINT8 wmt_to_lte_test_evt1[] = { 0x02, 0x16, 0x0d, 0x00,
+		0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
+		0xa, 0xb
+	};
+	static UINT8 wmt_to_lte_test_evt2[] = { 0x02, 0x16, 0x09, 0x00,
+		0x01, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
+	};
+	static UINT8 wmt_to_lte_test_evt3[] = { 0x02, 0x16, 0x02, 0x00,
+		0x02, 0xff
+	};
+	static UINT8 wmt_to_lte_test_evt4[] = { 0x02, 0x16, 0x0d, 0x00,
+		0x03, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
+		0xa, 0xb
+	};
+
+	local_buffer = kmalloc(512, GFP_KERNEL);
+	if (!local_buffer) {
+		WMT_ERR_FUNC("local_buffer kmalloc memory fail\n");
+		return 0;
+	}
+
+	if (par2 == 1) {
+		handle_len =
+		    wmt_idc_msg_to_lte_handing_for_test(&wmt_to_lte_test_evt1[0], osal_sizeof(wmt_to_lte_test_evt1));
+		if (handle_len != osal_sizeof(wmt_to_lte_test_evt1)) {
+			WMT_ERR_FUNC("par2=1,wmt send to lte msg fail:handle_len(%d),buff_len(%d)\n",
+				     handle_len, osal_sizeof(wmt_to_lte_test_evt1));
+		} else {
+			WMT_INFO_FUNC("par2=1,wmt send to lte msg OK! send_len(%d)\n", handle_len);
+		}
+	}
+	if (par2 == 2) {
+		osal_memcpy(&local_buffer[0], &wmt_to_lte_test_evt1[0], osal_sizeof(wmt_to_lte_test_evt1));
+		osal_memcpy(&local_buffer[osal_sizeof(wmt_to_lte_test_evt1)],
+			    &wmt_to_lte_test_evt2[0], osal_sizeof(wmt_to_lte_test_evt2));
+
+		handle_len =
+		    wmt_idc_msg_to_lte_handing_for_test(&local_buffer[0],
+							osal_sizeof(wmt_to_lte_test_evt1) +
+							osal_sizeof(wmt_to_lte_test_evt2));
+		if (handle_len != osal_sizeof(wmt_to_lte_test_evt1) + osal_sizeof(wmt_to_lte_test_evt2)) {
+			WMT_ERR_FUNC("par2=2,wmt send to lte msg fail:handle_len(%d),buff_len(%d)\n",
+				     handle_len, osal_sizeof(wmt_to_lte_test_evt1) + osal_sizeof(wmt_to_lte_test_evt2));
+		} else {
+			WMT_INFO_FUNC("par2=1,wmt send to lte msg OK! send_len(%d)\n", handle_len);
+		}
+	}
+	if (par2 == 3) {
+		osal_memcpy(&local_buffer[0], &wmt_to_lte_test_evt1[0], osal_sizeof(wmt_to_lte_test_evt1));
+		osal_memcpy(&local_buffer[osal_sizeof(wmt_to_lte_test_evt1)],
+			    &wmt_to_lte_test_evt2[0], osal_sizeof(wmt_to_lte_test_evt2));
+		osal_memcpy(&local_buffer[osal_sizeof(wmt_to_lte_test_evt1) + osal_sizeof(wmt_to_lte_test_evt2)],
+			    &wmt_to_lte_test_evt3[0], osal_sizeof(wmt_to_lte_test_evt3));
+
+		handle_len = wmt_idc_msg_to_lte_handing_for_test(&local_buffer[0], osal_sizeof(wmt_to_lte_test_evt1) +
+								 osal_sizeof(wmt_to_lte_test_evt2) +
+								 osal_sizeof(wmt_to_lte_test_evt3));
+		if (handle_len !=
+		    osal_sizeof(wmt_to_lte_test_evt1) + osal_sizeof(wmt_to_lte_test_evt2) +
+		    osal_sizeof(wmt_to_lte_test_evt3)) {
+			WMT_ERR_FUNC("par2=3,wmt send to lte msg fail:handle_len(%d),buff_len(%d)\n", handle_len,
+				     osal_sizeof(wmt_to_lte_test_evt1) + osal_sizeof(wmt_to_lte_test_evt2) +
+				     osal_sizeof(wmt_to_lte_test_evt3));
+		} else {
+			WMT_INFO_FUNC("par3=1,wmt send to lte msg OK! send_len(%d)\n", handle_len);
+		}
+	}
+	if (par2 == 4) {
+		handle_len =
+		    wmt_idc_msg_to_lte_handing_for_test(&wmt_to_lte_test_evt4[0], osal_sizeof(wmt_to_lte_test_evt4));
+		if (handle_len != osal_sizeof(wmt_to_lte_test_evt4)) {
+			WMT_ERR_FUNC("par2=1,wmt send to lte msg fail:handle_len(%d),buff_len(%d)\n",
+				     handle_len, osal_sizeof(wmt_to_lte_test_evt4));
+		} else {
+			WMT_INFO_FUNC("par2=1,wmt send to lte msg OK! send_len(%d)\n", handle_len);
+		}
+	}
+	if (par2 == 5) {
+		if (par3 >= 1024)
+			par3 = 1024;
+
+		iRet = wmt_dbg_lte_to_wmt_test(IPC_MSG_ID_EL1_LTE_DEFAULT_PARAM_IND, par3);
+		WMT_INFO_FUNC("IPC_MSG_ID_EL1_LTE_DEFAULT_PARAM_IND test result(%d)\n", iRet);
+	}
+	if (par2 == 6) {
+		if (par3 >= 1024)
+			par3 = 1024;
+
+		iRet = wmt_dbg_lte_to_wmt_test(IPC_MSG_ID_EL1_LTE_OPER_FREQ_PARAM_IND, par3);
+		WMT_INFO_FUNC("IPC_MSG_ID_EL1_LTE_OPER_FREQ_PARAM_IND test result(%d)\n", iRet);
+	}
+	if (par2 == 7) {
+		if (par3 >= 1024)
+			par3 = 1024;
+
+		iRet = wmt_dbg_lte_to_wmt_test(IPC_MSG_ID_EL1_WIFI_MAX_PWR_IND, par3);
+		WMT_INFO_FUNC("IPC_MSG_ID_EL1_WIFI_MAX_PWR_IND test result(%d)\n", iRet);
+	}
+	if (par2 == 8) {
+		if (par3 >= 1024)
+			par3 = 1024;
+
+		iRet = wmt_dbg_lte_to_wmt_test(IPC_MSG_ID_EL1_LTE_TX_IND, par3);
+		WMT_INFO_FUNC("IPC_MSG_ID_EL1_LTE_TX_IND test result(%d)\n", iRet);
+	}
+	if (par2 == 9) {
+		if (par3 > 0)
+			wmt_core_set_flag_for_test(1);
+		else
+			wmt_core_set_flag_for_test(0);
+	}
+	return 0;
+	kfree(local_buffer);
+}
+#endif
+
+static ssize_t wmt_dev_dbg_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+
+	INT32 retval = 0;
+	INT32 i_ret = 0;
+	PINT8 warn_msg = "no data available, please run echo 15 xx > /proc/driver/wmt_psm first\n";
+
+	if (*f_pos > 0) {
+		retval = 0;
+	} else {
+		/*len = sprintf(page, "%d\n", g_psm_enable); */
+		if (gCoexBuf.availSize <= 0) {
+			WMT_INFO_FUNC("no data available, please run echo 15 xx > /proc/driver/wmt_psm first\n");
+			retval = osal_strlen(warn_msg) + 1;
+			if (count < retval)
+				retval = count;
+
+			i_ret = copy_to_user(buf, warn_msg, retval);
+			if (i_ret) {
+				WMT_ERR_FUNC("copy to buffer failed, ret:%d\n", retval);
+				retval = -EFAULT;
+				goto err_exit;
+			}
+			*f_pos += retval;
+		} else {
+			INT32 i = 0;
+			INT32 len = 0;
+			INT8 msg_info[128];
+			INT32 max_num = 0;
+			/*we do not check page buffer, because there are only
+			* 100 bytes in g_coex_buf, no reason page buffer is not
+			* enough, a bomb is placed here on unexpected condition
+			*/
+
+			WMT_INFO_FUNC("%d bytes available\n", gCoexBuf.availSize);
+			max_num = ((osal_sizeof(msg_info) > count ? osal_sizeof(msg_info) : count) - 1) / 5;
+
+			if (max_num > gCoexBuf.availSize)
+				max_num = gCoexBuf.availSize;
+			else
+				WMT_INFO_FUNC("round to %d bytes due to local buffer size limitation\n", max_num);
+
+
+			for (i = 0; i < max_num; i++)
+				len += osal_sprintf(msg_info + len, "0x%02x ", gCoexBuf.buffer[i]);
+
+
+			len += osal_sprintf(msg_info + len, "\n");
+			retval = len;
+
+			i_ret = copy_to_user(buf, msg_info, retval);
+			if (i_ret) {
+				WMT_ERR_FUNC("copy to buffer failed, ret:%d\n", retval);
+				retval = -EFAULT;
+				goto err_exit;
+			}
+			*f_pos += retval;
+
+		}
+	}
+	gCoexBuf.availSize = 0;
+err_exit:
+
+	return retval;
+}
+
+static ssize_t wmt_dev_dbg_write(struct file *filp, const char __user *buffer, size_t count, loff_t *f_pos)
+{
+	INT8 buf[256];
+	PINT8 pBuf;
+	ssize_t len = count;
+	INT32 x = 0, y = 0, z = 0;
+	PINT8 pToken = NULL;
+	PINT8 pDelimiter = " \t";
+	long res;
+	INT32 ret;
+
+	WMT_INFO_FUNC("write parameter len = %d\n\r", (INT32) len);
+	if (len >= osal_sizeof(buf)) {
+		WMT_ERR_FUNC("input handling fail!\n");
+		len = osal_sizeof(buf) - 1;
+		return -1;
+	}
+
+	if (copy_from_user(buf, buffer, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	WMT_INFO_FUNC("write parameter data = %s\n\r", buf);
+
+	pBuf = buf;
+	pToken = osal_strsep(&pBuf, pDelimiter);
+
+	if (pToken != NULL) {
+		ret = osal_strtol(pToken, 16, &res);
+		if (ret) {
+			WMT_ERR_FUNC("get x fail(%d)\n", ret);
+			x = 0;
+		}
+		x = res;
+	} else {
+		x = 0;
+	}
+
+	pToken = osal_strsep(&pBuf, "\t\n ");
+	if (pToken != NULL) {
+		ret = osal_strtol(pToken, 16, &res);
+		if (ret) {
+			WMT_ERR_FUNC("get y fail(%d)\n", ret);
+			y = 0;
+		}
+		y = res;
+		WMT_INFO_FUNC("y = 0x%08x\n\r", y);
+	} else {
+		y = 3000;
+		/*efuse, register read write default value */
+		if (0x11 == x || 0x12 == x || 0x13 == x)
+			y = 0x80000000;
+
+	}
+
+	pToken = osal_strsep(&pBuf, "\t\n ");
+	if (pToken != NULL) {
+		ret = osal_strtol(pToken, 16, &res);
+		if (ret) {
+			WMT_ERR_FUNC("get z fail(%d)\n", ret);
+			z = 0;
+		}
+		z = res;
+	} else {
+		z = 10;
+		/*efuse, register read write default value */
+		if (0x11 == x || 0x12 == x || 0x13 == x)
+			z = 0xffffffff;
+
+	}
+
+	WMT_WARN_FUNC("x(0x%08x), y(0x%08x), z(0x%08x)\n\r", x, y, z);
+
+	if (osal_array_size(wmt_dev_dbg_func) > x && NULL != wmt_dev_dbg_func[x])
+		(*wmt_dev_dbg_func[x]) (x, y, z);
+	else
+		WMT_WARN_FUNC("no handler defined for command id(0x%08x)\n\r", x);
+
+	return len;
+}
+
+INT32 wmt_dev_dbg_setup(VOID)
+{
+	static const struct file_operations wmt_dbg_fops = {
+		.owner = THIS_MODULE,
+		.read = wmt_dev_dbg_read,
+		.write = wmt_dev_dbg_write,
+	};
+	gWmtDbgEntry = proc_create(WMT_DBG_PROCNAME, 0664, NULL, &wmt_dbg_fops);
+	if (gWmtDbgEntry == NULL) {
+		WMT_ERR_FUNC("Unable to create /proc entry\n\r");
+		return -1;
+	}
+	return 0;
+}
+
+INT32 wmt_dev_dbg_remove(VOID)
+{
+	if (NULL != gWmtDbgEntry)
+		remove_proc_entry(WMT_DBG_PROCNAME, NULL);
+
+#if CFG_WMT_PS_SUPPORT
+	wmt_lib_ps_deinit();
+#endif
+	return 0;
+}
+#endif
+
+#if CFG_WMT_PROC_FOR_AEE
+
+static ssize_t wmt_dev_proc_for_aee_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	INT32 retval = 0;
+	UINT32 len = 0;
+
+	WMT_INFO_FUNC("%s: count %d pos %lld\n", __func__, count, *f_pos);
+
+	if (0 == *f_pos) {
+		pBuf = wmt_lib_get_cpupcr_xml_format(&len);
+		g_buf_len = len;
+		WMT_INFO_FUNC("wmt_dev:wmt for aee buffer len(%d)\n", g_buf_len);
+	}
+
+	if (g_buf_len >= count) {
+
+		retval = copy_to_user(buf, pBuf, count);
+		if (retval) {
+			WMT_ERR_FUNC("copy to aee buffer failed, ret:%d\n", retval);
+			retval = -EFAULT;
+			goto err_exit;
+		}
+
+		*f_pos += count;
+		g_buf_len -= count;
+		pBuf += count;
+		WMT_INFO_FUNC("wmt_dev:after read,wmt for aee buffer len(%d)\n", g_buf_len);
+
+		retval = count;
+	} else if (0 != g_buf_len) {
+
+		retval = copy_to_user(buf, pBuf, g_buf_len);
+		if (retval) {
+			WMT_ERR_FUNC("copy to aee buffer failed, ret:%d\n", retval);
+			retval = -EFAULT;
+			goto err_exit;
+		}
+
+		*f_pos += g_buf_len;
+		len = g_buf_len;
+		g_buf_len = 0;
+		pBuf += len;
+		retval = len;
+		WMT_INFO_FUNC("wmt_dev:after read,wmt for aee buffer len(%d)\n", g_buf_len);
+	} else {
+		WMT_INFO_FUNC("wmt_dev: no data available for aee\n");
+		retval = 0;
+	}
+err_exit:
+	return retval;
+}
+
+static ssize_t wmt_dev_proc_for_aee_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
+{
+	WMT_TRC_FUNC();
+	return 0;
+}
+
+INT32 wmt_dev_proc_for_aee_setup(VOID)
+{
+	static const struct file_operations wmt_aee_fops = {
+		.owner = THIS_MODULE,
+		.read = wmt_dev_proc_for_aee_read,
+		.write = wmt_dev_proc_for_aee_write,
+	};
+
+	gWmtDbgEntry = proc_create(WMT_AEE_PROCNAME, 0664, NULL, &wmt_aee_fops);
+	if (gWmtDbgEntry == NULL) {
+		WMT_ERR_FUNC("Unable to create /proc entry\n\r");
+		return -1;
+	}
+
+	return 0;
+}
+
+INT32 wmt_dev_proc_for_aee_remove(VOID)
+{
+	if (NULL != gWmtAeeEntry)
+		remove_proc_entry(WMT_AEE_PROCNAME, NULL);
+
+	return 0;
+}
+#endif
+
+VOID wmt_dev_rx_event_cb(VOID)
+{
+	u4RxFlag = 1;
+	atomic_inc(&gRxCount);
+	if (NULL != gpRxEvent) {
+		/* u4RxFlag = 1; */
+		/* atomic_inc(&gRxCount); */
+		wake_up_interruptible(&gpRxEvent->waitQueue);
+	} else {
+		/* WMT_ERR_FUNC("null gpRxEvent, flush rx!\n"); */
+		/* wmt_lib_flush_rx(); */
+	}
+}
+
+INT32 wmt_dev_rx_timeout(P_OSAL_EVENT pEvent)
+{
+
+	UINT32 ms = pEvent->timeoutValue;
+	long lRet = 0;
+
+	gpRxEvent = pEvent;
+	if (0 != ms)
+		lRet = wait_event_interruptible_timeout(gpRxEvent->waitQueue, 0 != u4RxFlag, msecs_to_jiffies(ms));
+	else
+		lRet = wait_event_interruptible(gpRxEvent->waitQueue, u4RxFlag != 0);
+
+	u4RxFlag = 0;
+/* gpRxEvent = NULL; */
+	if (atomic_dec_return(&gRxCount)) {
+		WMT_ERR_FUNC("gRxCount != 0 (%d), reset it!\n", atomic_read(&gRxCount));
+		atomic_set(&gRxCount, 0);
+	}
+
+	return lRet;
+}
+
+INT32 wmt_dev_read_file(PUINT8 pName, const PPUINT8 ppBufPtr, INT32 offset, INT32 padSzBuf)
+{
+	INT32 iRet = -1;
+	struct file *fd;
+	/* ssize_t iRet; */
+	INT32 file_len;
+	INT32 read_len;
+	PVOID pBuf;
+        mm_segment_t fs;
+
+	/* struct cred *cred = get_task_cred(current); */
+	//const struct cred *cred = get_current_cred();
+
+	if (!ppBufPtr) {
+		WMT_ERR_FUNC("invalid ppBufptr!\n");
+		return -1;
+	}
+	*ppBufPtr = NULL;
+
+	fd = filp_open(pName, O_RDONLY, 0);
+        if (IS_ERR(fd)) {
+            WMT_ERR_FUNC("error code:%d\n", PTR_ERR(fd));
+            return -2;
+        }
+
+        if(fd->f_op == NULL) {
+            printk(KERN_ERR "invalid file op \r\n");
+            return -3;
+        }
+
+#if 0
+	if (!fd || IS_ERR(fd) || !fd->f_op || !fd->f_op->read) {
+		WMT_ERR_FUNC("failed to open or read!(0x%p, %d, %d, %d)\n", fd, PTR_ERR(fd), cred->fsuid, cred->fsgid);
+		if (IS_ERR(fd))
+			WMT_ERR_FUNC("error code:%d\n", PTR_ERR(fd));
+		return -1;
+	}
+#endif
+	file_len = fd->f_path.dentry->d_inode->i_size;
+	file_len = fd->f_op->llseek(fd, 0, 2);
+	fd->f_op->llseek(fd, 0, 0);
+	pBuf = vmalloc((file_len + BCNT_PATCH_BUF_HEADROOM + 3) & ~0x3UL);
+	if (!pBuf) {
+		WMT_ERR_FUNC("failed to vmalloc(%d)\n", (INT32) ((file_len + 3) & ~0x3UL));
+		goto read_file_done;
+	}
+
+	do {
+		if (fd->f_pos != offset) {
+			if (fd->f_op->llseek) {
+				if (fd->f_op->llseek(fd, offset, 0) != offset) {
+					WMT_ERR_FUNC("failed to seek!!\n");
+					goto read_file_done;
+				}
+			} else {
+				fd->f_pos = offset;
+			}
+		}
+
+                fs=get_fs();
+		read_len = kernel_read(fd, pBuf + padSzBuf, file_len, &fd->f_pos);
+                set_fs(fs);
+		if (read_len != file_len)
+			WMT_WARN_FUNC("read abnormal: read_len(%d), file_len(%d)\n", read_len, file_len);
+
+	} while (false);
+
+	iRet = 0;
+	*ppBufPtr = pBuf;
+
+read_file_done:
+	if (iRet) {
+		if (pBuf)
+			vfree(pBuf);
+
+	}
+
+	filp_close(fd, NULL);
+
+	return (iRet) ? iRet : read_len;
+}
+
+/* TODO: [ChangeFeature][George] refine this function name for general filesystem read operation, not patch only. */
+INT32 wmt_dev_patch_get(PUINT8 pPatchName, osal_firmware **ppPatch, INT32 padSzBuf)
+{
+	INT32 iRet = -1;
+	osal_firmware *pfw;
+	uid_t orig_uid;
+	gid_t orig_gid;
+
+	/* struct cred *cred = get_task_cred(current); */
+	struct cred *cred = (struct cred *)get_current_cred();
+
+	mm_segment_t orig_fs = get_fs();
+
+	if (*ppPatch) {
+		WMT_WARN_FUNC("f/w patch already exists\n");
+		if ((*ppPatch)->data)
+			vfree((*ppPatch)->data);
+
+		kfree(*ppPatch);
+		*ppPatch = NULL;
+	}
+
+	if (!osal_strlen(pPatchName)) {
+		WMT_ERR_FUNC("empty f/w name\n");
+		osal_assert((osal_strlen(pPatchName) > 0));
+		return -1;
+	}
+
+	pfw = kzalloc(sizeof(osal_firmware), /*GFP_KERNEL */ GFP_ATOMIC);
+	if (!pfw) {
+		WMT_ERR_FUNC("kzalloc(%d) fail\n", sizeof(osal_firmware));
+		return -2;
+	}
+
+	orig_uid = cred->fsuid.val;
+	orig_gid = cred->fsgid.val;
+	cred->fsuid.val = cred->fsgid.val = 0;
+
+	set_fs(get_ds());
+
+	/* load patch file from fs */
+	iRet = wmt_dev_read_file(pPatchName, (const PPUINT8)&pfw->data, 0, padSzBuf);
+	set_fs(orig_fs);
+
+	cred->fsuid.val = orig_uid;
+	cred->fsgid.val = orig_gid;
+
+
+	if (iRet > 0) {
+		pfw->size = iRet;
+		*ppPatch = pfw;
+		WMT_DBG_FUNC("load (%s) to addr(0x%p) success\n", pPatchName, pfw->data);
+		return 0;
+	}
+	kfree(pfw);
+	*ppPatch = NULL;
+	WMT_ERR_FUNC("load file (%s) fail, iRet(%d)\n", pPatchName, iRet);
+	return -1;
+}
+
+INT32 wmt_dev_patch_put(osal_firmware **ppPatch)
+{
+	if (NULL != *ppPatch) {
+		if ((*ppPatch)->data)
+			vfree((*ppPatch)->data);
+
+		kfree(*ppPatch);
+		*ppPatch = NULL;
+	}
+	return 0;
+}
+
+VOID wmt_dev_patch_info_free(VOID)
+{
+
+	kfree(pPatchInfo);
+	pPatchInfo = NULL;
+
+}
+
+MTK_WCN_BOOL wmt_dev_is_file_exist(PUINT8 pFileName)
+{
+	struct file *fd = NULL;
+	/* ssize_t iRet; */
+	INT32 fileLen = -1;
+	const struct cred *cred = get_current_cred();
+
+	if (pFileName == NULL) {
+		WMT_ERR_FUNC("invalid file name pointer(%p)\n", pFileName);
+		return MTK_WCN_BOOL_FALSE;
+	}
+	if (osal_strlen(pFileName) < osal_strlen(defaultPatchName)) {
+		WMT_ERR_FUNC("invalid file name(%s)\n", pFileName);
+		return MTK_WCN_BOOL_FALSE;
+	}
+	/* struct cred *cred = get_task_cred(current); */
+
+	fd = filp_open(pFileName, O_RDONLY, 0);
+	if (!fd || IS_ERR(fd) || !fd->f_op || !fd->f_op->read) {
+		WMT_ERR_FUNC("failed to open or read(%s)!(0x%p, %d, %d)\n", pFileName, fd, cred->fsuid, cred->fsgid);
+		return MTK_WCN_BOOL_FALSE;
+	}
+	fileLen = fd->f_path.dentry->d_inode->i_size;
+	filp_close(fd, NULL);
+	fd = NULL;
+	if (fileLen <= 0) {
+		WMT_ERR_FUNC("invalid file(%s), length(%d)\n", pFileName, fileLen);
+		return MTK_WCN_BOOL_FALSE;
+	}
+	WMT_ERR_FUNC("valid file(%s), length(%d)\n", pFileName, fileLen);
+	return true;
+
+}
+
+/* static unsigned long count_last_access_sdio = 0; */
+static unsigned long count_last_access_btif;
+static unsigned long jiffies_last_poll;
+
+#if 0
+static INT32 wmt_dev_tra_sdio_update(void)
+{
+	count_last_access_sdio += 1;
+	/* WMT_INFO_FUNC("jiffies_last_access_sdio: jiffies = %ul\n", jiffies); */
+
+	return 0;
+}
+#endif
+
+extern INT32 wmt_dev_tra_bitf_update(void)
+{
+	count_last_access_btif += 1;
+	/* WMT_INFO_FUNC("jiffies_last_access_btif: jiffies = %ul\n", jiffies); */
+
+	return 0;
+}
+
+static UINT32 wmt_dev_tra_ahb_poll(void)
+{
+#define TIME_THRESHOLD_TO_TEMP_QUERY 3000
+#define COUNT_THRESHOLD_TO_TEMP_QUERY 200
+
+	unsigned long ahb_during_count = 0;
+	unsigned long poll_during_time = 0;
+
+	/* if (jiffies > jiffies_last_poll) */
+	if (time_after(jiffies, jiffies_last_poll))
+		poll_during_time = jiffies - jiffies_last_poll;
+	else
+		poll_during_time = 0xffffffff;
+
+
+	WMT_DBG_FUNC("**jiffies_to_mesecs(0xffffffff) = %lu\n", jiffies_to_msecs(0xffffffff));
+
+	if (jiffies_to_msecs(poll_during_time) < TIME_THRESHOLD_TO_TEMP_QUERY) {
+		WMT_DBG_FUNC("**poll_during_time = %lu < %lu, not to query\n",
+			     jiffies_to_msecs(poll_during_time), TIME_THRESHOLD_TO_TEMP_QUERY);
+		return -1;
+	}
+	/* ahb_during_count = count_last_access_sdio; */
+	if (NULL == mtk_wcn_wlan_bus_tx_cnt) {
+		WMT_ERR_FUNC("WMT-DEV:mtk_wcn_wlan_bus_tx_cnt null pointer\n");
+		return -1;
+	}
+	ahb_during_count = (*mtk_wcn_wlan_bus_tx_cnt) ();
+
+	if (ahb_during_count < COUNT_THRESHOLD_TO_TEMP_QUERY) {
+		WMT_DBG_FUNC("**ahb_during_count = %lu < %lu, not to query\n",
+			     ahb_during_count, COUNT_THRESHOLD_TO_TEMP_QUERY);
+		return -2;
+	}
+
+	if (NULL == mtk_wcn_wlan_bus_tx_cnt_clr) {
+		WMT_ERR_FUNC("WMT-DEV:mtk_wcn_wlan_bus_tx_cnt_clr null pointer\n");
+		return -3;
+	}
+	(*mtk_wcn_wlan_bus_tx_cnt_clr) ();
+	/* count_last_access_sdio = 0; */
+	jiffies_last_poll = jiffies;
+
+	WMT_INFO_FUNC("**poll_during_time = %lu > %lu, ahb_during_count = %lu > %lu, query\n",
+		      jiffies_to_msecs(poll_during_time), TIME_THRESHOLD_TO_TEMP_QUERY,
+		      jiffies_to_msecs(ahb_during_count), COUNT_THRESHOLD_TO_TEMP_QUERY);
+
+	return 0;
+}
+
+long wmt_dev_tm_temp_query(void)
+{
+#define HISTORY_NUM       5
+#define TEMP_THRESHOLD   65
+#define REFRESH_TIME    300	/* sec */
+
+	static INT32 temp_table[HISTORY_NUM] = { 99 };	/* not query yet. */
+	static INT32 idx_temp_table;
+	static struct timeval query_time, now_time;
+
+	INT8 query_cond = 0;
+	INT32 current_temp = 0;
+	INT32 index = 0;
+	long return_temp = 0;
+	/* Query condition 1: */
+	/* If we have the high temperature records on the past, we continue to query/monitor */
+	/* the real temperature until cooling */
+	for (index = 0; index < HISTORY_NUM; index++) {
+		if (temp_table[index] >= TEMP_THRESHOLD) {
+			query_cond = 1;
+			WMT_DBG_FUNC("temperature table is still initial value, we should query temp temperature..\n");
+		}
+	}
+
+	do_gettimeofday(&now_time);
+#if 1
+	/* Query condition 2: */
+	/* Moniter the ahb bus activity to decide if we have the need to query temperature. */
+	if (!query_cond) {
+		if (wmt_dev_tra_ahb_poll() == 0) {
+			query_cond = 1;
+			WMT_INFO_FUNC("ahb traffic , we must query temperature..\n");
+		} else {
+			WMT_DBG_FUNC("ahb idle traffic ....\n");
+		}
+
+		/* only WIFI tx power might make temperature varies largely */
+#if 0
+		if (!query_cond) {
+			last_access_time = wmt_dev_tra_uart_poll();
+			if (jiffies_to_msecs(last_access_time) < TIME_THRESHOLD_TO_TEMP_QUERY) {
+				query_cond = 1;
+				WMT_DBG_FUNC("uart busy traffic , we must query temperature..\n");
+			} else {
+				WMT_DBG_FUNC("uart still idle traffic , we don't query temp temperature..\n");
+			}
+		}
+#endif
+	}
+#endif
+	/* Query condition 3: */
+	/* If the query time exceeds the a certain of period, refresh temp table. */
+	/*  */
+	if (!query_cond) {
+		/* time overflow, we refresh temp table again for simplicity! */
+		if ((now_time.tv_sec < query_time.tv_sec) ||
+		    ((now_time.tv_sec > query_time.tv_sec) && (now_time.tv_sec - query_time.tv_sec) > REFRESH_TIME)) {
+			query_cond = 1;
+
+			WMT_INFO_FUNC("It is long time (> %d sec) not to query, we must query temp temperature..\n",
+				      REFRESH_TIME);
+			for (index = 0; index < HISTORY_NUM; index++)
+				temp_table[index] = 99;
+
+		}
+	}
+
+	if (query_cond) {
+		/* update the temperature record */
+		mtk_wcn_wmt_therm_ctrl(WMTTHERM_ENABLE);
+		current_temp = mtk_wcn_wmt_therm_ctrl(WMTTHERM_READ);
+		mtk_wcn_wmt_therm_ctrl(WMTTHERM_DISABLE);
+		idx_temp_table = (idx_temp_table + 1) % HISTORY_NUM;
+		temp_table[idx_temp_table] = current_temp;
+		do_gettimeofday(&query_time);
+
+		WMT_INFO_FUNC("[Thermal] current_temp = 0x%x\n", (current_temp & 0xFF));
+	} else {
+		current_temp = temp_table[idx_temp_table];
+		idx_temp_table = (idx_temp_table + 1) % HISTORY_NUM;
+		temp_table[idx_temp_table] = current_temp;
+	}
+
+	/*  */
+	/* Dump information */
+	/*  */
+	WMT_DBG_FUNC("[Thermal] idx_temp_table = %d\n", idx_temp_table);
+	WMT_DBG_FUNC("[Thermal] now.time = %d, query.time = %d, REFRESH_TIME = %d\n", now_time.tv_sec,
+		     query_time.tv_sec, REFRESH_TIME);
+
+	WMT_DBG_FUNC("[0] = %d, [1] = %d, [2] = %d, [3] = %d, [4] = %d\n----\n",
+		     temp_table[0], temp_table[1], temp_table[2], temp_table[3], temp_table[4]);
+
+	return_temp = ((current_temp & 0x80) == 0x0) ? current_temp : (-1) * (current_temp & 0x7f);
+
+	return return_temp;
+}
+
+ssize_t WMT_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
+{
+	INT32 iRet = 0;
+	UINT8 wrBuf[NAME_MAX + 1] = { 0 };
+	INT32 copySize = (count < NAME_MAX) ? count : NAME_MAX;
+
+	WMT_LOUD_FUNC("count:%d copySize:%d\n", count, copySize);
+
+	if (copySize > 0) {
+		if (copy_from_user(wrBuf, buf, copySize)) {
+			iRet = -EFAULT;
+			goto write_done;
+		}
+		iRet = copySize;
+		wrBuf[NAME_MAX] = '\0';
+
+		if (!strncasecmp(wrBuf, "ok", NAME_MAX)) {
+			WMT_DBG_FUNC("resp str ok\n");
+			/* pWmtDevCtx->cmd_result = 0; */
+			wmt_lib_trigger_cmd_signal(0);
+		} else {
+			WMT_WARN_FUNC("warning resp str (%s)\n", wrBuf);
+			/* pWmtDevCtx->cmd_result = -1; */
+			wmt_lib_trigger_cmd_signal(-1);
+		}
+		/* complete(&pWmtDevCtx->cmd_comp); */
+
+	}
+
+write_done:
+	return iRet;
+}
+
+ssize_t WMT_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	INT32 iRet = 0;
+	PUINT8 pCmd = NULL;
+	UINT32 cmdLen = 0;
+
+	pCmd = wmt_lib_get_cmd();
+
+	if (pCmd != NULL) {
+		cmdLen = osal_strlen(pCmd) < NAME_MAX ? osal_strlen(pCmd) : NAME_MAX;
+		WMT_DBG_FUNC("cmd str(%s)\n", pCmd);
+		if (copy_to_user(buf, pCmd, cmdLen))
+			iRet = -EFAULT;
+		else
+			iRet = cmdLen;
+
+	}
+#if 0
+	if (test_and_clear_bit(WMT_STAT_CMD, &pWmtDevCtx->state)) {
+		iRet = osal_strlen(localBuf) < NAME_MAX ? osal_strlen(localBuf) : NAME_MAX;
+		/* we got something from STP driver */
+		WMT_DBG_FUNC("copy cmd to user by read:%s\n", localBuf);
+		if (copy_to_user(buf, localBuf, iRet)) {
+			iRet = -EFAULT;
+			goto read_done;
+		}
+	}
+#endif
+	return iRet;
+}
+
+unsigned int WMT_poll(struct file *filp, poll_table *wait)
+{
+	UINT32 mask = 0;
+	P_OSAL_EVENT pEvent = wmt_lib_get_cmd_event();
+
+	poll_wait(filp, &pEvent->waitQueue, wait);
+	/* empty let select sleep */
+	if (MTK_WCN_BOOL_TRUE == wmt_lib_get_cmd_status())
+		mask |= POLLIN | POLLRDNORM;	/* readable */
+
+#if 0
+	if (test_bit(WMT_STAT_CMD, &pWmtDevCtx->state))
+		mask |= POLLIN | POLLRDNORM;	/* readable */
+
+#endif
+	mask |= POLLOUT | POLLWRNORM;	/* writable */
+	return mask;
+}
+
+/* INT32 WMT_ioctl(struct inode *inode, struct file *filp, UINT32 cmd, unsigned long arg) */
+long WMT_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+
+	INT32 iRet = 0;
+	UINT8 *pBuffer = NULL;
+
+	WMT_DBG_FUNC("cmd (%u), arg (0x%lx)\n", cmd, arg);
+	switch (cmd) {
+	case WMT_IOCTL_SET_PATCH_NAME:	/* patch location */
+		{
+
+			pBuffer = kmalloc(NAME_MAX + 1, GFP_KERNEL);
+			if (!pBuffer) {
+				WMT_ERR_FUNC("pBuffer kmalloc memory fail\n");
+				return 0;
+			}
+			if (copy_from_user(pBuffer, (void *)arg, NAME_MAX)) {
+				iRet = -EFAULT;
+				kfree(pBuffer);
+				break;
+			}
+			pBuffer[NAME_MAX] = '\0';
+			wmt_lib_set_patch_name(pBuffer);
+			kfree(pBuffer);
+		}
+		break;
+
+	case WMT_IOCTL_SET_STP_MODE:	/* stp/hif/fm mode */
+
+		/* set hif conf */
+		do {
+			P_OSAL_OP pOp;
+			MTK_WCN_BOOL bRet;
+			P_OSAL_SIGNAL pSignal = NULL;
+			P_WMT_HIF_CONF pHif = NULL;
+
+			iRet = wmt_lib_set_hif(arg);
+			if (0 != iRet) {
+				WMT_INFO_FUNC("wmt_lib_set_hif fail\n");
+				break;
+			}
+
+			pOp = wmt_lib_get_free_op();
+			if (!pOp) {
+				WMT_INFO_FUNC("get_free_lxop fail\n");
+				break;
+			}
+			pSignal = &pOp->signal;
+			pOp->op.opId = WMT_OPID_HIF_CONF;
+
+			pHif = wmt_lib_get_hif();
+
+			osal_memcpy(&pOp->op.au4OpData[0], pHif, sizeof(WMT_HIF_CONF));
+			pOp->op.u4InfoBit = WMT_OP_HIF_BIT;
+			pSignal->timeoutValue = 0;
+
+			bRet = wmt_lib_put_act_op(pOp);
+			WMT_DBG_FUNC("WMT_OPID_HIF_CONF result(%d)\n", bRet);
+			iRet = (MTK_WCN_BOOL_FALSE == bRet) ? -EFAULT : 0;
+		} while (0);
+
+		break;
+
+	case WMT_IOCTL_FUNC_ONOFF_CTRL:	/* test turn on/off func */
+
+		do {
+			MTK_WCN_BOOL bRet = MTK_WCN_BOOL_FALSE;
+
+			if (arg & 0x80000000)
+				bRet = mtk_wcn_wmt_func_on(arg & 0xF);
+			else
+				bRet = mtk_wcn_wmt_func_off(arg & 0xF);
+
+			iRet = (MTK_WCN_BOOL_FALSE == bRet) ? -EFAULT : 0;
+		} while (0);
+
+		break;
+
+	case WMT_IOCTL_LPBK_POWER_CTRL:
+		/*switch Loopback function on/off
+		   arg:     bit0 = 1:turn loopback function on
+		   bit0 = 0:turn loopback function off
+		 */
+		do {
+			MTK_WCN_BOOL bRet = MTK_WCN_BOOL_FALSE;
+
+			if (arg & 0x01)
+				bRet = mtk_wcn_wmt_func_on(WMTDRV_TYPE_LPBK);
+			else
+				bRet = mtk_wcn_wmt_func_off(WMTDRV_TYPE_LPBK);
+
+			iRet = (MTK_WCN_BOOL_FALSE == bRet) ? -EFAULT : 0;
+		} while (0);
+
+		break;
+
+	case WMT_IOCTL_LPBK_TEST:
+		do {
+			P_OSAL_OP pOp;
+			MTK_WCN_BOOL bRet;
+			UINT32 u4Wait;
+			/* UINT8 lpbk_buf[1024] = {0}; */
+			UINT32 effectiveLen = 0;
+			P_OSAL_SIGNAL pSignal = NULL;
+
+			if (copy_from_user(&effectiveLen, (void *)arg, sizeof(effectiveLen))) {
+				iRet = -EFAULT;
+				WMT_ERR_FUNC("copy_from_user failed at %d\n", __LINE__);
+				break;
+			}
+			if (effectiveLen > sizeof(gLpbkBuf)) {
+				iRet = -EFAULT;
+				WMT_ERR_FUNC("length is too long\n");
+				break;
+			}
+			WMT_DBG_FUNC("len = %d\n", effectiveLen);
+
+			pOp = wmt_lib_get_free_op();
+			if (!pOp) {
+				WMT_WARN_FUNC("get_free_lxop fail\n");
+				iRet = -EFAULT;
+				break;
+			}
+			u4Wait = 2000;
+			if (copy_from_user(&gLpbkBuf[0], (void *)arg + sizeof(unsigned long), effectiveLen)) {
+				WMT_ERR_FUNC("copy_from_user failed at %d\n", __LINE__);
+				iRet = -EFAULT;
+				break;
+			}
+			pSignal = &pOp->signal;
+			pOp->op.opId = WMT_OPID_LPBK;
+			pOp->op.au4OpData[0] = effectiveLen;	/* packet length */
+			pOp->op.au4OpData[1] = (SIZE_T) &gLpbkBuf[0];	/* packet buffer pointer */
+			memcpy(&gLpbkBufLog, &gLpbkBuf[((effectiveLen >= 4) ? effectiveLen - 4 : 0)], 4);
+			pSignal->timeoutValue = MAX_EACH_WMT_CMD;
+			WMT_INFO_FUNC("OPID(%d) type(%d) start\n", pOp->op.opId, pOp->op.au4OpData[0]);
+			if (DISABLE_PSM_MONITOR()) {
+				WMT_ERR_FUNC("wake up failed,OPID(%d) type(%d) abort\n",
+					     pOp->op.opId, pOp->op.au4OpData[0]);
+				wmt_lib_put_op_to_free_queue(pOp);
+				return -1;
+			}
+
+			bRet = wmt_lib_put_act_op(pOp);
+			ENABLE_PSM_MONITOR();
+			if (MTK_WCN_BOOL_FALSE == bRet) {
+				WMT_WARN_FUNC("OPID(%d) type(%d) buf tail(0x%08x) fail\n",
+					      pOp->op.opId, pOp->op.au4OpData[0], gLpbkBufLog);
+				iRet = -1;
+				break;
+			}
+			WMT_INFO_FUNC("OPID(%d) length(%d) ok\n", pOp->op.opId, pOp->op.au4OpData[0]);
+			iRet = pOp->op.au4OpData[0];
+			if (copy_to_user((void *)arg + sizeof(SIZE_T) + sizeof(UINT8[2048]), gLpbkBuf, iRet)) {
+				iRet = -EFAULT;
+				break;
+			}
+
+		} while (0);
+
+		break;
+
+	case WMT_IOCTL_ADIE_LPBK_TEST:
+		do {
+			P_OSAL_OP pOp;
+			MTK_WCN_BOOL bRet;
+			P_OSAL_SIGNAL pSignal = NULL;
+
+			pOp = wmt_lib_get_free_op();
+			if (!pOp) {
+				WMT_WARN_FUNC("get_free_lxop fail\n");
+				iRet = -EFAULT;
+				break;
+			}
+
+			pSignal = &pOp->signal;
+			pOp->op.opId = WMT_OPID_ADIE_LPBK_TEST;
+			pOp->op.au4OpData[0] = 0;
+			pOp->op.au4OpData[1] = (SIZE_T) &gLpbkBuf[0];
+			pSignal->timeoutValue = MAX_EACH_WMT_CMD;
+			WMT_INFO_FUNC("OPID(%d) start\n", pOp->op.opId);
+			if (DISABLE_PSM_MONITOR()) {
+				WMT_ERR_FUNC("wake up failed,OPID(%d)abort\n", pOp->op.opId);
+				wmt_lib_put_op_to_free_queue(pOp);
+				return -1;
+			}
+
+			bRet = wmt_lib_put_act_op(pOp);
+			ENABLE_PSM_MONITOR();
+			if (MTK_WCN_BOOL_FALSE == bRet) {
+				WMT_WARN_FUNC("OPID(%d) fail\n", pOp->op.opId);
+				iRet = -1;
+				break;
+			}
+			WMT_INFO_FUNC("OPID(%d) length(%d) ok\n", pOp->op.opId, pOp->op.au4OpData[0]);
+			iRet = pOp->op.au4OpData[0];
+			if (copy_to_user((void *)arg + sizeof(SIZE_T), gLpbkBuf, iRet)) {
+				iRet = -EFAULT;
+				break;
+			}
+
+		} while (0);
+
+		break;
+
+	case 10:
+		{
+			pBuffer = kmalloc(NAME_MAX + 1, GFP_KERNEL);
+			if (!pBuffer) {
+				WMT_ERR_FUNC("pBuffer kmalloc memory fail\n");
+				return 0;
+			}
+			wmt_lib_host_awake_get();
+			mtk_wcn_stp_coredump_start_ctrl(1);
+			osal_strcpy(pBuffer, "MT662x f/w coredump start-");
+			if (copy_from_user
+			    (pBuffer + osal_strlen(pBuffer), (void *)arg, NAME_MAX - osal_strlen(pBuffer))) {
+				/* osal_strcpy(pBuffer, "MT662x f/w assert core dump start"); */
+				WMT_ERR_FUNC("copy assert string failed\n");
+			}
+			pBuffer[NAME_MAX] = '\0';
+			osal_dbg_assert_aee(pBuffer, pBuffer);
+			kfree(pBuffer);
+		}
+		break;
+	case 11:
+		{
+			osal_dbg_assert_aee("MT662x f/w coredump end", "MT662x firmware coredump ends");
+			wmt_lib_host_awake_put();
+		}
+		break;
+
+	case WMT_IOCTL_GET_CHIP_INFO:
+		{
+			if (0 == arg)
+				return wmt_lib_get_icinfo(WMTCHIN_CHIPID);
+			else if (1 == arg)
+				return wmt_lib_get_icinfo(WMTCHIN_HWVER);
+			else if (2 == arg)
+				return wmt_lib_get_icinfo(WMTCHIN_FWVER);
+
+		}
+		break;
+
+	case WMT_IOCTL_SET_LAUNCHER_KILL:{
+			if (1 == arg) {
+				WMT_INFO_FUNC("launcher may be killed,block abnormal stp tx.\n");
+				wmt_lib_set_stp_wmt_last_close(1);
+			} else {
+				wmt_lib_set_stp_wmt_last_close(0);
+			}
+
+		}
+		break;
+
+	case WMT_IOCTL_SET_PATCH_NUM:{
+			pAtchNum = arg;
+			WMT_DBG_FUNC(" get patch num from launcher = %d\n", pAtchNum);
+			wmt_lib_set_patch_num(pAtchNum);
+			pPatchInfo = kcalloc(pAtchNum, sizeof(WMT_PATCH_INFO), GFP_ATOMIC);
+			if (!pPatchInfo) {
+				WMT_ERR_FUNC("allocate memory fail!\n");
+				break;
+			}
+		}
+		break;
+
+	case WMT_IOCTL_SET_PATCH_INFO:{
+			WMT_PATCH_INFO wMtPatchInfo;
+			P_WMT_PATCH_INFO pTemp = NULL;
+			UINT32 dWloadSeq;
+			static UINT32 counter;
+
+			if (!pPatchInfo) {
+				WMT_ERR_FUNC("NULL patch info pointer\n");
+				break;
+			}
+
+			if (copy_from_user(&wMtPatchInfo, (void *)arg, sizeof(WMT_PATCH_INFO))) {
+				WMT_ERR_FUNC("copy_from_user failed at %d\n", __LINE__);
+				iRet = -EFAULT;
+				break;
+			}
+
+			dWloadSeq = wMtPatchInfo.dowloadSeq;
+			WMT_DBG_FUNC(
+				"patch dl seq %d,name %s,address info 0x%02x,0x%02x,0x%02x,0x%02x\n",
+			     dWloadSeq, wMtPatchInfo.patchName,
+			     wMtPatchInfo.addRess[0],
+			     wMtPatchInfo.addRess[1],
+			     wMtPatchInfo.addRess[2],
+			     wMtPatchInfo.addRess[3]);
+			osal_memcpy(pPatchInfo + dWloadSeq - 1, &wMtPatchInfo, sizeof(WMT_PATCH_INFO));
+			pTemp = pPatchInfo + dWloadSeq - 1;
+			if (++counter == pAtchNum) {
+				wmt_lib_set_patch_info(pPatchInfo);
+				counter = 0;
+			}
+		}
+		break;
+
+	case WMT_IOCTL_WMT_COREDUMP_CTRL:
+			mtk_wcn_stp_coredump_flag_ctrl(arg);
+		break;
+	case WMT_IOCTL_WMT_QUERY_CHIPID:
+		{
+			iRet = mtk_wcn_wmt_chipid_query();
+			WMT_WARN_FUNC("chipid = 0x%x\n", iRet);
+		}
+		break;
+	case WMT_IOCTL_SEND_BGW_DS_CMD:
+		do {
+			P_OSAL_OP pOp;
+			MTK_WCN_BOOL bRet;
+			UINT8 desense_buf[14] = { 0 };
+			UINT32 effectiveLen = 14;
+			P_OSAL_SIGNAL pSignal = NULL;
+
+			pOp = wmt_lib_get_free_op();
+			if (!pOp) {
+				WMT_WARN_FUNC("get_free_lxop fail\n");
+				iRet = -EFAULT;
+				break;
+			}
+			if (copy_from_user(&desense_buf[0], (void *)arg, effectiveLen)) {
+				WMT_ERR_FUNC("copy_from_user failed at %d\n", __LINE__);
+				iRet = -EFAULT;
+				break;
+			}
+			pSignal = &pOp->signal;
+			pOp->op.opId = WMT_OPID_BGW_DS;
+			pOp->op.au4OpData[0] = effectiveLen;	/* packet length */
+			pOp->op.au4OpData[1] = (SIZE_T) &desense_buf[0];	/* packet buffer pointer */
+			pSignal->timeoutValue = MAX_EACH_WMT_CMD;
+			WMT_INFO_FUNC("OPID(%d) start\n", pOp->op.opId);
+			if (DISABLE_PSM_MONITOR()) {
+				WMT_ERR_FUNC("wake up failed,opid(%d) abort\n", pOp->op.opId);
+				wmt_lib_put_op_to_free_queue(pOp);
+				return -1;
+			}
+
+			bRet = wmt_lib_put_act_op(pOp);
+			ENABLE_PSM_MONITOR();
+			if (MTK_WCN_BOOL_FALSE == bRet) {
+				WMT_WARN_FUNC("OPID(%d) fail\n", pOp->op.opId);
+				iRet = -1;
+				break;
+			}
+			WMT_INFO_FUNC("OPID(%d) length(%d) ok\n", pOp->op.opId, pOp->op.au4OpData[0]);
+			iRet = pOp->op.au4OpData[0];
+
+		} while (0);
+
+		break;
+	case WMT_IOCTL_FW_DBGLOG_CTRL:
+		{
+			iRet = wmt_plat_set_dbg_mode(arg);
+			if (iRet == 0)
+				wmt_dbg_fwinfor_from_emi(0, 1, 0);
+		}
+		break;
+	case WMT_IOCTL_DYNAMIC_DUMP_CTRL:
+		{
+			UINT32 i = 0, j = 0, k = 0;
+			UINT8 *pBuf = NULL;
+			UINT32 int_buf[10];
+			char Buffer[10][11];
+
+			pBuf = kmalloc(DYNAMIC_DUMP_BUF + 1, GFP_KERNEL);
+			if (!pBuf) {
+				WMT_ERR_FUNC("pBuf kmalloc memory fail\n");
+				return 0;
+			}
+			if (copy_from_user(pBuf, (void *)arg, DYNAMIC_DUMP_BUF)) {
+				iRet = -EFAULT;
+				kfree(pBuf);
+				break;
+			}
+			pBuf[DYNAMIC_DUMP_BUF] = '\0';
+			WMT_INFO_FUNC("get dynamic dump data from property(%s)\n", pBuf);
+			memset(Buffer, 0, 10*11);
+			for (i = 0; i < DYNAMIC_DUMP_BUF; i++) {
+				if (pBuf[i] == '/') {
+					k = 0;
+					j++;
+				} else {
+					Buffer[j][k] = pBuf[i];
+					k++;
+				}
+			}
+			for (j = 0; j < 10; j++) {
+				iRet = kstrtou32(Buffer[j], 0, &int_buf[j]);
+				if (iRet) {
+					WMT_ERR_FUNC("string convert fail(%d)\n", iRet);
+					break;
+				}
+				WMT_INFO_FUNC("dynamic dump data buf[%d]:(0x%x)\n", j, int_buf[j]);
+			}
+			wmt_plat_set_dynamic_dumpmem(int_buf);
+			kfree(pBuf);
+		}
+		break;
+	default:
+		iRet = -EINVAL;
+		WMT_WARN_FUNC("unknown cmd (%d)\n", cmd);
+		break;
+	}
+
+	return iRet;
+}
+#ifdef CONFIG_COMPAT
+long WMT_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	long ret;
+	WMT_INFO_FUNC("cmd[0x%x]\n", cmd);
+		switch (cmd) {
+		case COMPAT_WMT_IOCTL_SET_PATCH_NAME:
+			ret = WMT_unlocked_ioctl(filp, WMT_IOCTL_SET_PATCH_NAME, (unsigned long)compat_ptr(arg));
+			break;
+		case COMPAT_WMT_IOCTL_LPBK_TEST:
+			ret = WMT_unlocked_ioctl(filp, WMT_IOCTL_LPBK_TEST, (unsigned long)compat_ptr(arg));
+			break;
+		case COMPAT_WMT_IOCTL_SET_PATCH_INFO:
+			ret = WMT_unlocked_ioctl(filp, WMT_IOCTL_SET_PATCH_INFO, (unsigned long)compat_ptr(arg));
+			break;
+		case COMPAT_WMT_IOCTL_PORT_NAME:
+			ret = WMT_unlocked_ioctl(filp, WMT_IOCTL_PORT_NAME, (unsigned long)compat_ptr(arg));
+			break;
+		case COMPAT_WMT_IOCTL_WMT_CFG_NAME:
+			ret = WMT_unlocked_ioctl(filp, WMT_IOCTL_WMT_CFG_NAME, (unsigned long)compat_ptr(arg));
+			break;
+		case COMPAT_WMT_IOCTL_SEND_BGW_DS_CMD:
+			ret = WMT_unlocked_ioctl(filp, WMT_IOCTL_SEND_BGW_DS_CMD, (unsigned long)compat_ptr(arg));
+			break;
+		default: {
+			ret = WMT_unlocked_ioctl(filp, cmd, arg);
+			break;
+			}
+		}
+	return ret;
+}
+#endif
+static int WMT_open(struct inode *inode, struct file *file)
+{
+	long ret;
+
+	WMT_INFO_FUNC("major %d minor %d (pid %d)\n", imajor(inode), iminor(inode), current->pid);
+	ret = wait_event_timeout(gWmtInitWq, gWmtInitDone != 0, msecs_to_jiffies(WMT_DEV_INIT_TO_MS));
+	if (!ret) {
+		WMT_WARN_FUNC("wait_event_timeout (%d)ms,(%d)jiffies,return -EIO\n",
+			      WMT_DEV_INIT_TO_MS, msecs_to_jiffies(WMT_DEV_INIT_TO_MS));
+		return -EIO;
+	}
+
+	if (atomic_inc_return(&gWmtRefCnt) == 1)
+		WMT_INFO_FUNC("1st call\n");
+
+	return 0;
+}
+
+static int WMT_close(struct inode *inode, struct file *file)
+{
+	WMT_INFO_FUNC("major %d minor %d (pid %d)\n", imajor(inode), iminor(inode), current->pid);
+
+	if (atomic_dec_return(&gWmtRefCnt) == 0)
+		WMT_INFO_FUNC("last call\n");
+
+	return 0;
+}
+
+const struct file_operations gWmtFops = {
+	.open = WMT_open,
+	.release = WMT_close,
+	.read = WMT_read,
+	.write = WMT_write,
+/* .ioctl = WMT_ioctl, */
+	.unlocked_ioctl = WMT_unlocked_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = WMT_compat_ioctl,
+#endif
+	.poll = WMT_poll,
+};
+
+void wmt_dev_bgw_desense_init(VOID)
+{
+	bgw_init_socket();
+}
+
+void wmt_dev_bgw_desense_deinit(VOID)
+{
+	bgw_destroy_netlink_kernel();
+}
+
+void wmt_dev_send_cmd_to_daemon(UINT32 cmd)
+{
+	send_command_to_daemon(cmd);
+}
+
+static int WMT_init(void)
+{
+	dev_t devID = MKDEV(gWmtMajor, 0);
+	INT32 cdevErr = -1;
+	INT32 ret = -1;
+
+	WMT_INFO_FUNC("WMT Version= %s DATE=%s\n", MTK_WMT_VERSION, MTK_WMT_DATE);
+	/* Prepare a UINT8 device */
+	/*static allocate chrdev */
+	gWmtInitDone = 0;
+	init_waitqueue_head((wait_queue_head_t *) &gWmtInitWq);
+	stp_drv_init();
+
+	ret = register_chrdev_region(devID, WMT_DEV_NUM, WMT_DRIVER_NAME);
+	if (ret) {
+		WMT_ERR_FUNC("fail to register chrdev\n");
+		return ret;
+	}
+	cdev_init(&gWmtCdev, &gWmtFops);
+	gWmtCdev.owner = THIS_MODULE;
+	cdevErr = cdev_add(&gWmtCdev, devID, WMT_DEV_NUM);
+	if (cdevErr) {
+		WMT_ERR_FUNC("cdev_add() fails (%d)\n", cdevErr);
+		goto error;
+	}
+	WMT_INFO_FUNC("driver(major %d) installed\n", gWmtMajor);
+#if WMT_CREATE_NODE_DYNAMIC
+	wmt_class = class_create(THIS_MODULE, "stpwmt");
+	if (IS_ERR(wmt_class))
+		goto error;
+	wmt_dev = device_create(wmt_class, NULL, devID, NULL, "stpwmt");
+	if (IS_ERR(wmt_dev))
+		goto error;
+#endif
+
+#if 0
+	pWmtDevCtx = wmt_drv_create();
+	if (!pWmtDevCtx) {
+		WMT_ERR_FUNC("wmt_drv_create() fails\n");
+		goto error;
+	}
+	ret = wmt_drv_init(pWmtDevCtx);
+	if (ret) {
+		WMT_ERR_FUNC("wmt_drv_init() fails (%d)\n", ret);
+		goto error;
+	}
+	WMT_INFO_FUNC("stp_btmcb_reg\n");
+	wmt_cdev_btmcb_reg();
+	ret = wmt_drv_start(pWmtDevCtx);
+	if (ret) {
+		WMT_ERR_FUNC("wmt_drv_start() fails (%d)\n", ret);
+		goto error;
+	}
+#endif
+	ret = wmt_lib_init();
+	if (ret) {
+		WMT_ERR_FUNC("wmt_lib_init() fails (%d)\n", ret);
+		goto error;
+	}
+#if CFG_WMT_DBG_SUPPORT
+	wmt_dev_dbg_setup();
+#endif
+
+#if CFG_WMT_PROC_FOR_AEE
+	wmt_dev_proc_for_aee_setup();
+#endif
+
+	WMT_INFO_FUNC("wmt_dev register thermal cb\n");
+	wmt_lib_register_thermal_ctrl_cb(wmt_dev_tm_temp_query);
+	wmt_dev_bgw_desense_init();
+	gWmtInitDone = 1;
+	wake_up(&gWmtInitWq);
+	osal_sleepable_lock_init(&g_es_lr_lock);
+	INIT_WORK(&gPwrOnOffWork, wmt_pwr_on_off_handler);
+#ifdef CONFIG_EARLYSUSPEND
+	register_early_suspend(&wmt_early_suspend_handler);
+	WMT_INFO_FUNC("register_early_suspend finished\n");
+#else
+	wmt_fb_notifier.notifier_call = wmt_fb_notifier_callback;
+	ret = fb_register_client(&wmt_fb_notifier);
+	if (ret)
+		WMT_ERR_FUNC("wmt register fb_notifier failed! ret(%d)\n", ret);
+	else
+		WMT_INFO_FUNC("wmt register fb_notifier OK!\n");
+#endif
+	WMT_INFO_FUNC("success\n");
+	return 0;
+
+error:
+	wmt_lib_deinit();
+#if CFG_WMT_DBG_SUPPORT
+	wmt_dev_dbg_remove();
+#endif
+#if WMT_CREATE_NODE_DYNAMIC
+	if (!(IS_ERR(wmt_dev)))
+		device_destroy(wmt_class, devID);
+	if (!(IS_ERR(wmt_class))) {
+		class_destroy(wmt_class);
+		wmt_class = NULL;
+	}
+#endif
+
+	if (cdevErr == 0)
+		cdev_del(&gWmtCdev);
+
+	if (ret == 0) {
+		unregister_chrdev_region(devID, WMT_DEV_NUM);
+		gWmtMajor = -1;
+	}
+
+	WMT_ERR_FUNC("fail\n");
+
+	return -1;
+}
+
+static void WMT_exit(void)
+{
+	dev_t dev = MKDEV(gWmtMajor, 0);
+
+	osal_sleepable_lock_deinit(&g_es_lr_lock);
+#ifdef CONFIG_EARLYSUSPEND
+	unregister_early_suspend(&wmt_early_suspend_handler);
+	WMT_INFO_FUNC("unregister_early_suspend finished\n");
+#else
+	fb_unregister_client(&wmt_fb_notifier);
+#endif
+
+	wmt_dev_bgw_desense_deinit();
+
+	wmt_lib_register_thermal_ctrl_cb(NULL);
+
+	wmt_lib_deinit();
+
+#if CFG_WMT_DBG_SUPPORT
+	wmt_dev_dbg_remove();
+#endif
+
+#if CFG_WMT_PROC_FOR_AEE
+	wmt_dev_proc_for_aee_remove();
+#endif
+#if WMT_CREATE_NODE_DYNAMIC
+	if (wmt_dev) {
+		device_destroy(wmt_class, dev);
+		wmt_dev = NULL;
+	}
+	if (wmt_class) {
+		class_destroy(wmt_class);
+		wmt_class = NULL;
+	}
+#endif
+	cdev_del(&gWmtCdev);
+	unregister_chrdev_region(dev, WMT_DEV_NUM);
+	gWmtMajor = -1;
+
+	stp_drv_exit();
+
+	WMT_INFO_FUNC("done\n");
+}
+
+#ifdef MTK_WCN_REMOVE_KERNEL_MODULE
+
+int mtk_wcn_soc_common_drv_init(void)
+{
+	return WMT_init();
+
+}
+EXPORT_SYMBOL(mtk_wcn_soc_common_drv_init);
+void mtk_wcn_soc_common_drv_exit(void)
+{
+	return WMT_exit();
+}
+EXPORT_SYMBOL(mtk_wcn_soc_common_drv_exit);
+
+#else
+module_init(WMT_init);
+module_exit(WMT_exit);
+#endif
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("MediaTek Inc WCN");
+MODULE_DESCRIPTION("MTK WCN combo driver for WMT function");
+
+module_param(gWmtMajor, uint, 0);
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/wmt_exp.c b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/wmt_exp.c
new file mode 100644
index 00000000..d38dc3f
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pri/wmt_exp.c
@@ -0,0 +1,612 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[WMT-EXP]"
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+#include "osal_typedef.h"
+
+#include <wmt_exp.h>
+#include <wmt_lib.h>
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+wmt_wlan_probe_cb mtk_wcn_wlan_probe = NULL;
+wmt_wlan_remove_cb mtk_wcn_wlan_remove = NULL;
+wmt_wlan_bus_cnt_get_cb mtk_wcn_wlan_bus_tx_cnt = NULL;
+wmt_wlan_bus_cnt_clr_cb mtk_wcn_wlan_bus_tx_cnt_clr = NULL;
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+OSAL_BIT_OP_VAR gBtWifiGpsState;
+OSAL_BIT_OP_VAR gGpsFmState;
+UINT32 gWifiProbed = 0;
+UINT32 gWmtDbgLvl = WMT_LOG_ERR;
+MTK_WCN_BOOL g_pwr_off_flag = MTK_WCN_BOOL_TRUE;
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+static MTK_WCN_BOOL mtk_wcn_wmt_func_ctrl(ENUM_WMTDRV_TYPE_T type, ENUM_WMT_OPID_T opId);
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+static MTK_WCN_BOOL mtk_wcn_wmt_func_ctrl(ENUM_WMTDRV_TYPE_T type, ENUM_WMT_OPID_T opId)
+{
+	P_OSAL_OP pOp;
+	MTK_WCN_BOOL bRet;
+	P_OSAL_SIGNAL pSignal;
+
+	pOp = wmt_lib_get_free_op();
+	if (!pOp) {
+		WMT_WARN_FUNC("get_free_lxop fail\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	pSignal = &pOp->signal;
+
+	pOp->op.opId = opId;
+	pOp->op.au4OpData[0] = type;
+	if (WMTDRV_TYPE_WIFI == type)
+		pSignal->timeoutValue = 4000;
+		/*donot block system server/init/netd from longer than 5s, in case of ANR happens*/
+	else
+		pSignal->timeoutValue = (WMT_OPID_FUNC_ON == pOp->op.opId) ? MAX_FUNC_ON_TIME : MAX_FUNC_OFF_TIME;
+
+	WMT_INFO_FUNC("OPID(%d) type(%d) start\n", pOp->op.opId, pOp->op.au4OpData[0]);
+
+	/*do not check return value, we will do this either way */
+	wmt_lib_host_awake_get();
+	/*wake up chip first */
+	if (DISABLE_PSM_MONITOR()) {
+		WMT_ERR_FUNC("wake up failed,OPID(%d) type(%d) abort\n", pOp->op.opId, pOp->op.au4OpData[0]);
+		wmt_lib_put_op_to_free_queue(pOp);
+		wmt_lib_host_awake_put();
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	bRet = wmt_lib_put_act_op(pOp);
+	ENABLE_PSM_MONITOR();
+	wmt_lib_host_awake_put();
+
+	if (MTK_WCN_BOOL_FALSE == bRet)
+		WMT_WARN_FUNC("OPID(%d) type(%d) fail\n", pOp->op.opId, pOp->op.au4OpData[0]);
+	else
+		WMT_WARN_FUNC("OPID(%d) type(%d) ok\n", pOp->op.opId, pOp->op.au4OpData[0]);
+
+	return bRet;
+}
+
+#if WMT_EXP_HID_API_EXPORT
+MTK_WCN_BOOL _mtk_wcn_wmt_func_off(ENUM_WMTDRV_TYPE_T type)
+#else
+MTK_WCN_BOOL mtk_wcn_wmt_func_off(ENUM_WMTDRV_TYPE_T type)
+#endif
+{
+	MTK_WCN_BOOL ret;
+
+	if (type == WMTDRV_TYPE_BT)
+		osal_printtimeofday("############ BT OFF ====>");
+
+	ret = mtk_wcn_wmt_func_ctrl(type, WMT_OPID_FUNC_OFF);
+
+	if (type == WMTDRV_TYPE_BT)
+		osal_printtimeofday("############ BT OFF <====");
+
+	return ret;
+}
+#if !WMT_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_wmt_func_off);
+#endif
+
+#if WMT_EXP_HID_API_EXPORT
+MTK_WCN_BOOL _mtk_wcn_wmt_func_on(ENUM_WMTDRV_TYPE_T type)
+#else
+MTK_WCN_BOOL mtk_wcn_wmt_func_on(ENUM_WMTDRV_TYPE_T type)
+#endif
+{
+	MTK_WCN_BOOL ret;
+
+	if (type == WMTDRV_TYPE_BT)
+		osal_printtimeofday("############ BT ON ====>");
+
+	ret = mtk_wcn_wmt_func_ctrl(type, WMT_OPID_FUNC_ON);
+
+	if (type == WMTDRV_TYPE_BT)
+		osal_printtimeofday(" ############BT ON <====");
+
+	return ret;
+}
+#if !WMT_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_wmt_func_on);
+#endif
+
+VOID mtk_wcn_wmt_func_ctrl_for_plat(UINT32 on, ENUM_WMTDRV_TYPE_T type)
+{
+	if (on)
+		mtk_wcn_wmt_func_on(type);
+	else
+		mtk_wcn_wmt_func_off(type);
+}
+
+/*
+return value:
+enable/disable thermal sensor function: true(1)/false(0)
+read thermal sensor function:thermal value
+
+*/
+#if WMT_EXP_HID_API_EXPORT
+INT8 _mtk_wcn_wmt_therm_ctrl(ENUM_WMTTHERM_TYPE_T eType)
+#else
+INT8 mtk_wcn_wmt_therm_ctrl(ENUM_WMTTHERM_TYPE_T eType)
+#endif
+{
+	P_OSAL_OP pOp;
+	P_WMT_OP pOpData;
+	MTK_WCN_BOOL bRet;
+	P_OSAL_SIGNAL pSignal;
+
+	/*parameter validation check */
+	if (WMTTHERM_MAX < eType || WMTTHERM_ENABLE > eType) {
+		WMT_ERR_FUNC("invalid thermal control command (%d)\n", eType);
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	/*check if chip support thermal control function or not */
+	bRet = wmt_lib_is_therm_ctrl_support();
+	if (MTK_WCN_BOOL_FALSE == bRet) {
+		WMT_ERR_FUNC("thermal ctrl function not supported\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	pOp = wmt_lib_get_free_op();
+	if (!pOp) {
+		WMT_WARN_FUNC("get_free_lxop fail\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	pSignal = &pOp->signal;
+	pOpData = &pOp->op;
+	pOpData->opId = WMT_OPID_THERM_CTRL;
+	/*parameter fill */
+	pOpData->au4OpData[0] = eType;
+	pSignal->timeoutValue = MAX_EACH_WMT_CMD;
+
+	WMT_INFO_FUNC("OPID(%d) type(%d) start\n", pOp->op.opId, pOp->op.au4OpData[0]);
+
+	if (DISABLE_PSM_MONITOR()) {
+		WMT_ERR_FUNC("wake up failed,OPID(%d) type(%d) abort!\n", pOp->op.opId, pOp->op.au4OpData[0]);
+		wmt_lib_put_op_to_free_queue(pOp);
+		return -1;
+	}
+
+	bRet = wmt_lib_put_act_op(pOp);
+	ENABLE_PSM_MONITOR();
+
+	if (MTK_WCN_BOOL_FALSE == bRet) {
+		WMT_WARN_FUNC("OPID(%d) type(%d) fail\n\n", pOpData->opId, pOpData->au4OpData[0]);
+		/*0xFF means read error occurs */
+		/*will return to function driver */
+		pOpData->au4OpData[1] = (eType == WMTTHERM_READ) ? 0xFF : MTK_WCN_BOOL_FALSE;
+	} else {
+		WMT_INFO_FUNC("OPID(%d) type(%d) return(%d) ok\n\n",
+			      pOpData->opId, pOpData->au4OpData[0], pOpData->au4OpData[1]);
+	}
+	/*return value will be put to lxop->op.au4OpData[1] */
+	WMT_DBG_FUNC("therm ctrl type(%d), iRet(0x%08x)\n", eType, pOpData->au4OpData[1]);
+	return (INT8) pOpData->au4OpData[1];
+}
+#if !WMT_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_wmt_therm_ctrl);
+#endif
+
+#if WMT_EXP_HID_API_EXPORT
+ENUM_WMTHWVER_TYPE_T _mtk_wcn_wmt_hwver_get(VOID)
+#else
+ENUM_WMTHWVER_TYPE_T mtk_wcn_wmt_hwver_get(VOID)
+#endif
+{
+	/* TODO: [ChangeFeature][GeorgeKuo] Reconsider usage of this type */
+	/* TODO: how do we extend for new chip and newer revision? */
+	/* TODO: This way is hard to extend */
+	return wmt_lib_get_icinfo(WMTCHIN_MAPPINGHWVER);
+}
+#if !WMT_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_wmt_hwver_get);
+#endif
+
+#if WMT_EXP_HID_API_EXPORT
+MTK_WCN_BOOL _mtk_wcn_wmt_dsns_ctrl(ENUM_WMTDSNS_TYPE_T eType)
+#else
+MTK_WCN_BOOL mtk_wcn_wmt_dsns_ctrl(ENUM_WMTDSNS_TYPE_T eType)
+#endif
+{
+	P_OSAL_OP pOp;
+	P_WMT_OP pOpData;
+	MTK_WCN_BOOL bRet;
+	P_OSAL_SIGNAL pSignal;
+
+	if (WMTDSNS_MAX <= eType) {
+		WMT_ERR_FUNC("invalid desense control command (%d)\n", eType);
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	/*check if chip support thermal control function or not */
+	bRet = wmt_lib_is_dsns_ctrl_support();
+	if (MTK_WCN_BOOL_FALSE == bRet) {
+		WMT_ERR_FUNC("thermal ctrl function not supported\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	pOp = wmt_lib_get_free_op();
+	if (!pOp) {
+		WMT_WARN_FUNC("get_free_lxop fail\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	pSignal = &pOp->signal;
+	pOpData = &pOp->op;
+	pOpData->opId = WMT_OPID_DSNS;
+	pSignal->timeoutValue = MAX_EACH_WMT_CMD;
+	/*parameter fill */
+	if ((WMTDSNS_FM_DISABLE <= eType) && (WMTDSNS_FM_GPS_ENABLE >= eType)) {
+		pOpData->au4OpData[0] = WMTDRV_TYPE_FM;
+		pOpData->au4OpData[1] = eType;
+	}
+
+	WMT_INFO_FUNC("OPID(%d) type(%d) start\n", pOp->op.opId, pOp->op.au4OpData[0]);
+
+	if (DISABLE_PSM_MONITOR()) {
+		WMT_ERR_FUNC("wake up failed,OPID(%d) type(%d) abort\n", pOp->op.opId, pOp->op.au4OpData[0]);
+		wmt_lib_put_op_to_free_queue(pOp);
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	bRet = wmt_lib_put_act_op(pOp);
+	ENABLE_PSM_MONITOR();
+
+	if (MTK_WCN_BOOL_FALSE == bRet)
+		WMT_WARN_FUNC("OPID(%d) type(%d) fail\n\n", pOpData->opId, pOpData->au4OpData[0]);
+	else
+		WMT_INFO_FUNC("OPID(%d) type(%d) ok\n\n", pOpData->opId, pOpData->au4OpData[0]);
+
+	return bRet;
+}
+#if !WMT_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_wmt_dsns_ctrl);
+#endif
+
+#if WMT_EXP_HID_API_EXPORT
+INT32 _mtk_wcn_wmt_msgcb_reg(ENUM_WMTDRV_TYPE_T eType, PF_WMT_CB pCb)
+#else
+INT32 mtk_wcn_wmt_msgcb_reg(ENUM_WMTDRV_TYPE_T eType, PF_WMT_CB pCb)
+#endif
+{
+	return (INT32) wmt_lib_msgcb_reg(eType, pCb);
+}
+#if !WMT_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_wmt_msgcb_reg);
+#endif
+
+#if WMT_EXP_HID_API_EXPORT
+INT32 _mtk_wcn_wmt_msgcb_unreg(ENUM_WMTDRV_TYPE_T eType)
+#else
+INT32 mtk_wcn_wmt_msgcb_unreg(ENUM_WMTDRV_TYPE_T eType)
+#endif
+{
+	return (INT32) wmt_lib_msgcb_unreg(eType);
+}
+#if !WMT_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_wmt_msgcb_unreg);
+#endif
+
+#if WMT_EXP_HID_API_EXPORT
+INT32 _mtk_wcn_stp_wmt_sdio_op_reg(PF_WMT_SDIO_PSOP own_cb)
+#else
+INT32 mtk_wcn_stp_wmt_sdio_op_reg(PF_WMT_SDIO_PSOP own_cb)
+#endif
+{
+	wmt_lib_ps_set_sdio_psop(own_cb);
+	return 0;
+}
+#if !WMT_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_stp_wmt_sdio_op_reg);
+#endif
+
+#if WMT_EXP_HID_API_EXPORT
+INT32 _mtk_wcn_stp_wmt_sdio_host_awake(VOID)
+#else
+INT32 mtk_wcn_stp_wmt_sdio_host_awake(VOID)
+#endif
+{
+	wmt_lib_ps_irq_cb();
+	return 0;
+}
+#if !WMT_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_stp_wmt_sdio_host_awake);
+#endif
+
+#if WMT_EXP_HID_API_EXPORT
+MTK_WCN_BOOL _mtk_wcn_wmt_assert(ENUM_WMTDRV_TYPE_T type, UINT32 reason)
+#else
+MTK_WCN_BOOL mtk_wcn_wmt_assert(ENUM_WMTDRV_TYPE_T type, UINT32 reason)
+#endif
+{
+	P_OSAL_OP pOp = NULL;
+	MTK_WCN_BOOL bRet = MTK_WCN_BOOL_FALSE;
+	P_OSAL_SIGNAL pSignal;
+
+	pOp = wmt_lib_get_free_op();
+	if (!pOp) {
+		WMT_WARN_FUNC("get_free_lxop fail\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	wmt_lib_set_host_assert_info(type, reason, 1);
+
+	pSignal = &pOp->signal;
+
+	pOp->op.opId = WMT_OPID_CMD_TEST;
+
+	pSignal->timeoutValue = MAX_EACH_WMT_CMD;
+	/*this test command should be run with usb cable connected, so no host awake is needed */
+	/* wmt_lib_host_awake_get(); */
+	pOp->op.au4OpData[0] = 0;
+
+	/*wake up chip first */
+	if (DISABLE_PSM_MONITOR()) {
+		WMT_ERR_FUNC("wake up failed,assert flow abort\n");
+		wmt_lib_put_op_to_free_queue(pOp);
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	bRet = wmt_lib_put_act_op(pOp);
+	ENABLE_PSM_MONITOR();
+
+	/* wmt_lib_host_awake_put(); */
+	WMT_INFO_FUNC("CMD_TEST, opid (%d), par(%d, %d), ret(%d), result(%s)\n",
+		      pOp->op.opId,
+		      pOp->op.au4OpData[0],
+		      pOp->op.au4OpData[1], bRet, MTK_WCN_BOOL_FALSE == bRet ? "failed" : "succeed");
+
+	return bRet;
+}
+#if !WMT_EXP_HID_API_EXPORT
+EXPORT_SYMBOL(mtk_wcn_wmt_assert);
+#endif
+
+INT8 mtk_wcn_wmt_co_clock_flag_get(void)
+{
+	return wmt_lib_co_clock_get();
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_co_clock_flag_get);
+
+INT32 mtk_wcn_wmt_system_state_reset(void)
+{
+	osal_memset(&gBtWifiGpsState, 0, osal_sizeof(gBtWifiGpsState));
+	osal_memset(&gGpsFmState, 0, osal_sizeof(gGpsFmState));
+
+	return 0;
+}
+
+INT32 mtk_wcn_wmt_wlan_reg(P_MTK_WCN_WMT_WLAN_CB_INFO pWmtWlanCbInfo)
+{
+	INT32 iRet = -1;
+
+	if (!pWmtWlanCbInfo) {
+		WMT_ERR_FUNC("wlan cb info in null!\n");
+		return -1;
+	}
+
+	WMT_INFO_FUNC("wmt wlan cb register\n");
+	mtk_wcn_wlan_probe = pWmtWlanCbInfo->wlan_probe_cb;
+	mtk_wcn_wlan_remove = pWmtWlanCbInfo->wlan_remove_cb;
+	mtk_wcn_wlan_bus_tx_cnt = pWmtWlanCbInfo->wlan_bus_cnt_get_cb;
+	mtk_wcn_wlan_bus_tx_cnt_clr = pWmtWlanCbInfo->wlan_bus_cnt_clr_cb;
+
+	if (gWifiProbed) {
+		WMT_INFO_FUNC("wlan has been done power on,call probe directly\n");
+		iRet = (*mtk_wcn_wlan_probe) ();
+		if (!iRet) {
+			WMT_INFO_FUNC("call wlan probe OK when do wlan register to wmt\n");
+			gWifiProbed = 0;
+		} else {
+			WMT_ERR_FUNC("call wlan probe fail(%d) when do wlan register to wmt\n", iRet);
+			return -2;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_wlan_reg);
+
+INT32 mtk_wcn_wmt_wlan_unreg(void)
+{
+	WMT_INFO_FUNC("wmt wlan cb unregister\n");
+	mtk_wcn_wlan_probe = NULL;
+	mtk_wcn_wlan_remove = NULL;
+	mtk_wcn_wlan_bus_tx_cnt = NULL;
+	mtk_wcn_wlan_bus_tx_cnt_clr = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_wlan_unreg);
+
+MTK_WCN_BOOL mtk_wcn_set_connsys_power_off_flag(MTK_WCN_BOOL value)
+{
+	g_pwr_off_flag = value;
+	if (g_pwr_off_flag)
+		WMT_DBG_FUNC("enable connsys power off flag\n");
+	else
+		WMT_INFO_FUNC("disable connsys power off, maybe need trigger coredump!\n");
+	return g_pwr_off_flag;
+}
+EXPORT_SYMBOL(mtk_wcn_set_connsys_power_off_flag);
+
+#ifdef MTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+VOID mtk_wcn_wmt_exp_init(void)
+{
+	MTK_WCN_WMT_EXP_CB_INFO wmtExpCb = {
+
+		.wmt_func_on_cb = _mtk_wcn_wmt_func_on,
+		.wmt_func_off_cb = _mtk_wcn_wmt_func_off,
+		.wmt_therm_ctrl_cb = _mtk_wcn_wmt_therm_ctrl,
+		.wmt_hwver_get_cb = _mtk_wcn_wmt_hwver_get,
+		.wmt_dsns_ctrl_cb = _mtk_wcn_wmt_dsns_ctrl,
+		.wmt_msgcb_reg_cb = _mtk_wcn_wmt_msgcb_reg,
+		.wmt_msgcb_unreg_cb = _mtk_wcn_wmt_msgcb_unreg,
+		.wmt_sdio_op_reg_cb = _mtk_wcn_stp_wmt_sdio_op_reg,
+		.wmt_sdio_host_awake_cb = _mtk_wcn_stp_wmt_sdio_host_awake,
+		.wmt_assert_cb = _mtk_wcn_wmt_assert
+	};
+
+	WMT_DBG_FUNC("call mtk_wcn_wmt_exp_cb_reg() to set callbacks\n");
+	mtk_wcn_wmt_exp_cb_reg(&wmtExpCb);
+}
+
+VOID mtk_wcn_wmt_exp_deinit(void)
+{
+	WMT_DBG_FUNC("calling mtk_wcn_wmt_exp_cb_unreg() to clear callbacks\n");
+	mtk_wcn_wmt_exp_cb_unreg();
+}
+#ifdef CONFIG_MTK_COMBO_ANT
+/*
+	ctrlId: get ram code status opId or ram code download opId
+	pBuf: pointer to ANT ram code
+	length: total length of ANT ram code
+*/
+ENUM_WMT_ANT_RAM_STATUS mtk_wcn_wmt_ant_ram_ctrl(ENUM_WMT_ANT_RAM_CTRL ctrlId, PUINT8 pBuf,
+						 UINT32 length, ENUM_WMT_ANT_RAM_SEQ seq)
+{
+	ENUM_WMT_ANT_RAM_STATUS eRet = 0;
+	P_OSAL_OP pOp = NULL;
+	MTK_WCN_BOOL bRet = MTK_WCN_BOOL_FALSE;
+	P_OSAL_SIGNAL pSignal;
+
+	/*1. parameter validation check */
+	/*for WMT_ANT_RAM_GET_STATUS, ignore pBuf and length */
+	/*for WMT_ANT_RAM_DOWNLOAD,
+	   pBuf must not be NULL, kernel space memory pointer
+	   length must be large than 0 */
+
+	if ((WMT_ANT_RAM_GET_STATUS > ctrlId) || (WMT_ANT_RAM_CTRL_MAX <= ctrlId)) {
+		WMT_ERR_FUNC("error ctrlId:%d detected.\n", ctrlId);
+		eRet = WMT_ANT_RAM_PARA_ERR;
+		return eRet;
+	}
+
+	if ((WMT_ANT_RAM_DOWNLOAD == ctrlId) &&
+	    ((NULL == pBuf) ||
+	     (0 >= length) ||
+	     (1000 < length) || (seq >= WMT_ANT_RAM_SEQ_MAX) || (seq < WMT_ANT_RAM_START_PKT))) {
+		eRet = WMT_ANT_RAM_PARA_ERR;
+		WMT_ERR_FUNC
+		    ("error parameter detected, ctrlId:%d, pBuf:%p,length(0x%x),seq(%d) .\n",
+		     ctrlId, pBuf, length, seq);
+		return eRet;
+	}
+	/*get WMT opId */
+	pOp = wmt_lib_get_free_op();
+	if (!pOp) {
+		WMT_DBG_FUNC("get_free_lxop fail\n");
+		return MTK_WCN_BOOL_FALSE;
+	}
+
+	pSignal = &pOp->signal;
+	pSignal->timeoutValue =
+	    (WMT_ANT_RAM_DOWNLOAD == ctrlId) ? MAX_FUNC_ON_TIME : MAX_EACH_WMT_CMD;
+
+	pOp->op.opId =
+	    (WMT_ANT_RAM_DOWNLOAD == ctrlId) ? WMT_OPID_ANT_RAM_DOWN : WMT_OPID_ANT_RAM_STA_GET;
+	pOp->op.au4OpData[0] = (size_t) pBuf;
+	pOp->op.au4OpData[1] = length;
+	pOp->op.au4OpData[2] = seq;
+
+
+	/*disable PSM monitor */
+	if (DISABLE_PSM_MONITOR()) {
+		WMT_ERR_FUNC("wake up failed\n");
+		wmt_lib_put_op_to_free_queue(pOp);
+		return MTK_WCN_BOOL_FALSE;
+	}
+	/*wakeup wmtd thread */
+	bRet = wmt_lib_put_act_op(pOp);
+
+	/*enable PSM monitor */
+	ENABLE_PSM_MONITOR();
+
+	WMT_DBG_FUNC("CMD_TEST, opid (%d), ret(%d),retVal(%zu) result(%s)\n",
+		      pOp->op.opId,
+		      bRet,
+		      pOp->op.au4OpData[2], MTK_WCN_BOOL_FALSE == bRet ? "failed" : "succeed");
+
+	/*check return value and return result */
+	if (MTK_WCN_BOOL_FALSE == bRet) {
+		eRet = WMT_ANT_RAM_OP_ERR;
+	} else {
+		eRet = (WMT_ANT_RAM_DOWNLOAD == ctrlId) ?
+		    WMT_ANT_RAM_DOWN_OK :
+		    ((1 == pOp->op.au4OpData[2]) ? WMT_ANT_RAM_EXIST : WMT_ANT_RAM_NOT_EXIST);
+	}
+
+	return eRet;
+
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_ant_ram_ctrl);
+#endif
+
+#endif
+VOID mtk_wcn_wmt_set_wifi_ver(UINT32 Value)
+{
+	wmt_lib_soc_set_wifiver(Value);
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_set_wifi_ver);
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/Makefile b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/Makefile
new file mode 100644
index 00000000..4780faf
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/Makefile
@@ -0,0 +1,28 @@
+ifeq ($(CONFIG_MTK_COMBO), y)
+
+ccflags-y += \
+	-I$(srctree)/$(src)/../../linux/include \
+	-I$(srctree)/$(src)/../../linux/pri/include \
+	-I$(srctree)/$(src)/../../core/include \
+	-I$(srctree)/$(src)/../../include \
+	-I$(srctree)/$(src)/../include \
+	-I$(srctree)/$(src)/../../../common_detect \
+	-I$(srctree)/drivers/misc/mediatek/include/mt-plat/$(MTK_PLATFORM)/include/mach \
+	-DMTK_BT_HCI=1
+
+ccflags-y += -DWMT_CREATE_NODE_DYNAMIC=1
+
+ifeq ($(CONFIG_MTK_TC1_FEATURE), y)
+    ccflags-y += -DCFG_TC1_FEATURE=1
+else
+    ccflags-y += -DCFG_TC1_FEATURE=0
+endif
+
+obj-y += osal.o \
+         bgw_desense.o \
+         wmt_idc.o
+
+obj-$(CONFIG_MTK_COMBO_BT) += stp_chrdev_bt.o
+obj-$(CONFIG_MTK_COMBO_WIFI) += wmt_chrdev_wifi.o
+
+endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/bgw_desense.c b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/bgw_desense.c
new file mode 100644
index 00000000..11e45aa
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/bgw_desense.c
@@ -0,0 +1,153 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <linux/version.h>
+#include <linux/netlink.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include <linux/socket.h>
+#include <linux/skbuff.h>
+#include <net/sock.h>
+#include <net/genetlink.h>
+#include "bgw_desense.h"
+
+static struct sock *g_nl_sk;
+/* static struct sockaddr_nl src_addr, des_addr; */
+/* static struct iovec iov; */
+static int pid;
+/* static struct msghdr msg; */
+
+void bgw_destroy_netlink_kernel(void)
+{
+	if (g_nl_sk != NULL) {
+		/* sock_release(g_nl_sk->sk_socket); */
+		netlink_kernel_release(g_nl_sk);
+		MSG("release socket\n");
+		return;
+	}
+	ERR("no socket yet\n");
+}
+
+void send_command_to_daemon(const int command /*struct sk_buff *skb */)
+{
+/*
+	struct iphdr *iph;
+	struct ethhdr *ehdr;
+	*/
+	struct nlmsghdr *nlh;
+	struct sk_buff *nl_skb;
+	int res;
+
+	MSG("here we will send command to native daemon\n");
+/*	if(skb == NULL)
+	{
+		ERR("invalid sk_buff\n");
+		return;
+	}
+*/
+	if (!g_nl_sk) {
+		ERR("invalid socket\n");
+		return;
+	}
+	if (pid == 0) {
+		ERR("invalid native process pid\n");
+		return;
+	}
+	/*alloc data buffer for sending to native */
+	/*malloc data space at least 1500 bytes, which is ethernet data length */
+	nl_skb = alloc_skb(NLMSG_SPACE(MAX_NL_MSG_LEN), GFP_ATOMIC);
+	if (nl_skb == NULL) {
+		ERR("malloc skb error\n");
+		return;
+	}
+	MSG("malloc data space done\n");
+	/*
+	   ehdr = eth_hdr(skb);
+	   iph = ip_hdr(skb);
+	 */
+
+/* nlh = NLMSG_PUT(nl_skb, 0, 0, 0, NLMSG_SPACE(1500)-sizeof(struct nlmsghdr)); */
+	nlh = nlmsg_put(nl_skb, 0, 0, 0, MAX_NL_MSG_LEN, 0);
+	if (nlh == NULL) {
+		MSG("nlh is NULL\n");
+		kfree_skb(nl_skb);
+		return;
+	}
+	NETLINK_CB(nl_skb).portid = 0;
+
+/* memcpy(NLMSG_DATA(nlh), ACK, 5); */
+	*(char *)NLMSG_DATA(nlh) = command;
+	res = netlink_unicast(g_nl_sk, nl_skb, pid, MSG_DONTWAIT);
+	if (res == 0) {
+		MSG("send to user space process error\n");
+		return;
+	}
+	ERR("send to user space process done, data length = %d\n", res);
+}
+
+static void nl_data_handler(struct sk_buff *__skb)
+{
+	struct sk_buff *skb;
+	struct nlmsghdr *nlh;
+	int i;
+	int len;
+	char str[128];
+
+	MSG("we got netlink message\n");
+	len = NLMSG_SPACE(MAX_NL_MSG_LEN);
+	skb = skb_get(__skb);
+	if (skb == NULL)
+		ERR("skb_get return NULL");
+	if (skb->len >= NLMSG_SPACE(0)) {	/*presume there is 5byte payload at leaset */
+		MSG("length is enough\n");
+		nlh = nlmsg_hdr(skb);	/* point to data which include in skb */
+		memcpy(str, NLMSG_DATA(nlh), sizeof(str));
+		for (i = 0; i < 3; i++)
+			MSG("str[%d = %c]", i, str[i]);
+		MSG("str[0] = %d, str[1] = %d, str[2] = %d\n", str[0], str[1], str[2]);
+		if (str[0] == 'B' && str[1] == 'G' && str[2] == 'W') {
+			MSG("got native daemon init command, record it's pid\n");
+			pid = nlh->nlmsg_pid;	/*record the native process PID */
+			MSG("native daemon pid is %d\n", pid);
+		} else {
+			ERR("this is not BGW message, ignore it\n");
+			return;
+		}
+	} else {
+		ERR("not engouth data length\n");
+		return;
+	}
+
+	kfree_skb(skb);
+
+	send_command_to_daemon(ACK);
+}
+
+int bgw_init_socket(void)
+{
+	struct netlink_kernel_cfg cfg;
+
+	memset(&cfg, 0, sizeof(cfg));
+	cfg.input = nl_data_handler;
+
+	g_nl_sk = __netlink_kernel_create(&init_net, NETLINK_TEST, THIS_MODULE, &cfg);
+
+	if (g_nl_sk == NULL) {
+		ERR("netlink_kernel_create error\n");
+		return -1;
+	}
+	MSG("netlink_kernel_create ok\n");
+	return 0;
+}
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/osal.c b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/osal.c
new file mode 100644
index 00000000..8fe34f8
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/osal.c
@@ -0,0 +1,1198 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+#include "osal_typedef.h"
+#include "osal.h"
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/* CRC table for the CRC-16. The poly is 0x8005 (x^16 + x^15 + x^2 + 1) */
+static UINT16 const crc16_table[256] = {
+	0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
+	0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
+	0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
+	0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
+	0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
+	0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
+	0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
+	0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
+	0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
+	0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
+	0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
+	0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
+	0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
+	0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
+	0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
+	0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
+	0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
+	0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
+	0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
+	0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
+	0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
+	0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
+	0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
+	0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
+	0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
+	0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
+	0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
+	0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
+	0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
+	0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
+	0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
+	0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
+};
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+/*string operations*/
+_osal_inline_ UINT32 osal_strlen(const char *str)
+{
+	return strlen(str);
+}
+
+_osal_inline_ INT32 osal_strcmp(const char *dst, const char *src)
+{
+	return strcmp(dst, src);
+}
+
+_osal_inline_ INT32 osal_strncmp(const char *dst, const char *src, UINT32 len)
+{
+	return strncmp(dst, src, len);
+}
+
+_osal_inline_ char *osal_strcpy(char *dst, const char *src)
+{
+	return strcpy(dst, src);
+}
+
+_osal_inline_ char *osal_strncpy(char *dst, const char *src, UINT32 len)
+{
+	return strncpy(dst, src, len);
+}
+
+_osal_inline_ char *osal_strcat(char *dst, const char *src)
+{
+	return strcat(dst, src);
+}
+
+_osal_inline_ char *osal_strncat(char *dst, const char *src, UINT32 len)
+{
+	return strncat(dst, src, len);
+}
+
+_osal_inline_ char *osal_strchr(const char *str, UINT8 c)
+{
+	return strchr(str, c);
+}
+
+_osal_inline_ char *osal_strsep(char **str, const char *c)
+{
+	return strsep(str, c);
+}
+
+_osal_inline_ int osal_strtol(const char *str, UINT32 adecimal, long *res)
+{
+	return kstrtol(str, adecimal, res);
+}
+
+_osal_inline_ char *osal_strstr(char *str1, const char *str2)
+{
+	return strstr(str1, str2);
+}
+
+INT32 osal_snprintf(char *buf, UINT32 len, const char *fmt, ...)
+{
+	INT32 iRet = 0;
+	va_list args;
+
+	/*va_start(args, fmt); */
+	va_start(args, fmt);
+	/*iRet = snprintf(buf, len, fmt, args); */
+	iRet = vsnprintf(buf, len, fmt, args);
+	va_end(args);
+
+	return iRet;
+}
+
+INT32 osal_err_print(const char *str, ...)
+{
+	va_list args;
+	char tempString[DBG_LOG_STR_SIZE];
+
+	va_start(args, str);
+	vsnprintf(tempString, DBG_LOG_STR_SIZE, str, args);
+	va_end(args);
+
+	pr_err("%s", tempString);
+
+	return 0;
+}
+
+INT32 osal_dbg_print(const char *str, ...)
+{
+	va_list args;
+	char tempString[DBG_LOG_STR_SIZE];
+
+	va_start(args, str);
+	vsnprintf(tempString, DBG_LOG_STR_SIZE, str, args);
+	va_end(args);
+
+	pr_debug("%s", tempString);
+
+	return 0;
+}
+
+INT32 osal_warn_print(const char *str, ...)
+{
+	va_list args;
+	char tempString[DBG_LOG_STR_SIZE];
+
+	va_start(args, str);
+	vsnprintf(tempString, DBG_LOG_STR_SIZE, str, args);
+	va_end(args);
+
+	pr_warn("%s", tempString);
+
+	return 0;
+}
+
+INT32 osal_dbg_assert(INT32 expr, const char *file, INT32 line)
+{
+	if (!expr) {
+		pr_warn("%s (%d)\n", file, line);
+		/*BUG_ON(!expr); */
+#ifdef CFG_COMMON_GPIO_DBG_PIN
+/* package this part */
+		mt_set_gpio_out(GPIO70, GPIO_OUT_ZERO);
+		pr_warn("toggle GPIO70\n");
+		udelay(10);
+		mt_set_gpio_out(GPIO70, GPIO_OUT_ONE);
+#endif
+		return 1;
+	}
+	return 0;
+
+}
+
+INT32 osal_dbg_assert_aee(const char *module, const char *detail_description)
+{
+	osal_err_print("[WMT-ASSERT]" "[E][Module]:%s, [INFO]%s\n", module, detail_description);
+
+#ifdef WMT_PLAT_ALPS
+	/* aee_kernel_warning(module,detail_description); */
+	aee_kernel_warning_api(__FILE__, __LINE__, DB_OPT_WCN_ISSUE_INFO, module, detail_description);
+#endif
+	return 0;
+}
+
+INT32 osal_sprintf(char *str, const char *format, ...)
+{
+	INT32 iRet = 0;
+	va_list args;
+
+	va_start(args, format);
+	iRet = vsnprintf(str, DBG_LOG_STR_SIZE, format, args);
+	va_end(args);
+
+	return iRet;
+}
+
+_osal_inline_ VOID *osal_malloc(UINT32 size)
+{
+	return vmalloc(size);
+}
+
+_osal_inline_ VOID osal_free(const VOID *dst)
+{
+	vfree(dst);
+}
+
+_osal_inline_ VOID *osal_memset(VOID *buf, INT32 i, UINT32 len)
+{
+	return memset(buf, i, len);
+}
+
+_osal_inline_ VOID *osal_memcpy(VOID *dst, const VOID *src, UINT32 len)
+{
+#ifdef CONFIG_MTK_WCN_ARM64
+	char *tmp;
+	const char *s;
+	size_t i;
+
+	tmp = dst;
+	s = src;
+	for (i = 0; i < len; i++)
+		tmp[i] = s[i];
+
+	return dst;
+
+#else
+	return memcpy(dst, src, len);
+#endif
+}
+
+_osal_inline_ INT32 osal_memcmp(const VOID *buf1, const VOID *buf2, UINT32 len)
+{
+	return memcmp(buf1, buf2, len);
+}
+
+_osal_inline_ UINT16 osal_crc16(const UINT8 *buffer, const UINT32 length)
+{
+	UINT16 crc = 0;
+	UINT32 i = 0;
+
+	/* FIXME: Add STP checksum feature */
+	crc = 0;
+	for (i = 0; i < length; i++, buffer++)
+		crc = (crc >> 8) ^ crc16_table[(crc ^ (*buffer)) & 0xff];
+
+	return crc;
+}
+
+_osal_inline_ VOID osal_thread_show_stack(P_OSAL_THREAD pThread)
+{
+#ifdef MTK_WCN_BUILT_IN_DRIVER
+	return show_stack(pThread->pThread, NULL);
+#else
+	return;
+#endif
+}
+
+/*
+  *OSAL layer Thread Opeartion related APIs
+  *
+  *
+*/
+_osal_inline_ INT32 osal_thread_create(P_OSAL_THREAD pThread)
+{
+	pThread->pThread = kthread_create(pThread->pThreadFunc, pThread->pThreadData, pThread->threadName);
+	if (NULL == pThread->pThread)
+		return -1;
+
+	return 0;
+}
+
+_osal_inline_ INT32 osal_thread_run(P_OSAL_THREAD pThread)
+{
+	if (pThread->pThread) {
+		wake_up_process(pThread->pThread);
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+_osal_inline_ INT32 osal_thread_stop(P_OSAL_THREAD pThread)
+{
+	INT32 iRet;
+
+	if ((pThread) && (pThread->pThread)) {
+		iRet = kthread_stop(pThread->pThread);
+		/* pThread->pThread = NULL; */
+		return iRet;
+	}
+	return -1;
+}
+
+_osal_inline_ INT32 osal_thread_should_stop(P_OSAL_THREAD pThread)
+{
+	if ((pThread) && (pThread->pThread))
+		return kthread_should_stop();
+	else
+		return 1;
+
+}
+
+_osal_inline_ INT32
+osal_thread_wait_for_event(P_OSAL_THREAD pThread, P_OSAL_EVENT pEvent, P_OSAL_EVENT_CHECKER pChecker)
+{
+	/*  P_DEV_WMT pDevWmt;*/
+
+	if ((pThread) && (pThread->pThread) && (pEvent) && (pChecker)) {
+		/* pDevWmt = (P_DEV_WMT)(pThread->pThreadData);*/
+		return wait_event_interruptible(pEvent->waitQueue, (/*!RB_EMPTY(&pDevWmt->rActiveOpQ) || */
+									   osal_thread_should_stop(pThread)
+									   || (*pChecker) (pThread)));
+	}
+	return -1;
+}
+
+_osal_inline_ INT32 osal_thread_destroy(P_OSAL_THREAD pThread)
+{
+	if (pThread && (pThread->pThread)) {
+		kthread_stop(pThread->pThread);
+		pThread->pThread = NULL;
+	}
+	return 0;
+}
+
+/*
+  *OSAL layer Signal Opeartion related APIs
+  *initialization
+  *wait for signal
+  *wait for signal timerout
+  *raise signal
+  *destroy a signal
+  *
+*/
+
+_osal_inline_ INT32 osal_signal_init(P_OSAL_SIGNAL pSignal)
+{
+	if (pSignal) {
+		init_completion(&pSignal->comp);
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+_osal_inline_ INT32 osal_wait_for_signal(P_OSAL_SIGNAL pSignal)
+{
+	if (pSignal) {
+		wait_for_completion_interruptible(&pSignal->comp);
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+_osal_inline_ INT32 osal_wait_for_signal_timeout(P_OSAL_SIGNAL pSignal)
+{
+	/* return wait_for_completion_interruptible_timeout(&pSignal->comp, msecs_to_jiffies(pSignal->timeoutValue)); */
+	/* [ChangeFeature][George] gps driver may be closed by -ERESTARTSYS.
+	 * Avoid using *interruptible" version in order to complete our jobs, such
+	 * as function off gracefully.
+	 */
+	return wait_for_completion_timeout(&pSignal->comp, msecs_to_jiffies(pSignal->timeoutValue));
+}
+
+_osal_inline_ INT32 osal_raise_signal(P_OSAL_SIGNAL pSignal)
+{
+	/* TODO:[FixMe][GeorgeKuo]: DO sanity check here!!! */
+	complete(&pSignal->comp);
+	return 0;
+}
+
+_osal_inline_ INT32 osal_signal_deinit(P_OSAL_SIGNAL pSignal)
+{
+	/* TODO:[FixMe][GeorgeKuo]: DO sanity check here!!! */
+	pSignal->timeoutValue = 0;
+	return 0;
+}
+
+/*
+  *OSAL layer Event Opeartion related APIs
+  *initialization
+  *wait for signal
+  *wait for signal timerout
+  *raise signal
+  *destroy a signal
+  *
+*/
+
+INT32 osal_event_init(P_OSAL_EVENT pEvent)
+{
+	init_waitqueue_head(&pEvent->waitQueue);
+
+	return 0;
+}
+
+INT32 osal_wait_for_event(P_OSAL_EVENT pEvent, INT32(*condition) (PVOID), void *cond_pa)
+{
+	return wait_event_interruptible(pEvent->waitQueue, condition(cond_pa));
+}
+
+INT32 osal_wait_for_event_timeout(P_OSAL_EVENT pEvent, INT32(*condition) (PVOID), void *cond_pa)
+{
+	return wait_event_interruptible_timeout(pEvent->waitQueue, condition(cond_pa),
+						msecs_to_jiffies(pEvent->timeoutValue));
+}
+
+INT32 osal_trigger_event(P_OSAL_EVENT pEvent)
+{
+	INT32 ret = 0;
+
+	wake_up_interruptible(&pEvent->waitQueue);
+	return ret;
+}
+
+INT32 osal_event_deinit(P_OSAL_EVENT pEvent)
+{
+	return 0;
+}
+
+_osal_inline_ long osal_wait_for_event_bit_set(P_OSAL_EVENT pEvent, unsigned long *pState, UINT32 bitOffset)
+{
+	UINT32 ms = pEvent->timeoutValue;
+
+	if (ms != 0) {
+		return wait_event_interruptible_timeout(pEvent->waitQueue, test_bit(bitOffset, pState),
+							msecs_to_jiffies(ms));
+	} else {
+		return wait_event_interruptible(pEvent->waitQueue, test_bit(bitOffset, pState));
+	}
+
+}
+
+_osal_inline_ long osal_wait_for_event_bit_clr(P_OSAL_EVENT pEvent, unsigned long *pState, UINT32 bitOffset)
+{
+	UINT32 ms = pEvent->timeoutValue;
+
+	if (ms != 0) {
+		return wait_event_interruptible_timeout(pEvent->waitQueue, !test_bit(bitOffset, pState),
+							msecs_to_jiffies(ms));
+	} else {
+		return wait_event_interruptible(pEvent->waitQueue, !test_bit(bitOffset, pState));
+	}
+
+}
+
+/*
+  *bit test and set/clear operations APIs
+  *
+  *
+*/
+#if    OS_BIT_OPS_SUPPORT
+#define osal_bit_op_lock(x)
+#define osal_bit_op_unlock(x)
+#else
+
+_osal_inline_ INT32 osal_bit_op_lock(P_OSAL_UNSLEEPABLE_LOCK pLock)
+{
+
+	return 0;
+}
+
+_osal_inline_ INT32 osal_bit_op_unlock(P_OSAL_UNSLEEPABLE_LOCK pLock)
+{
+
+	return 0;
+}
+#endif
+_osal_inline_ INT32 osal_clear_bit(UINT32 bitOffset, P_OSAL_BIT_OP_VAR pData)
+{
+	osal_bit_op_lock(&(pData->opLock));
+	clear_bit(bitOffset, &pData->data);
+	osal_bit_op_unlock(&(pData->opLock));
+	return 0;
+}
+
+_osal_inline_ INT32 osal_set_bit(UINT32 bitOffset, P_OSAL_BIT_OP_VAR pData)
+{
+	osal_bit_op_lock(&(pData->opLock));
+	set_bit(bitOffset, &pData->data);
+	osal_bit_op_unlock(&(pData->opLock));
+	return 0;
+}
+
+_osal_inline_ INT32 osal_test_bit(UINT32 bitOffset, P_OSAL_BIT_OP_VAR pData)
+{
+	UINT32 iRet = 0;
+
+	osal_bit_op_lock(&(pData->opLock));
+	iRet = test_bit(bitOffset, &pData->data);
+	osal_bit_op_unlock(&(pData->opLock));
+	return iRet;
+}
+
+_osal_inline_ INT32 osal_test_and_clear_bit(UINT32 bitOffset, P_OSAL_BIT_OP_VAR pData)
+{
+	UINT32 iRet = 0;
+
+	osal_bit_op_lock(&(pData->opLock));
+	iRet = test_and_clear_bit(bitOffset, &pData->data);
+	osal_bit_op_unlock(&(pData->opLock));
+	return iRet;
+
+}
+
+_osal_inline_ INT32 osal_test_and_set_bit(UINT32 bitOffset, P_OSAL_BIT_OP_VAR pData)
+{
+	UINT32 iRet = 0;
+
+	osal_bit_op_lock(&(pData->opLock));
+	iRet = test_and_set_bit(bitOffset, &pData->data);
+	osal_bit_op_unlock(&(pData->opLock));
+	return iRet;
+}
+
+/*
+  *tiemr operations APIs
+  *create
+  *stop
+  * modify
+  *create
+  *delete
+  *
+*/
+
+INT32 osal_timer_create(P_OSAL_TIMER pTimer)
+{
+	struct timer_list *timer = &pTimer->timer;
+
+	/*init_timer(timer);
+	timer->function = pTimer->timeoutHandler;
+	timer->data = (unsigned long)pTimer->timeroutHandlerData;*/
+	timer_setup(timer,pTimer->timeoutHandler,0);
+	return 0;
+}
+
+INT32 osal_timer_start(P_OSAL_TIMER pTimer, UINT32 ms)
+{
+
+	struct timer_list *timer = &pTimer->timer;
+
+	timer->expires = jiffies + (ms / (1000 / HZ));
+	add_timer(timer);
+	return 0;
+}
+
+INT32 osal_timer_stop(P_OSAL_TIMER pTimer)
+{
+	struct timer_list *timer = &pTimer->timer;
+
+	del_timer(timer);
+	return 0;
+}
+
+INT32 osal_timer_stop_sync(P_OSAL_TIMER pTimer)
+{
+	struct timer_list *timer = &pTimer->timer;
+
+	del_timer_sync(timer);
+	return 0;
+}
+
+INT32 osal_timer_modify(P_OSAL_TIMER pTimer, UINT32 ms)
+{
+
+	mod_timer(&pTimer->timer, jiffies + (ms) / (1000 / HZ));
+	return 0;
+}
+
+INT32 _osal_fifo_init(OSAL_FIFO *pFifo, UINT8 *buf, UINT32 size)
+{
+	struct kfifo *fifo = NULL;
+	INT32 ret = -1;
+
+	if (!pFifo) {
+		pr_err("pFifo must be !NULL\n");
+		return -1;
+	}
+	if (pFifo->pFifoBody) {
+		pr_err("pFifo->pFifoBody must be NULL\n");
+		pr_err("pFifo(0x%p), pFifo->pFifoBody(0x%p)\n", pFifo, pFifo->pFifoBody);
+		return -1;
+	}
+	fifo = kzalloc(sizeof(struct kfifo), GFP_ATOMIC);
+	if (!buf) {
+		/*fifo's buffer is not ready, we allocate automatically */
+		ret = kfifo_alloc(fifo, size, /*GFP_KERNEL */ GFP_ATOMIC);
+	} else {
+		if (is_power_of_2(size)) {
+			kfifo_init(fifo, buf, size);
+			ret = 0;
+		} else {
+			kfifo_free(fifo);
+			fifo = NULL;
+			ret = -1;
+		}
+	}
+
+	pFifo->pFifoBody = fifo;
+	return (ret < 0) ? (-1) : (0);
+}
+
+INT32 _osal_fifo_deinit(OSAL_FIFO *pFifo)
+{
+	struct kfifo *fifo = NULL;
+
+	if (!pFifo || !pFifo->pFifoBody) {
+		pr_err("%s:pFifo = NULL or pFifo->pFifoBody = NULL, error\n", __func__);
+		return -1;
+	}
+
+	fifo = (struct kfifo *)pFifo->pFifoBody;
+
+	if (fifo)
+		kfifo_free(fifo);
+
+	return 0;
+}
+
+INT32 _osal_fifo_size(OSAL_FIFO *pFifo)
+{
+	struct kfifo *fifo = NULL;
+	INT32 ret = 0;
+
+	if (!pFifo || !pFifo->pFifoBody) {
+		pr_err("%s:pFifo = NULL or pFifo->pFifoBody = NULL, error\n", __func__);
+		return -1;
+	}
+
+	fifo = (struct kfifo *)pFifo->pFifoBody;
+
+	if (fifo)
+		ret = kfifo_size(fifo);
+
+	return ret;
+}
+
+/*returns unused bytes in fifo*/
+INT32 _osal_fifo_avail_size(OSAL_FIFO *pFifo)
+{
+	struct kfifo *fifo = NULL;
+	INT32 ret = 0;
+
+	if (!pFifo || !pFifo->pFifoBody) {
+		pr_err("%s:pFifo = NULL or pFifo->pFifoBody = NULL, error\n", __func__);
+		return -1;
+	}
+
+	fifo = (struct kfifo *)pFifo->pFifoBody;
+
+	if (fifo)
+		ret = kfifo_avail(fifo);
+
+	return ret;
+}
+
+/*returns used bytes in fifo*/
+INT32 _osal_fifo_len(OSAL_FIFO *pFifo)
+{
+	struct kfifo *fifo = NULL;
+	INT32 ret = 0;
+
+	if (!pFifo || !pFifo->pFifoBody) {
+		pr_err("%s:pFifo = NULL or pFifo->pFifoBody = NULL, error\n", __func__);
+		return -1;
+	}
+
+	fifo = (struct kfifo *)pFifo->pFifoBody;
+
+	if (fifo)
+		ret = kfifo_len(fifo);
+
+	return ret;
+}
+
+INT32 _osal_fifo_is_empty(OSAL_FIFO *pFifo)
+{
+	struct kfifo *fifo = NULL;
+	INT32 ret = 0;
+
+	if (!pFifo || !pFifo->pFifoBody) {
+		pr_err("%s:pFifo = NULL or pFifo->pFifoBody = NULL, error\n", __func__);
+		return -1;
+	}
+
+	fifo = (struct kfifo *)pFifo->pFifoBody;
+
+	if (fifo)
+		ret = kfifo_is_empty(fifo);
+
+	return ret;
+}
+
+INT32 _osal_fifo_is_full(OSAL_FIFO *pFifo)
+{
+	struct kfifo *fifo = NULL;
+	INT32 ret = 0;
+
+	if (!pFifo || !pFifo->pFifoBody) {
+		pr_err("%s:pFifo = NULL or pFifo->pFifoBody = NULL, error\n", __func__);
+		return -1;
+	}
+
+	fifo = (struct kfifo *)pFifo->pFifoBody;
+
+	if (fifo)
+		ret = kfifo_is_full(fifo);
+
+	return ret;
+}
+
+INT32 _osal_fifo_data_in(OSAL_FIFO *pFifo, const VOID *buf, UINT32 len)
+{
+	struct kfifo *fifo = NULL;
+	INT32 ret = 0;
+
+	if (!pFifo || !pFifo->pFifoBody) {
+		pr_err("%s:pFifo = NULL or pFifo->pFifoBody = NULL, error\n", __func__);
+		return -1;
+	}
+
+	fifo = (struct kfifo *)pFifo->pFifoBody;
+
+	if (fifo && buf && (len <= _osal_fifo_avail_size(pFifo))) {
+		ret = kfifo_in(fifo, buf, len);
+	} else {
+		pr_err("%s: kfifo_in, error, len = %d, _osal_fifo_avail_size = %d, buf=%p\n",
+		       __func__, len, _osal_fifo_avail_size(pFifo), buf);
+
+		ret = 0;
+	}
+
+	return ret;
+}
+
+INT32 _osal_fifo_data_out(OSAL_FIFO *pFifo, void *buf, UINT32 len)
+{
+	struct kfifo *fifo = NULL;
+	INT32 ret = 0;
+
+	if (!pFifo || !pFifo->pFifoBody) {
+		pr_err("%s:pFifo = NULL or pFifo->pFifoBody = NULL, error\n", __func__);
+		return -1;
+	}
+
+	fifo = (struct kfifo *)pFifo->pFifoBody;
+
+	if (fifo && buf && (len <= _osal_fifo_len(pFifo))) {
+		ret = kfifo_out(fifo, buf, len);
+	} else {
+		pr_err("%s: kfifo_out, error, len = %d, osal_fifo_len = %d, buf=%p\n",
+		       __func__, len, _osal_fifo_len(pFifo), buf);
+
+		ret = 0;
+	}
+
+	return ret;
+}
+
+INT32 _osal_fifo_reset(OSAL_FIFO *pFifo)
+{
+	struct kfifo *fifo = NULL;
+
+	if (!pFifo || !pFifo->pFifoBody) {
+		pr_err("%s:pFifo = NULL or pFifo->pFifoBody = NULL, error\n", __func__);
+		return -1;
+	}
+
+	fifo = (struct kfifo *)pFifo->pFifoBody;
+
+	if (fifo)
+		kfifo_reset(fifo);
+
+	return 0;
+}
+
+INT32 osal_fifo_init(P_OSAL_FIFO pFifo, UINT8 *buffer, UINT32 size)
+{
+	if (!pFifo) {
+		pr_err("%s:pFifo = NULL, error\n", __func__);
+		return -1;
+	}
+
+	pFifo->FifoInit = _osal_fifo_init;
+	pFifo->FifoDeInit = _osal_fifo_deinit;
+	pFifo->FifoSz = _osal_fifo_size;
+	pFifo->FifoAvailSz = _osal_fifo_avail_size;
+	pFifo->FifoLen = _osal_fifo_len;
+	pFifo->FifoIsEmpty = _osal_fifo_is_empty;
+	pFifo->FifoIsFull = _osal_fifo_is_full;
+	pFifo->FifoDataIn = _osal_fifo_data_in;
+	pFifo->FifoDataOut = _osal_fifo_data_out;
+	pFifo->FifoReset = _osal_fifo_reset;
+
+	if (NULL != pFifo->pFifoBody) {
+		pr_err("%s:Because pFifo room is avialable, we clear the room and allocate them again.\n", __func__);
+		pFifo->FifoDeInit(pFifo->pFifoBody);
+		pFifo->pFifoBody = NULL;
+	}
+
+	pFifo->FifoInit(pFifo, buffer, size);
+
+	return 0;
+}
+
+VOID osal_fifo_deinit(P_OSAL_FIFO pFifo)
+{
+	if (pFifo)
+		pFifo->FifoDeInit(pFifo);
+	else {
+		pr_err("%s:pFifo = NULL, error\n", __func__);
+		return;
+	}
+	kfree(pFifo->pFifoBody);
+}
+
+INT32 osal_fifo_reset(P_OSAL_FIFO pFifo)
+{
+	INT32 ret = -1;
+
+	if (pFifo) {
+		ret = pFifo->FifoReset(pFifo);
+	} else {
+		pr_err("%s:pFifo = NULL, error\n", __func__);
+		ret = -1;
+	}
+	return ret;
+}
+
+UINT32 osal_fifo_in(P_OSAL_FIFO pFifo, PUINT8 buffer, UINT32 size)
+{
+	UINT32 ret = 0;
+
+	if (pFifo) {
+		ret = pFifo->FifoDataIn(pFifo, buffer, size);
+	} else {
+		pr_err("%s:pFifo = NULL, error\n", __func__);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+UINT32 osal_fifo_out(P_OSAL_FIFO pFifo, PUINT8 buffer, UINT32 size)
+{
+	UINT32 ret = 0;
+
+	if (pFifo) {
+		ret = pFifo->FifoDataOut(pFifo, buffer, size);
+	} else {
+		pr_err("%s:pFifo = NULL, error\n", __func__);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+UINT32 osal_fifo_len(P_OSAL_FIFO pFifo)
+{
+	UINT32 ret = 0;
+
+	if (pFifo) {
+		ret = pFifo->FifoLen(pFifo);
+	} else {
+		pr_err("%s:pFifo = NULL, error\n", __func__);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+UINT32 osal_fifo_sz(P_OSAL_FIFO pFifo)
+{
+	UINT32 ret = 0;
+
+	if (pFifo) {
+		ret = pFifo->FifoSz(pFifo);
+	} else {
+		pr_err("%s:pFifo = NULL, error\n", __func__);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+UINT32 osal_fifo_avail(P_OSAL_FIFO pFifo)
+{
+	UINT32 ret = 0;
+
+	if (pFifo) {
+		ret = pFifo->FifoAvailSz(pFifo);
+	} else {
+		pr_err("%s:pFifo = NULL, error\n", __func__);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+UINT32 osal_fifo_is_empty(P_OSAL_FIFO pFifo)
+{
+	UINT32 ret = 0;
+
+	if (pFifo) {
+		ret = pFifo->FifoIsEmpty(pFifo);
+	} else {
+		pr_err("%s:pFifo = NULL, error\n", __func__);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+UINT32 osal_fifo_is_full(P_OSAL_FIFO pFifo)
+{
+	UINT32 ret = 0;
+
+	if (pFifo) {
+		ret = pFifo->FifoIsFull(pFifo);
+	} else {
+		pr_err("%s:pFifo = NULL, error\n", __func__);
+		ret = 0;
+	}
+	return ret;
+}
+
+INT32 osal_wake_lock_init(P_OSAL_WAKE_LOCK pLock)
+{
+	if (!pLock)
+		return -1;
+
+	if((pLock->wake_lock = wakeup_source_create(pLock->name)))
+		wakeup_source_add(pLock->wake_lock);
+
+	return 0;
+}
+
+INT32 osal_wake_lock_deinit(P_OSAL_WAKE_LOCK pLock)
+{
+	if (!pLock)
+		return -1;
+
+	wakeup_source_remove(pLock->wake_lock);
+	wakeup_source_destroy(pLock->wake_lock);
+	return 0;
+}
+
+INT32 osal_wake_lock(P_OSAL_WAKE_LOCK pLock)
+{
+	if (!pLock)
+		return -1;
+
+	__pm_stay_awake(pLock->wake_lock);
+
+	return 0;
+}
+
+INT32 osal_wake_unlock(P_OSAL_WAKE_LOCK pLock)
+{
+	if (!pLock)
+		return -1;
+
+	__pm_relax(pLock->wake_lock);
+
+	return 0;
+
+}
+
+INT32 osal_wake_lock_count(P_OSAL_WAKE_LOCK pLock)
+{
+	INT32 count = 0;
+
+	if (!pLock)
+		return -1;
+
+	count = pLock->wake_lock->active;
+	return count;
+}
+
+/*
+  *sleepable lock operations APIs
+  *init
+  *lock
+  *unlock
+  *destroy
+  *
+*/
+
+#if !defined(CONFIG_PROVE_LOCKING)
+INT32 osal_unsleepable_lock_init(P_OSAL_UNSLEEPABLE_LOCK pUSL)
+{
+	spin_lock_init(&(pUSL->lock));
+	return 0;
+}
+#endif
+
+INT32 osal_lock_unsleepable_lock(P_OSAL_UNSLEEPABLE_LOCK pUSL)
+{
+	spin_lock_irqsave(&(pUSL->lock), pUSL->flag);
+	return 0;
+}
+
+INT32 osal_unlock_unsleepable_lock(P_OSAL_UNSLEEPABLE_LOCK pUSL)
+{
+	spin_unlock_irqrestore(&(pUSL->lock), pUSL->flag);
+	return 0;
+}
+
+INT32 osal_unsleepable_lock_deinit(P_OSAL_UNSLEEPABLE_LOCK pUSL)
+{
+	return 0;
+}
+
+/*
+  *unsleepable operations APIs
+  *init
+  *lock
+  *unlock
+  *destroy
+
+  *
+*/
+
+#if !defined(CONFIG_PROVE_LOCKING)
+INT32 osal_sleepable_lock_init(P_OSAL_SLEEPABLE_LOCK pSL)
+{
+	mutex_init(&pSL->lock);
+	return 0;
+}
+#endif
+
+INT32 osal_lock_sleepable_lock(P_OSAL_SLEEPABLE_LOCK pSL)
+{
+	return mutex_lock_killable(&pSL->lock);
+}
+
+INT32 osal_unlock_sleepable_lock(P_OSAL_SLEEPABLE_LOCK pSL)
+{
+	mutex_unlock(&pSL->lock);
+	return 0;
+}
+
+INT32 osal_sleepable_lock_deinit(P_OSAL_SLEEPABLE_LOCK pSL)
+{
+	mutex_destroy(&pSL->lock);
+	return 0;
+}
+
+INT32 osal_sleep_ms(UINT32 ms)
+{
+	msleep(ms);
+	return 0;
+}
+
+INT32 osal_udelay(UINT32 us)
+{
+	udelay(us);
+	return 0;
+}
+
+INT32 osal_gettimeofday(PINT32 sec, PINT32 usec)
+{
+	INT32 ret = 0;
+	struct timeval now;
+
+	do_gettimeofday(&now);
+
+	if (sec != NULL)
+		*sec = now.tv_sec;
+	else
+		ret = -1;
+
+	if (usec != NULL)
+		*usec = now.tv_usec;
+	else
+		ret = -1;
+
+	return ret;
+}
+
+INT32 osal_printtimeofday(const PUINT8 prefix)
+{
+	INT32 ret;
+	INT32 sec;
+	INT32 usec;
+
+	ret = osal_gettimeofday(&sec, &usec);
+	ret += osal_dbg_print("%s>sec=%d, usec=%d\n", prefix, sec, usec);
+
+	return ret;
+}
+
+VOID osal_buffer_dump(const UINT8 *buf, const UINT8 *title, const UINT32 len, const UINT32 limit)
+{
+	INT32 k;
+	UINT32 dump_len;
+
+	pr_warn("start of dump>[%s] len=%d, limit=%d,", title, len, limit);
+
+	dump_len = ((0 != limit) && (len > limit)) ? limit : len;
+#if 0
+	if (limit != 0)
+		len = (len > limit) ? (limit) : (len);
+
+#endif
+
+	for (k = 0; k < dump_len; k++) {
+		if ((k != 0) && (k % 16 == 0))
+			pr_cont("\n");
+		pr_cont("0x%02x ", buf[k]);
+	}
+	pr_warn("<end of dump\n");
+}
+
+UINT32 osal_op_get_id(P_OSAL_OP pOp)
+{
+	return (pOp) ? pOp->op.opId : 0xFFFFFFFF;
+}
+
+MTK_WCN_BOOL osal_op_is_wait_for_signal(P_OSAL_OP pOp)
+{
+	return (pOp && pOp->signal.timeoutValue) ? MTK_WCN_BOOL_TRUE : MTK_WCN_BOOL_FALSE;
+}
+
+VOID osal_op_raise_signal(P_OSAL_OP pOp, INT32 result)
+{
+	if (pOp) {
+		pOp->result = result;
+		osal_raise_signal(&pOp->signal);
+	}
+}
+
+VOID osal_set_op_result(P_OSAL_OP pOp, INT32 result)
+{
+	if (pOp)
+		pOp->result = result;
+
+}
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/stp_chrdev_bt.c b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/stp_chrdev_bt.c
new file mode 100644
index 00000000..7ae4329
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/stp_chrdev_bt.c
@@ -0,0 +1,900 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/sched.h>
+#include <asm/current.h>
+#include <asm/uaccess.h>
+#include <linux/fcntl.h>
+#include <linux/poll.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#if WMT_CREATE_NODE_DYNAMIC
+#include <linux/device.h>
+#endif
+#include <linux/printk.h>
+
+#include "osal_typedef.h"
+#include "stp_exp.h"
+#include "wmt_exp.h"
+
+MODULE_LICENSE("Dual BSD/GPL");
+
+#ifdef MTK_BT_HCI
+#define MTK_BT_DEBUG 0
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+#endif
+
+
+#define BT_DRIVER_NAME "mtk_stp_BT_chrdev"
+#define BT_DEV_MAJOR 192	/* Never used number */
+
+#define PFX                         "[MTK-BT] "
+#define BT_LOG_DBG                  3
+#define BT_LOG_INFO                 2
+#define BT_LOG_WARN                 1
+#define BT_LOG_ERR                  0
+
+#define COMBO_IOC_MAGIC             0xb0
+#define COMBO_IOCTL_FW_ASSERT       _IOWR(COMBO_IOC_MAGIC, 0, int)
+#define COMBO_IOCTL_BT_IC_HW_VER    _IOWR(COMBO_IOC_MAGIC, 1, void*)
+#define COMBO_IOCTL_BT_IC_FW_VER    _IOWR(COMBO_IOC_MAGIC, 2, void*)
+#define COMBO_IOC_BT_HWVER          _IOWR(COMBO_IOC_MAGIC, 3, void*)
+
+static UINT32 gDbgLevel = BT_LOG_INFO;
+
+#define BT_DBG_FUNC(fmt, arg...)	\
+	do { if (gDbgLevel >= BT_LOG_DBG)	\
+		pr_debug(PFX "%s: "  fmt, __func__ , ##arg);	\
+	} while (0)
+#define BT_INFO_FUNC(fmt, arg...)	\
+	do { if (gDbgLevel >= BT_LOG_INFO)	\
+		pr_warn(PFX "%s: "  fmt, __func__ , ##arg);	\
+	} while (0)
+#define BT_WARN_FUNC(fmt, arg...)	\
+	do { if (gDbgLevel >= BT_LOG_WARN)	\
+		pr_err(PFX "%s: "  fmt, __func__ , ##arg);	\
+	} while (0)
+#define BT_ERR_FUNC(fmt, arg...)	\
+	do { if (gDbgLevel >= BT_LOG_ERR)	\
+		pr_err(PFX "%s: "   fmt, __func__ , ##arg);	\
+	} while (0)
+
+#define VERSION "1.0"
+
+#ifdef MTK_BT_HCI
+
+#define   NUM_REASSEMBLY   32
+struct mtk_hci {
+	struct hci_dev *hdev;
+	struct work_struct work;
+	struct sk_buff_head txq;
+        struct sk_buff *reassembly[NUM_REASSEMBLY];
+};
+
+static struct mtk_hci   mtk_hci;
+
+#endif
+
+#if WMT_CREATE_NODE_DYNAMIC
+struct class *stpbt_class = NULL;
+struct device *stpbt_dev = NULL;
+#endif
+
+static INT32 BT_devs = 1;	/* Device count */
+static INT32 BT_major = BT_DEV_MAJOR;	/* Dynamic allocation */
+module_param(BT_major, uint, 0);
+static struct cdev BT_cdev;
+
+#define BT_BUFFER_SIZE 2048
+static UINT8 i_buf[BT_BUFFER_SIZE];	/* Input buffer of read() */
+static UINT8 o_buf[BT_BUFFER_SIZE];	/* Output buffer of write() */
+
+static struct semaphore wr_mtx, rd_mtx;
+/* Wait queue for poll and read */
+static wait_queue_head_t inq;
+static DECLARE_WAIT_QUEUE_HEAD(BT_wq);
+static INT32 flag;
+/* Reset flag for whole chip reset senario */
+static volatile INT32 rstflag;
+
+#ifdef MTK_BT_HCI
+static int hci_reassembly(struct hci_dev *hdev, int type, void *data,
+	int count, __u8 index)
+{
+	int len = 0;
+	int hlen = 0;
+	int offset = 0;
+	int remain = count;
+	struct sk_buff *skb;
+	struct bt_skb_cb *scb;
+	u16 opcode = 0;
+	unsigned char *pdata = data;
+
+        struct mtk_hci *info = NULL;
+	struct hci_event_hdr *ehdr = NULL;
+	struct hci_ev_cmd_complete *ev = NULL;
+	struct hci_rp_read_local_ext_features *ext  = NULL;
+
+        info = hci_get_drvdata(hdev);
+        if ( NULL == info ) {
+            printk(KERN_ERR "mtk_bt_hci: invalid info point\n");
+            return 0;
+        }
+
+	if ((type < HCI_ACLDATA_PKT || type > HCI_EVENT_PKT) ||
+		index >= NUM_REASSEMBLY)
+		return -EILSEQ;
+
+	skb = info->reassembly[index];
+
+	if (!skb) {
+		switch (type) {
+		case HCI_ACLDATA_PKT:
+			len = HCI_MAX_FRAME_SIZE;
+			hlen = HCI_ACL_HDR_SIZE;
+			break;
+		case HCI_EVENT_PKT:
+			len = HCI_MAX_EVENT_SIZE;
+			hlen = HCI_EVENT_HDR_SIZE;
+			break;
+		case HCI_SCODATA_PKT:
+			len = HCI_MAX_SCO_SIZE;
+			hlen = HCI_SCO_HDR_SIZE;
+			break;
+		}
+
+		skb = bt_skb_alloc(len, GFP_ATOMIC);
+		if (!skb)
+			return -ENOMEM;
+
+		scb = (void *) skb->cb;
+		scb->expect = hlen;
+		scb->pkt_type = type;
+
+		info->reassembly[index] = skb;
+	}
+
+	while (count) {
+		scb = (void *) skb->cb;
+		len = min_t(uint, scb->expect, count);
+
+		/*
+		 * Workaround for MT7623+MT6625 BT: the max page in response of cmd READ_LOCAL_EXT_FEATURES
+                 * should be 1, instead of 2, so changing it to 1 here
+		 */
+
+		if (HCI_EVENT_PKT == type)
+		{
+			ehdr = (void *)pdata;
+			offset = sizeof(struct hci_event_hdr);
+			if ( HCI_EV_CMD_COMPLETE == ehdr->evt)
+			{
+				ev = (struct hci_ev_cmd_complete *)&pdata[offset];
+
+				offset += sizeof(struct hci_ev_cmd_complete);
+
+				opcode = __le16_to_cpu(ev->opcode);
+				if(HCI_OP_READ_LOCAL_EXT_FEATURES == opcode) {
+					ext = (struct hci_rp_read_local_ext_features *) &pdata[offset];
+					if( !ext->status && ext->max_page >= 2) {
+						pr_info("%s: this workaround is applied for mediatek BT\n", __func__);
+						ext->max_page = 1;
+					}
+				}
+
+			}
+		}
+
+		memcpy(skb_put(skb, len), data, len);
+
+		count -= len;
+		data += len;
+		scb->expect -= len;
+		remain = count;
+
+		switch (type) {
+		case HCI_EVENT_PKT:
+			if (skb->len == HCI_EVENT_HDR_SIZE) {
+				struct hci_event_hdr *h = hci_event_hdr(skb);
+
+				scb->expect = h->plen;
+
+				if (skb_tailroom(skb) < scb->expect) {
+					kfree_skb(skb);
+					info->reassembly[index] = NULL;
+					return -ENOMEM;
+				}
+			}
+
+			break;
+
+		case HCI_ACLDATA_PKT:
+			if (skb->len  == HCI_ACL_HDR_SIZE) {
+				struct hci_acl_hdr *h = hci_acl_hdr(skb);
+
+				scb->expect = __le16_to_cpu(h->dlen);
+
+				if (skb_tailroom(skb) < scb->expect) {
+					kfree_skb(skb);
+					info->reassembly[index] = NULL;
+					return -ENOMEM;
+				}
+			}
+			break;
+
+		case HCI_SCODATA_PKT:
+			if (skb->len == HCI_SCO_HDR_SIZE) {
+				struct hci_sco_hdr *h = hci_sco_hdr(skb);
+
+				scb->expect = h->dlen;
+
+				if (skb_tailroom(skb) < scb->expect) {
+					kfree_skb(skb);
+					info->reassembly[index] = NULL;
+					return -ENOMEM;
+				}
+			}
+			break;
+		}
+
+		if (scb->expect == 0) {
+			/* Complete frame */
+
+			bt_cb(skb)->pkt_type = type;
+			hci_recv_frame(hdev, skb);
+
+			info->reassembly[index] = NULL;
+			return remain;
+		}
+	}
+
+	return remain;
+}
+
+int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count)
+{
+	int rem = 0;
+
+	if (type < HCI_ACLDATA_PKT || type > HCI_EVENT_PKT)
+		return -EILSEQ;
+
+	while (count) {
+		rem = hci_reassembly(hdev, type, data, count, type - 1);
+		if (rem < 0)
+			return rem;
+
+		data += (count - rem);
+		count = rem;
+	}
+
+	return rem;
+}
+#endif
+
+#ifdef MTK_BT_HCI
+void
+hex_dump(char *prefix, char *p, int len)
+{
+	int i;
+
+	pr_err("%s ", prefix);
+	for (i = 0; i < len; i++)
+		pr_err("%02x ", (*p++ & 0xff));
+	pr_err("\n");
+}
+
+static int
+mtk_bt_hci_open(struct hci_dev *hdev)
+{
+	int err = 0;
+
+#if MTK_BT_DEBUG == 1
+	pr_err("# %s\n", __func__);
+#endif
+
+	err = mtk_wcn_wmt_func_on(WMTDRV_TYPE_BT);
+	if (err != MTK_WCN_BOOL_TRUE) {
+		pr_err("%s func on failed with %d\n", __func__, err);
+		return -ENODEV;
+	}
+
+	set_bit(HCI_RUNNING, &hdev->flags);
+
+	mtk_wcn_stp_set_bluez(1);
+
+	return 0;
+}
+
+static int
+mtk_bt_hci_close(struct hci_dev *hdev)
+{
+	int err = 0;
+
+#if MTK_BT_DEBUG == 1
+	pr_err("# %s\n", __func__);
+#endif
+
+	mtk_wcn_stp_set_bluez(0);
+
+	clear_bit(HCI_RUNNING, &hdev->flags);
+
+	err = mtk_wcn_wmt_func_off(WMTDRV_TYPE_BT);
+	if (err != MTK_WCN_BOOL_TRUE) {
+		pr_err("%s func off failed with %d\n", __func__, err);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void
+mtk_bt_hci_work(struct work_struct *work)
+{
+	int err;
+	struct sk_buff *skb;
+
+#if MTK_BT_DEBUG == 1
+	pr_err("# %s\n", __func__);
+#endif
+
+	while ((skb = skb_dequeue(&mtk_hci.txq))) {
+		skb_push(skb, 1);
+		skb->data[0] = bt_cb(skb)->pkt_type;
+
+#if MTK_BT_DEBUG == 1
+		hex_dump(">>", skb->data, skb->len);
+#endif
+
+		err = mtk_wcn_stp_send_data(skb->data, skb->len, BT_TASK_INDX);
+		if (err < 0) {
+			pr_err("%s err=%d\n", __func__, err);
+			mtk_hci.hdev->stat.err_tx++;
+			skb_queue_head(&mtk_hci.txq, skb);
+			break;
+		}
+
+		mtk_hci.hdev->stat.byte_tx += skb->len;
+		kfree_skb(skb);
+	}
+}
+
+static int
+mtk_bt_hci_send(struct hci_dev *hdev, struct sk_buff *skb)
+{
+#if MTK_BT_DEBUG == 1
+	pr_err("# %s\n", __func__);
+#endif
+
+	if (mtk_hci.hdev && !test_bit(HCI_RUNNING, &mtk_hci.hdev->flags))
+		return -EBUSY;
+
+	switch (bt_cb(skb)->pkt_type) {
+	case HCI_COMMAND_PKT:
+		mtk_hci.hdev->stat.cmd_tx++;
+		break;
+
+	case HCI_ACLDATA_PKT:
+		mtk_hci.hdev->stat.acl_tx++;
+		break;
+
+	case HCI_SCODATA_PKT:
+		mtk_hci.hdev->stat.sco_tx++;
+		break;
+
+	default:
+		return -EILSEQ;
+	}
+
+	skb_queue_tail(&mtk_hci.txq, skb);
+	schedule_work(&mtk_hci.work);
+
+	return 0;
+}
+
+static int
+mtk_bt_hci_flush(struct hci_dev *hdev)
+{
+	pr_err("%s: todo\n", __func__);
+
+	return 0;
+}
+
+static void
+mtk_bt_hci_receive(const PUINT8 data, INT32 size)
+{
+	int err;
+
+#if MTK_BT_DEBUG == 1
+	pr_err("# %s\n", __func__);
+	hex_dump("<<", data, size);
+#endif
+
+	err = hci_recv_fragment(mtk_hci.hdev, data[0], (void *)&data[1], size - 1);
+	if (err < 0)
+		pr_err("%s: hci_recv_fragment failed with %d\n", __func__, err);
+
+	if (mtk_hci.hdev)
+		mtk_hci.hdev->stat.byte_rx += size - 1;
+}
+
+static void
+mtk_bt_hci_notify(struct hci_dev *hdev, unsigned int evt)
+{
+	static const char * const notify_str[] = {
+		"null",
+		"HCI_NOTIFY_CONN_ADD",
+		"HCI_NOTIFY_CONN_DEL",
+		"HCI_NOTIFY_VOICE_SETTING"
+	};
+
+	if (evt > HCI_NOTIFY_VOICE_SETTING)
+		pr_info("%s event=0x%x\n", __func__, evt);
+	else
+		pr_info("%s event(%d)=%s\n", __func__, evt, notify_str[evt]);
+}
+#endif
+
+#ifdef MTK_BT_HCI
+
+int mtk_bt_hci_init(void)
+{
+	INT32 hci_err = 0;
+
+	mtk_hci.hdev = hci_alloc_dev();
+	if (!(mtk_hci.hdev)) {
+		mtk_hci.hdev = NULL;
+		BT_ERR_FUNC("%s hci_alloc_dev failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	mtk_hci.hdev->bus = HCI_SDIO;
+	mtk_hci.hdev->open = mtk_bt_hci_open;
+	mtk_hci.hdev->close = mtk_bt_hci_close;
+	mtk_hci.hdev->send = mtk_bt_hci_send;
+	mtk_hci.hdev->flush = mtk_bt_hci_flush;
+	mtk_hci.hdev->notify = mtk_bt_hci_notify;
+	SET_HCIDEV_DEV(mtk_hci.hdev, stpbt_dev);
+
+	hci_set_drvdata(mtk_hci.hdev, &mtk_hci);
+
+	mtk_wcn_stp_register_if_rx(mtk_bt_hci_receive);
+
+	hci_err = hci_register_dev(mtk_hci.hdev);
+	if (hci_err) {
+		BT_ERR_FUNC("%s hci_register_dev failed with %d\n", __func__, hci_err);
+		hci_free_dev(mtk_hci.hdev);
+		mtk_hci.hdev = NULL;
+		return hci_err;
+	}
+
+	skb_queue_head_init(&mtk_hci.txq);
+	INIT_WORK(&mtk_hci.work, mtk_bt_hci_work);
+
+	return 0;
+}
+#endif
+
+
+static VOID bt_cdev_rst_cb(ENUM_WMTDRV_TYPE_T src,
+			   ENUM_WMTDRV_TYPE_T dst, ENUM_WMTMSG_TYPE_T type, PVOID buf, UINT32 sz)
+{
+	/*
+	   Handle whole chip reset messages
+	 */
+	ENUM_WMTRSTMSG_TYPE_T rst_msg;
+
+	if (sz <= sizeof(ENUM_WMTRSTMSG_TYPE_T)) {
+		memcpy((PINT8)&rst_msg, (PINT8)buf, sz);
+		BT_DBG_FUNC("src = %d, dst = %d, type = %d, buf = 0x%x sz = %d, max = %d\n", src,
+			     dst, type, rst_msg, sz, WMTRSTMSG_RESET_MAX);
+		if ((src == WMTDRV_TYPE_WMT) && (dst == WMTDRV_TYPE_BT)
+		    && (type == WMTMSG_TYPE_RESET)) {
+			if (rst_msg == WMTRSTMSG_RESET_START) {
+				BT_INFO_FUNC("BT reset start!\n");
+				rstflag = 1;
+				wake_up_interruptible(&inq);
+
+			} else if (rst_msg == WMTRSTMSG_RESET_END) {
+				BT_INFO_FUNC("BT reset end!\n");
+				rstflag = 2;
+				wake_up_interruptible(&inq);
+			}
+		}
+	} else {
+		/* Invalid message format */
+		BT_WARN_FUNC("Invalid message format!\n");
+	}
+}
+
+VOID BT_event_cb(VOID)
+{
+	BT_DBG_FUNC("BT_event_cb()\n");
+
+	flag = 1;
+
+	/*
+	* Finally, wake up any reader blocked in poll or read
+	*/
+	wake_up_interruptible(&inq);
+	wake_up(&BT_wq);
+}
+
+unsigned int BT_poll(struct file *filp, poll_table *wait)
+{
+	UINT32 mask = 0;
+
+/* down(&wr_mtx); */
+	/*
+	 * The buffer is circular; it is considered full
+	 * if "wp" is right behind "rp". "left" is 0 if the
+	 * buffer is empty, and it is "1" if it is completely full.
+	 */
+	if (mtk_wcn_stp_is_rxqueue_empty(BT_TASK_INDX)) {
+		poll_wait(filp, &inq, wait);
+
+		if (!mtk_wcn_stp_is_rxqueue_empty(BT_TASK_INDX) || rstflag)
+			/* BT Rx queue has valid data, or whole chip reset occurs */
+			mask |= POLLIN | POLLRDNORM;	/* Readable */
+	} else {
+		mask |= POLLIN | POLLRDNORM;	/* Readable */
+	}
+
+	/* Do we need condition here? */
+	mask |= POLLOUT | POLLWRNORM;	/* Writable */
+/* up(&wr_mtx); */
+	return mask;
+}
+
+ssize_t BT_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
+{
+	INT32 retval = 0;
+	INT32 write_size;
+	INT32 written = 0;
+
+	down(&wr_mtx);
+
+	BT_DBG_FUNC("%s: count %zd pos %lld\n", __func__, count, *f_pos);
+	if (rstflag) {
+		if (rstflag == 1) {	/* Reset start */
+			retval = -88;
+			BT_INFO_FUNC("%s: detect whole chip reset start\n", __func__);
+		} else if (rstflag == 2) {	/* Reset end */
+			retval = -99;
+			BT_INFO_FUNC("%s: detect whole chip reset end\n", __func__);
+		}
+		goto OUT;
+	}
+
+	if (count > 0) {
+		if (count < BT_BUFFER_SIZE) {
+			write_size = count;
+		} else {
+			write_size = BT_BUFFER_SIZE;
+			BT_ERR_FUNC("%s: count > BT_BUFFER_SIZE\n", __func__);
+		}
+
+		if (copy_from_user(&o_buf[0], &buf[0], write_size)) {
+			retval = -EFAULT;
+			goto OUT;
+		}
+
+		written = mtk_wcn_stp_send_data(&o_buf[0], write_size, BT_TASK_INDX);
+		if (0 == written) {
+			retval = -ENOSPC;
+			/* No space is available, native program should not call BT_write with no delay */
+			BT_ERR_FUNC
+			    ("Packet length %zd, sent length %d, retval = %d\n",
+			     count, written, retval);
+		} else {
+			retval = written;
+		}
+
+	} else {
+		retval = -EFAULT;
+		BT_ERR_FUNC("Packet length %zd is not allowed, retval = %d\n", count, retval);
+	}
+
+OUT:
+	up(&wr_mtx);
+	return retval;
+}
+
+ssize_t BT_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	static int chip_reset_count;
+	INT32 retval = 0;
+
+	down(&rd_mtx);
+
+	BT_DBG_FUNC("%s: count %zd pos %lld\n", __func__, count, *f_pos);
+	if (rstflag) {
+		if (rstflag == 1) {	/* Reset start */
+			retval = -88;
+			if ((chip_reset_count%500) == 0)
+				BT_INFO_FUNC("%s: detect whole chip reset start, %d\n", __func__, chip_reset_count);
+			chip_reset_count++;
+		} else if (rstflag == 2) {	/* Reset end */
+			retval = -99;
+			BT_INFO_FUNC("%s: detect whole chip reset end\n", __func__);
+			chip_reset_count = 0;
+		}
+		goto OUT;
+	}
+
+	if (count > BT_BUFFER_SIZE) {
+		count = BT_BUFFER_SIZE;
+		BT_ERR_FUNC("%s: count > BT_BUFFER_SIZE\n", __func__);
+	}
+
+	retval = mtk_wcn_stp_receive_data(i_buf, count, BT_TASK_INDX);
+
+	while (retval == 0) {	/* Got nothing, wait for STP's signal */
+		/*
+		* If nonblocking mode, return directly.
+		* O_NONBLOCK is specified during open()
+		*/
+		if (filp->f_flags & O_NONBLOCK) {
+			BT_DBG_FUNC("Non-blocking BT_read\n");
+			retval = -EAGAIN;
+			goto OUT;
+		}
+
+		BT_DBG_FUNC("%s: wait_event 1\n", __func__);
+		wait_event(BT_wq, flag != 0);
+		BT_DBG_FUNC("%s: wait_event 2\n", __func__);
+		flag = 0;
+		retval = mtk_wcn_stp_receive_data(i_buf, count, BT_TASK_INDX);
+		BT_DBG_FUNC("%s: mtk_wcn_stp_receive_data returns %d\n", __func__, retval);
+	}
+
+	/* Got something from STP driver */
+	if (copy_to_user(buf, i_buf, retval)) {
+		retval = -EFAULT;
+		goto OUT;
+	}
+
+OUT:
+	up(&rd_mtx);
+	BT_DBG_FUNC("%s: retval = %d\n", __func__, retval);
+	return retval;
+}
+
+/* int BT_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg) */
+long BT_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	INT32 retval = 0;
+	MTK_WCN_BOOL bRet = MTK_WCN_BOOL_TRUE;
+	ENUM_WMTHWVER_TYPE_T hw_ver_sym = WMTHWVER_INVALID;
+
+	BT_DBG_FUNC("%s:  cmd: 0x%x\n", __func__, cmd);
+
+	switch (cmd) {
+	case COMBO_IOC_BT_HWVER:
+		/* Get combo HW version */
+		hw_ver_sym = mtk_wcn_wmt_hwver_get();
+		BT_INFO_FUNC("%s: HW version = %d, sizeof(hw_ver_sym) = %zd\n",
+			     __func__, hw_ver_sym, sizeof(hw_ver_sym));
+		if (copy_to_user((int __user *)arg, &hw_ver_sym, sizeof(hw_ver_sym)))
+			retval = -EFAULT;
+		break;
+
+	case COMBO_IOCTL_FW_ASSERT:
+		/* Trigger FW assert for debug */
+		BT_INFO_FUNC("%s: Host trigger FW assert......, reason:%lu\n", __func__, arg);
+		bRet = mtk_wcn_wmt_assert(WMTDRV_TYPE_BT, arg);
+		if (bRet == MTK_WCN_BOOL_TRUE) {
+			BT_INFO_FUNC("Host trigger FW assert succeed\n");
+			retval = 0;
+		} else {
+			BT_ERR_FUNC("Host trigger FW assert Failed\n");
+			retval = (-EBUSY);
+		}
+		break;
+	case COMBO_IOCTL_BT_IC_HW_VER:
+		retval = mtk_wcn_wmt_ic_info_get(WMTCHIN_HWVER);
+		break;
+	case COMBO_IOCTL_BT_IC_FW_VER:
+		retval = mtk_wcn_wmt_ic_info_get(WMTCHIN_FWVER);
+		break;
+	default:
+		retval = -EFAULT;
+		BT_ERR_FUNC("Unknown cmd (%d)\n", cmd);
+		break;
+	}
+
+	return retval;
+}
+
+long BT_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	return BT_unlocked_ioctl(filp, cmd, arg);
+}
+
+static int BT_open(struct inode *inode, struct file *file)
+{
+	BT_INFO_FUNC("%s: major %d minor %d pid %d\n", __func__, imajor(inode), iminor(inode), current->pid);
+
+	/* Turn on BT */
+	if (MTK_WCN_BOOL_FALSE == mtk_wcn_wmt_func_on(WMTDRV_TYPE_BT)) {
+		BT_WARN_FUNC("WMT turn on BT fail!\n");
+		return -ENODEV;
+	}
+
+	BT_INFO_FUNC("WMT turn on BT OK!\n");
+	rstflag = 0;
+
+	if (mtk_wcn_stp_is_ready()) {
+
+		mtk_wcn_stp_set_bluez(0);
+
+		BT_INFO_FUNC("Now it's in MTK Bluetooth Mode\n");
+		BT_INFO_FUNC("STP is ready!\n");
+
+		BT_DBG_FUNC("Register BT event callback!\n");
+		mtk_wcn_stp_register_event_cb(BT_TASK_INDX, BT_event_cb);
+	} else {
+		BT_ERR_FUNC("STP is not ready\n");
+		mtk_wcn_wmt_func_off(WMTDRV_TYPE_BT);
+		return -ENODEV;
+	}
+
+	BT_DBG_FUNC("Register BT reset callback!\n");
+	mtk_wcn_wmt_msgcb_reg(WMTDRV_TYPE_BT, bt_cdev_rst_cb);
+
+	/* init_MUTEX(&wr_mtx); */
+	sema_init(&wr_mtx, 1);
+	/* init_MUTEX(&rd_mtx); */
+	sema_init(&rd_mtx, 1);
+	BT_INFO_FUNC("%s: finish\n", __func__);
+
+	return 0;
+}
+
+static int BT_close(struct inode *inode, struct file *file)
+{
+	BT_INFO_FUNC("%s: major %d minor %d pid %d\n", __func__, imajor(inode), iminor(inode), current->pid);
+	rstflag = 0;
+	mtk_wcn_wmt_msgcb_unreg(WMTDRV_TYPE_BT);
+	mtk_wcn_stp_register_event_cb(BT_TASK_INDX, NULL);
+
+	if (MTK_WCN_BOOL_FALSE == mtk_wcn_wmt_func_off(WMTDRV_TYPE_BT)) {
+		BT_ERR_FUNC("WMT turn off BT fail!\n");
+		return -EIO;	/* Mostly, native program will not check this return value. */
+	}
+
+	BT_INFO_FUNC("WMT turn off BT OK!\n");
+
+	return 0;
+}
+
+const struct file_operations BT_fops = {
+	.open = BT_open,
+	.release = BT_close,
+	.read = BT_read,
+	.write = BT_write,
+	/* .ioctl = BT_ioctl, */
+	.unlocked_ioctl = BT_unlocked_ioctl,
+	.compat_ioctl = BT_compat_ioctl,
+	.poll = BT_poll
+};
+
+
+
+static int BT_init(void)
+{
+	dev_t dev = MKDEV(BT_major, 0);
+	INT32 alloc_ret = 0;
+	INT32 cdev_err = 0;
+
+	/* Static allocate char device */
+	alloc_ret = register_chrdev_region(dev, 1, BT_DRIVER_NAME);
+	if (alloc_ret) {
+		BT_ERR_FUNC("%s: Failed to register char device\n", __func__);
+		return alloc_ret;
+	}
+
+	cdev_init(&BT_cdev, &BT_fops);
+	BT_cdev.owner = THIS_MODULE;
+
+	cdev_err = cdev_add(&BT_cdev, dev, BT_devs);
+	if (cdev_err)
+		goto error;
+
+#if WMT_CREATE_NODE_DYNAMIC
+	stpbt_class = class_create(THIS_MODULE, "stpbt");
+	if (IS_ERR(stpbt_class))
+		goto error;
+	stpbt_dev = device_create(stpbt_class, NULL, dev, NULL, "stpbt");
+	if (IS_ERR(stpbt_dev))
+		goto error;
+#endif
+
+	BT_INFO_FUNC("%s driver(major %d) installed\n", BT_DRIVER_NAME, BT_major);
+
+	/* Init wait queue */
+	init_waitqueue_head(&(inq));
+
+#ifdef MTK_BT_HCI
+	mtk_bt_hci_init();
+#endif
+
+	return 0;
+
+error:
+#if WMT_CREATE_NODE_DYNAMIC
+	if (!IS_ERR(stpbt_dev))
+		device_destroy(stpbt_class, dev);
+	if (!IS_ERR(stpbt_class)) {
+		class_destroy(stpbt_class);
+		stpbt_class = NULL;
+	}
+#endif
+	if (cdev_err == 0)
+		cdev_del(&BT_cdev);
+
+	if (alloc_ret == 0)
+		unregister_chrdev_region(dev, BT_devs);
+
+	return -1;
+}
+
+static void BT_exit(void)
+{
+	dev_t dev = MKDEV(BT_major, 0);
+
+#if WMT_CREATE_NODE_DYNAMIC
+	if (stpbt_dev) {
+		device_destroy(stpbt_class, dev);
+		stpbt_dev = NULL;
+	}
+	if (stpbt_class) {
+		class_destroy(stpbt_class);
+		stpbt_class = NULL;
+	}
+#endif
+
+	cdev_del(&BT_cdev);
+	unregister_chrdev_region(dev, BT_devs);
+
+	BT_INFO_FUNC("%s driver removed\n", BT_DRIVER_NAME);
+}
+
+#if 0
+//#ifdef MTK_WCN_REMOVE_KERNEL_MODULE
+
+int mtk_wcn_stpbt_drv_init(void)
+{
+	return BT_init();
+}
+EXPORT_SYMBOL(mtk_wcn_stpbt_drv_init);
+
+void mtk_wcn_stpbt_drv_exit(void)
+{
+	return BT_exit();
+}
+EXPORT_SYMBOL(mtk_wcn_stpbt_drv_exit);
+
+#else
+
+module_init(BT_init);
+module_exit(BT_exit);
+
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/wmt_chrdev_wifi.c b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/wmt_chrdev_wifi.c
new file mode 100644
index 00000000..906f272
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/wmt_chrdev_wifi.c
@@ -0,0 +1,671 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/sched.h>
+#include <asm/current.h>
+#include <asm/uaccess.h>
+#include <linux/fcntl.h>
+#include <linux/poll.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <net/net_namespace.h>
+#include <linux/string.h>
+
+#include "wmt_exp.h"
+#include "stp_exp.h"
+
+MODULE_LICENSE("Dual BSD/GPL");
+
+#define WIFI_DRIVER_NAME "mtk_wmt_WIFI_chrdev"
+#define WIFI_DEV_MAJOR 155
+
+#define PFX                         "[MTK-WIFI] "
+#define WIFI_LOG_DBG                  3
+#define WIFI_LOG_INFO                 2
+#define WIFI_LOG_WARN                 1
+#define WIFI_LOG_ERR                  0
+
+UINT32 gDbgLevel = WIFI_LOG_DBG;
+
+UINT32 g_IsNeedDoChipReset = 0;
+EXPORT_SYMBOL(g_IsNeedDoChipReset);
+
+#define WIFI_DBG_FUNC(fmt, arg...)\
+	do {if (gDbgLevel >= WIFI_LOG_DBG) printk(PFX "%s: " fmt, __func__ , ##arg); } while (0)
+#define WIFI_INFO_FUNC(fmt, arg...)\
+	do {if (gDbgLevel >= WIFI_LOG_INFO) printk(PFX "%s: " fmt, __func__ , ##arg); } while (0)
+#define WIFI_WARN_FUNC(fmt, arg...)\
+	do {if (gDbgLevel >= WIFI_LOG_WARN) printk(PFX "%s: " fmt, __func__ , ##arg); } while (0)
+#define WIFI_ERR_FUNC(fmt, arg...)\
+	do {if (gDbgLevel >= WIFI_LOG_ERR) printk(PFX "%s: " fmt, __func__ , ##arg); } while (0)
+#define WIFI_TRC_FUNC(f)\
+	do {if (gDbgLevel >= WIFI_LOG_DBG) printk(PFX "<%s> <%d>\n", __func__, __LINE__); } while (0)
+
+#define VERSION "1.0"
+
+#define WLAN_IFACE_NAME "wlan0"
+#if CFG_TC1_FEATURE
+#define LEGACY_IFACE_NAME "legacy0"
+#endif
+
+enum {
+	WLAN_MODE_HALT,
+	WLAN_MODE_AP,
+	WLAN_MODE_STA_P2P,
+	WLAN_MODE_MAX
+};
+static INT32 wlan_mode = WLAN_MODE_HALT;
+static INT32 powered;
+static INT8 *ifname = WLAN_IFACE_NAME;
+#if CFG_TC1_FEATURE
+volatile INT32 wlan_if_changed = 0;
+EXPORT_SYMBOL(wlan_if_changed);
+#endif
+
+typedef enum _ENUM_RESET_STATUS_T {
+	RESET_FAIL,
+	RESET_SUCCESS
+} ENUM_RESET_STATUS_T;
+
+/*
+ *  enable = 1, mode = 0  => init P2P network
+ *  enable = 1, mode = 1  => init Soft AP network
+ *  enable = 0            => uninit P2P/AP network
+ */
+typedef struct _PARAM_CUSTOM_P2P_SET_STRUCT_T {
+	UINT32 u4Enable;
+	UINT32 u4Mode;
+} PARAM_CUSTOM_P2P_SET_STRUCT_T, *P_PARAM_CUSTOM_P2P_SET_STRUCT_T;
+typedef INT32(*set_p2p_mode) (struct net_device *netdev, PARAM_CUSTOM_P2P_SET_STRUCT_T p2pmode);
+
+static set_p2p_mode pf_set_p2p_mode;
+VOID register_set_p2p_mode_handler(set_p2p_mode handler)
+{
+	WIFI_INFO_FUNC("(pid %d) register set p2p mode handler %p\n", current->pid, handler);
+	pf_set_p2p_mode = handler;
+}
+EXPORT_SYMBOL(register_set_p2p_mode_handler);
+
+/* For dynamical debug level setting */
+/* copy of debug.h in wlan driver */
+#define DBG_CLASS_ERROR         BIT(0)
+#define DBG_CLASS_WARN          BIT(1)
+#define DBG_CLASS_STATE         BIT(2)
+#define DBG_CLASS_EVENT         BIT(3)
+#define DBG_CLASS_TRACE         BIT(4)
+#define DBG_CLASS_INFO          BIT(5)
+#define DBG_CLASS_LOUD          BIT(6)
+#define DBG_CLASS_TEMP          BIT(7)
+#define DBG_CLASS_MASK          BITS(0, 7)
+
+typedef enum _ENUM_DBG_MODULE_T {
+	DBG_INIT_IDX = 0,	/* For driver initial */
+	DBG_HAL_IDX,		/* For HAL(HW) Layer */
+	DBG_INTR_IDX,		/* For Interrupt */
+	DBG_REQ_IDX,
+	DBG_TX_IDX,
+	DBG_RX_IDX,
+	DBG_RFTEST_IDX,		/* For RF test mode */
+	DBG_EMU_IDX,		/* Developer specific */
+
+	DBG_SW1_IDX,		/* Developer specific */
+	DBG_SW2_IDX,		/* Developer specific */
+	DBG_SW3_IDX,		/* Developer specific */
+	DBG_SW4_IDX,		/* Developer specific */
+
+	DBG_HEM_IDX,		/* HEM */
+	DBG_AIS_IDX,		/* AIS */
+	DBG_RLM_IDX,		/* RLM */
+	DBG_MEM_IDX,		/* RLM */
+	DBG_CNM_IDX,		/* CNM */
+	DBG_RSN_IDX,		/* RSN */
+	DBG_BSS_IDX,		/* BSS */
+	DBG_SCN_IDX,		/* SCN */
+	DBG_SAA_IDX,		/* SAA */
+	DBG_AAA_IDX,		/* AAA */
+	DBG_P2P_IDX,		/* P2P */
+	DBG_QM_IDX,		/* QUE_MGT */
+	DBG_SEC_IDX,		/* SEC */
+	DBG_BOW_IDX,		/* BOW */
+	DBG_WAPI_IDX,		/* WAPI */
+	DBG_ROAMING_IDX,	/* ROAMING */
+
+	DBG_MODULE_NUM		/* Notice the XLOG check */
+} ENUM_DBG_MODULE_T;
+/* end */
+typedef VOID(*set_dbg_level) (UINT8 modules[DBG_MODULE_NUM]);
+
+UINT8 wlan_dbg_level[DBG_MODULE_NUM];
+static set_dbg_level pf_set_dbg_level;
+VOID register_set_dbg_level_handler(set_dbg_level handler)
+{
+	pf_set_dbg_level = handler;
+}
+EXPORT_SYMBOL(register_set_dbg_level_handler);
+
+static INT32 WIFI_devs = 1;
+static INT32 WIFI_major = WIFI_DEV_MAJOR;
+module_param(WIFI_major, uint, 0);
+static struct cdev WIFI_cdev;
+volatile INT32 retflag = 0;
+static struct semaphore wr_mtx;
+
+#define WMT_CHECK_DO_CHIP_RESET() \
+do { \
+	if (g_IsNeedDoChipReset) { \
+		g_IsNeedDoChipReset = 0; \
+		WIFI_ERR_FUNC("Do core dump and chip reset in %s line %d\n", __func__, __LINE__); \
+		mtk_wcn_wmt_assert(WMTDRV_TYPE_WIFI, 40); \
+	} \
+} while (0)
+
+/*******************************************************************
+ *  WHOLE CHIP RESET PROCEDURE:
+ *
+ *  WMTRSTMSG_RESET_START callback
+ *  -> wlanRemove
+ *  -> WMTRSTMSG_RESET_END callback
+ *
+ *******************************************************************
+*/
+/*-----------------------------------------------------------------*/
+/*
+ *  Receiving RESET_START message
+ */
+/*-----------------------------------------------------------------*/
+INT32 wifi_reset_start(VOID)
+{
+	struct net_device *netdev = NULL;
+	PARAM_CUSTOM_P2P_SET_STRUCT_T p2pmode;
+
+	down(&wr_mtx);
+
+	if (powered == 1) {
+		netdev = dev_get_by_name(&init_net, ifname);
+		if (netdev == NULL) {
+			WIFI_ERR_FUNC("Fail to get %s net device\n", ifname);
+		} else {
+			p2pmode.u4Enable = 0;
+			p2pmode.u4Mode = 0;
+
+			if (pf_set_p2p_mode) {
+				if (pf_set_p2p_mode(netdev, p2pmode) != 0)
+					WIFI_ERR_FUNC("Turn off p2p/ap mode fail");
+				else
+					WIFI_INFO_FUNC("Turn off p2p/ap mode");
+			}
+			dev_put(netdev);
+			netdev = NULL;
+		}
+	} else {
+		/* WIFI is off before whole chip reset, do nothing */
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(wifi_reset_start);
+
+/*-----------------------------------------------------------------*/
+/*
+ *  Receiving RESET_END/RESET_END_FAIL message
+ */
+/*-----------------------------------------------------------------*/
+INT32 wifi_reset_end(ENUM_RESET_STATUS_T status)
+{
+	struct net_device *netdev = NULL;
+	PARAM_CUSTOM_P2P_SET_STRUCT_T p2pmode;
+	INT32 wait_cnt = 0;
+	INT32 ret = -1;
+
+	if (status == RESET_FAIL) {
+		/* whole chip reset fail, donot recover WIFI */
+		ret = 0;
+		up(&wr_mtx);
+	} else if (status == RESET_SUCCESS) {
+		WIFI_WARN_FUNC("WIFI state recovering...\n");
+
+		if (powered == 1) {
+			/* WIFI is on before whole chip reset, reopen it now */
+			if (MTK_WCN_BOOL_FALSE == mtk_wcn_wmt_func_on(WMTDRV_TYPE_WIFI)) {
+				WIFI_ERR_FUNC("WMT turn on WIFI fail!\n");
+				goto done;
+			} else {
+				WIFI_INFO_FUNC("WMT turn on WIFI success!\n");
+			}
+
+			if (pf_set_p2p_mode == NULL) {
+				WIFI_ERR_FUNC("Set p2p mode handler is NULL\n");
+				goto done;
+			}
+
+			netdev = dev_get_by_name(&init_net, ifname);
+			while (netdev == NULL && wait_cnt < 10) {
+				WIFI_ERR_FUNC("Fail to get %s net device, sleep 300ms\n", ifname);
+				msleep(300);
+				wait_cnt++;
+				netdev = dev_get_by_name(&init_net, ifname);
+			}
+			if (wait_cnt >= 10) {
+				WIFI_ERR_FUNC("Get %s net device timeout\n", ifname);
+				goto done;
+			}
+
+			if (wlan_mode == WLAN_MODE_STA_P2P) {
+				p2pmode.u4Enable = 1;
+				p2pmode.u4Mode = 0;
+				if (pf_set_p2p_mode(netdev, p2pmode) != 0) {
+					WIFI_ERR_FUNC("Set wlan mode fail\n");
+				} else {
+					WIFI_WARN_FUNC("Set wlan mode %d\n", WLAN_MODE_STA_P2P);
+					ret = 0;
+				}
+			} else if (wlan_mode == WLAN_MODE_AP) {
+				p2pmode.u4Enable = 1;
+				p2pmode.u4Mode = 1;
+				if (pf_set_p2p_mode(netdev, p2pmode) != 0) {
+					WIFI_ERR_FUNC("Set wlan mode fail\n");
+				} else {
+					WIFI_WARN_FUNC("Set wlan mode %d\n", WLAN_MODE_AP);
+					ret = 0;
+				}
+			}
+done:
+			if (netdev != NULL)
+				dev_put(netdev);
+		} else {
+			/* WIFI is off before whole chip reset, do nothing */
+			ret = 0;
+		}
+		up(&wr_mtx);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(wifi_reset_end);
+
+static int WIFI_open(struct inode *inode, struct file *file)
+{
+	WIFI_INFO_FUNC("%s: major %d minor %d (pid %d)\n", __func__, imajor(inode), iminor(inode), current->pid);
+
+	return 0;
+}
+
+static int WIFI_close(struct inode *inode, struct file *file)
+{
+	WIFI_INFO_FUNC("%s: major %d minor %d (pid %d)\n", __func__, imajor(inode), iminor(inode), current->pid);
+	retflag = 0;
+
+	return 0;
+}
+
+ssize_t WIFI_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
+{
+	INT32 retval = -EIO;
+	INT8 local[12] = { 0 };
+	struct net_device *netdev = NULL;
+	PARAM_CUSTOM_P2P_SET_STRUCT_T p2pmode;
+	INT32 wait_cnt = 0;
+
+	down(&wr_mtx);
+	if (count <= 0) {
+		WIFI_ERR_FUNC("WIFI_write invalid param\n");
+		goto done;
+	}
+
+	if (0 == copy_from_user(local, buf, (count > sizeof(local)) ? sizeof(local) : count)) {
+		local[11] = 0;
+		WIFI_INFO_FUNC("WIFI_write %s\n", local);
+
+		if (local[0] == '0') {
+			if (powered == 0) {
+				WIFI_INFO_FUNC("WIFI is already power off!\n");
+				retval = count;
+				wlan_mode = WLAN_MODE_HALT;
+				goto done;
+			}
+
+			netdev = dev_get_by_name(&init_net, ifname);
+			if (netdev == NULL) {
+				WIFI_ERR_FUNC("Fail to get %s net device\n", ifname);
+			} else {
+				p2pmode.u4Enable = 0;
+				p2pmode.u4Mode = 0;
+
+				if (pf_set_p2p_mode) {
+					if (pf_set_p2p_mode(netdev, p2pmode) != 0) {
+						WIFI_ERR_FUNC("Turn off p2p/ap mode fail");
+					} else {
+						WIFI_INFO_FUNC("Turn off p2p/ap mode");
+						wlan_mode = WLAN_MODE_HALT;
+					}
+				}
+				dev_put(netdev);
+				netdev = NULL;
+			}
+
+			if (MTK_WCN_BOOL_FALSE == mtk_wcn_wmt_func_off(WMTDRV_TYPE_WIFI)) {
+				WIFI_ERR_FUNC("WMT turn off WIFI fail!\n");
+				WMT_CHECK_DO_CHIP_RESET();
+			} else {
+				WIFI_INFO_FUNC("WMT turn off WIFI OK!\n");
+				powered = 0;
+				retval = count;
+				wlan_mode = WLAN_MODE_HALT;
+#if CFG_TC1_FEATURE
+				ifname = WLAN_IFACE_NAME;
+				wlan_if_changed = 0;
+#endif
+			}
+		} else if (local[0] == '1') {
+			if (powered == 1) {
+				WIFI_INFO_FUNC("WIFI is already power on!\n");
+				retval = count;
+				goto done;
+			}
+
+			if (MTK_WCN_BOOL_FALSE == mtk_wcn_wmt_func_on(WMTDRV_TYPE_WIFI)) {
+				WIFI_ERR_FUNC("WMT turn on WIFI fail!\n");
+				WMT_CHECK_DO_CHIP_RESET();
+			} else {
+				powered = 1;
+				retval = count;
+				WIFI_INFO_FUNC("WMT turn on WIFI success!\n");
+				wlan_mode = WLAN_MODE_HALT;
+			}
+		} else if (local[0] == 'D') {
+			INT32 k = 0;
+			/*
+			 * 0: no debug
+			 * 1: common debug output
+			 * 2: more detials
+			 * 3: verbose
+			 */
+			switch (local[1]) {
+			case '0':
+				for (k = 0; k < DBG_MODULE_NUM; k++)
+					wlan_dbg_level[k] = 0;
+				if (pf_set_dbg_level)
+					pf_set_dbg_level(wlan_dbg_level);
+				break;
+			case '1':
+				for (k = 0; k < DBG_MODULE_NUM; k++) {
+					wlan_dbg_level[k] = DBG_CLASS_ERROR |
+					    DBG_CLASS_WARN |
+					    DBG_CLASS_STATE | DBG_CLASS_EVENT | DBG_CLASS_TRACE | DBG_CLASS_INFO;
+				}
+				wlan_dbg_level[DBG_TX_IDX] &= ~(DBG_CLASS_EVENT | DBG_CLASS_TRACE | DBG_CLASS_INFO);
+				wlan_dbg_level[DBG_RX_IDX] &= ~(DBG_CLASS_EVENT | DBG_CLASS_TRACE | DBG_CLASS_INFO);
+				wlan_dbg_level[DBG_REQ_IDX] &= ~(DBG_CLASS_EVENT | DBG_CLASS_TRACE | DBG_CLASS_INFO);
+				wlan_dbg_level[DBG_INTR_IDX] = 0;
+				wlan_dbg_level[DBG_MEM_IDX] = 0;
+				if (pf_set_dbg_level)
+					pf_set_dbg_level(wlan_dbg_level);
+				break;
+			case '2':
+				for (k = 0; k < DBG_MODULE_NUM; k++) {
+					wlan_dbg_level[k] = DBG_CLASS_ERROR |
+					    DBG_CLASS_WARN |
+					    DBG_CLASS_STATE | DBG_CLASS_EVENT | DBG_CLASS_TRACE | DBG_CLASS_INFO;
+				}
+				wlan_dbg_level[DBG_INTR_IDX] = 0;
+				wlan_dbg_level[DBG_MEM_IDX] = 0;
+				if (pf_set_dbg_level)
+					pf_set_dbg_level(wlan_dbg_level);
+				break;
+			case '3':
+				for (k = 0; k < DBG_MODULE_NUM; k++) {
+					wlan_dbg_level[k] = DBG_CLASS_ERROR |
+					    DBG_CLASS_WARN |
+					    DBG_CLASS_STATE |
+					    DBG_CLASS_EVENT | DBG_CLASS_TRACE | DBG_CLASS_INFO | DBG_CLASS_LOUD;
+				}
+				if (pf_set_dbg_level)
+					pf_set_dbg_level(wlan_dbg_level);
+				break;
+			default:
+				break;
+			}
+		} else if (local[0] == 'S' || local[0] == 'P' || local[0] == 'A') {
+			if (powered == 0) {
+				/* If WIFI is off, turn on WIFI first */
+				if (MTK_WCN_BOOL_FALSE == mtk_wcn_wmt_func_on(WMTDRV_TYPE_WIFI)) {
+					WIFI_ERR_FUNC("WMT turn on WIFI fail!\n");
+					WMT_CHECK_DO_CHIP_RESET();
+					goto done;
+				} else {
+					powered = 1;
+					WIFI_INFO_FUNC("WMT turn on WIFI success!\n");
+					wlan_mode = WLAN_MODE_HALT;
+				}
+			}
+
+			if (pf_set_p2p_mode == NULL) {
+				WIFI_ERR_FUNC("Set p2p mode handler is NULL\n");
+				goto done;
+			}
+
+			netdev = dev_get_by_name(&init_net, ifname);
+			while (netdev == NULL && wait_cnt < 10) {
+				WIFI_ERR_FUNC("Fail to get %s net device, sleep 300ms\n", ifname);
+				msleep(300);
+				wait_cnt++;
+				netdev = dev_get_by_name(&init_net, ifname);
+			}
+			if (wait_cnt >= 10) {
+				WIFI_ERR_FUNC("Get %s net device timeout\n", ifname);
+				goto done;
+			}
+
+			if ((wlan_mode == WLAN_MODE_STA_P2P && (local[0] == 'S' || local[0] == 'P')) ||
+			    (wlan_mode == WLAN_MODE_AP && (local[0] == 'A'))) {
+				WIFI_INFO_FUNC("WIFI is already in mode %d!\n", wlan_mode);
+				retval = count;
+				goto done;
+			}
+
+			if ((wlan_mode == WLAN_MODE_AP && (local[0] == 'S' || local[0] == 'P')) ||
+			    (wlan_mode == WLAN_MODE_STA_P2P && (local[0] == 'A'))) {
+				p2pmode.u4Enable = 0;
+				p2pmode.u4Mode = 0;
+				if (pf_set_p2p_mode(netdev, p2pmode) != 0) {
+					WIFI_ERR_FUNC("Turn off p2p/ap mode fail");
+					goto done;
+				}
+			}
+
+			if (local[0] == 'S' || local[0] == 'P') {
+#if CFG_TC1_FEATURE
+				/* Restore NIC name to wlan0 */
+				rtnl_lock();
+				if (strcmp(ifname, WLAN_IFACE_NAME) != 0) {
+					if (dev_change_name(netdev, WLAN_IFACE_NAME) != 0) {
+						WIFI_ERR_FUNC("netdev name change to %s fail\n", WLAN_IFACE_NAME);
+						rtnl_unlock();
+						goto done;
+					} else {
+						WIFI_INFO_FUNC("netdev name changed %s --> %s\n", ifname,
+							       WLAN_IFACE_NAME);
+						ifname = WLAN_IFACE_NAME;
+						wlan_if_changed = 0;
+					}
+				}
+				rtnl_unlock();
+#endif
+				p2pmode.u4Enable = 1;
+				p2pmode.u4Mode = 0;
+				if (pf_set_p2p_mode(netdev, p2pmode) != 0) {
+					WIFI_ERR_FUNC("Set wlan mode fail\n");
+				} else {
+					WIFI_INFO_FUNC("Set wlan mode %d --> %d\n", wlan_mode, WLAN_MODE_STA_P2P);
+					wlan_mode = WLAN_MODE_STA_P2P;
+					retval = count;
+				}
+			} else if (local[0] == 'A') {
+#if CFG_TC1_FEATURE
+				/* Change NIC name to legacy0, since wlan0 is used for AP */
+				rtnl_lock();
+				if (strcmp(ifname, LEGACY_IFACE_NAME) != 0) {
+					if (dev_change_name(netdev, LEGACY_IFACE_NAME) != 0) {
+						WIFI_ERR_FUNC("netdev name change to %s fail\n", LEGACY_IFACE_NAME);
+						rtnl_unlock();
+						goto done;
+					} else {
+						WIFI_INFO_FUNC("netdev name changed %s --> %s\n", ifname,
+							       LEGACY_IFACE_NAME);
+						ifname = LEGACY_IFACE_NAME;
+						wlan_if_changed = 1;
+					}
+				}
+				rtnl_unlock();
+#endif
+				p2pmode.u4Enable = 1;
+				p2pmode.u4Mode = 1;
+				if (pf_set_p2p_mode(netdev, p2pmode) != 0) {
+					WIFI_ERR_FUNC("Set wlan mode fail\n");
+				} else {
+					WIFI_INFO_FUNC("Set wlan mode %d --> %d\n", wlan_mode, WLAN_MODE_AP);
+					wlan_mode = WLAN_MODE_AP;
+					retval = count;
+				}
+			}
+			dev_put(netdev);
+			netdev = NULL;
+		}
+	}
+done:
+	if (netdev != NULL)
+		dev_put(netdev);
+
+	up(&wr_mtx);
+	return retval;
+}
+
+const struct file_operations WIFI_fops = {
+	.open = WIFI_open,
+	.release = WIFI_close,
+	.write = WIFI_write,
+};
+
+#if WMT_CREATE_NODE_DYNAMIC
+struct class *wmtwifi_class = NULL;
+#endif
+
+static int WIFI_init(void)
+{
+	dev_t dev = MKDEV(WIFI_major, 0);
+	INT32 alloc_ret = 0;
+	INT32 cdev_err = 0;
+#if WMT_CREATE_NODE_DYNAMIC
+	struct device *wmtwifi_dev = NULL;
+#endif
+
+	/* static allocate chrdev */
+	alloc_ret = register_chrdev_region(dev, 1, WIFI_DRIVER_NAME);
+	if (alloc_ret) {
+		WIFI_ERR_FUNC("Fail to register chrdev\n");
+		return alloc_ret;
+	}
+
+	cdev_init(&WIFI_cdev, &WIFI_fops);
+	WIFI_cdev.owner = THIS_MODULE;
+
+	cdev_err = cdev_add(&WIFI_cdev, dev, WIFI_devs);
+	if (cdev_err)
+		goto error;
+
+#if WMT_CREATE_NODE_DYNAMIC	/* mknod replace */
+	wmtwifi_class = class_create(THIS_MODULE, "wmtWifi");
+	if (IS_ERR(wmtwifi_class))
+		goto error;
+	wmtwifi_dev = device_create(wmtwifi_class, NULL, dev, NULL, "wmtWifi");
+	if (wmtwifi_dev == NULL)
+		goto error;
+	if (IS_ERR(wmtwifi_dev))
+		goto error;
+#endif
+
+	sema_init(&wr_mtx, 1);
+
+	WIFI_INFO_FUNC("%s driver(major %d) installed.\n", WIFI_DRIVER_NAME, WIFI_major);
+	retflag = 0;
+	wlan_mode = WLAN_MODE_HALT;
+	pf_set_p2p_mode = NULL;
+
+	return 0;
+
+error:
+#if WMT_CREATE_NODE_DYNAMIC
+	if (!IS_ERR(wmtwifi_dev))
+		device_destroy(wmtwifi_class, dev);
+	if (!IS_ERR(wmtwifi_class)) {
+		class_destroy(wmtwifi_class);
+		wmtwifi_class = NULL;
+	}
+#endif
+
+	if (cdev_err == 0)
+		cdev_del(&WIFI_cdev);
+
+	if (alloc_ret == 0)
+		unregister_chrdev_region(dev, WIFI_devs);
+
+	return -1;
+}
+
+static void WIFI_exit(void)
+{
+	dev_t dev = MKDEV(WIFI_major, 0);
+
+	retflag = 0;
+
+#if WMT_CREATE_NODE_DYNAMIC
+	device_destroy(wmtwifi_class, dev);
+	class_destroy(wmtwifi_class);
+	wmtwifi_class = NULL;
+#endif
+
+	cdev_del(&WIFI_cdev);
+	unregister_chrdev_region(dev, WIFI_devs);
+
+	WIFI_INFO_FUNC("%s driver removed.\n", WIFI_DRIVER_NAME);
+}
+
+#ifdef MTK_WCN_REMOVE_KERNEL_MODULE
+
+INT32 mtk_wcn_wmt_wifi_init(VOID)
+{
+	return WIFI_init();
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_wifi_init);
+
+VOID mtk_wcn_wmt_wifi_exit(VOID)
+{
+	return WIFI_exit();
+}
+EXPORT_SYMBOL(mtk_wcn_wmt_wifi_exit);
+
+#else
+
+module_init(WIFI_init);
+module_exit(WIFI_exit);
+
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/wmt_idc.c b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/wmt_idc.c
new file mode 100644
index 00000000..641e516
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/linux/pub/wmt_idc.c
@@ -0,0 +1,307 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "osal_typedef.h"
+#include "wmt_idc.h"
+#include "wmt_lib.h"
+
+#if CFG_WMT_LTE_COEX_HANDLING
+
+MTK_WCN_WMT_IDC_INFO gWmtIdcInfo;
+
+INT32 wmt_idc_init(VOID)
+{
+	INT32 iRet;
+
+	osal_memset(&gWmtIdcInfo, 0, osal_sizeof(gWmtIdcInfo));
+	gWmtIdcInfo.iit.src_mod_id = AP_MOD_WMT;
+	gWmtIdcInfo.iit.dest_mod_id = MD_MOD_EL1;
+	gWmtIdcInfo.iit.sap_id = 0;
+	gWmtIdcInfo.ops.rx_cb = wmt_idc_msg_from_lte_handing;
+
+	iRet = mtk_conn_md_bridge_reg(gWmtIdcInfo.iit.src_mod_id, &gWmtIdcInfo.ops);
+	if (iRet) {
+		WMT_ERR_FUNC("mtk_conn_md_bridge_reg fail(%d)\n", iRet);
+		return -1;
+	}
+	/* mtk_wcn_stp_flush_rx_queue(COEX_TASK_INDX); */
+	return 0;
+
+}
+
+INT32 wmt_idc_deinit(VOID)
+{
+	INT32 iRet;
+
+	iRet = mtk_conn_md_bridge_unreg(gWmtIdcInfo.iit.src_mod_id);
+	if (iRet)
+		WMT_ERR_FUNC("mtk_conn_md_bridge_unreg fail(%d)\n", iRet);
+
+	osal_memset(&gWmtIdcInfo, 0, osal_sizeof(gWmtIdcInfo));
+
+	return 0;
+}
+
+INT32 wmt_idc_msg_from_lte_handing(ipc_ilm_t *ilm)
+{
+	MTK_WCN_BOOL bRet;
+
+	if (NULL == ilm) {
+		WMT_ERR_FUNC("NULL pointer\n");
+		return -1;
+	}
+	if (mtk_wcn_stp_is_ready()) {
+		bRet = wmt_lib_handle_idc_msg(ilm);
+		if (MTK_WCN_BOOL_FALSE == bRet) {
+			WMT_ERR_FUNC("wmt handing idc msg fail\n");
+			return -2;
+		}
+	} else {
+		WMT_INFO_FUNC("Received LTE msg,but STP is not ready,drop it!\n");
+	}
+	return 0;
+}
+
+VOID wmt_idc_dump_debug_msg(UINT8 *str, UINT8 *p_buf, UINT32 buf_len)
+{
+	UINT32 idx = 0;
+
+	WMT_DBG_FUNC("%s:, length:%d\n", str, buf_len);
+
+	WMT_DBG_FUNC("ASCII output:\n");
+
+	for (idx = 0; idx < buf_len;) {
+		WMT_DBG_FUNC("%c", p_buf[idx]);
+		idx++;
+		if (0 == idx % 16)
+			WMT_DBG_FUNC("\n");
+	}
+
+	WMT_DBG_FUNC("HEX output:\n");
+
+	for (idx = 0; idx < buf_len;) {
+		WMT_DBG_FUNC("%02x ", p_buf[idx]);
+		idx++;
+		if (0 == idx % 16)
+			WMT_DBG_FUNC("\n");
+	}
+}
+
+INT32 wmt_idc_msg_to_lte_handing(VOID)
+{
+	UINT32 readlen = 0;
+	local_para_struct *p_lps = NULL;
+	UINT8 *p_data = NULL;
+	UINT8 opcode = 0;
+	UINT16 msg_len = 0;
+	UINT32 handle_len = 0;
+#if	CFG_WMT_LTE_ENABLE_MSGID_MAPPING
+	MTK_WCN_BOOL unknown_msgid = MTK_WCN_BOOL_FALSE;
+#endif
+	readlen = mtk_wcn_stp_receive_data(&gWmtIdcInfo.buffer[0], LTE_IDC_BUFFER_MAX_SIZE, COEX_TASK_INDX);
+	if (readlen == 0) {
+		osal_sleep_ms(5);
+		readlen = mtk_wcn_stp_receive_data(&gWmtIdcInfo.buffer[0], LTE_IDC_BUFFER_MAX_SIZE, COEX_TASK_INDX);
+	}
+
+	if (readlen > 0) {
+		WMT_DBG_FUNC("read data len from fw(%d)\n", readlen);
+		wmt_idc_dump_debug_msg("WMT->LTE from STP buffer", &gWmtIdcInfo.buffer[0], readlen);
+		p_data = &gWmtIdcInfo.buffer[0];
+
+		while (handle_len < readlen) {
+			p_data += 2;	/*omit direction & opcode 2 bytes */
+			osal_memcpy(&msg_len, p_data, 2);
+			msg_len -= 1;	/*flag byte */
+			WMT_DBG_FUNC("current raw data len(%d) from connsys firmware\n", msg_len);
+
+			p_data += 2;	/*length: 2 bytes */
+
+			/*how to handle flag(msg type) need to Scott comment */
+			/************************************************/
+
+			if (*p_data == WMT_IDC_RX_OPCODE_DEBUG_MONITOR)
+				/*do not need transfer to LTE */
+			{
+				p_data += 1;	/*flag : 1 byte */
+				/*need to handle these debug message */
+				wmt_idc_dump_debug_msg("WIFI DEBUG MONITOR", p_data, msg_len);
+			} else
+				/*need to transfer to LTE */
+			{
+				p_lps =
+				    (local_para_struct *) osal_malloc(osal_sizeof(local_para_struct) +
+								      osal_sizeof(UINT8) * msg_len);
+				if (NULL == p_lps) {
+					WMT_ERR_FUNC("allocate local_para_struct memory fail\n");
+					return -1;
+				}
+
+				p_lps->msg_len = msg_len + osal_sizeof(local_para_struct);
+
+				opcode = *p_data;
+				WMT_DBG_FUNC("current opcode(%d) to LTE\n", opcode);
+
+				p_data += 1;	/*flag : 1 byte */
+				osal_memcpy(p_lps->data, p_data, msg_len);
+
+				gWmtIdcInfo.iit.local_para_ptr = p_lps;
+
+#if	CFG_WMT_LTE_ENABLE_MSGID_MAPPING
+				switch (opcode) {
+				case WMT_IDC_RX_OPCODE_BTWF_DEF_PARA:
+					gWmtIdcInfo.iit.msg_id = IPC_MSG_ID_EL1_WIFIBT_OPER_DEFAULT_PARAM_IND;
+					break;
+				case WMT_IDC_RX_OPCODE_BTWF_CHAN_RAN:
+					gWmtIdcInfo.iit.msg_id = IPC_MSG_ID_EL1_WIFIBT_OPER_FREQ_IND;
+					break;
+				case WMT_IDC_RX_OPCODE_LTE_FREQ_IDX_TABLE:
+					gWmtIdcInfo.iit.msg_id = IPC_MSG_ID_EL1_WIFIBT_FREQ_IDX_TABLE_IND;
+					break;
+				case WMT_IDC_RX_OPCODE_BTWF_PROFILE_IND:
+					gWmtIdcInfo.iit.msg_id = IPC_MSG_ID_EL1_WIFIBT_PROFILE_IND;
+					break;
+				case WMT_IDC_RX_OPCODE_UART_PIN_SEL:
+					gWmtIdcInfo.iit.msg_id = IPC_MSG_ID_EL1_PIN_TYPE_IND;
+					break;
+					/* case WMT_IDC_RX_OPCODE_TDM_REQ: */
+					/* gWmtIdcInfo.iit.msg_id = IPC_MSG_ID_EL1_WIFIBT_OPER_FREQ_IND; */
+					/* break; */
+				default:
+					unknown_msgid = MTK_WCN_BOOL_TRUE;
+					WMT_ERR_FUNC("unknown opcode(%d) from connsys firmware\n", opcode);
+					break;
+				}
+				if (MTK_WCN_BOOL_FALSE == unknown_msgid) {
+					/*handling flag value in wmt cmd */
+					mtk_conn_md_bridge_send_msg(&gWmtIdcInfo.iit);
+				}
+#else
+				if (opcode >= LTE_MSG_ID_OFFSET) {
+					gWmtIdcInfo.iit.msg_id = opcode + IPC_EL1_MSG_ID_BEGIN - LTE_MSG_ID_OFFSET + 1;
+					/*handling flag value in wmt cmd */
+					mtk_conn_md_bridge_send_msg(&gWmtIdcInfo.iit);
+					WMT_DBG_FUNC("CONN->LTE: (0x%x->0x%x)\n", opcode, gWmtIdcInfo.iit.msg_id);
+				} else {
+					WMT_ERR_FUNC("opcode(%d)from connsys fw is out of range,drop it!\n", opcode);
+				}
+#endif
+				osal_free(p_lps);
+			}
+
+			p_data += msg_len;	/*point to next package header */
+
+			handle_len += (msg_len + 5);
+		}
+
+	} else {
+		WMT_ERR_FUNC("there is no coex data in stp buffer\n");
+	}
+
+	osal_memset(&gWmtIdcInfo.buffer[0], 0, LTE_IDC_BUFFER_MAX_SIZE);
+
+	return 0;
+}
+
+UINT32 wmt_idc_msg_to_lte_handing_for_test(UINT8 *p_buf, UINT32 len)
+{
+	UINT32 readlen = len;
+	local_para_struct *p_lps = NULL;
+	UINT8 *p_data = NULL;
+	UINT8 opcode = 0;
+	UINT16 msg_len = 0;
+	UINT32 handle_len = 0;
+	MTK_WCN_BOOL unknown_msgid = MTK_WCN_BOOL_FALSE;
+
+	osal_memcpy(&gWmtIdcInfo.buffer[0], p_buf, len);
+
+	if (readlen > 0) {
+		WMT_DBG_FUNC("read data len from fw(%d)\n", readlen);
+		p_data = &gWmtIdcInfo.buffer[0];
+
+		while (handle_len < readlen) {
+			p_data += 2;	/*omit direction & opcode 2 bytes */
+			osal_memcpy(&msg_len, p_data, 2);
+			msg_len -= 1;	/*flag byte */
+			WMT_DBG_FUNC("current raw data len(%d) from connsys firmware\n", msg_len);
+
+			p_data += 2;	/*length: 2 bytes */
+
+			/*how to handle flag(msg type) need to Scott comment */
+			/************************************************/
+
+			if (*p_data == WMT_IDC_RX_OPCODE_DEBUG_MONITOR)
+				/*do not need transfer to LTE */
+			{
+				p_data += 1;	/*flag : 1 byte */
+				/*need to handle these debug message */
+				wmt_idc_dump_debug_msg("WIFI DEBUG MONITOR", p_data, msg_len);
+			} else
+				/*need to transfer to LTE */
+			{
+				p_lps =
+				    (local_para_struct *) osal_malloc(osal_sizeof(local_para_struct) +
+								      osal_sizeof(UINT8) * msg_len);
+				if (NULL == p_lps) {
+					WMT_ERR_FUNC("allocate local_para_struct memory fail\n");
+					return -1;
+				}
+
+				p_lps->msg_len = msg_len + osal_sizeof(local_para_struct);
+
+				opcode = *p_data;
+				WMT_DBG_FUNC("current opcode(%d) to LTE\n", opcode);
+
+				p_data += 1;	/*flag : 1 byte */
+				osal_memcpy(p_lps->data, p_data, msg_len);
+
+				gWmtIdcInfo.iit.local_para_ptr = p_lps;
+
+				switch (opcode) {
+				case WMT_IDC_RX_OPCODE_BTWF_DEF_PARA:
+					gWmtIdcInfo.iit.msg_id = IPC_MSG_ID_EL1_WIFIBT_OPER_DEFAULT_PARAM_IND;
+					break;
+				case WMT_IDC_RX_OPCODE_BTWF_CHAN_RAN:
+					gWmtIdcInfo.iit.msg_id = IPC_MSG_ID_EL1_WIFIBT_OPER_FREQ_IND;
+					break;
+					/* case WMT_IDC_RX_OPCODE_TDM_REQ: */
+					/* gWmtIdcInfo.iit.msg_id = IPC_MSG_ID_EL1_WIFIBT_OPER_FREQ_IND; */
+					/* break; */
+				default:
+					unknown_msgid = MTK_WCN_BOOL_TRUE;
+					WMT_ERR_FUNC("unknown opcode(%d) from connsys firmware\n", opcode);
+					break;
+				}
+				if (MTK_WCN_BOOL_FALSE == unknown_msgid) {
+					/*handling flag value in wmt cmd */
+					mtk_conn_md_bridge_send_msg(&gWmtIdcInfo.iit);
+				}
+				osal_free(p_lps);
+			}
+
+			p_data += msg_len;	/*point to next package header */
+
+			handle_len += (msg_len + 5);
+		}
+
+	} else {
+		WMT_ERR_FUNC("there is no coex data in stp buffer\n");
+	}
+
+	osal_memset(&gWmtIdcInfo.buffer[0], 0, LTE_IDC_BUFFER_MAX_SIZE);
+
+	return handle_len;
+}
+
+#endif
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/mt7623/Makefile b/drivers/misc/mediatek/connectivity/common/conn_soc/mt7623/Makefile
new file mode 100644
index 00000000..18ae0d1
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/mt7623/Makefile
@@ -0,0 +1,25 @@
+# WMT HAL driver for MT7623
+
+ccflags-y += \
+	-I$(srctree)/$(src)/include \
+	-I$(srctree)/$(src)/../linux/include \
+	-I$(srctree)/$(src)/../include \
+	-I$(srctree)/$(src)/../../common_detect
+
+  ifeq ($(CONFIG_MTK_CLKMGR),y)
+	ccflags-y +=	-I$(srctree)/drivers/misc/mediatek/include/mt-plat/$(MTK_PLATFORM)/include/mach
+	endif
+  #ifeq ($(CONFIG_MTK_EMI_MPU),y)
+	ccflags-y +=	-I$(srctree)/drivers/misc/mediatek/include/mt-plat/$(MTK_PLATFORM)/include/mach
+	#endif
+
+subdir-ccflags-y += -D MTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+
+ifeq ($(CONFIG_MTK_CONN_LTE_IDC_SUPPORT),y)
+	subdir-ccflags-y += -DWMT_IDC_SUPPORT=1
+else
+	subdir-ccflags-y += -DWMT_IDC_SUPPORT=0
+endif
+
+obj-y += mtk_wcn_consys_hw.o
+obj-y += wmt_plat_alps.o
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/mt7623/include/mtk_wcn_consys_hw.h b/drivers/misc/mediatek/connectivity/common/conn_soc/mt7623/include/mtk_wcn_consys_hw.h
new file mode 100644
index 00000000..94d6af9
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/mt7623/include/mtk_wcn_consys_hw.h
@@ -0,0 +1,287 @@
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _MTK_WCN_CONSYS_HW_H_
+#define _MTK_WCN_CONSYS_HW_H_
+
+#include <sync_write.h>
+/*#include <mt_reg_base.h>*/
+#include "wmt_plat.h"
+
+/*device tree mode*/
+#ifdef CONFIG_OF
+/* #if 1 */
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/irqreturn.h>
+#include <linux/of_address.h>
+#endif
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+#define CONSYS_BT_WIFI_SHARE_V33        0
+#define CONSYS_PMIC_CTRL_ENABLE         1
+#define CONSYS_PMIC_CTRL_UPMU           1
+#define CONSYS_EMI_MPU_SETTING          0
+#define CONSYS_AHB_CLK_MAGEMENT         1
+#define CONSYS_USE_PLATFORM_WRITE       1
+#define CONSYS_PWR_ON_OFF_API_AVAILABLE 1
+#define CONSYS_CLOCK_BUF_CTRL           0
+#if defined(CONFIG_MTK_LEGACY)
+#define CONFIG_MTK_PMIC_LEGACY          0
+#endif
+#define CONFIG_RESET_CONTROL            1
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+/*tag start:new platform need to make sure these define */
+#define PLATFORM_SOC_CHIP 0x7623
+/*tag end*/
+
+#ifdef CONFIG_OF
+
+struct CONSYS_BASE_ADDRESS {
+	SIZE_T mcu_base;
+	SIZE_T ap_rgu_base;
+	SIZE_T topckgen_base;
+	SIZE_T spm_base;
+};
+
+/*TOPCKGEN_BASE*/
+#define CONSYS_TOP_CLKCG_CLR_OFFSET	0x00000084
+#define CONSYS_TOP_CLKCG_SET_OFFSET	0x00000054
+#define CONSYS_WD_SYS_RST_OFFSET		0x00000018
+#define CONSYS_AP2CONN_OSC_EN_OFFSET	0x00000800
+#define CONSYS_EMI_MAPPING_OFFSET		0x00000310
+/*AP_RGU_BASE*/
+#define CONSYS_CPU_SW_RST_OFFSET		0x00000018
+/*SPM_BASE*/
+#define CONSYS_PWRON_CONFG_EN_OFFSET	0x00000000
+#define CONSYS_TOP1_PWR_CTRL_OFFSET	0x00000280
+#define CONSYS_PWR_CONN_ACK_OFFSET		0x0000060c
+#define CONSYS_PWR_CONN_ACK_S_OFFSET	0x00000610
+/*CONN_MCU_CONFIG_BASE*/
+#define CONSYS_CHIP_ID_OFFSET			0x00000008
+#define CONSYS_ROM_RAM_DELSEL_OFFSET	0x00000114
+#define CONSYS_MCU_CFG_ACR_OFFSET		0x00000110
+#define CONSYS_CPUPCR_OFFSET			0x00000160
+/*AXI bus*/
+
+#define CONSYS_TOPAXI_PROT_EN_OFFSET    0x1220
+#define CONSYS_TOPAXI_PROT_STA1_OFFSET  0x0228
+#endif
+
+#define CONSYS_SET_BIT(REG, BITVAL) (*((volatile UINT32*)(REG)) |= ((UINT32)(BITVAL)))
+#define CONSYS_CLR_BIT(REG, BITVAL)       ((*(volatile UINT32*)(REG)) &= ~((UINT32)(BITVAL)))
+#define CONSYS_CLR_BIT_WITH_KEY(REG, BITVAL, KEY) {\
+	UINT32 val = (*(volatile UINT32*)(REG)); \
+	val &= ~((UINT32)(BITVAL)); \
+	val |= ((UINT32)(KEY)); \
+	(*(volatile UINT32*)(REG)) = val;\
+}
+#define CONSYS_REG_READ(addr) (*((volatile UINT32*)(addr)))
+#if CONSYS_USE_PLATFORM_WRITE
+#define CONSYS_REG_WRITE(addr, data)  mt_reg_sync_writel(data, addr)
+#else
+#define CONSYS_REG_WRITE(addr, data)  (*((volatile UINT32*)(addr)) = (UINT32)(data))
+#endif
+
+/*tag start: connsys register base address (hard code, no use) */
+#define AP_RGU_BASE			0xF0007000
+#define TOPCKGEN_BASE			0xF0000000
+#define SPM_BASE				0xF0006000
+#define CONN_MCU_CONFIG_BASE	0xF8070000
+/*GIC Interrupt ID*/
+#define MT_CONN2AP_BTIF_WAKEUP_IRQ_ID 237
+/*tag end*/
+
+/*connsys register offset define(hard code mode)*/
+#if 1
+	/*top clock gating control register */
+#define CONSYS_TOP_CLKCG_CLR_REG		(TOPCKGEN_BASE + 0x00000084)
+#define CONSYS_TOP_CLKCG_SET_REG		(TOPCKGEN_BASE + 0x00000054)
+#define CONSYS_TOP_CLKCG_BIT			(0x1 << 26)
+
+	/*SPM clock gating control register */
+#define CONSYS_PWRON_CONFG_EN_REG		(SPM_BASE + 0x00000000)
+#define CONSYS_PWRON_CONFG_EN_VALUE	(0x0b160001)
+#define CONSYS_PWRON_CONFG_DIS_VALUE	(0x0b160000)
+#endif
+
+#define CONSYS_CPU_SW_RST_REG				(AP_RGU_BASE + 0x00000018)
+#define CONSYS_TOP1_PWR_CTRL_REG			(SPM_BASE + 0x00000280)
+#define CONSYS_PWR_CONN_ACK_REG			(SPM_BASE + 0x0000060c)
+#define CONSYS_PWR_CONN_ACK_S_REG			(SPM_BASE + 0x00000610)
+
+#define CONSYS_WD_SYS_RST_REG				(TOPCKGEN_BASE + 0x00000018)
+#define CONSYS_CHIP_ID_REG					(CONN_MCU_CONFIG_BASE + 0x00000008)
+#define CONSYS_ROM_RAM_DELSEL_REG			(CONN_MCU_CONFIG_BASE + 0x00000114)
+#define CONSYS_MCU_CFG_ACR_REG				(CONN_MCU_CONFIG_BASE + 0x00000110)
+#define CONSYS_AFE_REG						(CONN_TOP_CR_BASE + 0x00002000)
+#define CONSYS_AFE_REG_DIG_RCK_01			(CONSYS_AFE_REG + 0x00000010)
+#define CONSYS_AFE_REG_WBG_PLL_02			(CONSYS_AFE_REG + 0x00000028)
+#define CONSYS_AFE_REG_WBG_WB_TX_01			(CONSYS_AFE_REG + 0x0000003c)
+#define CONSYS_AFE_REG_DIG_RCK_01_VALUE	(0x174b0160)
+#define CONSYS_AFE_REG_WBG_PLL_02_VALUE		(0x844083fe)
+#define CONSYS_AFE_REG_WBG_WB_TX_01_VALUE	(0x7fc39a20)
+
+#define CONSYS_TOPAXI_PROT_EN				(TOPCKGEN_BASE + 0x0220)
+#define CONSYS_TOPAXI_PROT_STA1				(TOPCKGEN_BASE + 0x0228)
+#define CONSYS_PROT_MASK				((0x1<<13) | (0x1<<14) | (0x1<<15))	/* bit 13, 14, 15 */
+/*CONSYS_CPU_SW_RST_REG*/
+#define CONSYS_CPU_SW_RST_BIT				(0x1 << 12)
+#define CONSYS_CPU_SW_RST_CTRL_KEY			(0x88 << 24)
+
+/*CONSYS_TOP1_PWR_CTRL_REG*/
+#define CONSYS_SPM_PWR_RST_BIT				(0x1 << 0)
+#define CONSYS_SPM_PWR_ISO_S_BIT			(0x1 << 1)
+#define CONSYS_SPM_PWR_ON_BIT				(0x1 << 2)
+#define CONSYS_SPM_PWR_ON_S_BIT			(0x1 << 3)
+#define CONSYS_CLK_CTRL_BIT				(0x1 << 4)
+#define CONSYS_SRAM_CONN_PD_BIT			(0x1 << 8)
+
+/*CONSYS_PWR_CONN_ACK_REG*/
+#define CONSYS_PWR_ON_ACK_BIT				(0x1 << 1)
+
+/*CONSYS_PWR_CONN_ACK_S_REG*/
+#define CONSYS_PWR_CONN_ACK_S_BIT			(0x1 << 1)
+
+/*CONSYS_WD_SYS_RST_REG*/
+#define CONSYS_WD_SYS_RST_CTRL_KEY			(0x88 << 24)
+#define CONSYS_WD_SYS_RST_BIT				(0x1 << 9)
+
+/*CONSYS_MCU_CFG_ACR_REG*/
+#define CONSYS_MCU_CFG_ACR_MBIST_BIT		(0x1 << 18)
+
+/* EMI part mapping & ctrl*/
+#define KBYTE								(1024*sizeof(char))
+#define CONSYS_EMI_AP_PHY_OFFSET			(0x80000)
+#define CONSYS_EMI_AP_PHY_BASE				(0x80080000)
+#define CONSYS_EMI_FW_PHY_BASE				(0xf0080000)
+#define CONSYS_EMI_MEM_SIZE					(343*KBYTE)	/*coredump space , 343K is enough */
+#define CONSYS_EMI_PAGED_TRACE_OFFSET		(0x400)
+#define CONSYS_EMI_PAGED_DUMP_OFFSET		(0x8400)
+#define CONSYS_EMI_FULL_DUMP_OFFSET			(0x10400)
+
+/*cpupcr*/
+#define CONSYS_CPUPCR_REG					(CONN_MCU_CONFIG_BASE + 0x00000160)
+/*emi mapping*/
+#define CONSYS_EMI_MAPPING					(TOPCKGEN_BASE + 0x1310)
+
+/*control app2cnn_osc_en*/
+#define CONSYS_AP2CONN_OSC_EN_REG			(TOPCKGEN_BASE + 0x00001800)
+#define CONSYS_AP2CONN_OSC_EN_BIT			(0x1 << 16)
+#define CONSYS_AP2CONN_WAKEUP_BIT			(0x1 << 17)
+
+/*paged dump address start*/
+#define CONSYS_PAGED_DUMP_START_ADDR		(0xf0088400)
+#define CONSYS_PAGED_DUMP_SIZE				(32*KBYTE)
+
+/*full dump address start*/
+#define CONSYS_FULL_DUMP_START_ADDR			(0xf0090400)
+#define CONSYS_FULL_DUMP_DLM_LEN			(0x1f000)
+#define CONSYS_FULL_DUMP_SYSB2_START		(CONSYS_FULL_DUMP_START_ADDR + CONSYS_FULL_DUMP_DLM_LEN)
+#define CONSYS_FULL_DUMP_SYSB2_LEN			(0x6800)
+#define CONSYS_FULL_DUMP_SYSB3_START		(CONSYS_FULL_DUMP_SYSB2_START + CONSYS_FULL_DUMP_SYSB2_LEN)
+#define CONSYS_FULL_DUMP_SYSB3_LEN			(0x16800)
+
+/*force fw assert pattern*/
+#define EXP_APMEM_HOST_OUTBAND_ASSERT_MAGIC_W1   (0x19b30bb1)
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+typedef enum _ENUM_EMI_CTRL_STATE_OFFSET_ {
+	EXP_APMEM_CTRL_STATE = 0x0,
+	EXP_APMEM_CTRL_HOST_SYNC_STATE = 0x4,
+	EXP_APMEM_CTRL_HOST_SYNC_NUM = 0x8,
+	EXP_APMEM_CTRL_CHIP_SYNC_STATE = 0xc,
+	EXP_APMEM_CTRL_CHIP_SYNC_NUM = 0x10,
+	EXP_APMEM_CTRL_CHIP_SYNC_ADDR = 0x14,
+	EXP_APMEM_CTRL_CHIP_SYNC_LEN = 0x18,
+	EXP_APMEM_CTRL_CHIP_PRINT_BUFF_START = 0x1c,
+	EXP_APMEM_CTRL_CHIP_PRINT_BUFF_LEN = 0x20,
+	EXP_APMEM_CTRL_CHIP_PRINT_BUFF_IDX = 0x24,
+	EXP_APMEM_CTRL_CHIP_INT_STATUS = 0x28,
+	EXP_APMEM_CTRL_CHIP_PAGED_DUMP_END = 0x2c,
+	EXP_APMEM_CTRL_HOST_OUTBAND_ASSERT_W1 = 0x30,
+	EXP_APMEM_CTRL_CHIP_DYNAMIC_DUMP = 0x48,
+	EXP_APMEM_CTRL_MAX
+} ENUM_EMI_CTRL_STATE_OFFSET, *P_ENUM_EMI_CTRL_STATE_OFFSET;
+
+#if CONSYS_BT_WIFI_SHARE_V33
+typedef struct _BT_WIFI_V33_STATUS_ {
+	UINT32 counter;
+	UINT32 flags;
+	spinlock_t lock;
+} BT_WIFI_V33_STATUS;
+
+#endif
+
+typedef enum _CONSYS_GPS_CO_CLOCK_TYPE_ {
+	GPS_TCXO_TYPE = 0,
+	GPS_CO_TSX_TYPE = 1,
+	GPS_CO_DCXO_TYPE = 2,
+	GPS_CO_VCTCXO_TYPE = 3,
+	GPS_CO_CLOCK_TYPE_MAX
+} CONSYS_GPS_CO_CLOCK_TYPE, *P_CONSYS_GPS_CO_CLOCK_TYPE;
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+extern struct CONSYS_BASE_ADDRESS conn_reg;
+#if CONSYS_BT_WIFI_SHARE_V33
+extern BT_WIFI_V33_STATUS gBtWifiV33;
+#endif
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+extern INT32 mtk_wcn_consys_hw_init(VOID);
+extern INT32 mtk_wcn_consys_hw_deinit(VOID);
+extern INT32 mtk_wcn_consys_hw_pwr_off(VOID);
+extern INT32 mtk_wcn_consys_hw_pwr_on(UINT32 co_clock_type);
+extern INT32 mtk_wcn_consys_hw_rst(UINT32 co_clock_type);
+extern INT32 mtk_wcn_consys_hw_bt_paldo_ctrl(UINT32 enable);
+extern INT32 mtk_wcn_consys_hw_wifi_paldo_ctrl(UINT32 enable);
+extern INT32 mtk_wcn_consys_hw_vcn28_ctrl(UINT32 enable);
+extern INT32 mtk_wcn_consys_hw_state_show(VOID);
+extern UINT8 *mtk_wcn_consys_emi_virt_addr_get(UINT32 ctrl_state_offset);
+#if CONSYS_ENALBE_SET_JTAG
+extern UINT32 mtk_wcn_consys_jtag_flag_ctrl(UINT32 en);
+#endif
+extern UINT32 mtk_wcn_consys_soc_chipid(VOID);
+#if !defined(CONFIG_MTK_GPIO_LEGACY)
+extern struct pinctrl *mtk_wcn_consys_get_pinctrl(VOID);
+#endif
+extern INT32 mtk_wcn_consys_set_dynamic_dump(PUINT32 buf);
+#endif /* _MTK_WCN_CMB_HW_H_ */
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/mt7623/mtk_wcn_consys_hw.c b/drivers/misc/mediatek/connectivity/common/conn_soc/mt7623/mtk_wcn_consys_hw.c
new file mode 100644
index 00000000..0869301
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/mt7623/mtk_wcn_consys_hw.c
@@ -0,0 +1,730 @@
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG "[WMT-CONSYS-HW]"
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/memblock.h>
+#include "osal_typedef.h"
+#include "mtk_wcn_consys_hw.h"
+#include <linux/mfd/mt6323/registers.h>
+#include <soc/mediatek/pmic_wrap.h>
+#include <linux/regmap.h>
+#if CONSYS_EMI_MPU_SETTING
+#include <emi_mpu.h>
+#endif
+
+#include <linux/regulator/consumer.h>
+#include <linux/pinctrl/consumer.h>
+#ifdef CONFIG_MTK_HIBERNATION
+#include <mtk_hibernate_dpm.h>
+#endif
+
+#include <linux/of_reserved_mem.h>
+
+#if CONSYS_CLOCK_BUF_CTRL
+#include <mt_clkbuf_ctl.h>
+#endif
+
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+static INT32 mtk_wmt_probe(struct platform_device *pdev);
+static INT32 mtk_wmt_remove(struct platform_device *pdev);
+
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+struct CONSYS_BASE_ADDRESS conn_reg;
+static phys_addr_t gConEmiPhyBase;
+static UINT8 __iomem *pEmibaseaddr;
+static struct clk *clk_infra_conn_main;	/*ctrl infra_connmcu_bus clk */
+static struct platform_device *my_pdev;
+static struct reset_control *rstc;
+static struct regulator *reg_VCN18;
+static struct regulator *reg_VCN28;
+static struct regulator *reg_VCN33_BT;
+static struct regulator *reg_VCN33_WIFI;
+static struct pinctrl *consys_pinctrl;
+static struct pinctrl *mt6625_spi_pinctrl;
+static struct pinctrl_state *mt6625_spi_default;
+static struct regmap *pmic_regmap;
+#define DYNAMIC_DUMP_GROUP_NUM 5
+
+static const struct of_device_id apwmt_of_ids[] = {
+	{.compatible = "mediatek,mt7623-consys"},
+	{}
+};
+MODULE_DEVICE_TABLE(of, apwmt_of_ids);
+
+static struct platform_driver mtk_wmt_dev_drv = {
+	.probe = mtk_wmt_probe,
+	.remove = mtk_wmt_remove,
+	.driver = {
+		   .name = "mt7623consys",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(apwmt_of_ids),
+		   },
+};
+
+static INT32 mtk_wmt_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct device_node *node = NULL;
+
+	pm_runtime_enable(&pdev->dev);
+	my_pdev = pdev;
+	mt6625_spi_pinctrl  = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR(mt6625_spi_pinctrl)) {
+		ret = PTR_ERR(mt6625_spi_pinctrl);
+		WMT_PLAT_ERR_FUNC("Wmt cannot find pinctrl!\n");
+		goto set_pin_exit;
+	}
+	mt6625_spi_default = pinctrl_lookup_state(mt6625_spi_pinctrl, "default");
+	if (IS_ERR(mt6625_spi_default)) {
+		ret = PTR_ERR(mt6625_spi_default);
+		WMT_PLAT_ERR_FUNC("Wmt Cannot find pinctrl default!\n");
+		goto set_pin_exit;
+	}
+	pinctrl_select_state(mt6625_spi_pinctrl, mt6625_spi_default);
+set_pin_exit:
+
+	node = of_parse_phandle(pdev->dev.of_node, "mediatek,pwrap-regmap", 0);
+	if (node) {
+		pmic_regmap = pwrap_node_to_regmap(node);
+		if (IS_ERR(pmic_regmap))
+			goto set_pmic_wrap_exit;
+	} else {
+		WMT_PLAT_ERR_FUNC("Pwrap node has not register regmap.\n");
+		goto set_pmic_wrap_exit;
+	}
+set_pmic_wrap_exit:
+
+	clk_infra_conn_main = devm_clk_get(&pdev->dev, "consysbus");
+	if (IS_ERR(clk_infra_conn_main)) {
+		WMT_PLAT_ERR_FUNC("sean debug [CCF]cannot get clk_infra_conn_main clock.\n");
+		return PTR_ERR(clk_infra_conn_main);
+	}
+	WMT_PLAT_DBG_FUNC("[CCF]clk_infra_conn_main=%p\n", clk_infra_conn_main);
+
+	reg_VCN18 = devm_regulator_get(&pdev->dev, "vcn18");
+	if (IS_ERR(reg_VCN18)) {
+		ret = PTR_ERR(reg_VCN18);
+		WMT_PLAT_ERR_FUNC("Regulator_get VCN_1V8 fail, ret=%d\n", ret);
+	}
+	reg_VCN28 = devm_regulator_get(&pdev->dev, "vcn28");
+	if (IS_ERR(reg_VCN28)) {
+		ret = PTR_ERR(reg_VCN28);
+		WMT_PLAT_ERR_FUNC("Regulator_get VCN_2V8 fail, ret=%d\n", ret);
+	}
+	reg_VCN33_BT = devm_regulator_get(&pdev->dev, "vcn33_bt");
+	if (IS_ERR(reg_VCN33_BT)) {
+		ret = PTR_ERR(reg_VCN33_BT);
+		WMT_PLAT_ERR_FUNC("Regulator_get VCN33_BT fail, ret=%d\n", ret);
+	}
+	reg_VCN33_WIFI = devm_regulator_get(&pdev->dev, "vcn33_wifi");
+	if (IS_ERR(reg_VCN33_WIFI)) {
+		ret = PTR_ERR(reg_VCN33_WIFI);
+		WMT_PLAT_ERR_FUNC("Regulator_get VCN33_WIFI fail, ret=%d\n", ret);
+	}
+
+	rstc = devm_reset_control_get(&pdev->dev, "connsys");
+	if (IS_ERR(rstc)) {
+		ret = PTR_ERR(rstc);
+		WMT_PLAT_ERR_FUNC("CanNot get consys reset. ret=%d\n", ret);
+		return PTR_ERR(rstc);
+	}
+
+	consys_pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR(consys_pinctrl)) {
+		ret = PTR_ERR(consys_pinctrl);
+		WMT_PLAT_ERR_FUNC("CanNot find consys pinctrl. ret=%d\n", ret);
+		return PTR_ERR(consys_pinctrl);
+	}
+	return 0;
+}
+
+static INT32 mtk_wmt_remove(struct platform_device *pdev)
+{
+	pm_runtime_disable(&pdev->dev);
+
+	return 0;
+}
+
+VOID mtk_wcn_consys_power_on(VOID)
+{
+	INT32 iRet = -1;
+	iRet = pm_runtime_get_sync(&my_pdev->dev);
+	if (iRet)
+		WMT_PLAT_ERR_FUNC("pm_runtime_get_sync() fail(%d)\n", iRet);
+	else
+		WMT_PLAT_INFO_FUNC("pm_runtime_get_sync() CONSYS ok\n");
+
+	iRet = device_init_wakeup(&my_pdev->dev, true);
+	if (iRet)
+		WMT_PLAT_ERR_FUNC("device_init_wakeup(true) fail.\n");
+	else
+		WMT_PLAT_INFO_FUNC("device_init_wakeup(true) CONSYS ok\n");
+}
+
+VOID mtk_wcn_consys_power_off(VOID)
+{
+	INT32 iRet = -1;
+
+	iRet = pm_runtime_put_sync(&my_pdev->dev);
+	if (iRet)
+		WMT_PLAT_ERR_FUNC("pm_runtime_put_sync() fail.\n");
+	else
+		WMT_PLAT_INFO_FUNC("pm_runtime_put_sync() CONSYS ok\n");
+
+	iRet = device_init_wakeup(&my_pdev->dev, false);
+	if (iRet)
+		WMT_PLAT_ERR_FUNC("device_init_wakeup(false) fail.\n");
+	else
+		WMT_PLAT_INFO_FUNC("device_init_wakeup(false) CONSYS ok\n");
+}
+
+INT32 mtk_wcn_consys_hw_reg_ctrl(UINT32 on, UINT32 co_clock_type)
+{
+	UINT32 retry = 10;
+	UINT32 consysHwChipId = 0;
+
+	WMT_PLAT_DBG_FUNC("CONSYS-HW-REG-CTRL(0x%08x),start\n", on);
+	if (on) {
+		WMT_PLAT_DBG_FUNC("++\n");
+		/*need PMIC driver provide new API protocol */
+		/*1.AP power on VCN_1V8 LDO (with PMIC_WRAP API) VCN_1V8  */
+		regulator_set_mode(reg_VCN18, REGULATOR_MODE_STANDBY);
+		/* VOL_DEFAULT, VOL_1200, VOL_1300, VOL_1500, VOL_1800... */
+		if (reg_VCN18) {
+			regulator_set_voltage(reg_VCN18, 1800000, 1800000);
+			if (regulator_enable(reg_VCN18))
+				WMT_PLAT_ERR_FUNC("enable VCN18 fail\n");
+			else
+				WMT_PLAT_DBG_FUNC("enable VCN18 ok\n");
+		}
+		udelay(150);
+		if (co_clock_type) {
+			/*step0,clk buf ctrl */
+			WMT_PLAT_INFO_FUNC("co clock type(%d),turn on clk buf\n", co_clock_type);
+#if CONSYS_CLOCK_BUF_CTRL
+			clk_buf_ctrl(CLK_BUF_CONN, 1);
+#endif
+			/*if co-clock mode: */
+			/*2.set VCN28 to SW control mode (with PMIC_WRAP API) */
+			/*turn on VCN28 LDO only when FMSYS is activated"  */
+			regmap_update_bits(pmic_regmap, 0x41C, 0x1 << 14, 0x0 << 14);/*V28*/
+		} else {
+			/*if NOT co-clock: */
+			/*2.1.switch VCN28 to HW control mode (with PMIC_WRAP API) */
+			regmap_update_bits(pmic_regmap, 0x41C, 0x1 << 14, 0x1 << 14);/*V28*/
+			/*2.2.turn on VCN28 LDO (with PMIC_WRAP API)" */
+			/*fix vcn28 not balance warning */
+			if (reg_VCN28) {
+				regulator_set_voltage(reg_VCN28, 2800000, 2800000);
+				if (regulator_enable(reg_VCN28))
+					WMT_PLAT_ERR_FUNC("enable VCN_2V8 fail!\n");
+				else
+					WMT_PLAT_DBG_FUNC("enable VCN_2V8 ok\n");
+			}
+		}
+
+		/*3.assert CONNSYS CPU SW reset  0x10007018 "[12]=1'b1  [31:24]=8'h88 (key)" */
+		reset_control_reset(rstc);
+		mtk_wcn_consys_power_on();
+		/*11.26M is ready now, delay 10us for mem_pd de-assert */
+		udelay(10);
+		/*enable AP bus clock : connmcu_bus_pd  API: enable_clock() ++?? */
+		clk_prepare_enable(clk_infra_conn_main);
+		WMT_PLAT_DBG_FUNC("[CCF]enable clk_infra_conn_main\n");
+		/*12.poll CONNSYS CHIP ID until chipid is returned  0x18070008 */
+		while (retry-- > 0) {
+			consysHwChipId = CONSYS_REG_READ(conn_reg.mcu_base + CONSYS_CHIP_ID_OFFSET) - 0xf6d;
+
+			if ((consysHwChipId == 0x0321) || (consysHwChipId == 0x0335) || (consysHwChipId == 0x0337)) {
+				WMT_PLAT_INFO_FUNC("retry(%d)consys chipId(0x%08x)\n", retry, consysHwChipId);
+				break;
+			}
+			if ((consysHwChipId == 0x8163) || (consysHwChipId == 0x8127) || (consysHwChipId == 0x7623)) {
+				WMT_PLAT_INFO_FUNC("retry(%d)consys chipId(0x%08x)\n", retry, consysHwChipId);
+				break;
+			}
+
+			WMT_PLAT_ERR_FUNC("Read CONSYS chipId(0x%08x)", consysHwChipId);
+			msleep(20);
+		}
+
+		if ((0 == retry) || (0 == consysHwChipId))
+			WMT_PLAT_ERR_FUNC("Maybe has a consys power on issue,(0x%08x)\n", consysHwChipId);
+
+		msleep(40);
+
+	} else {
+
+		clk_disable_unprepare(clk_infra_conn_main);
+		WMT_PLAT_DBG_FUNC("[CCF] clk_disable_unprepare(clk_infra_conn_main) calling\n");
+		mtk_wcn_consys_power_off();
+
+		if (co_clock_type) {
+			/*VCN28 has been turned off by GPS OR FM */
+#if CONSYS_CLOCK_BUF_CTRL
+			clk_buf_ctrl(CLK_BUF_CONN, 0);
+#endif
+		} else {
+			regmap_update_bits(pmic_regmap, 0x41C, 0x1 << 14, 0x0 << 14);/*V28*/
+			/*turn off VCN28 LDO (with PMIC_WRAP API)" */
+			if (reg_VCN28) {
+				if (regulator_disable(reg_VCN28))
+					WMT_PLAT_ERR_FUNC("disable VCN_2V8 fail!\n");
+				else
+					WMT_PLAT_DBG_FUNC("disable VCN_2V8 ok\n");
+			}
+		}
+
+		/*AP power off MT6625L VCN_1V8 LDO */
+		regulator_set_mode(reg_VCN18, REGULATOR_MODE_STANDBY);
+		if (reg_VCN18) {
+			if (regulator_disable(reg_VCN18))
+				WMT_PLAT_ERR_FUNC("disable VCN_1V8 fail!\n");
+			else
+				WMT_PLAT_DBG_FUNC("disable VCN_1V8 ok\n");
+		}
+
+	}
+	WMT_PLAT_DBG_FUNC("CONSYS-HW-REG-CTRL(0x%08x),finish\n", on);
+	return 0;
+}
+
+INT32 mtk_wcn_consys_hw_gpio_ctrl(UINT32 on)
+{
+	INT32 iRet = 0;
+
+	WMT_PLAT_DBG_FUNC("CONSYS-HW-GPIO-CTRL(0x%08x), start\n", on);
+
+	if (on) {
+
+		/* TODO: [FixMe][GeorgeKuo] double check if BGF_INT is implemented ok */
+		/* iRet += wmt_plat_gpio_ctrl(PIN_BGF_EINT, PIN_STA_MUX); */
+		iRet += wmt_plat_eirq_ctrl(PIN_BGF_EINT, PIN_STA_INIT);
+		iRet += wmt_plat_eirq_ctrl(PIN_BGF_EINT, PIN_STA_EINT_DIS);
+		WMT_PLAT_DBG_FUNC("CONSYS-HW, BGF IRQ registered and disabled\n");
+
+	} else {
+
+		/* set bgf eint/all eint to deinit state, namely input low state */
+		iRet += wmt_plat_eirq_ctrl(PIN_BGF_EINT, PIN_STA_EINT_DIS);
+		iRet += wmt_plat_eirq_ctrl(PIN_BGF_EINT, PIN_STA_DEINIT);
+		WMT_PLAT_DBG_FUNC("CONSYS-HW, BGF IRQ unregistered and disabled\n");
+		/* iRet += wmt_plat_gpio_ctrl(PIN_BGF_EINT, PIN_STA_DEINIT); */
+	}
+	WMT_PLAT_DBG_FUNC("CONSYS-HW-GPIO-CTRL(0x%08x), finish\n", on);
+	return iRet;
+
+}
+
+INT32 mtk_wcn_consys_hw_pwr_on(UINT32 co_clock_type)
+{
+	INT32 iRet = 0;
+
+	WMT_PLAT_INFO_FUNC("CONSYS-HW-PWR-ON, start\n");
+
+	iRet += mtk_wcn_consys_hw_reg_ctrl(1, co_clock_type);
+	iRet += mtk_wcn_consys_hw_gpio_ctrl(1);
+
+	WMT_PLAT_INFO_FUNC("CONSYS-HW-PWR-ON, finish(%d)\n", iRet);
+	return iRet;
+}
+
+INT32 mtk_wcn_consys_hw_pwr_off(VOID)
+{
+	INT32 iRet = 0;
+
+	WMT_PLAT_INFO_FUNC("CONSYS-HW-PWR-OFF, start\n");
+
+	iRet += mtk_wcn_consys_hw_reg_ctrl(0, 0);
+	iRet += mtk_wcn_consys_hw_gpio_ctrl(0);
+
+	WMT_PLAT_INFO_FUNC("CONSYS-HW-PWR-OFF, finish(%d)\n", iRet);
+	return iRet;
+}
+
+INT32 mtk_wcn_consys_hw_rst(UINT32 co_clock_type)
+{
+	INT32 iRet = 0;
+
+	WMT_PLAT_INFO_FUNC("CONSYS-HW, hw_rst start, eirq should be disabled before this step\n");
+
+	/*1. do whole hw power off flow */
+	iRet += mtk_wcn_consys_hw_reg_ctrl(0, co_clock_type);
+
+	/*2. do whole hw power on flow */
+	iRet += mtk_wcn_consys_hw_reg_ctrl(1, co_clock_type);
+
+	WMT_PLAT_INFO_FUNC("CONSYS-HW, hw_rst finish, eirq should be enabled after this step\n");
+	return iRet;
+}
+
+#if CONSYS_BT_WIFI_SHARE_V33
+INT32 mtk_wcn_consys_hw_bt_paldo_ctrl(UINT32 enable)
+{
+	/* spin_lock_irqsave(&gBtWifiV33.lock,gBtWifiV33.flags); */
+	if (enable) {
+		if (1 == gBtWifiV33.counter) {
+			gBtWifiV33.counter++;
+			WMT_PLAT_DBG_FUNC("V33 has been enabled,counter(%d)\n", gBtWifiV33.counter);
+		} else if (2 == gBtWifiV33.counter) {
+			WMT_PLAT_DBG_FUNC("V33 has been enabled,counter(%d)\n", gBtWifiV33.counter);
+		} else {
+#if CONSYS_PMIC_CTRL_ENABLE
+			/*do BT PMIC on,depenency PMIC API ready */
+			/*switch BT PALDO control from SW mode to HW mode:0x416[5]-->0x1 */
+			/* VOL_DEFAULT, VOL_3300, VOL_3400, VOL_3500, VOL_3600 */
+			hwPowerOn(MT6323_POWER_LDO_VCN33, VOL_3300, "wcn_drv");
+			upmu_set_vcn33_on_ctrl_bt(1);
+#endif
+			WMT_PLAT_INFO_FUNC("WMT do BT/WIFI v3.3 on\n");
+			gBtWifiV33.counter++;
+		}
+
+	} else {
+		if (1 == gBtWifiV33.counter) {
+			/*do BT PMIC off */
+			/*switch BT PALDO control from HW mode to SW mode:0x416[5]-->0x0 */
+#if CONSYS_PMIC_CTRL_ENABLE
+		    upmu_set_vcn33_on_ctrl_bt(0);
+			hwPowerDown(MT6323_POWER_LDO_VCN33, "wcn_drv");
+#endif
+			WMT_PLAT_INFO_FUNC("WMT do BT/WIFI v3.3 off\n");
+			gBtWifiV33.counter--;
+		} else if (2 == gBtWifiV33.counter) {
+			gBtWifiV33.counter--;
+			WMT_PLAT_DBG_FUNC("V33 no need disabled,counter(%d)\n", gBtWifiV33.counter);
+		} else {
+			WMT_PLAT_DBG_FUNC("V33 has been disabled,counter(%d)\n", gBtWifiV33.counter);
+		}
+
+	}
+	/* spin_unlock_irqrestore(&gBtWifiV33.lock,gBtWifiV33.flags); */
+	return 0;
+}
+
+INT32 mtk_wcn_consys_hw_wifi_paldo_ctrl(UINT32 enable)
+{
+	mtk_wcn_consys_hw_bt_paldo_ctrl(enable);
+	return 0;
+}
+
+#else
+INT32 mtk_wcn_consys_hw_bt_paldo_ctrl(UINT32 enable)
+{
+
+	if (enable) {
+		/*do BT PMIC on,depenency PMIC API ready */
+		/*switch BT PALDO control from SW mode to HW mode:0x416[5]-->0x1 */
+		if (reg_VCN33_BT) {
+			regulator_set_voltage(reg_VCN33_BT, 3300000, 3300000);
+			if (regulator_enable(reg_VCN33_BT))
+				WMT_PLAT_ERR_FUNC("WMT do BT PMIC on fail!\n");
+		}
+		regmap_update_bits(pmic_regmap, 0x416, 0x1 << 5, 0x1 << 5);/*BT*/
+		WMT_PLAT_INFO_FUNC("WMT do BT PMIC on\n");
+	} else {
+		/*do BT PMIC off */
+		/*switch BT PALDO control from HW mode to SW mode:0x416[5]-->0x0 */
+		regmap_update_bits(pmic_regmap, 0x416, 0x1 << 5, 0x0 << 5);/*BT*/
+		if (reg_VCN33_BT)
+			if (regulator_disable(reg_VCN33_BT))
+				WMT_PLAT_ERR_FUNC("WMT do BT PMIC off fail!\n");
+		WMT_PLAT_INFO_FUNC("WMT do BT PMIC off\n");
+	}
+
+	return 0;
+
+}
+
+INT32 mtk_wcn_consys_hw_wifi_paldo_ctrl(UINT32 enable)
+{
+
+	if (enable) {
+		/*do WIFI PMIC on,depenency PMIC API ready */
+		/*switch WIFI PALDO control from SW mode to HW mode:0x418[14]-->0x1 */
+		if (reg_VCN33_WIFI) {
+			regulator_set_voltage(reg_VCN33_WIFI, 3300000, 3300000);
+			if (regulator_enable(reg_VCN33_WIFI))
+				WMT_PLAT_ERR_FUNC("WMT do WIFI PMIC on fail!\n");
+			else
+				WMT_PLAT_INFO_FUNC("WMT do WIFI PMIC on !\n");
+		}
+		regmap_update_bits(pmic_regmap, 0x418, 0x1 << 14, 0x1 << 14);/*WIFI*/
+		WMT_PLAT_INFO_FUNC("WMT do WIFI PMIC on\n");
+	} else {
+		/*do WIFI PMIC off */
+		/*switch WIFI PALDO control from HW mode to SW mode:0x418[14]-->0x0 */
+		regmap_update_bits(pmic_regmap, 0x418, 0x1 << 14, 0x0 << 14);/*WIFI*/
+		if (reg_VCN33_WIFI)
+			if (regulator_disable(reg_VCN33_WIFI))
+				WMT_PLAT_ERR_FUNC("WMT do WIFI PMIC off fail!\n");
+		WMT_PLAT_INFO_FUNC("WMT do WIFI PMIC off\n");
+	}
+
+	return 0;
+}
+
+#endif
+
+EXPORT_SYMBOL(mtk_wcn_consys_hw_wifi_paldo_ctrl);
+
+INT32 mtk_wcn_consys_hw_vcn28_ctrl(UINT32 enable)
+{
+	if (enable) {
+		/*in co-clock mode,need to turn on vcn28 when fm on */
+		if (reg_VCN28) {
+			regulator_set_voltage(reg_VCN28, 2800000, 2800000);
+			if (regulator_enable(reg_VCN28))
+				WMT_PLAT_ERR_FUNC("WMT do VCN28 PMIC on fail!\n");
+		}
+		WMT_PLAT_INFO_FUNC("turn on vcn28 for fm/gps usage in co-clock mode\n");
+	} else {
+		/*in co-clock mode,need to turn off vcn28 when fm off */
+		if (reg_VCN28)
+			if (regulator_disable(reg_VCN28))
+				WMT_PLAT_ERR_FUNC("WMT do VCN28 PMIC off fail!\n");
+		WMT_PLAT_INFO_FUNC("turn off vcn28 for fm/gps usage in co-clock mode\n");
+	}
+	return 0;
+}
+
+INT32 mtk_wcn_consys_hw_state_show(VOID)
+{
+	return 0;
+}
+
+INT32 mtk_wcn_consys_hw_restore(struct device *device)
+{
+	UINT32 addrPhy = 0;
+
+	if (gConEmiPhyBase) {
+
+#if CONSYS_EMI_MPU_SETTING
+		/*set MPU for EMI share Memory */
+		WMT_PLAT_INFO_FUNC("setting MPU for EMI share memory\n");
+
+#if 0
+	emi_mpu_set_region_protection(gConEmiPhyBase + SZ_1M/2,
+		gConEmiPhyBase + SZ_1M,
+		5,
+		SET_ACCESS_PERMISSON(FORBIDDEN, NO_PROTECTION, FORBIDDEN, NO_PROTECTION));
+
+
+#else
+		WMT_PLAT_WARN_FUNC("not define platform config\n");
+#endif
+
+#endif
+		/*consys to ap emi remapping register:10001310, cal remapping address */
+		addrPhy = (gConEmiPhyBase & 0xFFF00000) >> 20;
+
+		/*enable consys to ap emi remapping bit12 */
+		addrPhy = addrPhy | 0x1000;
+
+		CONSYS_REG_WRITE(conn_reg.topckgen_base + CONSYS_EMI_MAPPING_OFFSET,
+				 CONSYS_REG_READ(conn_reg.topckgen_base + CONSYS_EMI_MAPPING_OFFSET) | addrPhy);
+
+		WMT_PLAT_INFO_FUNC("CONSYS_EMI_MAPPING dump in restore cb(0x%08x)\n",
+				   CONSYS_REG_READ(conn_reg.topckgen_base + CONSYS_EMI_MAPPING_OFFSET));
+
+#if 1
+		pEmibaseaddr = ioremap_nocache(gConEmiPhyBase + CONSYS_EMI_AP_PHY_OFFSET, CONSYS_EMI_MEM_SIZE);
+#else
+		pEmibaseaddr = ioremap_nocache(CONSYS_EMI_AP_PHY_BASE, CONSYS_EMI_MEM_SIZE);
+#endif
+		if (pEmibaseaddr) {
+			WMT_PLAT_INFO_FUNC("EMI mapping OK(0x%p)\n", pEmibaseaddr);
+			memset_io(pEmibaseaddr, 0, CONSYS_EMI_MEM_SIZE);
+		} else {
+			WMT_PLAT_ERR_FUNC("EMI mapping fail\n");
+		}
+	} else {
+		WMT_PLAT_ERR_FUNC("consys emi memory address gConEmiPhyBase invalid\n");
+	}
+
+	return 0;
+}
+
+/*Reserved memory by device tree!*/
+int reserve_memory_consys_fn(struct reserved_mem *rmem)
+{
+	WMT_PLAT_WARN_FUNC(" name: %s, base: 0x%llx, size: 0x%llx\n", rmem->name,
+			   (unsigned long long)rmem->base, (unsigned long long)rmem->size);
+	gConEmiPhyBase = rmem->base;
+	return 0;
+}
+
+RESERVEDMEM_OF_DECLARE(reserve_memory_test, "mediatek,consys-reserve-memory", reserve_memory_consys_fn);
+
+
+INT32 mtk_wcn_consys_hw_init(void)
+{
+
+	INT32 iRet = -1;
+	UINT32 addrPhy = 0;
+	INT32 i = 0;
+	struct device_node *node = NULL;
+
+	node = of_find_compatible_node(NULL, NULL, "mediatek,mt7623-consys");
+	if (node) {
+		/* registers base address */
+		conn_reg.mcu_base = (SIZE_T) of_iomap(node, i);
+		WMT_PLAT_DBG_FUNC("Get mcu register base(0x%zx)\n", conn_reg.mcu_base);
+		i++;
+
+		conn_reg.topckgen_base = (SIZE_T) of_iomap(node, i);
+		WMT_PLAT_DBG_FUNC("Get topckgen register base(0x%zx)\n", conn_reg.topckgen_base);
+		i++;
+	} else {
+		WMT_PLAT_ERR_FUNC("[%s] can't find CONSYS compatible node\n", __func__);
+		return iRet;
+	}
+	if (gConEmiPhyBase) {
+#if CONSYS_EMI_MPU_SETTING
+		/*set MPU for EMI share Memory */
+		WMT_PLAT_INFO_FUNC("setting MPU for EMI share memory\n");
+
+#if 0
+	emi_mpu_set_region_protection(gConEmiPhyBase + SZ_1M/2,
+		gConEmiPhyBase + SZ_1M,
+		5,
+		SET_ACCESS_PERMISSON(FORBIDDEN, NO_PROTECTION, FORBIDDEN, NO_PROTECTION));
+#else
+		WMT_PLAT_WARN_FUNC("not define platform config\n");
+#endif
+
+#endif
+		WMT_PLAT_DBG_FUNC("get consys start phy address(0x%zx)\n", (SIZE_T) gConEmiPhyBase);
+
+		/*consys to ap emi remapping register:10001310, cal remapping address */
+		addrPhy = (gConEmiPhyBase & 0xFFF00000) >> 20;
+
+		/*enable consys to ap emi remapping bit12 */
+		addrPhy = addrPhy | 0x1000;
+
+		CONSYS_REG_WRITE(conn_reg.topckgen_base + CONSYS_EMI_MAPPING_OFFSET,
+				 CONSYS_REG_READ(conn_reg.topckgen_base + CONSYS_EMI_MAPPING_OFFSET) | addrPhy);
+
+		WMT_PLAT_INFO_FUNC("CONSYS_EMI_MAPPING dump(0x%08x)\n",
+				   CONSYS_REG_READ(conn_reg.topckgen_base + CONSYS_EMI_MAPPING_OFFSET));
+
+#if 1
+		pEmibaseaddr = ioremap_nocache(gConEmiPhyBase + CONSYS_EMI_AP_PHY_OFFSET, CONSYS_EMI_MEM_SIZE);
+#else
+		pEmibaseaddr = ioremap_nocache(CONSYS_EMI_AP_PHY_BASE, CONSYS_EMI_MEM_SIZE);
+#endif
+		/* pEmibaseaddr = ioremap_nocache(0x80090400,270*KBYTE); */
+		if (pEmibaseaddr) {
+			WMT_PLAT_INFO_FUNC("EMI mapping OK(0x%p)\n", pEmibaseaddr);
+			memset_io(pEmibaseaddr, 0, CONSYS_EMI_MEM_SIZE);
+			iRet = 0;
+		} else {
+			WMT_PLAT_ERR_FUNC("EMI mapping fail\n");
+		}
+	} else {
+		WMT_PLAT_ERR_FUNC("consys emi memory address gConEmiPhyBase invalid\n");
+	}
+#ifdef CONFIG_MTK_HIBERNATION
+	WMT_PLAT_INFO_FUNC("register connsys restore cb for complying with IPOH function\n");
+	register_swsusp_restore_noirq_func(ID_M_CONNSYS, mtk_wcn_consys_hw_restore, NULL);
+#endif
+	iRet = platform_driver_register(&mtk_wmt_dev_drv);
+	if (iRet)
+		WMT_PLAT_ERR_FUNC("WMT platform driver registered failed(%d)\n", iRet);
+	return iRet;
+}
+
+INT32 mtk_wcn_consys_hw_deinit(void)
+{
+	if (pEmibaseaddr) {
+		iounmap(pEmibaseaddr);
+		pEmibaseaddr = NULL;
+	}
+#ifdef CONFIG_MTK_HIBERNATION
+	unregister_swsusp_restore_noirq_func(ID_M_CONNSYS);
+#endif
+
+	platform_driver_unregister(&mtk_wmt_dev_drv);
+	return 0;
+}
+
+UINT8 *mtk_wcn_consys_emi_virt_addr_get(UINT32 ctrl_state_offset)
+{
+	UINT8 *p_virtual_addr = NULL;
+
+	if (!pEmibaseaddr) {
+		WMT_PLAT_ERR_FUNC("EMI base address is NULL\n");
+		return NULL;
+	}
+	WMT_PLAT_DBG_FUNC("ctrl_state_offset(%08x)\n", ctrl_state_offset);
+	p_virtual_addr = pEmibaseaddr + ctrl_state_offset;
+
+	return p_virtual_addr;
+}
+
+UINT32 mtk_wcn_consys_soc_chipid(void)
+{
+	return PLATFORM_SOC_CHIP;
+}
+
+struct pinctrl *mtk_wcn_consys_get_pinctrl()
+{
+	return consys_pinctrl;
+}
+INT32 mtk_wcn_consys_set_dynamic_dump(PUINT32 str_buf)
+{
+	PUINT8 vir_addr = NULL;
+
+	vir_addr = mtk_wcn_consys_emi_virt_addr_get(EXP_APMEM_CTRL_CHIP_DYNAMIC_DUMP);
+	if (!vir_addr) {
+		WMT_PLAT_ERR_FUNC("get vir address fail\n");
+		return -2;
+	}
+	memcpy(vir_addr, str_buf, DYNAMIC_DUMP_GROUP_NUM*8);
+	WMT_PLAT_INFO_FUNC("dynamic dump register value(0x%08x)\n", CONSYS_REG_READ(vir_addr));
+	return 0;
+}
diff --git a/drivers/misc/mediatek/connectivity/common/conn_soc/mt7623/wmt_plat_alps.c b/drivers/misc/mediatek/connectivity/common/conn_soc/mt7623/wmt_plat_alps.c
new file mode 100644
index 00000000..8f92846
--- /dev/null
+++ b/drivers/misc/mediatek/connectivity/common/conn_soc/mt7623/wmt_plat_alps.c
@@ -0,0 +1,1043 @@
+/*! \file
+    \brief  Declaration of library functions
+
+    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[WMT-PLAT]"
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+#include <linux/delay.h>
+#include <linux/pinctrl/consumer.h>
+/* ALPS header files */
+/*#include <mtk_rtc.h>*/
+/*#include <mt_irq.h>*/
+#if defined(CONFIG_MTK_GPIO_LEGACY)
+#include <mt_gpio.h>
+#endif
+#include <mtk_wcn_cmb_stub.h>
+
+/* MTK_WCN_COMBO header files */
+#include "osal_typedef.h"
+#include "mtk_wcn_consys_hw.h"
+#include "stp_dbg.h"
+
+#define CFG_WMT_WAKELOCK_SUPPORT 1
+
+#ifdef CONFIG_MTK_MT6306_SUPPORT
+#define MTK_WCN_MT6306_IS_READY 1
+#else
+#define MTK_WCN_MT6306_IS_READY 0
+#endif
+
+#if	MTK_WCN_MT6306_IS_READY
+#include <dcl_sim_gpio.h>
+
+#ifdef	GPIO_GPS_LNA_PIN
+#undef	GPIO_GPS_LNA_PIN
+#endif
+
+#define GPIO_GPS_LNA_PIN GPIO7
+#endif
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+EMI_CTRL_STATE_OFFSET mtk_wcn_emi_state_off = {
+	.emi_apmem_ctrl_state = EXP_APMEM_CTRL_STATE,
+	.emi_apmem_ctrl_host_sync_state = EXP_APMEM_CTRL_HOST_SYNC_STATE,
+	.emi_apmem_ctrl_host_sync_num = EXP_APMEM_CTRL_HOST_SYNC_NUM,
+	.emi_apmem_ctrl_chip_sync_state = EXP_APMEM_CTRL_CHIP_SYNC_STATE,
+	.emi_apmem_ctrl_chip_sync_num = EXP_APMEM_CTRL_CHIP_SYNC_NUM,
+	.emi_apmem_ctrl_chip_sync_addr = EXP_APMEM_CTRL_CHIP_SYNC_ADDR,
+	.emi_apmem_ctrl_chip_sync_len = EXP_APMEM_CTRL_CHIP_SYNC_LEN,
+	.emi_apmem_ctrl_chip_print_buff_start = EXP_APMEM_CTRL_CHIP_PRINT_BUFF_START,
+	.emi_apmem_ctrl_chip_print_buff_len = EXP_APMEM_CTRL_CHIP_PRINT_BUFF_LEN,
+	.emi_apmem_ctrl_chip_print_buff_idx = EXP_APMEM_CTRL_CHIP_PRINT_BUFF_IDX,
+	.emi_apmem_ctrl_chip_int_status = EXP_APMEM_CTRL_CHIP_INT_STATUS,
+	.emi_apmem_ctrl_chip_paded_dump_end = EXP_APMEM_CTRL_CHIP_PAGED_DUMP_END,
+	.emi_apmem_ctrl_host_outband_assert_w1 = EXP_APMEM_CTRL_HOST_OUTBAND_ASSERT_W1,
+};
+
+CONSYS_EMI_ADDR_INFO mtk_wcn_emi_addr_info = {
+	.emi_phy_addr = CONSYS_EMI_FW_PHY_BASE,
+	.paged_trace_off = CONSYS_EMI_PAGED_TRACE_OFFSET,
+	.paged_dump_off = CONSYS_EMI_PAGED_DUMP_OFFSET,
+	.full_dump_off = CONSYS_EMI_FULL_DUMP_OFFSET,
+	.p_ecso = &mtk_wcn_emi_state_off,
+};
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+static VOID wmt_plat_bgf_eirq_cb(VOID);
+
+static INT32 wmt_plat_bgf_eint_ctrl(ENUM_PIN_STATE state);
+static INT32 wmt_plat_i2s_ctrl(ENUM_PIN_STATE state);
+static INT32 wmt_plat_gps_sync_ctrl(ENUM_PIN_STATE state);
+static INT32 wmt_plat_gps_lna_ctrl(ENUM_PIN_STATE state);
+
+static INT32 wmt_plat_dump_pin_conf(VOID);
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+UINT32 gCoClockFlag = 0;
+BGF_IRQ_BALANCE gbgfIrqBle;
+UINT32 wmtPlatLogLvl = WMT_PLAT_LOG_DBG;
+#if CONSYS_BT_WIFI_SHARE_V33
+BT_WIFI_V33_STATUS gBtWifiV33;
+#endif
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+#if CFG_WMT_WAKELOCK_SUPPORT
+static struct mutex gOsSLock;
+static struct wakeup_source *wmtWakeLock;
+#endif
+
+irq_cb wmt_plat_bgf_irq_cb = NULL;
+device_audio_if_cb wmt_plat_audio_if_cb = NULL;
+func_ctrl_cb wmt_plat_func_ctrl_cb = NULL;
+thermal_query_ctrl_cb wmt_plat_thermal_query_ctrl_cb = NULL;
+deep_idle_ctrl_cb wmt_plat_deep_idle_ctrl_cb = NULL;
+
+static const fp_set_pin gfp_set_pin_table[] = {
+	[PIN_BGF_EINT] = wmt_plat_bgf_eint_ctrl,
+	[PIN_I2S_GRP] = wmt_plat_i2s_ctrl,
+	[PIN_GPS_SYNC] = wmt_plat_gps_sync_ctrl,
+	[PIN_GPS_LNA] = wmt_plat_gps_lna_ctrl,
+};
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+/*!
+ * \brief audio control callback function for CMB_STUB on ALPS
+ *
+ * A platform function required for dynamic binding with CMB_STUB on ALPS.
+ *
+ * \param state desired audio interface state to use
+ * \param flag audio interface control options
+ *
+ * \retval 0 operation success
+ * \retval -1 invalid parameters
+ * \retval < 0 error for operation fail
+ */
+INT32 wmt_plat_audio_ctrl(CMB_STUB_AIF_X state, CMB_STUB_AIF_CTRL ctrl)
+{
+	INT32 iRet = 0;
+	UINT32 pinShare = 0;
+
+	/* input sanity check */
+	if ((CMB_STUB_AIF_MAX <= state)
+	    || (CMB_STUB_AIF_CTRL_MAX <= ctrl)) {
+		return -1;
+	}
+
+	iRet = 0;
+
+	/* set host side first */
+	switch (state) {
+	case CMB_STUB_AIF_0:
+		/* BT_PCM_OFF & FM line in/out */
+		iRet += wmt_plat_gpio_ctrl(PIN_I2S_GRP, PIN_STA_DEINIT);
+		break;
+
+	case CMB_STUB_AIF_1:
+		iRet += wmt_plat_gpio_ctrl(PIN_I2S_GRP, PIN_STA_DEINIT);
+		break;
+
+	case CMB_STUB_AIF_2:
+		iRet += wmt_plat_gpio_ctrl(PIN_I2S_GRP, PIN_STA_INIT);
+		break;
+
+	case CMB_STUB_AIF_3:
+		iRet += wmt_plat_gpio_ctrl(PIN_I2S_GRP, PIN_STA_INIT);
+		break;
+
+	default:
+		/* FIXME: move to cust folder? */
+		WMT_PLAT_ERR_FUNC("invalid state [%d]\n", state);
+		iRet = -1;
+		break;
+	}
+
+	if (CMB_STUB_AIF_CTRL_EN == ctrl) {
+		WMT_PLAT_INFO_FUNC("call chip aif setting\n");
+		/* need to control chip side GPIO */
+		if (NULL != wmt_plat_audio_if_cb) {
+			iRet += (*wmt_plat_audio_if_cb) (state, (pinShare) ? MTK_WCN_BOOL_TRUE : MTK_WCN_BOOL_FALSE);
+		} else {
+			WMT_PLAT_WARN_FUNC("wmt_plat_audio_if_cb is not registered\n");
+			iRet -= 1;
+		}
+
+	} else {
+		WMT_PLAT_INFO_FUNC("skip chip aif setting\n");
+	}
+
+	return iRet;
+
+}
+
+static VOID wmt_plat_func_ctrl(UINT32 type, UINT32 on)
+{
+	if (wmt_plat_func_ctrl_cb)
+		(*wmt_plat_func_ctrl_cb) (on, type);
+}
+
+static long wmt_plat_thermal_ctrl(VOID)
+{
+	long temp = 0;
+
+	if (wmt_plat_thermal_query_ctrl_cb)
+		temp = (*wmt_plat_thermal_query_ctrl_cb) ();
+
+	return temp;
+}
+
+static INT32 wmt_plat_deep_idle_ctrl(UINT32 dpilde_ctrl)
+{
+	INT32 iRet = -1;
+
+	if (wmt_plat_deep_idle_ctrl_cb)
+		iRet = (*wmt_plat_deep_idle_ctrl_cb) (dpilde_ctrl);
+
+	return iRet;
+}
+
+static VOID wmt_plat_bgf_eirq_cb(VOID)
+{
+#if CFG_WMT_PS_SUPPORT
+/* #error "need to disable EINT here" */
+	/* wmt_lib_ps_irq_cb(); */
+	if (NULL != wmt_plat_bgf_irq_cb)
+		(*(wmt_plat_bgf_irq_cb)) ();
+	else
+		WMT_PLAT_WARN_FUNC("WMT-PLAT: wmt_plat_bgf_irq_cb not registered\n");
+#else
+	return;
+#endif
+
+}
+
+irqreturn_t wmt_plat_bgf_irq_isr(INT32 i, VOID *arg)
+{
+#if CFG_WMT_PS_SUPPORT
+	wmt_plat_eirq_ctrl(PIN_BGF_EINT, PIN_STA_EINT_DIS);
+	wmt_plat_bgf_eirq_cb();
+#else
+	WMT_PLAT_INFO_FUNC("skip irq handing because psm is disable");
+#endif
+	return IRQ_HANDLED;
+}
+
+VOID wmt_plat_irq_cb_reg(irq_cb bgf_irq_cb)
+{
+	wmt_plat_bgf_irq_cb = bgf_irq_cb;
+}
+EXPORT_SYMBOL(wmt_plat_irq_cb_reg);
+
+VOID wmt_plat_aif_cb_reg(device_audio_if_cb aif_ctrl_cb)
+{
+	wmt_plat_audio_if_cb = aif_ctrl_cb;
+}
+EXPORT_SYMBOL(wmt_plat_aif_cb_reg);
+
+VOID wmt_plat_func_ctrl_cb_reg(func_ctrl_cb subsys_func_ctrl)
+{
+	wmt_plat_func_ctrl_cb = subsys_func_ctrl;
+}
+EXPORT_SYMBOL(wmt_plat_func_ctrl_cb_reg);
+
+VOID wmt_plat_thermal_ctrl_cb_reg(thermal_query_ctrl_cb thermal_query_ctrl)
+{
+	wmt_plat_thermal_query_ctrl_cb = thermal_query_ctrl;
+}
+EXPORT_SYMBOL(wmt_plat_thermal_ctrl_cb_reg);
+
+VOID wmt_plat_deep_idle_ctrl_cb_reg(deep_idle_ctrl_cb deep_idle_ctrl)
+{
+	wmt_plat_deep_idle_ctrl_cb = deep_idle_ctrl;
+}
+EXPORT_SYMBOL(wmt_plat_deep_idle_ctrl_cb_reg);
+
+UINT32 wmt_plat_soc_co_clock_flag_get(VOID)
+{
+	return gCoClockFlag;
+}
+
+static UINT32 wmt_plat_soc_co_clock_flag_set(UINT32 flag)
+{
+	gCoClockFlag = flag;
+	return 0;
+}
+
+INT32 wmt_plat_init(UINT32 co_clock_type)
+{
+	CMB_STUB_CB stub_cb;
+	INT32 iret;
+	/*init wmt function ctrl wakelock if wake lock is supported by host platform */
+
+	wmt_plat_soc_co_clock_flag_set(co_clock_type);
+
+	stub_cb.aif_ctrl_cb = wmt_plat_audio_ctrl;
+	stub_cb.func_ctrl_cb = wmt_plat_func_ctrl;
+	stub_cb.thermal_query_cb = wmt_plat_thermal_ctrl;
+	stub_cb.deep_idle_ctrl_cb = wmt_plat_deep_idle_ctrl;
+	stub_cb.size = sizeof(stub_cb);
+
+	/* register to cmb_stub */
+	iret = mtk_wcn_cmb_stub_reg(&stub_cb);
+#ifdef CFG_WMT_WAKELOCK_SUPPORT
+	if((wmtWakeLock = wakeup_source_create("wmtFuncCtrl")))
+		wakeup_source_add(wmtWakeLock);
+	mutex_init(&gOsSLock);
+#endif
+
+#if CONSYS_BT_WIFI_SHARE_V33
+	gBtWifiV33.counter = 0;
+	spin_lock_init(&gBtWifiV33.lock);
+#endif
+
+	iret += mtk_wcn_consys_hw_init();
+
+	spin_lock_init(&gbgfIrqBle.lock);
+	WMT_PLAT_DBG_FUNC("WMT-PLAT: ALPS platform init (%d)\n", iret);
+
+	return 0;
+}
+EXPORT_SYMBOL(wmt_plat_init);
+
+INT32 wmt_plat_deinit(VOID)
+{
+	INT32 iret = 0;
+	/* 2. unreg to cmb_stub */
+	iret = mtk_wcn_cmb_stub_unreg();
+printk(KERN_ALERT "DEBUG: Passed %s %d now calling wmt wakelock deinit\n",__FUNCTION__,__LINE__);
+	/*3. wmt wakelock deinit */
+#ifdef CFG_WMT_WAKELOCK_SUPPORT
+printk(KERN_ALERT "DEBUG: Passed %s %d now calling wakeup_source_trash\n",__FUNCTION__,__LINE__);
+	wakeup_source_remove(wmtWakeLock);
+	wakeup_source_destroy(wmtWakeLock);
+printk(KERN_ALERT "DEBUG: Passed %s %d now calling mutex_destroy\n",__FUNCTION__,__LINE__);
+	mutex_destroy(&gOsSLock);
+	WMT_PLAT_DBG_FUNC("destroy wmtWakeLock\n");
+#endif
+printk(KERN_ALERT "DEBUG: Passed %s %d now calling consys hw deinit\n",__FUNCTION__,__LINE__);
+
+	iret += mtk_wcn_consys_hw_deinit();
+
+	WMT_PLAT_DBG_FUNC("WMT-PLAT: ALPS platform init (%d)\n", iret);
+
+	return 0;
+}
+EXPORT_SYMBOL(wmt_plat_deinit);
+
+static INT32 wmt_plat_dump_pin_conf(VOID)
+{
+	WMT_PLAT_DBG_FUNC("[WMT-PLAT]=>dump wmt pin configuration start<=\n");
+#if defined(CONFIG_MTK_GPIO_LEGACY)
+
+#ifdef GPIO_COMBO_BGF_EINT_PIN
+	WMT_PLAT_DBG_FUNC("BGF_EINT(GPIO%d)\n", GPIO_COMBO_BGF_EINT_PIN);
+#else
+	WMT_PLAT_DBG_FUNC("BGF_EINT(not defined)\n");
+#endif
+
+#ifdef CUST_EINT_COMBO_BGF_NUM
+	WMT_PLAT_DBG_FUNC("BGF_EINT_NUM(%d)\n", CUST_EINT_COMBO_BGF_NUM);
+#else
+	WMT_PLAT_DBG_FUNC("BGF_EINT_NUM(not defined)\n");
+#endif
+
+#ifdef GPIO_COMBO_URXD_PIN
+	WMT_PLAT_DBG_FUNC("UART_RX(GPIO%d)\n", GPIO_COMBO_URXD_PIN);
+#else
+	WMT_PLAT_DBG_FUNC("UART_RX(not defined)\n");
+#endif
+#if defined(FM_DIGITAL_INPUT) || defined(FM_DIGITAL_OUTPUT)
+#ifdef GPIO_COMBO_I2S_CK_PIN
+	WMT_PLAT_DBG_FUNC("I2S_CK(GPIO%d)\n", GPIO_COMBO_I2S_CK_PIN);
+#else
+	WMT_PLAT_DBG_FUNC("I2S_CK(not defined)\n");
+#endif
+#ifdef GPIO_COMBO_I2S_WS_PIN
+	WMT_PLAT_DBG_FUNC("I2S_WS(GPIO%d)\n", GPIO_COMBO_I2S_WS_PIN);
+#else
+	WMT_PLAT_DBG_FUNC("I2S_WS(not defined)\n");
+#endif
+#ifdef GPIO_COMBO_I2S_DAT_PIN
+	WMT_PLAT_DBG_FUNC("I2S_DAT(GPIO%d)\n", GPIO_COMBO_I2S_DAT_PIN);
+#else
+	WMT_PLAT_DBG_FUNC("I2S_DAT(not defined)\n");
+#endif
+#else /* FM_ANALOG_INPUT || FM_ANALOG_OUTPUT */
+	WMT_PLAT_DBG_FUNC("FM digital mode is not set, no need for I2S GPIOs\n");
+#endif
+#ifdef GPIO_GPS_SYNC_PIN
+	WMT_PLAT_DBG_FUNC("GPS_SYNC(GPIO%d)\n", GPIO_GPS_SYNC_PIN);
+#else
+	WMT_PLAT_DBG_FUNC("GPS_SYNC(not defined)\n");
+#endif
+
+#ifdef GPIO_GPS_LNA_PIN
+	WMT_PLAT_INFO_FUNC("GPS_LNA(GPIO%d)\n", GPIO_GPS_LNA_PIN);
+#else
+	WMT_PLAT_INFO_FUNC("GPS_LNA(not defined)\n");
+#endif
+
+#else /* #if defined(CONFIG_MTK_GPIO_LEGACY) */
+#endif
+	WMT_PLAT_DBG_FUNC("[WMT-PLAT]=>dump wmt pin configuration emds<=\n");
+	return 0;
+}
+
+INT32 wmt_plat_pwr_ctrl(ENUM_FUNC_STATE state)
+{
+	INT32 ret = -1;
+
+	switch (state) {
+	case FUNC_ON:
+		/* TODO:[ChangeFeature][George] always output this or by request throuth /proc or sysfs? */
+		wmt_plat_dump_pin_conf();
+		ret = mtk_wcn_consys_hw_pwr_on(gCoClockFlag);
+		break;
+
+	case FUNC_OFF:
+		ret = mtk_wcn_consys_hw_pwr_off();
+		break;
+
+	case FUNC_RST:
+		ret = mtk_wcn_consys_hw_rst(gCoClockFlag);
+		break;
+	case FUNC_STAT:
+		ret = mtk_wcn_consys_hw_state_show();
+		break;
+	default:
+		WMT_PLAT_WARN_FUNC("WMT-PLAT:Warnning, invalid state(%d) in pwr_ctrl\n", state);
+		break;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(wmt_plat_pwr_ctrl);
+
+INT32 wmt_plat_eirq_ctrl(ENUM_PIN_ID id, ENUM_PIN_STATE state)
+{
+#ifdef CONFIG_OF
+	struct device_node *node;
+	unsigned int irq_info[3] = { 0, 0, 0 };
+#endif
+	INT32 iret = -EINVAL;
+	static INT32 bgf_irq_num = -1;
+	static UINT32 bgf_irq_flag;
+	/* TODO: [ChangeFeature][GeorgeKuo]: use another function to handle this, as done in gpio_ctrls */
+
+	if ((PIN_STA_INIT != state)
+	    && (PIN_STA_DEINIT != state)
+	    && (PIN_STA_EINT_EN != state)
+	    && (PIN_STA_EINT_DIS != state)) {
+		WMT_PLAT_WARN_FUNC("WMT-PLAT:invalid PIN_STATE(%d) in eirq_ctrl for PIN(%d)\n", state, id);
+		return -1;
+	}
+
+	switch (id) {
+	case PIN_BGF_EINT:
+
+		if (PIN_STA_INIT == state) {
+#ifdef CONFIG_OF
+			node = of_find_compatible_node(NULL, NULL, "mediatek,mt7623-consys");
+			if (node) {
+				bgf_irq_num = irq_of_parse_and_map(node, 0);
+				/* get the interrupt line behaviour */
+				if (of_property_read_u32_array(node, "interrupts", irq_info, ARRAY_SIZE(irq_info))) {
+					WMT_PLAT_ERR_FUNC("get irq flags from DTS fail!!\n");
+					return iret;
+				}
+				bgf_irq_flag = irq_info[2];
+				WMT_PLAT_INFO_FUNC("get irq id(%d) and irq trigger flag(%d) from DT\n", bgf_irq_num,
+						   bgf_irq_flag);
+			} else {
+				WMT_PLAT_ERR_FUNC("[%s] can't find CONSYS compatible node\n", __func__);
+				return iret;
+			}
+#else
+			bgf_irq_num = MT_CONN2AP_BTIF_WAKEUP_IRQ_ID;
+			bgf_irq_flag = IRQF_TRIGGER_LOW;
+#endif
+			iret = request_irq(bgf_irq_num, wmt_plat_bgf_irq_isr, bgf_irq_flag, "BTIF_WAKEUP_IRQ", NULL);
+			if (iret) {
+				WMT_PLAT_ERR_FUNC("request_irq fail,irq_no(%d),iret(%d)\n", bgf_irq_num, iret);
+				return iret;
+			}
+			gbgfIrqBle.counter = 1;
+
+		} else if (PIN_STA_EINT_EN == state) {
+
+			spin_lock_irqsave(&gbgfIrqBle.lock, gbgfIrqBle.flags);
+			if (gbgfIrqBle.counter) {
+				WMT_PLAT_DBG_FUNC("BGF INT has been enabled,counter(%d)\n", gbgfIrqBle.counter);
+			} else {
+				enable_irq(bgf_irq_num);
+				gbgfIrqBle.counter++;
+			}
+			WMT_PLAT_DBG_FUNC("WMT-PLAT:BGFInt (en)\n");
+			spin_unlock_irqrestore(&gbgfIrqBle.lock, gbgfIrqBle.flags);
+		} else if (PIN_STA_EINT_DIS == state) {
+			spin_lock_irqsave(&gbgfIrqBle.lock, gbgfIrqBle.flags);
+			if (!gbgfIrqBle.counter) {
+				WMT_PLAT_INFO_FUNC("BGF INT has been disabled,counter(%d)\n", gbgfIrqBle.counter);
+			} else {
+				disable_irq_nosync(bgf_irq_num);
+				gbgfIrqBle.counter--;
+			}
+			WMT_PLAT_DBG_FUNC("WMT-PLAT:BGFInt (dis)\n");
+			spin_unlock_irqrestore(&gbgfIrqBle.lock, gbgfIrqBle.flags);
+		} else {
+			free_irq(bgf_irq_num, NULL);
+			/* de-init: nothing to do in ALPS, such as un-registration... */
+		}
+		iret = 0;
+		break;
+
+	default:
+		WMT_PLAT_WARN_FUNC("WMT-PLAT:unsupported EIRQ(PIN_ID:%d) in eirq_ctrl\n", id);
+		iret = -1;
+		break;
+	}
+
+	return iret;
+}
+EXPORT_SYMBOL(wmt_plat_eirq_ctrl);
+
+INT32 wmt_plat_gpio_ctrl(ENUM_PIN_ID id, ENUM_PIN_STATE state)
+{
+	if ((PIN_ID_MAX > id)
+	    && (PIN_STA_MAX > state)) {
+
+		/* TODO: [FixMe][GeorgeKuo] do sanity check to const function table when init and skip checking here */
+		if (gfp_set_pin_table[id])
+			return (*(gfp_set_pin_table[id])) (state);	/* .handler */
+		WMT_PLAT_WARN_FUNC("WMT-PLAT: null fp for gpio_ctrl(%d)\n", id);
+		return -2;
+	}
+	return -1;
+}
+EXPORT_SYMBOL(wmt_plat_gpio_ctrl);
+
+INT32 wmt_plat_bgf_eint_ctrl(ENUM_PIN_STATE state)
+{
+#if defined(CONFIG_MTK_GPIO_LEGACY)
+#ifdef GPIO_COMBO_BGF_EINT_PIN
+	switch (state) {
+	case PIN_STA_INIT:
+		/*set to gpio input low, pull down enable */
+		mt_set_gpio_mode(GPIO_COMBO_BGF_EINT_PIN, GPIO_COMBO_BGF_EINT_PIN_M_GPIO);
+		mt_set_gpio_dir(GPIO_COMBO_BGF_EINT_PIN, GPIO_DIR_IN);
+		mt_set_gpio_pull_select(GPIO_COMBO_BGF_EINT_PIN, GPIO_PULL_DOWN);
+		mt_set_gpio_pull_enable(GPIO_COMBO_BGF_EINT_PIN, GPIO_PULL_ENABLE);
+		WMT_PLAT_DBG_FUNC("WMT-PLAT:BGFInt init(in pd)\n");
+		break;
+
+	case PIN_STA_MUX:
+		mt_set_gpio_mode(GPIO_COMBO_BGF_EINT_PIN, GPIO_COMBO_BGF_EINT_PIN_M_GPIO);
+		mt_set_gpio_pull_enable(GPIO_COMBO_BGF_EINT_PIN, GPIO_PULL_ENABLE);
+		mt_set_gpio_pull_select(GPIO_COMBO_BGF_EINT_PIN, GPIO_PULL_UP);
+		mt_set_gpio_mode(GPIO_COMBO_BGF_EINT_PIN, GPIO_COMBO_BGF_EINT_PIN_M_EINT);
+		WMT_PLAT_DBG_FUNC("WMT-PLAT:BGFInt mux (eint)\n");
+		break;
+
+	case PIN_STA_IN_L:
+	case PIN_STA_DEINIT:
+		/*set to gpio input low, pull down enable */
+		mt_set_gpio_mode(GPIO_COMBO_BGF_EINT_PIN, GPIO_COMBO_BGF_EINT_PIN_M_GPIO);
+		mt_set_gpio_dir(GPIO_COMBO_BGF_EINT_PIN, GPIO_DIR_IN);
+		mt_set_gpio_pull_select(GPIO_COMBO_BGF_EINT_PIN, GPIO_PULL_DOWN);
+		mt_set_gpio_pull_enable(GPIO_COMBO_BGF_EINT_PIN, GPIO_PULL_ENABLE);
+		WMT_PLAT_DBG_FUNC("WMT-PLAT:BGFInt deinit(in pd)\n");
+		break;
+
+	default:
+		WMT_PLAT_WARN_FUNC("WMT-PLAT:Warnning, invalid state(%d) on BGF EINT\n", state);
+		break;
+	}
+#else
+	WMT_PLAT_INFO_FUNC("WMT-PLAT:BGF EINT not defined\n");
+#endif
+#else /* #if defined(CONFIG_MTK_GPIO_LEGACY) */
+#endif
+	return 0;
+}
+
+static INT32 wmt_plat_gps_sync_ctrl(ENUM_PIN_STATE state)
+{
+#if defined(CONFIG_MTK_GPIO_LEGACY)
+
+#ifdef GPIO_GPS_SYNC_PIN
+#ifndef GPIO_GPS_SYNC_PIN_M_GPS_SYNC
+#ifdef GPIO_GPS_SYNC_PIN_M_MD1_GPS_SYNC
+#define GPIO_GPS_SYNC_PIN_M_GPS_SYNC GPIO_GPS_SYNC_PIN_M_MD1_GPS_SYNC
+#else
+#ifdef GPIO_GPS_SYNC_PIN_M_MD2_GPS_SYNC
+#define GPIO_GPS_SYNC_PIN_M_GPS_SYNC GPIO_GPS_SYNC_PIN_M_MD2_GPS_SYNC
+#endif
+#endif
+#endif
+	switch (state) {
+	case PIN_STA_INIT:
+	case PIN_STA_DEINIT:
+		mt_set_gpio_mode(GPIO_GPS_SYNC_PIN, GPIO_GPS_SYNC_PIN_M_GPIO);
+		mt_set_gpio_dir(GPIO_GPS_SYNC_PIN, GPIO_DIR_OUT);
+		mt_set_gpio_out(GPIO_GPS_SYNC_PIN, GPIO_OUT_ZERO);
+		break;
+
+	case PIN_STA_MUX:
+		mt_set_gpio_mode(GPIO_GPS_SYNC_PIN, GPIO_GPS_SYNC_PIN_M_GPS_SYNC);
+		break;
+
+	default:
+		break;
+	}
+#endif
+
+#else /* #if defined(CONFIG_MTK_GPIO_LEGACY) */
+#endif
+	return 0;
+}
+
+#if MTK_WCN_MT6306_IS_READY
+/* MT6306 GPIO7 is GPIO_GPS_LNA_EN, for K2 common phone pin modification	*/
+static INT32 wmt_plat_gps_lna_ctrl(ENUM_PIN_STATE state)
+{
+#ifdef GPIO_GPS_LNA_PIN
+	switch (state) {
+	case PIN_STA_INIT:
+	case PIN_STA_DEINIT:
+		WMT_PLAT_ERR_FUNC("Gps LNA pin ctrl %d!\n", state);
+		mt6306_set_gpio_dir(GPIO_GPS_LNA_PIN, GPIO_DIR_OUT);
+		mt6306_set_gpio_out(GPIO_GPS_LNA_PIN, GPIO_OUT_ZERO);
+		break;
+	case PIN_STA_OUT_H:
+		WMT_PLAT_ERR_FUNC("Gps LNA pin output high!\n");
+		mt6306_set_gpio_out(GPIO_GPS_LNA_PIN, GPIO_OUT_ONE);
+		break;
+	case PIN_STA_OUT_L:
+		WMT_PLAT_ERR_FUNC("Gps LNA pin output low!\n");
+		mt6306_set_gpio_out(GPIO_GPS_LNA_PIN, GPIO_OUT_ZERO);
+		break;
+	default:
+		WMT_PLAT_WARN_FUNC("%d mode not defined for  gps lna pin !!!\n", state);
+		break;
+	}
+	return 0;
+#else
+	WMT_PLAT_WARN_FUNC("host gps lna pin not defined!!!\n");
+	    return 0;
+#endif
+}
+#else
+
+static INT32 wmt_plat_gps_lna_ctrl(ENUM_PIN_STATE state)
+{
+#if !defined(CONFIG_MTK_GPIO_LEGACY)
+	static struct pinctrl_state *gps_lna_init;
+	static struct pinctrl_state *gps_lna_oh;
+	static struct pinctrl_state *gps_lna_ol;
+	static struct pinctrl *consys_pinctrl;
+
+	WMT_PLAT_DBG_FUNC("ENTER++\n");
+	consys_pinctrl = mtk_wcn_consys_get_pinctrl();
+	if (NULL == consys_pinctrl) {
+		WMT_PLAT_ERR_FUNC("get consys pinctrl fail\n");
+		return -1;
+	}
+
+	gps_lna_init = pinctrl_lookup_state(consys_pinctrl, "gps_lna_state_init");
+	if (NULL == gps_lna_init) {
+		WMT_PLAT_ERR_FUNC("Cannot find gps lna pin init state!\n");
+		return -2;
+	}
+
+	gps_lna_oh = pinctrl_lookup_state(consys_pinctrl, "gps_lna_state_oh");
+	if (NULL == gps_lna_oh) {
+		WMT_PLAT_ERR_FUNC("Cannot find gps lna pin oh state!\n");
+		return -3;
+	}
+
+	gps_lna_ol = pinctrl_lookup_state(consys_pinctrl, "gps_lna_state_ol");
+	if (NULL == gps_lna_ol) {
+		WMT_PLAT_ERR_FUNC("Cannot find gps lna pin ol state!\n");
+		return -4;
+	}
+
+	switch (state) {
+	case PIN_STA_INIT:
+	case PIN_STA_DEINIT:
+		pinctrl_select_state(consys_pinctrl, gps_lna_init);
+		WMT_PLAT_INFO_FUNC("set gps lna to init\n");
+		break;
+	case PIN_STA_OUT_H:
+		pinctrl_select_state(consys_pinctrl, gps_lna_oh);
+		WMT_PLAT_INFO_FUNC("set gps lna to oh\n");
+		break;
+	case PIN_STA_OUT_L:
+		pinctrl_select_state(consys_pinctrl, gps_lna_ol);
+		WMT_PLAT_INFO_FUNC("set gps lna to ol\n");
+		break;
+
+	default:
+		WMT_PLAT_WARN_FUNC("%d mode not defined for  gps lna pin !!!\n", state);
+		break;
+	}
+	return 0;
+#else
+#ifdef GPIO_GPS_LNA_PIN
+	switch (state) {
+	case PIN_STA_INIT:
+	case PIN_STA_DEINIT:
+		mt_set_gpio_pull_enable(GPIO_GPS_LNA_PIN, GPIO_PULL_DISABLE);
+		mt_set_gpio_dir(GPIO_GPS_LNA_PIN, GPIO_DIR_OUT);
+		mt_set_gpio_mode(GPIO_GPS_LNA_PIN, GPIO_GPS_LNA_PIN_M_GPIO);
+		mt_set_gpio_out(GPIO_GPS_LNA_PIN, GPIO_OUT_ZERO);
+		break;
+	case PIN_STA_OUT_H:
+		mt_set_gpio_out(GPIO_GPS_LNA_PIN, GPIO_OUT_ONE);
+		break;
+	case PIN_STA_OUT_L:
+		mt_set_gpio_out(GPIO_GPS_LNA_PIN, GPIO_OUT_ZERO);
+		break;
+
+	default:
+		WMT_PLAT_WARN_FUNC("%d mode not defined for  gps lna pin !!!\n", state);
+		break;
+	}
+	return 0;
+#else
+	WMT_PLAT_WARN_FUNC("host gps lna pin not defined!!!\n");
+	    return 0;
+#endif
+#endif /* !defined(CONFIG_MTK_GPIO_LEGACY) */
+}
+#endif
+
+INT32 wmt_plat_i2s_ctrl(ENUM_PIN_STATE state)
+{
+	/* TODO: [NewFeature][GeorgeKuo]: GPIO_I2Sx is changed according to different project. */
+	/* TODO: provide a translation table in board_custom.h for different ALPS project customization. */
+#if defined(CONFIG_MTK_GPIO_LEGACY)
+
+#if defined(FM_DIGITAL_INPUT) || defined(FM_DIGITAL_OUTPUT)
+#if defined(GPIO_COMBO_I2S_CK_PIN)
+	switch (state) {
+	case PIN_STA_INIT:
+	case PIN_STA_MUX:
+		mt_set_gpio_mode(GPIO_COMBO_I2S_CK_PIN, GPIO_COMBO_I2S_CK_PIN_M_I2S0_CK);
+		mt_set_gpio_mode(GPIO_COMBO_I2S_WS_PIN, GPIO_COMBO_I2S_WS_PIN_M_I2S0_WS);
+		mt_set_gpio_mode(GPIO_COMBO_I2S_DAT_PIN, GPIO_COMBO_I2S_DAT_PIN_M_I2S0_DAT);
+		WMT_PLAT_DBG_FUNC("WMT-PLAT:I2S init (I2S0 system)\n");
+		break;
+	case PIN_STA_IN_L:
+	case PIN_STA_DEINIT:
+		mt_set_gpio_mode(GPIO_COMBO_I2S_CK_PIN, GPIO_COMBO_I2S_CK_PIN_M_GPIO);
+		mt_set_gpio_dir(GPIO_COMBO_I2S_CK_PIN, GPIO_DIR_OUT);
+		mt_set_gpio_out(GPIO_COMBO_I2S_CK_PIN, GPIO_OUT_ZERO);
+
+		mt_set_gpio_mode(GPIO_COMBO_I2S_WS_PIN, GPIO_COMBO_I2S_WS_PIN_M_GPIO);
+		mt_set_gpio_dir(GPIO_COMBO_I2S_WS_PIN, GPIO_DIR_OUT);
+		mt_set_gpio_out(GPIO_COMBO_I2S_WS_PIN, GPIO_OUT_ZERO);
+
+		mt_set_gpio_mode(GPIO_COMBO_I2S_DAT_PIN, GPIO_COMBO_I2S_DAT_PIN_M_GPIO);
+		mt_set_gpio_dir(GPIO_COMBO_I2S_DAT_PIN, GPIO_DIR_OUT);
+		mt_set_gpio_out(GPIO_COMBO_I2S_DAT_PIN, GPIO_OUT_ZERO);
+		WMT_PLAT_DBG_FUNC("WMT-PLAT:I2S deinit (out 0)\n");
+		break;
+	default:
+		WMT_PLAT_WARN_FUNC("WMT-PLAT:Warnning, invalid state(%d) on I2S Group\n", state);
+		break;
+	}
+#else
+	WMT_PLAT_ERR_FUNC("[MT6620]Error:FM digital mode set, but no I2S GPIOs defined\n");
+#endif
+#else
+	WMT_PLAT_INFO_FUNC
+	    ("[MT6620]warnning:FM digital mode is not set, no I2S GPIO settings should be modified by combo driver\n");
+#endif
+
+#else /* #if defined(CONFIG_MTK_GPIO_LEGACY) */
+#endif
+	return 0;
+}
+
+INT32 wmt_plat_wake_lock_ctrl(ENUM_WL_OP opId)
+{
+#ifdef CFG_WMT_WAKELOCK_SUPPORT
+	static INT32 counter;
+	INT32 status;
+	INT32 ret = 0;
+
+	ret = mutex_lock_killable(&gOsSLock);
+	if (ret) {
+		WMT_PLAT_ERR_FUNC("--->lock gOsSLock failed, ret=%d\n", ret);
+		return ret;
+	}
+
+	if (WL_OP_GET == opId)
+		++counter;
+	else if (WL_OP_PUT == opId)
+		--counter;
+
+	mutex_unlock(&gOsSLock);
+	if (WL_OP_GET == opId && counter == 1) {
+		__pm_stay_awake(wmtWakeLock);
+		status = wmtWakeLock->active;
+		WMT_PLAT_DBG_FUNC("WMT-PLAT: after wake_lock(%d), counter(%d)\n", status, counter);
+
+	} else if (WL_OP_PUT == opId && counter == 0) {
+		__pm_relax(wmtWakeLock);
+		status = wmtWakeLock->active;
+		WMT_PLAT_DBG_FUNC("WMT-PLAT: after wake_unlock(%d), counter(%d)\n", status, counter);
+	} else {
+		status = wmtWakeLock->active;
+		WMT_PLAT_WARN_FUNC("WMT-PLAT: wakelock status(%d), counter(%d)\n", status, counter);
+	}
+	return 0;
+#else
+	WMT_PLAT_WARN_FUNC("WMT-PLAT: host awake function is not supported.\n");
+	return 0;
+
+#endif
+}
+EXPORT_SYMBOL(wmt_plat_wake_lock_ctrl);
+
+INT32 wmt_plat_soc_paldo_ctrl(ENUM_PALDO_TYPE ePt, ENUM_PALDO_OP ePo)
+{
+	INT32 iRet = 0;
+
+	switch (ePt) {
+
+	case BT_PALDO:
+		iRet = mtk_wcn_consys_hw_bt_paldo_ctrl(ePo);
+		break;
+	case WIFI_PALDO:
+		iRet = mtk_wcn_consys_hw_wifi_paldo_ctrl(ePo);
+		break;
+	case FM_PALDO:
+	case GPS_PALDO:
+		iRet = mtk_wcn_consys_hw_vcn28_ctrl(ePo);
+		break;
+	default:
+		WMT_PLAT_WARN_FUNC("WMT-PLAT:Warnning, invalid type(%d) in palod_ctrl\n", ePt);
+		break;
+	}
+	return iRet;
+}
+EXPORT_SYMBOL(wmt_plat_soc_paldo_ctrl);
+
+UINT8 *wmt_plat_get_emi_virt_add(UINT32 offset)
+{
+	return mtk_wcn_consys_emi_virt_addr_get(offset);
+}
+EXPORT_SYMBOL(wmt_plat_get_emi_virt_add);
+
+P_CONSYS_EMI_ADDR_INFO wmt_plat_get_emi_phy_add(VOID)
+{
+	return &mtk_wcn_emi_addr_info;
+}
+EXPORT_SYMBOL(wmt_plat_get_emi_phy_add);
+
+#if CONSYS_ENALBE_SET_JTAG
+UINT32 wmt_plat_jtag_flag_ctrl(UINT32 en)
+{
+	return 0;
+}
+EXPORT_SYMBOL(wmt_plat_jtag_flag_ctrl);
+#endif
+
+#if CFG_WMT_DUMP_INT_STATUS
+VOID wmt_plat_BGF_irq_dump_status(VOID)
+{
+	WMT_PLAT_INFO_FUNC("this function is null in MT8127\n");
+}
+EXPORT_SYMBOL(wmt_plat_BGF_irq_dump_status);
+
+MTK_WCN_BOOL wmt_plat_dump_BGF_irq_status(VOID)
+{
+	return MTK_WCN_BOOL_FALSE;
+}
+EXPORT_SYMBOL(wmt_plat_dump_BGF_irq_status);
+#endif
+
+UINT32 wmt_plat_read_cpupcr(void)
+{
+	return CONSYS_REG_READ(conn_reg.mcu_base + CONSYS_CPUPCR_OFFSET);
+}
+EXPORT_SYMBOL(wmt_plat_read_cpupcr);
+
+UINT32 wmt_plat_read_dmaregs(UINT32 type)
+{
+	return 0;
+#if 0
+	switch (type) {
+	case CONNSYS_CLK_GATE_STATUS:
+		return CONSYS_REG_READ(CONNSYS_CLK_GATE_STATUS_REG);
+	case CONSYS_EMI_STATUS:
+		return CONSYS_REG_READ(CONSYS_EMI_STATUS_REG);
+	case SYSRAM1:
+		return CONSYS_REG_READ(SYSRAM1_REG);
+	case SYSRAM2:
+		return CONSYS_REG_READ(SYSRAM2_REG);
+	case SYSRAM3:
+		return CONSYS_REG_READ(SYSRAM3_REG);
+	default:
+		return 0;
+	}
+#endif
+}
+
+INT32 wmt_plat_set_host_dump_state(ENUM_HOST_DUMP_STATE state)
+{
+	PUINT8 p_virtual_addr = NULL;
+
+	p_virtual_addr = wmt_plat_get_emi_virt_add(EXP_APMEM_CTRL_HOST_SYNC_STATE);
+	if (!p_virtual_addr) {
+		WMT_PLAT_ERR_FUNC("get virtual address fail\n");
+		return -1;
+	}
+
+	CONSYS_REG_WRITE(p_virtual_addr, state);
+
+	return 0;
+}
+EXPORT_SYMBOL(wmt_plat_set_host_dump_state);
+
+UINT32 wmt_plat_force_trigger_assert(ENUM_FORCE_TRG_ASSERT_T type)
+{
+	PUINT8 p_virtual_addr = NULL;
+
+	switch (type) {
+	case STP_FORCE_TRG_ASSERT_EMI:
+
+		WMT_PLAT_INFO_FUNC("[Force Assert] stp_trigger_firmware_assert_via_emi -->\n");
+		p_virtual_addr = wmt_plat_get_emi_virt_add(EXP_APMEM_CTRL_HOST_OUTBAND_ASSERT_W1);
+		if (!p_virtual_addr) {
+			WMT_PLAT_ERR_FUNC("get virtual address fail\n");
+			return -1;
+		}
+
+		CONSYS_REG_WRITE(p_virtual_addr, EXP_APMEM_HOST_OUTBAND_ASSERT_MAGIC_W1);
+		WMT_PLAT_INFO_FUNC("[Force Assert] stp_trigger_firmware_assert_via_emi <--\n");
+		break;
+	case STP_FORCE_TRG_ASSERT_DEBUG_PIN:
+
+		CONSYS_REG_WRITE(conn_reg.topckgen_base + CONSYS_AP2CONN_OSC_EN_OFFSET,
+				 CONSYS_REG_READ(conn_reg.topckgen_base +
+						 CONSYS_AP2CONN_OSC_EN_OFFSET) & ~CONSYS_AP2CONN_WAKEUP_BIT);
+		WMT_PLAT_INFO_FUNC("enable:dump CONSYS_AP2CONN_OSC_EN_REG(0x%x)\n",
+				   CONSYS_REG_READ(conn_reg.topckgen_base + CONSYS_AP2CONN_OSC_EN_OFFSET));
+		usleep_range(64, 96);
+		CONSYS_REG_WRITE(conn_reg.topckgen_base + CONSYS_AP2CONN_OSC_EN_OFFSET,
+				 CONSYS_REG_READ(conn_reg.topckgen_base +
+						 CONSYS_AP2CONN_OSC_EN_OFFSET) | CONSYS_AP2CONN_WAKEUP_BIT);
+		WMT_PLAT_INFO_FUNC("disable:dump CONSYS_AP2CONN_OSC_EN_REG(0x%x)\n",
+				   CONSYS_REG_READ(conn_reg.topckgen_base + CONSYS_AP2CONN_OSC_EN_OFFSET));
+
+		break;
+	default:
+		WMT_PLAT_ERR_FUNC("unknown force trigger assert type\n");
+		break;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(wmt_plat_force_trigger_assert);
+
+INT32 wmt_plat_update_host_sync_num(VOID)
+{
+	PUINT8 p_virtual_addr = NULL;
+	UINT32 sync_num = 0;
+
+	p_virtual_addr = wmt_plat_get_emi_virt_add(EXP_APMEM_CTRL_HOST_SYNC_NUM);
+	if (!p_virtual_addr) {
+		WMT_PLAT_ERR_FUNC("get virtual address fail\n");
+		return -1;
+	}
+
+	sync_num = CONSYS_REG_READ(p_virtual_addr);
+	CONSYS_REG_WRITE(p_virtual_addr, sync_num + 1);
+
+	return 0;
+}
+EXPORT_SYMBOL(wmt_plat_update_host_sync_num);
+
+INT32 wmt_plat_get_dump_info(UINT32 offset)
+{
+	PUINT8 p_virtual_addr = NULL;
+
+	p_virtual_addr = wmt_plat_get_emi_virt_add(offset);
+	if (!p_virtual_addr) {
+		WMT_PLAT_ERR_FUNC("get virtual address fail\n");
+		return -1;
+	}
+	WMT_PLAT_INFO_FUNC("connsys_reg_read (0x%x), (0x%p), (0x%x)\n", CONSYS_REG_READ(p_virtual_addr), p_virtual_addr,
+			   offset);
+	return CONSYS_REG_READ(p_virtual_addr);
+}
+EXPORT_SYMBOL(wmt_plat_get_dump_info);
+
+UINT32 wmt_plat_get_soc_chipid(void)
+{
+	UINT32 chipId = mtk_wcn_consys_soc_chipid();
+
+	WMT_PLAT_INFO_FUNC("current SOC chip:0x%x\n", chipId);
+	return chipId;
+}
+EXPORT_SYMBOL(wmt_plat_get_soc_chipid);
+
+#if CFG_WMT_LTE_COEX_HANDLING
+INT32 wmt_plat_get_tdm_antsel_index(VOID)
+{
+	WMT_PLAT_INFO_FUNC("not support LTE in this platform\n");
+	return 0;
+}
+EXPORT_SYMBOL(wmt_plat_get_tdm_antsel_index);
+#endif
+INT32 wmt_plat_set_dbg_mode(UINT32 flag)
+{
+	return -1;
+}
+VOID wmt_plat_set_dynamic_dumpmem(UINT32 *buf)
+{
+	mtk_wcn_consys_set_dynamic_dump(buf);
+}
