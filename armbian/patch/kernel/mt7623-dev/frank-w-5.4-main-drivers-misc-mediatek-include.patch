diff --git a/drivers/misc/mediatek/include/mt-plat/aee.h b/drivers/misc/mediatek/include/mt-plat/aee.h
new file mode 100644
index 00000000..d1cf448
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/aee.h
@@ -0,0 +1,284 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#if !defined(__AEE_H__)
+#define __AEE_H__
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+
+#define AEE_MODULE_NAME_LENGTH 64
+#define AEE_PROCESS_NAME_LENGTH 256
+#define AEE_BACKTRACE_LENGTH 3072
+
+typedef enum {
+	AE_DEFECT_FATAL,
+	AE_DEFECT_EXCEPTION,
+	AE_DEFECT_WARNING,
+	AE_DEFECT_REMINDING,
+	AE_DEFECT_ATTR_END
+} AE_DEFECT_ATTR;
+
+typedef enum {
+	AE_KE = 0,		/* Fatal Exception */
+	AE_HWT,
+	AE_REBOOT,
+	AE_NE,
+	AE_JE,
+	AE_SWT,
+	AE_EE,
+	AE_EXP_ERR_END,
+	AE_ANR,			/* Error or Warning or Defect */
+	AE_RESMON,
+	AE_MODEM_WARNING,
+	AE_WTF,
+	AE_WRN_ERR_END,
+	AE_MANUAL,		/* Manual Raise */
+	AE_EXP_CLASS_END,
+
+	AE_KERNEL_PROBLEM_REPORT = 1000,
+	AE_SYSTEM_JAVA_DEFECT,
+	AE_SYSTEM_NATIVE_DEFECT,
+	AE_MANUAL_MRDUMP_KEY,
+} AE_EXP_CLASS;			/* General Program Exception Class */
+
+typedef enum {
+	AEE_REBOOT_MODE_NORMAL = 0,
+	AEE_REBOOT_MODE_KERNEL_OOPS,
+	AEE_REBOOT_MODE_KERNEL_PANIC,
+	AEE_REBOOT_MODE_NESTED_EXCEPTION,
+	AEE_REBOOT_MODE_WDT,
+	AEE_REBOOT_MODE_MANUAL_KDUMP,
+} AEE_REBOOT_MODE;
+
+#define AEE_SZ_SYMBOL_L 140
+#define AEE_SZ_SYMBOL_S 80
+struct aee_bt_frame {
+	__u64 pc;
+	__u64 lr;
+	__u32 pad[5];
+	char pc_symbol[AEE_SZ_SYMBOL_S];	/* Now we use different symbol length for PC &LR */
+	char lr_symbol[AEE_SZ_SYMBOL_L];
+};
+
+/* aee_process_info struct should strictly small than ipanic_buffer, now 4KB */
+struct aee_process_info {
+	char process_path[AEE_PROCESS_NAME_LENGTH];
+	char backtrace[AEE_BACKTRACE_LENGTH];
+	struct aee_bt_frame ke_frame;
+};
+
+struct aee_process_bt {
+	__u32 pid;
+	__u32 nr_entries;
+	struct aee_bt_frame *entries;
+};
+
+
+struct aee_thread_reg {
+	pid_t tid;
+	struct pt_regs regs;
+};
+
+struct aee_user_thread_stack {
+	pid_t tid;
+	int StackLength;
+	unsigned char *Userthread_Stack; /*8k stack ,define to char only for match 64bit/32bit*/
+};
+
+struct aee_user_thread_maps {
+	pid_t tid;
+	int Userthread_mapsLength;
+	unsigned char *Userthread_maps; /*8k stack ,define to char only for match 64bit/32bit*/
+};
+
+
+
+struct aee_oops {
+	struct list_head list;
+	AE_DEFECT_ATTR attr;
+	AE_EXP_CLASS clazz;
+
+	char module[AEE_MODULE_NAME_LENGTH];
+	/* consist with struct aee_process_info */
+	char process_path[AEE_PROCESS_NAME_LENGTH];
+	char backtrace[AEE_BACKTRACE_LENGTH];
+	struct aee_bt_frame ke_frame;
+
+	char *detail;
+	int detail_len;
+
+	char *console;
+	int console_len;
+
+	char *android_main;
+	int android_main_len;
+	char *android_radio;
+	int android_radio_len;
+	char *android_system;
+	int android_system_len;
+
+	char *userspace_info;
+	int userspace_info_len;
+
+	char *mmprofile;
+	int mmprofile_len;
+
+	char *mini_rdump;
+	int mini_rdump_len;
+
+
+	struct aee_user_thread_stack userthread_stack;
+	struct aee_thread_reg userthread_reg;
+	struct aee_user_thread_maps userthread_maps;
+
+	int dump_option;
+};
+
+struct aee_kernel_api {
+	void (*kernel_reportAPI)(const AE_DEFECT_ATTR attr, const int db_opt, const char *module,
+		     const char *msg);
+	void (*md_exception)(const char *assert_type, const int *log, int log_size, const int *phy,
+		     int phy_size, const char *detail, const int db_opt);
+	void (*md32_exception)(const char *assert_type, const int *log, int log_size,
+		     const int *phy, int phy_size, const char *detail, const int db_opt);
+	void (*combo_exception)(const char *assert_type, const int *log, int log_size,
+		     const int *phy, int phy_size, const char *detail, const int db_opt);
+	void (*scp_exception)(const char *assert_type, const int *log, int log_size,
+		     const int *phy, int phy_size, const char *detail, const int db_opt);
+};
+
+void aee_sram_printk(const char *fmt, ...);
+int aee_nested_printf(const char *fmt, ...);
+void aee_wdt_irq_info(void);
+void aee_wdt_fiq_info(void *arg, void *regs, void *svc_sp);
+void aee_trigger_kdb(void);
+struct aee_oops *aee_oops_create(AE_DEFECT_ATTR attr, AE_EXP_CLASS clazz, const char *module);
+void aee_oops_set_backtrace(struct aee_oops *oops, const char *backtrace);
+void aee_oops_set_process_path(struct aee_oops *oops, const char *process_path);
+void aee_oops_free(struct aee_oops *oops);
+/* powerkey press,modules use bits */
+#define AE_WDT_Powerkey_DEVICE_PATH		"/dev/kick_powerkey"
+#define WDT_SETBY_DEFAULT		(0)
+#define WDT_SETBY_Backlight		(1<<0)
+#define WDT_SETBY_Display			(1<<1)
+#define WDT_SETBY_SF				(1<<2)
+#define WDT_SETBY_PM				(1<<3)
+#define WDT_SETBY_WMS_DISABLE_PWK_MONITOR	(0xAEEAEE00)
+#define WDT_SETBY_WMS_ENABLE_PWK_MONITOR	(0xAEEAEE01)
+#define WDT_PWK_HANG_FORCE_HWT				(0xAEE0FFFF)
+
+/* QHQ RT Monitor */
+#define AEEIOCTL_RT_MON_Kick _IOR('p', 0x0A, int)
+#define AE_WDT_DEVICE_PATH      "/dev/RT_Monitor"
+/* QHQ RT Monitor    end */
+
+/* DB dump option bits, set relative bit to 1 to include related file in db */
+#define DB_OPT_DEFAULT                  (0)
+#define DB_OPT_FTRACE                   (1<<0)
+#define DB_OPT_PRINTK_TOO_MUCH          (1<<1)
+#define DB_OPT_NE_JBT_TRACES            (1<<2)
+#define DB_OPT_SWT_JBT_TRACES           (1<<3)
+#define DB_OPT_VM_TRACES                (1<<4)
+#define DB_OPT_DUMPSYS_ACTIVITY         (1<<5)
+#define DB_OPT_DUMPSYS_WINDOW           (1<<6)
+#define DB_OPT_DUMPSYS_GFXINFO          (1<<7)
+#define DB_OPT_DUMPSYS_SURFACEFLINGER   (1<<8)
+#define DB_OPT_DISPLAY_HANG_DUMP        (1<<9)
+#define DB_OPT_LOW_MEMORY_KILLER        (1<<10)
+#define DB_OPT_PROC_MEM                 (1<<11)
+#define DB_OPT_FS_IO_LOG                (1<<12)
+#define DB_OPT_PROCESS_COREDUMP         (1<<13)
+#define DB_OPT_VM_HPROF                 (1<<14)
+#define DB_OPT_PROCMEM                  (1<<15)
+#define DB_OPT_DUMPSYS_INPUT            (1<<16)
+#define DB_OPT_MMPROFILE_BUFFER         (1<<17)
+#define DB_OPT_BINDER_INFO              (1<<18)
+#define DB_OPT_WCN_ISSUE_INFO           (1<<19)
+#define DB_OPT_DUMMY_DUMP               (1<<20)
+#define DB_OPT_PID_MEMORY_INFO          (1<<21)
+#define DB_OPT_VM_OOME_HPROF            (1<<22)
+#define DB_OPT_PID_SMAPS                (1<<23)
+#define DB_OPT_PROC_CMDQ_INFO           (1<<24)
+#define DB_OPT_PROC_USKTRK              (1<<25)
+#define DB_OPT_SF_RTT_DUMP              (1<<26)
+#define DB_OPT_PAGETYPE_INFO            (1<<27)
+#define DB_OPT_DUMPSYS_PROCSTATS        (1<<28)
+#define DB_OPT_DUMP_DISPLAY             (1<<29)
+#define DB_OPT_NATIVE_BACKTRACE		(1<<30)
+#define DB_OPT_AARCH64			(1<<31)
+
+#define aee_kernel_exception(module, msg...)	\
+	aee_kernel_exception_api(__FILE__, __LINE__, DB_OPT_DEFAULT, module, msg)
+#define aee_kernel_warning(module, msg...)	\
+	aee_kernel_warning_api(__FILE__, __LINE__, DB_OPT_DEFAULT, module, msg)
+#define aee_kernel_reminding(module, msg...)	\
+	aee_kernel_reminding_api(__FILE__, __LINE__, DB_OPT_DEFAULT, module, msg)
+#define aee_kernel_dal_show(msg)	\
+	aee_kernel_dal_api(__FILE__, __LINE__, msg)
+
+#define aed_md_exception(log, log_size, phy, phy_size, detail)	\
+	aed_md_exception_api(log, log_size, phy, phy_size, detail, DB_OPT_DEFAULT)
+#define aed_md32_exception(log, log_size, phy, phy_size, detail)	\
+	aed_md32_exception_api(log, log_size, phy, phy_size, detail, DB_OPT_DEFAULT)
+#define aed_scp_exception(log, log_size, phy, phy_size, detail)	\
+	aed_scp_exception_api(log, log_size, phy, phy_size, detail, DB_OPT_DEFAULT)
+#define aed_combo_exception(log, log_size, phy, phy_size, detail)	\
+	aed_combo_exception_api(log, log_size, phy, phy_size, detail, DB_OPT_DEFAULT)
+
+void aee_kernel_exception_api(const char *file, const int line, const int db_opt,
+			      const char *module, const char *msg, ...);
+void aee_kernel_warning_api(const char *file, const int line, const int db_opt, const char *module,
+			    const char *msg, ...);
+void aee_kernel_reminding_api(const char *file, const int line, const int db_opt,
+			      const char *module, const char *msg, ...);
+void aee_kernel_dal_api(const char *file, const int line, const char *msg);
+
+void aed_md_exception_api(const int *log, int log_size, const int *phy, int phy_size,
+			  const char *detail, const int db_opt);
+void aed_md32_exception_api(const int *log, int log_size, const int *phy, int phy_size,
+			    const char *detail, const int db_opt);
+void aed_scp_exception_api(const int *log, int log_size, const int *phy, int phy_size,
+			    const char *detail, const int db_opt);
+void aed_combo_exception_api(const int *log, int log_size, const int *phy, int phy_size,
+			     const char *detail, const int db_opt);
+
+void aee_kernel_wdt_kick_Powkey_api(const char *module, int msg);
+int aee_kernel_wdt_kick_api(int kinterval);
+void aee_powerkey_notify_press(unsigned long pressed);
+int aee_kernel_Powerkey_is_press(void);
+
+void ipanic_recursive_ke(struct pt_regs *regs, struct pt_regs *excp_regs, int cpu);
+
+/* QHQ RT Monitor */
+void aee_kernel_RT_Monitor_api(int lParam);
+/* QHQ RT Monitor    end */
+void mt_fiq_printf(const char *fmt, ...);
+void aee_register_api(struct aee_kernel_api *aee_api);
+int aee_in_nested_panic(void);
+void aee_stop_nested_panic(struct pt_regs *regs);
+void aee_wdt_dump_info(void);
+void aee_wdt_printf(const char *fmt, ...);
+
+void aee_fiq_ipi_cpu_stop(void *arg, void *regs, void *svc_sp);
+
+#if defined(CONFIG_MTK_AEE_DRAM_CONSOLE)
+void aee_dram_console_reserve_memory(void);
+#else
+static inline void aee_dram_console_reserve_memory(void)
+{
+}
+#endif
+
+extern void *aee_excp_regs;	/* To store latest exception, in case of stack corruption */
+#endif				/* __AEE_H__ */
diff --git a/drivers/misc/mediatek/include/mt-plat/mrdump.h b/drivers/misc/mediatek/include/mt-plat/mrdump.h
new file mode 100644
index 00000000..b6bdfa2
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mrdump.h
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2016 MediaTek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ */
+
+#if !defined(__MRDUMP_H__)
+#define __MRDUMP_H__
+
+#include <stdarg.h>
+#include <linux/elf.h>
+#include <linux/elfcore.h>
+#include <asm/ptrace.h>
+#include <mt-plat/aee.h>
+
+#ifdef __aarch64__
+#define reg_pc	pc
+#define reg_lr	regs[30]
+#define reg_sp	sp
+#define reg_fp	regs[29]
+#else
+#define reg_pc	ARM_pc
+#define reg_lr	ARM_lr
+#define reg_sp	ARM_sp
+#define reg_ip	ARM_ip
+#define reg_fp	ARM_fp
+#endif
+
+#define MRDUMP_CPU_MAX 16
+
+#define MRDUMP_DEV_NULL 0
+#define MRDUMP_DEV_SDCARD 1
+#define MRDUMP_DEV_EMMC 2
+
+#define MRDUMP_FS_NULL 0
+#define MRDUMP_FS_VFAT 1
+#define MRDUMP_FS_EXT4 2
+
+#define MRDUMP_GO_DUMP "MRDUMP04"
+
+typedef uint32_t arm32_gregset_t[18];
+typedef uint64_t aarch64_gregset_t[34];
+
+struct mrdump_crash_record {
+	int reboot_mode;
+
+	char msg[128];
+	char backtrace[512];
+
+	uint32_t fault_cpu;
+
+	union {
+		arm32_gregset_t arm32_regs;
+		aarch64_gregset_t aarch64_regs;
+	} cpu_regs[MRDUMP_CPU_MAX];
+};
+
+struct mrdump_machdesc {
+	uint32_t crc;
+
+	uint32_t output_device;
+
+	uint32_t nr_cpus;
+
+	uint64_t page_offset;
+	uint64_t high_memory;
+
+	uint64_t vmalloc_start;
+	uint64_t vmalloc_end;
+
+	uint64_t modules_start;
+	uint64_t modules_end;
+
+	uint64_t phys_offset;
+	uint64_t master_page_table;
+
+	uint32_t output_fstype;
+	uint32_t output_lbaooo;
+};
+
+struct mrdump_control_block {
+	char sig[8];
+
+	struct mrdump_machdesc machdesc;
+	struct mrdump_crash_record crash_record;
+};
+
+/* NOTE!! any change to this struct should be compatible in aed */
+struct mrdump_mini_reg_desc {
+	unsigned long reg;	/* register value */
+	unsigned long kstart;	/* start kernel addr of memory dump */
+	unsigned long kend;	/* end kernel addr of memory dump */
+	unsigned long pos;	/* next pos to dump */
+	int valid;		/* 1: valid regiser, 0: invalid regiser */
+	int pad;		/* reserved */
+	loff_t offset;		/* offset in buffer */
+};
+
+/* it should always be smaller than MRDUMP_MINI_HEADER_SIZE */
+struct mrdump_mini_header {
+	struct mrdump_mini_reg_desc reg_desc[ELF_NGREG];
+};
+
+#define MRDUMP_MINI_NR_SECTION 60
+#define MRDUMP_MINI_SECTION_SIZE (32 * 1024)
+#define NT_IPANIC_MISC 4095
+#define MRDUMP_MINI_NR_MISC 20
+
+struct mrdump_mini_elf_misc {
+	unsigned long vaddr;
+	unsigned long paddr;
+	unsigned long start;
+	unsigned long size;
+};
+
+#define NOTE_NAME_SHORT 12
+#define NOTE_NAME_LONG  20
+
+struct mrdump_mini_elf_psinfo {
+		struct elf_note note;
+		char name[NOTE_NAME_SHORT];
+		struct elf_prpsinfo data;
+};
+
+struct mrdump_mini_elf_prstatus {
+		struct elf_note note;
+		char name[NOTE_NAME_SHORT];
+		struct elf_prstatus data;
+};
+
+struct mrdump_mini_elf_note {
+		struct elf_note note;
+		char name[NOTE_NAME_LONG];
+		struct mrdump_mini_elf_misc data;
+};
+
+struct mrdump_mini_elf_header {
+	struct elfhdr ehdr;
+	struct elf_phdr phdrs[MRDUMP_MINI_NR_SECTION];
+	struct mrdump_mini_elf_psinfo psinfo;
+	struct mrdump_mini_elf_prstatus prstatus[NR_CPUS + 1];
+	struct mrdump_mini_elf_note misc[MRDUMP_MINI_NR_MISC];
+};
+
+typedef struct mrdump_rsvmem_block {
+	phys_addr_t start_addr;
+	phys_addr_t size;
+} mrdump_rsvmem_block_t;
+
+
+#define MRDUMP_MINI_HEADER_SIZE ALIGN(sizeof(struct mrdump_mini_elf_header), PAGE_SIZE)
+#define MRDUMP_MINI_DATA_SIZE (MRDUMP_MINI_NR_SECTION * MRDUMP_MINI_SECTION_SIZE)
+#define MRDUMP_MINI_BUF_SIZE (MRDUMP_MINI_HEADER_SIZE + MRDUMP_MINI_DATA_SIZE)
+
+#ifdef CONFIG_MTK_RAM_CONSOLE_DRAM_ADDR
+#define MRDUMP_MINI_BUF_PADDR (CONFIG_MTK_RAM_CONSOLE_DRAM_ADDR + 0xf0000)
+#else
+#define MRDUMP_MINI_BUF_PADDR 0
+#endif
+
+int mrdump_init(void);
+void __mrdump_create_oops_dump(AEE_REBOOT_MODE reboot_mode, struct pt_regs *regs, const char *msg,
+			       ...);
+#if defined(CONFIG_MTK_AEE_IPANIC)
+void mrdump_rsvmem(void);
+#else
+static inline void mrdump_rsvmem(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MTK_AEE_MRDUMP)
+void aee_kdump_reboot(AEE_REBOOT_MODE, const char *msg, ...);
+#else
+static inline void aee_kdump_reboot(AEE_REBOOT_MODE reboot_mode, const char *msg, ...)
+{
+}
+#endif
+
+typedef int (*mrdump_write)(void *buf, int off, int len, int encrypt);
+#if defined(CONFIG_MTK_AEE_IPANIC)
+int mrdump_mini_create_oops_dump(AEE_REBOOT_MODE reboot_mode, mrdump_write write,
+				 loff_t sd_offset, const char *msg, va_list ap);
+void mrdump_mini_reserve_memory(void);
+#else
+static inline int mrdump_mini_create_oops_dump(AEE_REBOOT_MODE reboot_mode, mrdump_write write,
+					       loff_t sd_offset, const char *msg, va_list ap)
+{
+	return 0;
+}
+
+static inline void mrdump_mini_reserve_memory(void)
+{
+}
+#endif
+
+#endif
diff --git a/drivers/misc/mediatek/include/mt-plat/mt7622/include/mach/mtk_thermal.h b/drivers/misc/mediatek/include/mt-plat/mt7622/include/mach/mtk_thermal.h
new file mode 100644
index 00000000..1b60f00
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mt7622/include/mach/mtk_thermal.h
@@ -0,0 +1,295 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+
+#ifndef _MT8167_THERMAL_H
+#define _MT8167_THERMAL_H
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+
+#include <linux/io.h>
+#include <linux/uaccess.h>
+
+#include "sync_write.h"
+
+extern void __iomem *thermal_base;
+extern void __iomem *auxadc_ts_base;
+extern void __iomem *apmixed_base;
+extern void __iomem *pericfg_base;
+extern int auxadc_ts_phy_base;
+extern int apmixed_phy_base;
+
+#define THERM_CTRL_BASE_2 thermal_base
+#define AUXADC_BASE_2     auxadc_ts_base
+#define PERICFG_BASE	pericfg_base
+#define APMIXED_BASE_2    apmixed_base
+
+#define MT6752_EVB_BUILD_PASS /*Jerry fix build error FIX_ME*/
+
+/*******************************************************************************
+* AUXADC Register Definition
+******************************************************************************/
+/*AUXADC_BASE: 0xF1001000 from Vincent Liang 2014.5.8*/
+
+#define AUXADC_CON0_V       (AUXADC_BASE_2 + 0x000)	/*yes, 0x11003000*/
+#define AUXADC_CON1_V       (AUXADC_BASE_2 + 0x004)
+#define AUXADC_CON1_SET_V   (AUXADC_BASE_2 + 0x008)
+#define AUXADC_CON1_CLR_V   (AUXADC_BASE_2 + 0x00C)
+#define AUXADC_CON2_V       (AUXADC_BASE_2 + 0x010)
+/*#define AUXADC_CON3_V       (AUXADC_BASE_2 + 0x014)*/
+#define AUXADC_DAT0_V       (AUXADC_BASE_2 + 0x014)
+#define AUXADC_DAT1_V       (AUXADC_BASE_2 + 0x018)
+#define AUXADC_DAT2_V       (AUXADC_BASE_2 + 0x01C)
+#define AUXADC_DAT3_V       (AUXADC_BASE_2 + 0x020)
+#define AUXADC_DAT4_V       (AUXADC_BASE_2 + 0x024)
+#define AUXADC_DAT5_V       (AUXADC_BASE_2 + 0x028)
+#define AUXADC_DAT6_V       (AUXADC_BASE_2 + 0x02C)
+#define AUXADC_DAT7_V       (AUXADC_BASE_2 + 0x030)
+#define AUXADC_DAT8_V       (AUXADC_BASE_2 + 0x034)
+#define AUXADC_DAT9_V       (AUXADC_BASE_2 + 0x038)
+#define AUXADC_DAT10_V       (AUXADC_BASE_2 + 0x03C)
+#define AUXADC_DAT11_V       (AUXADC_BASE_2 + 0x040)
+#define AUXADC_MISC_V       (AUXADC_BASE_2 + 0x094)
+
+#define AUXADC_CON0_P       (auxadc_ts_phy_base + 0x000)
+#define AUXADC_CON1_P       (auxadc_ts_phy_base + 0x004)
+#define AUXADC_CON1_SET_P   (auxadc_ts_phy_base + 0x008)
+#define AUXADC_CON1_CLR_P   (auxadc_ts_phy_base + 0x00C)
+#define AUXADC_CON2_P       (auxadc_ts_phy_base + 0x010)
+/*#define AUXADC_CON3_P       (auxadc_ts_phy_base + 0x014)*/
+#define AUXADC_DAT0_P       (auxadc_ts_phy_base + 0x014)
+#define AUXADC_DAT1_P       (auxadc_ts_phy_base + 0x018)
+#define AUXADC_DAT2_P       (auxadc_ts_phy_base + 0x01C)
+#define AUXADC_DAT3_P       (auxadc_ts_phy_base + 0x020)
+#define AUXADC_DAT4_P       (auxadc_ts_phy_base + 0x024)
+#define AUXADC_DAT5_P       (auxadc_ts_phy_base + 0x028)
+#define AUXADC_DAT6_P       (auxadc_ts_phy_base + 0x02C)
+#define AUXADC_DAT7_P       (auxadc_ts_phy_base + 0x030)
+#define AUXADC_DAT8_P       (auxadc_ts_phy_base + 0x034)
+#define AUXADC_DAT9_P       (auxadc_ts_phy_base + 0x038)
+#define AUXADC_DAT10_P       (auxadc_ts_phy_base + 0x03C)
+#define AUXADC_DAT11_P       (auxadc_ts_phy_base + 0x040)
+
+#define AUXADC_MISC_P       (auxadc_ts_phy_base + 0x094)
+
+/*******************************************************************************
+* Peripheral Configuration Register Definition
+******************************************************************************/
+/*#define PERICFG_BASE (0x10002000)*/
+#define PERI_GLOBALCON_RST0 (pericfg_base + 0x000) /*yes, 0x10002000*/
+/*******************************************************************************
+ * APMixedSys Configuration Register Definition
+ ******************************************************************************/
+#define TS_CON0             (APMIXED_BASE_2 + 0x600) /*yes 0x10209000*/
+#define TS_CON1             (APMIXED_BASE_2 + 0x604)
+#define TS_CON0_TM             (APMIXED_BASE_2 + 0x600)	/* yes 0x10209000 */
+#define TS_CON1_TM             (APMIXED_BASE_2 + 0x604)
+#define TS_CON0_P           (apmixed_phy_base + 0x600)
+#define TS_CON1_P           (apmixed_phy_base + 0x604)
+
+/*******************************************************************************
+ * Thermal Controller Register Definition
+ ******************************************************************************/
+#define TEMPMONCTL0         (THERM_CTRL_BASE_2 + 0x000) /*yes 0x1100B000*/
+#define TEMPMONCTL1         (THERM_CTRL_BASE_2 + 0x004)
+#define TEMPMONCTL2         (THERM_CTRL_BASE_2 + 0x008)
+#define TEMPMONINT          (THERM_CTRL_BASE_2 + 0x00C)
+#define TEMPMONINTSTS       (THERM_CTRL_BASE_2 + 0x010)
+#define TEMPMONIDET0        (THERM_CTRL_BASE_2 + 0x014)
+#define TEMPMONIDET1        (THERM_CTRL_BASE_2 + 0x018)
+#define TEMPMONIDET2        (THERM_CTRL_BASE_2 + 0x01C)
+#define TEMPH2NTHRE         (THERM_CTRL_BASE_2 + 0x024)
+#define TEMPHTHRE           (THERM_CTRL_BASE_2 + 0x028)
+#define TEMPCTHRE           (THERM_CTRL_BASE_2 + 0x02C)
+#define TEMPOFFSETH         (THERM_CTRL_BASE_2 + 0x030)
+#define TEMPOFFSETL         (THERM_CTRL_BASE_2 + 0x034)
+#define TEMPMSRCTL0         (THERM_CTRL_BASE_2 + 0x038)
+#define TEMPMSRCTL1         (THERM_CTRL_BASE_2 + 0x03C)
+#define TEMPAHBPOLL         (THERM_CTRL_BASE_2 + 0x040)
+#define TEMPAHBTO           (THERM_CTRL_BASE_2 + 0x044)
+#define TEMPADCPNP0         (THERM_CTRL_BASE_2 + 0x048)
+#define TEMPADCPNP1         (THERM_CTRL_BASE_2 + 0x04C)
+#define TEMPADCPNP2         (THERM_CTRL_BASE_2 + 0x050)
+#define TEMPADCPNP3         (THERM_CTRL_BASE_2 + 0x0B4)
+
+#define TEMPADCMUX          (THERM_CTRL_BASE_2 + 0x054)
+#define TEMPADCEXT          (THERM_CTRL_BASE_2 + 0x058)
+#define TEMPADCEXT1         (THERM_CTRL_BASE_2 + 0x05C)
+#define TEMPADCEN           (THERM_CTRL_BASE_2 + 0x060)
+#define TEMPPNPMUXADDR      (THERM_CTRL_BASE_2 + 0x064)
+#define TEMPADCMUXADDR      (THERM_CTRL_BASE_2 + 0x068)
+#define TEMPADCEXTADDR      (THERM_CTRL_BASE_2 + 0x06C)
+#define TEMPADCEXT1ADDR     (THERM_CTRL_BASE_2 + 0x070)
+#define TEMPADCENADDR       (THERM_CTRL_BASE_2 + 0x074)
+#define TEMPADCVALIDADDR    (THERM_CTRL_BASE_2 + 0x078)
+#define TEMPADCVOLTADDR     (THERM_CTRL_BASE_2 + 0x07C)
+#define TEMPRDCTRL          (THERM_CTRL_BASE_2 + 0x080)
+#define TEMPADCVALIDMASK    (THERM_CTRL_BASE_2 + 0x084)
+#define TEMPADCVOLTAGESHIFT (THERM_CTRL_BASE_2 + 0x088)
+#define TEMPADCWRITECTRL    (THERM_CTRL_BASE_2 + 0x08C)
+#define TEMPMSR0            (THERM_CTRL_BASE_2 + 0x090)
+#define TEMPMSR1            (THERM_CTRL_BASE_2 + 0x094)
+#define TEMPMSR2            (THERM_CTRL_BASE_2 + 0x098)
+#define TEMPMSR3            (THERM_CTRL_BASE_2 + 0x0B8)
+
+#define TEMPIMMD0           (THERM_CTRL_BASE_2 + 0x0A0)
+#define TEMPIMMD1           (THERM_CTRL_BASE_2 + 0x0A4)
+#define TEMPIMMD2           (THERM_CTRL_BASE_2 + 0x0A8)
+#define TEMPIMMD3           (THERM_CTRL_BASE_2 + 0x0BC)
+
+
+#define TEMPPROTCTL         (THERM_CTRL_BASE_2 + 0x0C0)
+#define TEMPPROTTA          (THERM_CTRL_BASE_2 + 0x0C4)
+#define TEMPPROTTB          (THERM_CTRL_BASE_2 + 0x0C8)
+#define TEMPPROTTC          (THERM_CTRL_BASE_2 + 0x0CC)
+
+#define TEMPSPARE0          (THERM_CTRL_BASE_2 + 0x0F0)
+#define TEMPSPARE1          (THERM_CTRL_BASE_2 + 0x0F4)
+#define TEMPSPARE2          (THERM_CTRL_BASE_2 + 0x0F8)
+#define TEMPSPARE3          (THERM_CTRL_BASE_2 + 0x0FC)
+
+#define PTPCORESEL          (THERM_CTRL_BASE_2 + 0x400)
+#define THERMINTST          (THERM_CTRL_BASE_2 + 0x404)
+#define PTPODINTST          (THERM_CTRL_BASE_2 + 0x408)
+#define THSTAGE0ST          (THERM_CTRL_BASE_2 + 0x40C)
+#define THSTAGE1ST          (THERM_CTRL_BASE_2 + 0x410)
+#define THSTAGE2ST          (THERM_CTRL_BASE_2 + 0x414)
+#define THAHBST0            (THERM_CTRL_BASE_2 + 0x418)
+#define THAHBST1            (THERM_CTRL_BASE_2 + 0x41C) /*Only for DE debug*/
+#define PTPSPARE0           (THERM_CTRL_BASE_2 + 0x420)
+#define PTPSPARE1           (THERM_CTRL_BASE_2 + 0x424)
+#define PTPSPARE2           (THERM_CTRL_BASE_2 + 0x428)
+#define PTPSPARE3           (THERM_CTRL_BASE_2 + 0x42C)
+#define THSLPEVEB           (THERM_CTRL_BASE_2 + 0x430)
+
+
+#define PTPSPARE0_P           (thermal_phy_base + 0x420)
+#define PTPSPARE1_P           (thermal_phy_base + 0x424)
+#define PTPSPARE2_P           (thermal_phy_base + 0x428)
+#define PTPSPARE3_P           (thermal_phy_base + 0x42C)
+
+/*******************************************************************************
+ * Thermal Controller Register Mask Definition
+ ******************************************************************************/
+#define THERMAL_ENABLE_SEN0     0x1
+#define THERMAL_ENABLE_SEN1     0x2
+#define THERMAL_ENABLE_SEN2     0x4
+#define THERMAL_MONCTL0_MASK    0x00000007
+
+#define THERMAL_PUNT_MASK       0x00000FFF
+#define THERMAL_FSINTVL_MASK    0x03FF0000
+#define THERMAL_SPINTVL_MASK    0x000003FF
+#define THERMAL_MON_INT_MASK    0x0007FFFF
+
+#define THERMAL_MON_CINTSTS0    0x000001
+#define THERMAL_MON_HINTSTS0    0x000002
+#define THERMAL_MON_LOINTSTS0   0x000004
+#define THERMAL_MON_HOINTSTS0   0x000008
+#define THERMAL_MON_NHINTSTS0   0x000010
+#define THERMAL_MON_CINTSTS1    0x000020
+#define THERMAL_MON_HINTSTS1    0x000040
+#define THERMAL_MON_LOINTSTS1   0x000080
+#define THERMAL_MON_HOINTSTS1   0x000100
+#define THERMAL_MON_NHINTSTS1   0x000200
+#define THERMAL_MON_CINTSTS2    0x000400
+#define THERMAL_MON_HINTSTS2    0x000800
+#define THERMAL_MON_LOINTSTS2   0x001000
+#define THERMAL_MON_HOINTSTS2   0x002000
+#define THERMAL_MON_NHINTSTS2   0x004000
+#define THERMAL_MON_TOINTSTS    0x008000
+#define THERMAL_MON_IMMDINTSTS0 0x010000
+#define THERMAL_MON_IMMDINTSTS1 0x020000
+#define THERMAL_MON_IMMDINTSTS2 0x040000
+#define THERMAL_MON_FILTINTSTS0 0x080000
+#define THERMAL_MON_FILTINTSTS1 0x100000
+#define THERMAL_MON_FILTINTSTS2 0x200000
+
+
+#define THERMAL_tri_SPM_State0	0x20000000
+#define THERMAL_tri_SPM_State1	0x40000000
+#define THERMAL_tri_SPM_State2	0x80000000
+
+
+#define THERMAL_MSRCTL0_MASK    0x00000007
+#define THERMAL_MSRCTL1_MASK    0x00000038
+#define THERMAL_MSRCTL2_MASK    0x000001C0
+
+enum thermal_sensor_name {
+	THERMAL_SENSOR1     = 0,/*TS_MCU1*/
+	THERMAL_SENSOR_NUM
+};
+
+enum thermal_bank_name {
+	THERMAL_BANK0     = 0, /*CPU (TS_MCU1) (TS1)*/
+	THERMAL_BANK_NUM
+};
+
+struct TS_SVS {
+	unsigned int ts_MTS;
+	unsigned int ts_BTS;
+};
+
+struct mtk_gpu_power_info {
+	unsigned int gpufreq_khz;
+	unsigned int gpufreq_power;
+};
+
+/* svs driver need this function */
+extern void get_thermal_slope_intercept(struct TS_SVS *ts_info, enum thermal_bank_name ts_bank);
+
+/* mtk_thermal_platform.c need this */
+extern void set_taklking_flag(bool flag);
+
+#define THERMAL_WRAP_WR32(val, addr)  mt_reg_sync_writel((val), ((void *)addr))
+
+enum MTK_THERMAL_SENSOR_CPU_ID_MET {
+	MTK_THERMAL_SENSOR_TS1 = 0,
+	MTK_THERMAL_SENSOR_TS2,
+	MTK_THERMAL_SENSOR_TS3,
+	MTK_THERMAL_SENSOR_TS4,
+	MTK_THERMAL_SENSOR_TSABB,
+
+	ATM_CPU_LIMIT,
+	ATM_GPU_LIMIT,
+
+	MTK_THERMAL_SENSOR_CPU_COUNT
+};
+
+extern int tscpu_get_cpu_temp_met(enum MTK_THERMAL_SENSOR_CPU_ID_MET id);
+extern int mtk_gpufreq_register(struct mtk_gpu_power_info *freqs, int num);
+
+typedef void (*met_thermalsampler_funcMET)(void);
+void mt_thermalsampler_registerCB(met_thermalsampler_funcMET pCB);
+
+void tscpu_start_thermal(void);
+void tscpu_stop_thermal(void);
+void tscpu_cancel_thermal_timer(void);
+void tscpu_start_thermal_timer(void);
+int mtkts_bts_get_hw_temp(void);
+
+extern int get_immediate_ts1_wrap(void);
+extern int get_immediate_ts2_wrap(void);
+extern int get_immediate_ts3_wrap(void);
+
+extern int is_cpu_power_unlimit(void);	/* in mtk_ts_cpu.c */
+extern int is_cpu_power_min(void);	/* in mtk_ts_cpu.c */
+extern int get_cpu_target_tj(void);
+extern int get_cpu_target_offset(void);
+
+extern int mtktscpu_debug_log;
+
+#endif
+
diff --git a/drivers/misc/mediatek/include/mt-plat/mt8127/include/mach/mt_freqhopping.h b/drivers/misc/mediatek/include/mt-plat/mt8127/include/mach/mt_freqhopping.h
new file mode 100644
index 00000000..142a007
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mt8127/include/mach/mt_freqhopping.h
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2011 MediaTek, Inc.
+ *
+ * Author: Holmes Chiou <holmes.chiou@mediatek.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __MT_FREQHOPPING_H__
+#define __MT_FREQHOPPING_H__
+
+#define MT_FHPLL_MAX 6
+#define MT_SSC_NR_PREDEFINE_SETTING 10	/* TODO: is 10 a good number ? */
+
+#define MEMPLL_SSC 0
+#define MAINPLL_SSC 1
+
+#define FHTAG "[FH]"
+
+#define VERBOSE_DEBUG 0
+
+#if VERBOSE_DEBUG
+#define FH_MSG(fmt, args...) \
+	pr_debug(FHTAG""fmt" <- %s(): L<%d>  PID<%s><%d>\n", ##args, __func__, __LINE__, current->comm, current->pid)
+#else
+
+#if 1				/* log level is 6 xlog */
+#define FH_MSG(fmt, args...)	pr_debug(fmt, ##args)
+#else				/* log level is 4 (printk) */
+#define FH_MSG(fmt, args...)	printk(FHTAG""fmt"\n", ##args)
+#endif
+
+#endif
+
+/* not support at mt2701 yet */
+/* DRAMC */
+#define FULLY_VERSION_FHCTL	0
+
+enum FH_FH_STATUS {
+	FH_FH_DISABLE = 0,
+	FH_FH_ENABLE_SSC,
+	FH_FH_ENABLE_DFH,
+	FH_FH_ENABLE_DVFS,
+};
+
+enum FH_PLL_STATUS {
+	FH_PLL_DISABLE = 0,
+	FH_PLL_ENABLE = 1
+};
+
+/* TODO: FREQ_MODIFIED should not be here */
+/* FH_PLL_STATUS_FREQ_MODIFIED = 3 */
+
+
+enum FH_CMD {
+	FH_CMD_ENABLE = 1,
+	FH_CMD_DISABLE,
+	FH_CMD_ENABLE_USR_DEFINED,
+	FH_CMD_DISABLE_USR_DEFINED,
+	FH_CMD_INTERNAL_MAX_CMD,
+/* TODO:  do we need these cmds ?
+ * FH_CMD_PLL_ENABLE,
+ * FH_CMD_PLL_DISABLE,
+ * FH_CMD_EXT_ALL_FULL_RANGE_CMD,
+ * FH_CMD_EXT_ALL_HALF_RANGE_CMD,
+ * FH_CMD_EXT_DISABLE_ALL_CMD,
+ * FH_CMD_EXT_DESIGNATED_PLL_FULL_RANGE_CMD,
+ * FH_CMD_EXT_DESIGNATED_PLL_AND_SETTING_CMD
+*/
+};
+
+/*
+ * enum FH_OPCODE{
+ * FH_OPCODE_ENABLE_WITH_ID = 1,
+ * FH_OPCODE_ENABLE_WITHOUT_ID,
+ * FH_OPCODE_DISABLE,
+ * };
+*/
+
+enum FH_PLL_ID {
+	MT658X_FH_MINIMUMM_PLL = 0,
+	MT658X_FH_ARM_PLL = MT658X_FH_MINIMUMM_PLL,
+	MT658X_FH_MAIN_PLL = 1,
+	MT658X_FH_MEM_PLL = 2,
+	MT658X_FH_MSDC_PLL = 3,
+	MT658X_FH_MM_PLL = 4,	/* MT658X_FH_TVD_PLL        = 4, */
+	MT658X_FH_VENC_PLL = 5,	/* MT658X_FH_LVDS_PLL       = 5, */
+	/* 8127 FHCTL MB */
+	MT658X_FH_TVD_PLL = 6,	/* MT658X_FH_TVD_PLL     = 6, */
+	MT658X_FH_MAXIMUMM_PLL = MT658X_FH_TVD_PLL,
+	/* 8127 FHCTL ME */
+	MT658X_FH_PLL_TOTAL_NUM
+};
+
+/* keep track the status of each PLL */
+/* TODO: do we need another "uint mode" for Dynamic FH */
+typedef struct {
+	unsigned int fh_status;
+	unsigned int pll_status;
+	unsigned int setting_id;
+	unsigned int curr_freq;
+	unsigned int user_defined;
+} fh_pll_t;
+
+
+/* Record the owner of enable freq hopping <==TBD */
+struct freqhopping_pll {
+	union {
+		int mt_pll[MT_FHPLL_MAX];
+		struct {
+			int mt_arm_fhpll;
+			int mt_main_fhpll;
+			int mt_mem_fhpll;
+			int mt_msdc_fhpll;
+			int mt_mm_fhpll;
+			int mt_venc_fhpll;
+		};
+	};
+};
+
+struct freqhopping_ssc {
+	unsigned int freq;
+	unsigned int dt;
+	unsigned int df;
+	unsigned int upbnd;
+	unsigned int lowbnd;
+	unsigned int dds;
+};
+
+struct freqhopping_ioctl {
+	unsigned int pll_id;
+	struct freqhopping_ssc ssc_setting;	/* used only when user-define */
+	int result;
+};
+
+int freqhopping_config(unsigned int pll_id, unsigned long vco_freq, unsigned int enable);
+void mt_freqhopping_init(void);
+void mt_freqhopping_pll_init(void);
+int mt_h2l_mempll(void);
+int mt_l2h_mempll(void);
+int mt_h2l_dvfs_mempll(void);
+int mt_l2h_dvfs_mempll(void);
+int mt_dfs_armpll(unsigned int current_freq, unsigned int target_freq);
+int mt_is_support_DFS_mode(void);
+void mt_fh_popod_save(void);
+void mt_fh_popod_restore(void);
+int mt_fh_dram_overclock(int clk);
+int mt_fh_get_dramc(void);
+unsigned int mt_get_emi_freq(void);
+
+#endif				/* !__MT_FREQHOPPING_H__ */
diff --git a/drivers/misc/mediatek/include/mt-plat/mt8127/include/mach/mt_spm_mtcmos.h b/drivers/misc/mediatek/include/mt-plat/mt8127/include/mach/mt_spm_mtcmos.h
new file mode 100644
index 00000000..0c049db
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mt8127/include/mach/mt_spm_mtcmos.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2015 MediaTek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+
+#define STA_POWER_DOWN  0
+#define STA_POWER_ON    1
+
+/*
+ * 1. for CPU MTCMOS: CPU0, CPU1, CPU2, CPU3, DBG0, CPU4, CPU5, CPU6, CPU7, DBG1, CPUSYS1
+ * 2. call spm_mtcmos_cpu_lock/unlock() before/after any operations
+ */
+extern int spm_mtcmos_cpu_init(void);
+extern void spm_mtcmos_cpu_lock(unsigned long *flags);
+extern void spm_mtcmos_cpu_unlock(unsigned long *flags);
+extern int spm_mtcmos_ctrl_cpu(unsigned int cpu, int state, int chkWfiBeforePdn);
+extern int spm_mtcmos_ctrl_cpu0(int state, int chkWfiBeforePdn);
+extern int spm_mtcmos_ctrl_cpu1(int state, int chkWfiBeforePdn);
+extern int spm_mtcmos_ctrl_cpu2(int state, int chkWfiBeforePdn);
+extern int spm_mtcmos_ctrl_cpu3(int state, int chkWfiBeforePdn);
+extern int spm_mtcmos_ctrl_cpu4(int state, int chkWfiBeforePdn);
+extern int spm_mtcmos_ctrl_cpu5(int state, int chkWfiBeforePdn);
+extern int spm_mtcmos_ctrl_cpu6(int state, int chkWfiBeforePdn);
+extern int spm_mtcmos_ctrl_cpu7(int state, int chkWfiBeforePdn);
+extern int spm_mtcmos_ctrl_cpusys0(int state, int chkWfiBeforePdn);
+extern bool spm_cpusys0_can_power_down(void);
diff --git a/drivers/misc/mediatek/include/mt-plat/mt8127/include/mach/mtk_boot_share_page.h b/drivers/misc/mediatek/include/mt-plat/mt8127/include/mach/mtk_boot_share_page.h
new file mode 100644
index 00000000..28176b3
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mt8127/include/mach/mtk_boot_share_page.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2015 MediaTek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MTK_BOOT_SHARE_PAGE_H__
+#define __MTK_BOOT_SHARE_PAGE_H__
+
+#define BOOT_SHARE_BASE  (0xC0002000)      /* address in linux kernel */
+#define BOOT_SHARE_SIZE  (0x1000)          /* page size 4K bytes */
+
+#define BOOT_SHARE_MAGIC (0x4545544D)      /* MTEE */
+
+/* Memory map & defines for boot share page */
+/*
+ *  Note:
+ *  1. BOOT_SHARE_XXXXX_OFST is the address offset related to BOOT_SHARE_BASE
+ */
+#define BOOT_SHARE_MAGIC1_OFST   (0)
+#define BOOT_SHARE_MAGIC1_SIZE   (4)
+
+#define BOOT_SHARE_DEV_INFO_OFST (BOOT_SHARE_MAGIC1_OFST+BOOT_SHARE_MAGIC1_SIZE)
+#define BOOT_SHARE_DEV_INFO_SIZE (16)
+
+#define BOOT_SHARE_HOTPLUG_OFST  (1008)    /* 16 bytes for hotplug/jump-reg */
+#define BOOT_SHARE_HOTPLUG_SIZE  (32)
+
+#define BOOT_SHARE_MAGIC2_OFST   (4092)
+#define BOOT_SHARE_MAGIC2_SIZE   (4)
+
+#endif /* __MTK_BOOT_SHARE_PAGE_H__ */
diff --git a/drivers/misc/mediatek/include/mt-plat/mt8127/include/mach/mtk_thermal.h b/drivers/misc/mediatek/include/mt-plat/mt8127/include/mach/mtk_thermal.h
new file mode 100644
index 00000000..eefdaad
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mt8127/include/mach/mtk_thermal.h
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2016 MediaTek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ */
+
+#ifndef _MT8127_THERMAL_H
+#define _MT8127_THERMAL_H
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+
+#include <linux/io.h>
+#include <linux/uaccess.h>
+
+#include "mt-plat/sync_write.h"
+#include <linux/types.h>
+
+/* #include <mach/mt_gpufreq.h> */
+/* #include "../../../../../thermal/mt8127/inc/mt_gpufreq.h" */
+
+#if 1
+extern void __iomem *thermal_base;
+extern void __iomem *auxadc_ts_base;
+extern void __iomem *pericfg_base;
+extern void __iomem *apmixed_ts_base;
+
+extern int mtktscpu_limited_dmips;
+
+void __attribute__ ((weak)) mt_gpufreq_thermal_protect(unsigned int limited_power) {
+}
+
+unsigned int __attribute__ ((weak)) mt_gpufreq_get_cur_freq(void) {
+	return 0;
+}
+
+u32 __attribute__ ((weak)) get_devinfo_with_index(u32 index) {
+	return 0;
+}
+
+extern int IMM_GetOneChannelValue(int dwChannel, int data[4], int *rawdata);
+extern int IMM_IsAdcInitReady(void);
+extern int PMIC_IMM_GetOneChannelValue(int dwChannel, int deCount, int trimd);
+extern int thermal_phy_base;
+extern int auxadc_ts_phy_base;
+extern int apmixed_phy_base;
+extern int pericfg_phy_base;
+
+/* extern int last_abb_t; */
+/* extern int last_CPU2_t; */
+extern int get_immediate_temp2_wrap(void);
+extern void mtkts_dump_cali_info(void);
+extern u32 get_devinfo_with_index(u32 index);
+extern int bts_cur_temp;
+
+#define THERM_CTRL_BASE_2  thermal_base
+#define AUXADC_BASE_2      auxadc_ts_base
+#define PERICFG_BASE_2     pericfg_base
+#define APMIXED_BASE_2     apmixed_ts_base
+#endif
+
+/*******************************************************************************
+ * AUXADC Register Definition
+ ******************************************************************************/
+#define AUXADC_CON0_V       (AUXADC_BASE_2 + 0x000)	/* yes, 0x11001000 */
+#define AUXADC_CON1_V       (AUXADC_BASE_2 + 0x004)
+#define AUXADC_CON1_SET_V   (AUXADC_BASE_2 + 0x008)
+#define AUXADC_CON1_CLR_V   (AUXADC_BASE_2 + 0x00C)
+#define AUXADC_CON2_V       (AUXADC_BASE_2 + 0x010)
+#define AUXADC_DAT0_V       (AUXADC_BASE_2 + 0x014)
+#define AUXADC_DAT1_V       (AUXADC_BASE_2 + 0x018)
+#define AUXADC_DAT2_V       (AUXADC_BASE_2 + 0x01C)
+#define AUXADC_DAT3_V       (AUXADC_BASE_2 + 0x020)
+#define AUXADC_DAT4_V       (AUXADC_BASE_2 + 0x024)
+#define AUXADC_DAT5_V       (AUXADC_BASE_2 + 0x028)
+#define AUXADC_DAT6_V       (AUXADC_BASE_2 + 0x02C)
+#define AUXADC_DAT7_V       (AUXADC_BASE_2 + 0x030)
+#define AUXADC_DAT8_V       (AUXADC_BASE_2 + 0x034)
+#define AUXADC_DAT9_V       (AUXADC_BASE_2 + 0x038)
+#define AUXADC_DAT10_V       (AUXADC_BASE_2 + 0x03C)
+#define AUXADC_DAT11_V       (AUXADC_BASE_2 + 0x040)
+#define AUXADC_MISC_V       (AUXADC_BASE_2 + 0x094)
+#define AUXADC_CON0_P       (auxadc_ts_phy_base + 0x000)
+#define AUXADC_CON1_P       (auxadc_ts_phy_base + 0x004)
+#define AUXADC_CON1_SET_P   (auxadc_ts_phy_base + 0x008)
+#define AUXADC_CON1_CLR_P   (auxadc_ts_phy_base + 0x00C)
+#define AUXADC_CON2_P       (auxadc_ts_phy_base + 0x010)
+#define AUXADC_DAT0_P       (auxadc_ts_phy_base + 0x014)
+#define AUXADC_DAT1_P       (auxadc_ts_phy_base + 0x018)
+#define AUXADC_DAT2_P       (auxadc_ts_phy_base + 0x01C)
+#define AUXADC_DAT3_P       (auxadc_ts_phy_base + 0x020)
+#define AUXADC_DAT4_P       (auxadc_ts_phy_base + 0x024)
+#define AUXADC_DAT5_P       (auxadc_ts_phy_base + 0x028)
+#define AUXADC_DAT6_P       (auxadc_ts_phy_base + 0x02C)
+#define AUXADC_DAT7_P       (auxadc_ts_phy_base + 0x030)
+#define AUXADC_DAT8_P       (auxadc_ts_phy_base + 0x034)
+#define AUXADC_DAT9_P       (auxadc_ts_phy_base + 0x038)
+#define AUXADC_DAT10_P       (auxadc_ts_phy_base + 0x03C)
+#define AUXADC_DAT11_P       (auxadc_ts_phy_base + 0x040)
+#define AUXADC_MISC_P       (auxadc_ts_phy_base + 0x094)
+
+/*******************************************************************************
+ * Peripheral Configuration Register Definition
+ ******************************************************************************/
+#define PERI_GLOBALCON_RST0 (PERICFG_BASE_2 + 0x000)	/* yes, 0x10003000 */
+
+/*******************************************************************************
+ * APMixedSys Configuration Register Definition
+ ******************************************************************************/
+#define TS_CON0             (APMIXED_BASE_2 + 0x600)	/* yes 0x10209000 */
+#define TS_CON1             (APMIXED_BASE_2 + 0x604)
+/*******************************************************************************
+ * Thermal Controller Register Definition
+ ******************************************************************************/
+#define TEMPMONCTL0         (THERM_CTRL_BASE_2 + 0x000)	/* yes 0x1100B000 */
+#define TEMPMONCTL1         (THERM_CTRL_BASE_2 + 0x004)
+#define TEMPMONCTL2         (THERM_CTRL_BASE_2 + 0x008)
+#define TEMPMONINT          (THERM_CTRL_BASE_2 + 0x00C)
+#define TEMPMONINTSTS       (THERM_CTRL_BASE_2 + 0x010)
+#define TEMPMONIDET0        (THERM_CTRL_BASE_2 + 0x014)
+#define TEMPMONIDET1        (THERM_CTRL_BASE_2 + 0x018)
+#define TEMPMONIDET2        (THERM_CTRL_BASE_2 + 0x01C)
+#define TEMPH2NTHRE         (THERM_CTRL_BASE_2 + 0x024)
+#define TEMPHTHRE           (THERM_CTRL_BASE_2 + 0x028)
+#define TEMPCTHRE           (THERM_CTRL_BASE_2 + 0x02C)
+#define TEMPOFFSETH         (THERM_CTRL_BASE_2 + 0x030)
+#define TEMPOFFSETL         (THERM_CTRL_BASE_2 + 0x034)
+#define TEMPMSRCTL0         (THERM_CTRL_BASE_2 + 0x038)
+#define TEMPMSRCTL1         (THERM_CTRL_BASE_2 + 0x03C)
+#define TEMPAHBPOLL         (THERM_CTRL_BASE_2 + 0x040)
+#define TEMPAHBTO           (THERM_CTRL_BASE_2 + 0x044)
+#define TEMPADCPNP0         (THERM_CTRL_BASE_2 + 0x048)
+#define TEMPADCPNP1         (THERM_CTRL_BASE_2 + 0x04C)
+#define TEMPADCPNP2         (THERM_CTRL_BASE_2 + 0x050)
+#define TEMPADCPNP3         (THERM_CTRL_BASE_2 + 0x0B4)
+
+#define TEMPADCMUX          (THERM_CTRL_BASE_2 + 0x054)
+#define TEMPADCEXT          (THERM_CTRL_BASE_2 + 0x058)
+#define TEMPADCEXT1         (THERM_CTRL_BASE_2 + 0x05C)
+#define TEMPADCEN           (THERM_CTRL_BASE_2 + 0x060)
+#define TEMPPNPMUXADDR      (THERM_CTRL_BASE_2 + 0x064)
+#define TEMPADCMUXADDR      (THERM_CTRL_BASE_2 + 0x068)
+#define TEMPADCEXTADDR      (THERM_CTRL_BASE_2 + 0x06C)
+#define TEMPADCEXT1ADDR     (THERM_CTRL_BASE_2 + 0x070)
+#define TEMPADCENADDR       (THERM_CTRL_BASE_2 + 0x074)
+#define TEMPADCVALIDADDR    (THERM_CTRL_BASE_2 + 0x078)
+#define TEMPADCVOLTADDR     (THERM_CTRL_BASE_2 + 0x07C)
+#define TEMPRDCTRL          (THERM_CTRL_BASE_2 + 0x080)
+#define TEMPADCVALIDMASK    (THERM_CTRL_BASE_2 + 0x084)
+#define TEMPADCVOLTAGESHIFT (THERM_CTRL_BASE_2 + 0x088)
+#define TEMPADCWRITECTRL    (THERM_CTRL_BASE_2 + 0x08C)
+#define TEMPMSR0            (THERM_CTRL_BASE_2 + 0x090)
+#define TEMPMSR1            (THERM_CTRL_BASE_2 + 0x094)
+#define TEMPMSR2            (THERM_CTRL_BASE_2 + 0x098)
+#define TEMPMSR3            (THERM_CTRL_BASE_2 + 0x0B8)
+
+#define TEMPIMMD0           (THERM_CTRL_BASE_2 + 0x0A0)
+#define TEMPIMMD1           (THERM_CTRL_BASE_2 + 0x0A4)
+#define TEMPIMMD2           (THERM_CTRL_BASE_2 + 0x0A8)
+
+#define TEMPPROTCTL         (THERM_CTRL_BASE_2 + 0x0C0)
+#define TEMPPROTTA          (THERM_CTRL_BASE_2 + 0x0C4)
+#define TEMPPROTTB          (THERM_CTRL_BASE_2 + 0x0C8)
+#define TEMPPROTTC          (THERM_CTRL_BASE_2 + 0x0CC)
+
+#define TEMPSPARE0          (THERM_CTRL_BASE_2 + 0x0F0)
+#define TEMPSPARE1          (THERM_CTRL_BASE_2 + 0x0F4)
+#define TEMPSPARE2          (THERM_CTRL_BASE_2 + 0x0F8)
+#define TEMPSPARE3          (THERM_CTRL_BASE_2 + 0x0FC)
+
+#define PTPCORESEL          (THERM_CTRL_BASE_2 + 0x400)
+#define THERMINTST          (THERM_CTRL_BASE_2 + 0x404)
+#define PTPODINTST          (THERM_CTRL_BASE_2 + 0x408)
+#define THSTAGE0ST          (THERM_CTRL_BASE_2 + 0x40C)
+#define THSTAGE1ST          (THERM_CTRL_BASE_2 + 0x410)
+#define THSTAGE2ST          (THERM_CTRL_BASE_2 + 0x414)
+#define THAHBST0            (THERM_CTRL_BASE_2 + 0x418)
+#define THAHBST1            (THERM_CTRL_BASE_2 + 0x41C)	/* Only for DE debug */
+#define PTPSPARE0           (THERM_CTRL_BASE_2 + 0x420)
+#define PTPSPARE1           (THERM_CTRL_BASE_2 + 0x424)
+#define PTPSPARE2           (THERM_CTRL_BASE_2 + 0x428)
+#define PTPSPARE3           (THERM_CTRL_BASE_2 + 0x42C)
+#define THSLPEVEB           (THERM_CTRL_BASE_2 + 0x430)
+
+/*******************************************************************************
+ * Thermal Controller Register Mask Definition
+ ******************************************************************************/
+#define THERMAL_ENABLE_SEN0     0x1
+#define THERMAL_ENABLE_SEN1     0x2
+#define THERMAL_ENABLE_SEN2     0x4
+#define THERMAL_MONCTL0_MASK    0x00000007
+
+#define THERMAL_PUNT_MASK       0x00000FFF
+#define THERMAL_FSINTVL_MASK    0x03FF0000
+#define THERMAL_SPINTVL_MASK    0x000003FF
+#define THERMAL_MON_INT_MASK    0x0007FFFF
+
+#define THERMAL_MON_CINTSTS0    0x000001
+#define THERMAL_MON_HINTSTS0    0x000002
+#define THERMAL_MON_LOINTSTS0   0x000004
+#define THERMAL_MON_HOINTSTS0   0x000008
+#define THERMAL_MON_NHINTSTS0   0x000010
+#define THERMAL_MON_CINTSTS1    0x000020
+#define THERMAL_MON_HINTSTS1    0x000040
+#define THERMAL_MON_LOINTSTS1   0x000080
+#define THERMAL_MON_HOINTSTS1   0x000100
+#define THERMAL_MON_NHINTSTS1   0x000200
+#define THERMAL_MON_CINTSTS2    0x000400
+#define THERMAL_MON_HINTSTS2    0x000800
+#define THERMAL_MON_LOINTSTS2   0x001000
+#define THERMAL_MON_HOINTSTS2   0x002000
+#define THERMAL_MON_NHINTSTS2   0x004000
+#define THERMAL_MON_TOINTSTS    0x008000
+#define THERMAL_MON_IMMDINTSTS0 0x010000
+#define THERMAL_MON_IMMDINTSTS1 0x020000
+#define THERMAL_MON_IMMDINTSTS2 0x040000
+#define THERMAL_MON_FILTINTSTS0 0x080000
+#define THERMAL_MON_FILTINTSTS1 0x100000
+#define THERMAL_MON_FILTINTSTS2 0x200000
+
+
+#define THERMAL_tri_SPM_State0	0x20000000
+#define THERMAL_tri_SPM_State1	0x40000000
+#define THERMAL_tri_SPM_State2	0x80000000
+
+
+#define THERMAL_MSRCTL0_MASK    0x00000007
+#define THERMAL_MSRCTL1_MASK    0x00000038
+#define THERMAL_MSRCTL2_MASK    0x000001C0
+
+/* extern int thermal_one_shot_handler(int times); */
+
+typedef enum {
+	THERMAL_SENSOR1 = 0,	/* TS1 */
+	THERMAL_SENSOR_NUM
+} thermal_sensor_name;
+
+struct TS_PTPOD {
+	unsigned int ts_MTS;
+	unsigned int ts_BTS;
+};
+
+extern void get_thermal_slope_intercept(struct TS_PTPOD *ts_info);
+extern void set_taklking_flag(bool flag);
+extern int tscpu_get_cpu_temp(void);
+
+/*5 thermal sensors*/
+typedef enum {
+	MTK_THERMAL_SENSOR_TS1 = 0,
+	ATM_CPU_LIMIT,
+	ATM_GPU_LIMIT,
+	MTK_THERMAL_SENSOR_CPU_COUNT
+} MTK_THERMAL_SENSOR_CPU_ID_MET;
+
+struct mtk_cpu_power_info {
+	unsigned int cpufreq_khz;
+	unsigned int cpufreq_ncpu;
+	unsigned int cpufreq_power;
+};
+extern int mtk_cpufreq_register(struct mtk_cpu_power_info *freqs, int num);
+
+extern int tscpu_get_cpu_temp_met(MTK_THERMAL_SENSOR_CPU_ID_MET id);
+
+
+typedef void (*met_thermalsampler_funcMET) (void);
+void mt_thermalsampler_registerCB(met_thermalsampler_funcMET pCB);
+
+void tscpu_start_thermal(void);
+void tscpu_stop_thermal(void);
+void tscpu_cancel_thermal_timer(void);
+void tscpu_start_thermal_timer(void);
+int mtkts_AP_get_hw_temp(void);
+
+extern int amddulthro_backoff(int level);
+/* extern int IMM_GetOneChannelValue(int dwChannel, int data[4], int *rawdata); */
+/* extern int IMM_IsAdcInitReady(void); */
+extern int get_immediate_temp2_wrap(void);
+extern void mtkts_dump_cali_info(void);
+extern unsigned int read_dram_temperature(void);
+extern int mtk_thermal_get_cpu_load_sum(void);
+
+/**********************************
+ * Power table struct for thermal
+ **********************************/
+struct mt_gpufreq_power_table_info {
+	unsigned int gpufreq_khz;
+	unsigned int gpufreq_volt;
+	unsigned int gpufreq_power;
+};
+
+extern int mtk_gpufreq_register(struct mt_gpufreq_power_table_info *freqs, int num);
+#endif
diff --git a/drivers/misc/mediatek/include/mt-plat/mt_sched.h b/drivers/misc/mediatek/include/mt-plat/mt_sched.h
new file mode 100644
index 00000000..71206f0
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mt_sched.h
@@ -0,0 +1,34 @@
+/*
+* Copyright (C) 2016 MediaTek Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+*/
+
+#ifdef CONFIG_MTK_SCHED_RQAVG_US
+/*
+ * @cpu: cpu id
+ * @reset: reset the statistic start time after this time query
+ * @use_maxfreq: caculate cpu loading with max cpu max frequency
+ * return: cpu loading as percentage (0~100)
+ */
+extern unsigned int sched_get_percpu_load(int cpu, bool reset, bool use_maxfreq);
+
+/*
+ * return: heavy task(loading>90%) number in the system
+ */
+extern unsigned int sched_get_nr_heavy_task(void);
+
+/*
+ * @threshold: heavy task loading threshold (0~1023)
+ * return: heavy task(loading>threshold) number in the system
+ */
+extern unsigned int sched_get_nr_heavy_task_by_threshold(unsigned int threshold);
+#endif /* CONFIG_MTK_SCHED_RQAVG_US */
+
diff --git a/drivers/misc/mediatek/include/mt-plat/mtk_io.h b/drivers/misc/mediatek/include/mt-plat/mtk_io.h
new file mode 100644
index 00000000..de17db5
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mtk_io.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MT_IO_H__
+#define __MT_IO_H__
+
+/* only for arm64 */
+#ifdef CONFIG_ARM64
+#define IOMEM(a)	((void __force __iomem *)((a)))
+#endif
+
+#endif  /* !__MT_IO_H__ */
+
diff --git a/drivers/misc/mediatek/include/mt-plat/mtk_lpae.h b/drivers/misc/mediatek/include/mt-plat/mtk_lpae.h
new file mode 100644
index 00000000..d679c5a
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mtk_lpae.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2016 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MTK_LPAE_H__
+#define __MTK_LPAE_H__
+#ifdef CONFIG_MTK_LM_MODE
+
+#include <mt-plat/mtk_io.h>
+
+#define INTERAL_MAPPING_OFFSET (0x40000000)
+#define INTERAL_MAPPING_LIMIT (INTERAL_MAPPING_OFFSET + 0x80000000)
+
+#define MT_OVERFLOW_ADDR_START 0x100000000ULL
+
+unsigned int __attribute__((weak)) enable_4G(void)
+{
+	return 0;
+}
+
+/* For HW modules which support 33-bit address setting */
+#define CROSS_OVERFLOW_ADDR_TRANSFER(phy_addr, size, ret) \
+	do { \
+		ret = 0; \
+		if (enable_4G()) {\
+			if (((phys_addr_t)phy_addr < MT_OVERFLOW_ADDR_START)\
+					&& (((phys_addr_t)phy_addr + size) >= MT_OVERFLOW_ADDR_START)) \
+				ret = MT_OVERFLOW_ADDR_START - phy_addr; \
+		} \
+	}  while (0) \
+
+/* For SPM and MD32 only in ROME */
+#define MAPPING_DRAM_ACCESS_ADDR(phy_addr) \
+	do { \
+		if (enable_4G()) {\
+			if (phy_addr >= INTERAL_MAPPING_OFFSET && phy_addr < INTERAL_MAPPING_LIMIT) \
+				phy_addr += INTERAL_MAPPING_OFFSET; \
+		} \
+	} while (0)\
+
+#else /* !CONFIG_ARM_LPAE */
+
+#define CROSS_OVERFLOW_ADDR_TRANSFER(phy_addr, size, ret)
+#define MAPPING_DRAM_ACCESS_ADDR(phy_addr)
+#define MT_OVERFLOW_ADDR_START 0
+
+static inline unsigned int enable_4G(void)
+{
+	return 0;
+}
+
+#endif
+#endif  /*!__MTK_LPAE_H__ */
diff --git a/drivers/misc/mediatek/include/mt-plat/mtk_mdm_monitor.h b/drivers/misc/mediatek/include/mt-plat/mtk_mdm_monitor.h
new file mode 100644
index 00000000..7baafc4
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mtk_mdm_monitor.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _MTK_MDM_MONITOR_H
+#define _MTK_MDM_MONITOR_H
+
+struct md_info {
+	char *attribute;
+	int value;
+	char *unit;
+	int invalid_value;
+	int index;
+};
+
+extern
+int mtk_mdm_get_md_info(struct md_info **p_inf, int *size);
+
+extern
+int mtk_mdm_start_query(void);
+
+extern
+int mtk_mdm_stop_query(void);
+
+extern
+int mtk_mdm_set_signal_period(int second);
+
+extern
+int mtk_mdm_set_md1_signal_period(int second);
+
+extern
+int mtk_mdm_set_md2_signal_period(int second);
+#endif
diff --git a/drivers/misc/mediatek/include/mt-plat/mtk_platform_debug.h b/drivers/misc/mediatek/include/mt-plat/mtk_platform_debug.h
new file mode 100644
index 00000000..8f20f38
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mtk_platform_debug.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MTK_PLATFORM_DEBUG_H__
+#define __MTK_PLATFORM_DEBUG_H__
+
+#ifdef CONFIG_MTK_PLAT_SRAM_FLAG
+/* plat_sram_flag */
+extern int set_sram_flag_lastpc_valid(void);
+extern int set_sram_flag_dfd_valid(void);
+extern int set_sram_flag_etb_user(unsigned int etb_id, unsigned int user_id);
+#endif
+
+#ifdef CONFIG_MTK_DFD_INTERNAL_DUMP
+extern int dfd_setup(void);
+#endif
+
+#endif /* __MTK_PLATFORM_DEBUG_H__ */
diff --git a/drivers/misc/mediatek/include/mt-plat/mtk_ram_console.h b/drivers/misc/mediatek/include/mt-plat/mtk_ram_console.h
new file mode 100644
index 00000000..3a94a1b
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mtk_ram_console.h
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MTK_RAM_CONSOLE_H__
+#define __MTK_RAM_CONSOLE_H__
+
+#include <linux/console.h>
+#include <linux/pstore.h>
+
+typedef enum {
+	AEE_FIQ_STEP_FIQ_ISR_BASE = 1,
+	AEE_FIQ_STEP_WDT_FIQ_INFO = 4,
+	AEE_FIQ_STEP_WDT_FIQ_STACK,
+	AEE_FIQ_STEP_WDT_FIQ_LOOP,
+	AEE_FIQ_STEP_WDT_FIQ_DONE,
+	AEE_FIQ_STEP_WDT_IRQ_INFO = 8,
+	AEE_FIQ_STEP_WDT_IRQ_KICK,
+	AEE_FIQ_STEP_WDT_IRQ_SMP_STOP,
+	AEE_FIQ_STEP_WDT_IRQ_TIME,
+	AEE_FIQ_STEP_WDT_IRQ_STACK,
+	AEE_FIQ_STEP_WDT_IRQ_GIC,
+	AEE_FIQ_STEP_WDT_IRQ_LOCALTIMER,
+	AEE_FIQ_STEP_WDT_IRQ_IDLE,
+	AEE_FIQ_STEP_WDT_IRQ_SCHED,
+	AEE_FIQ_STEP_WDT_IRQ_DONE,
+	AEE_FIQ_STEP_KE_WDT_INFO = 20,
+	AEE_FIQ_STEP_KE_WDT_PERCPU,
+	AEE_FIQ_STEP_KE_WDT_LOG,
+	AEE_FIQ_STEP_KE_SCHED_DEBUG,
+	AEE_FIQ_STEP_KE_EINT_DEBUG,
+	AEE_FIQ_STEP_KE_WDT_DONE,
+	AEE_FIQ_STEP_KE_IPANIC_DIE = 32,
+	AEE_FIQ_STEP_KE_IPANIC_START,
+	AEE_FIQ_STEP_KE_IPANIC_OOP_HEADER,
+	AEE_FIQ_STEP_KE_IPANIC_DETAIL,
+	AEE_FIQ_STEP_KE_IPANIC_CONSOLE,
+	AEE_FIQ_STEP_KE_IPANIC_USERSPACE,
+	AEE_FIQ_STEP_KE_IPANIC_ANDROID,
+	AEE_FIQ_STEP_KE_IPANIC_MMPROFILE,
+	AEE_FIQ_STEP_KE_IPANIC_HEADER,
+	AEE_FIQ_STEP_KE_IPANIC_DONE,
+	AEE_FIQ_STEP_KE_NESTED_PANIC = 64,
+} AEE_FIQ_STEP_NUM;
+
+#ifdef CONFIG_MTK_RAM_CONSOLE
+extern int aee_rr_curr_fiq_step(void);
+extern void aee_rr_rec_fiq_step(u8 i);
+extern void aee_rr_rec_reboot_mode(u8 mode);
+extern void aee_rr_rec_kdump_params(void *params);
+extern void aee_rr_rec_last_irq_enter(int cpu, int irq, u64 j);
+extern void aee_rr_rec_last_irq_exit(int cpu, int irq, u64 j);
+extern void aee_rr_rec_last_sched_jiffies(int cpu, u64 j, const char *comm);
+extern void aee_sram_fiq_log(const char *msg);
+extern void ram_console_write(struct console *console, const char *s, unsigned int count);
+extern void aee_sram_fiq_save_bin(const char *buffer, size_t len);
+extern void aee_rr_rec_hotplug_footprint(int cpu, u8 fp);
+extern void aee_rr_rec_hotplug_cpu_event(u8 val);
+extern void aee_rr_rec_hotplug_cb_index(u8 val);
+extern void aee_rr_rec_hotplug_cb_fp(unsigned long val);
+#ifdef CONFIG_MTK_EMMC_SUPPORT
+extern void last_kmsg_store_to_emmc(void);
+#endif
+
+#else
+static inline void aee_rr_rec_hotplug_footprint(int cpu, u8 fp)
+{
+}
+static inline void aee_rr_rec_hotplug_cpu_event(u8 val)
+{
+}
+static inline void aee_rr_rec_hotplug_cb_index(u8 val)
+{
+}
+static inline void aee_rr_rec_hotplug_cb_fp(unsigned long val)
+{
+}
+static inline int aee_rr_curr_fiq_step(void)
+{
+	return 0;
+}
+
+static inline void aee_rr_rec_fiq_step(u8 i)
+{
+}
+
+static inline unsigned int aee_rr_curr_exp_type(void)
+{
+	return 0;
+}
+
+static inline void aee_rr_rec_exp_type(unsigned int type)
+{
+}
+
+static inline void aee_rr_rec_reboot_mode(u8 mode)
+{
+}
+
+static inline void aee_rr_rec_kdump_params(void *params)
+{
+}
+
+static inline void aee_rr_rec_last_irq_enter(int cpu, int irq, u64 j)
+{
+}
+
+static inline void aee_rr_rec_last_irq_exit(int cpu, int irq, u64 j)
+{
+}
+
+static inline void aee_rr_rec_last_sched_jiffies(int cpu, u64 j, const char *comm)
+{
+}
+
+static inline void aee_sram_fiq_log(const char *msg)
+{
+}
+
+static inline void ram_console_write(struct console *console, const char *s, unsigned int count)
+{
+}
+
+static inline void aee_sram_fiq_save_bin(unsigned char *buffer, size_t len)
+{
+}
+
+#ifdef CONFIG_MTK_EMMC_SUPPORT
+static inline void last_kmsg_store_to_emmc(void)
+{
+}
+#endif
+
+#endif /* CONFIG_MTK_RAM_CONSOLE */
+
+#ifdef CONFIG_MTK_AEE_IPANIC
+extern int ipanic_kmsg_write(unsigned int part, const char *buf, size_t size);
+extern int ipanic_kmsg_get_next(int *count, u64 *id, enum pstore_type_id *type, struct timespec *time,
+				  char **buf, struct pstore_info *psi);
+#else
+static inline int ipanic_kmsg_write(unsigned int part, const char *buf, size_t size)
+{
+	return 0;
+}
+
+static inline int ipanic_kmsg_get_next(int *count, u64 *id, enum pstore_type_id *type, struct timespec *time,
+				  char **buf, struct pstore_info *psi)
+{
+	return 0;
+}
+#endif /* CONFIG_MTK_AEE_IPANIC */
+
+#endif
diff --git a/drivers/misc/mediatek/include/mt-plat/mtk_rtc.h b/drivers/misc/mediatek/include/mt-plat/mtk_rtc.h
new file mode 100644
index 00000000..2181e99
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mtk_rtc.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef MTK_RTC_H
+#define MTK_RTC_H
+
+#include <linux/ioctl.h>
+#include <linux/rtc.h>
+#include <linux/types.h>
+
+typedef enum {
+	RTC_GPIO_USER_WIFI = 8,
+	RTC_GPIO_USER_GPS = 9,
+	RTC_GPIO_USER_BT = 10,
+	RTC_GPIO_USER_FM = 11,
+	RTC_GPIO_USER_PMIC = 12,
+} rtc_gpio_user_t;
+
+#ifdef CONFIG_MTK_RTC
+
+/*
+ * NOTE:
+ * 1. RTC_GPIO always exports 32K enabled by some user even if the phone is powered off
+ */
+
+extern unsigned long rtc_read_hw_time(void);
+extern void rtc_gpio_enable_32k(rtc_gpio_user_t user);
+extern void rtc_gpio_disable_32k(rtc_gpio_user_t user);
+extern bool rtc_gpio_32k_status(void);
+
+/* for AUDIOPLL (deprecated) */
+extern void rtc_enable_abb_32k(void);
+extern void rtc_disable_abb_32k(void);
+
+/* NOTE: used in Sleep driver to workaround Vrtc-Vore level shifter issue */
+extern void rtc_enable_writeif(void);
+extern void rtc_disable_writeif(void);
+
+extern void rtc_mark_recovery(void);
+#if defined(CONFIG_MTK_KERNEL_POWER_OFF_CHARGING)
+extern void rtc_mark_kpoc(void);
+#endif/*if defined(CONFIG_MTK_KERNEL_POWER_OFF_CHARGING)*/
+extern void rtc_mark_fast(void);
+extern u16 rtc_rdwr_uart_bits(u16 *val);
+extern void rtc_bbpu_power_down(void);
+extern void rtc_read_pwron_alarm(struct rtc_wkalrm *alm);
+extern int get_rtc_spare_fg_value(void);
+extern int set_rtc_spare_fg_value(int val);
+extern void rtc_irq_handler(void);
+extern bool crystal_exist_status(void);
+extern void mt_power_off(void);
+#else/*ifdef CONFIG_MTK_RTC*/
+#define rtc_read_hw_time()              ({ 0; })
+#define rtc_gpio_enable_32k(user)	do {} while (0)
+#define rtc_gpio_disable_32k(user)	do {} while (0)
+#define rtc_gpio_32k_status()		do {} while (0)
+#define rtc_enable_abb_32k()		do {} while (0)
+#define rtc_disable_abb_32k()		do {} while (0)
+#define rtc_enable_writeif()		do {} while (0)
+#define rtc_disable_writeif()		do {} while (0)
+#define rtc_mark_recovery()             do {} while (0)
+#if defined(CONFIG_MTK_KERNEL_POWER_OFF_CHARGING)
+#define rtc_mark_kpoc()                 do {} while (0)
+#endif/*if defined(CONFIG_MTK_KERNEL_POWER_OFF_CHARGING)*/
+#define rtc_mark_fast()		        do {} while (0)
+#define rtc_rdwr_uart_bits(val)		({ 0; })
+#define rtc_bbpu_power_down()		do {} while (0)
+#define rtc_read_pwron_alarm(alm)	do {} while (0)
+#define get_rtc_spare_fg_value()	({ 0; })
+#define set_rtc_spare_fg_value(val)	({ 0; })
+#define rtc_irq_handler()			do {} while (0)
+#define crystal_exist_status()		do {} while (0)
+__weak void mt_power_off(void);
+#endif/*ifdef CONFIG_MTK_RTC*/
+#endif
diff --git a/drivers/misc/mediatek/include/mt-plat/mtk_thermal_ext_control.h b/drivers/misc/mediatek/include/mt-plat/mtk_thermal_ext_control.h
new file mode 100644
index 00000000..eac6bc7
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mtk_thermal_ext_control.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2009 Travis Geiselbrecht
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _MTK_THERMAL_EXT_CONTROL_H
+#define _MTK_THERMAL_EXT_CONTROL_H
+
+#define THERMAL_MD32_IPI_MSG_BASE 0x1F00
+#define THERMAL_AP_IPI_MSG_BASE   0x2F00
+
+typedef enum {
+	THERMAL_AP_IPI_MSG_SET_TZ_THRESHOLD = THERMAL_AP_IPI_MSG_BASE,
+	THERMAL_AP_IPI_MSG_MD32_START,
+
+	THERMAL_MD32_IPI_MSG_READY = THERMAL_MD32_IPI_MSG_BASE,
+	THERMAL_MD32_IPI_MSG_MD32_START_ACK,
+	THERMAL_MD32_IPI_MSG_REACH_THRESHOLD,
+} thermal_ipi_msg_id;
+
+typedef enum {
+/* MTK_THERMAL_EXT_SENSOR_CPU = 0, */
+	MTK_THERMAL_EXT_SENSOR_ABB = 0,
+	MTK_THERMAL_EXT_SENSOR_PMIC,
+	MTK_THERMAL_EXT_SENSOR_BATTERY,
+	MTK_THERMAL_EXT_SENSOR_COUNT
+} MTK_THERMAL_EXT_SENSOR_ID;
+
+typedef struct {
+	int id;			/* id of this tz */
+	int polling_delay;	/* polling delay of this tz */
+	long high_trip_point;	/* high threshold of this tz */
+	long low_trip_point;	/* low threshold of this tz */
+} thermal_zone_data;
+
+typedef struct {
+	int id;			/* id of this tz */
+	long high_trip_point;	/* high threshold of this tz */
+	long low_trip_point;	/* low threshold of this tz */
+	long temperature;	/* Current temperature gotten from TS */
+} thermal_zone_status;
+
+typedef struct {
+	short id;
+	union {
+		thermal_zone_data tz;
+		thermal_zone_status tz_status;
+	} data;
+} thermal_ipi_msg;
+
+#endif				/* _MTK_THERMAL_EXT_CONTROL_H */
diff --git a/drivers/misc/mediatek/include/mt-plat/mtk_thermal_monitor.h b/drivers/misc/mediatek/include/mt-plat/mtk_thermal_monitor.h
new file mode 100644
index 00000000..7903b49
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mtk_thermal_monitor.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _MTK_THERMAL_MONITOR_H
+#define _MTK_THERMAL_MONITOR_H
+
+#include <linux/thermal.h>
+
+/*
+ *  MTK_THERMAL_WRAPPER_BYPASS = 1 (use original Linux Thermal API)
+ *  MTK_THERMAL_WRAPPER_BYPASS = 0 (use MTK Thermal API Monitor)
+ */
+#define MTK_THERMAL_WRAPPER_BYPASS 0
+
+#if MTK_THERMAL_WRAPPER_BYPASS
+/* Original LTF API */
+#define mtk_thermal_zone_device_register      thermal_zone_device_register
+#define mtk_thermal_zone_device_unregister    thermal_zone_device_unregister
+#define mtk_thermal_cooling_device_unregister thermal_cooling_device_unregister
+#define mtk_thermal_cooling_device_register   thermal_cooling_device_register
+#define mtk_thermal_zone_bind_cooling_device  thermal_zone_bind_cooling_device
+
+#else
+
+struct thermal_cooling_device_ops_extra {
+	int (*set_cur_temp)(struct thermal_cooling_device *, unsigned long);
+};
+
+extern
+struct thermal_zone_device *mtk_thermal_zone_device_register_wrapper
+(char *type, int trips, void *devdata, const struct thermal_zone_device_ops *ops,
+int tc1, int tc2, int passive_delay, int polling_delay);
+
+extern
+void mtk_thermal_zone_device_unregister_wrapper(struct thermal_zone_device *tz);
+
+extern
+struct thermal_cooling_device *mtk_thermal_cooling_device_register_wrapper
+(char *type, void *devdata, const struct thermal_cooling_device_ops *ops);
+
+extern
+struct thermal_cooling_device *mtk_thermal_cooling_device_register_wrapper_extra
+(char *type, void *devdata, const struct thermal_cooling_device_ops *ops,
+const struct thermal_cooling_device_ops_extra *ops_ext);
+
+extern
+int mtk_thermal_cooling_device_add_exit_point
+(struct thermal_cooling_device *cdev, int exit_point);
+
+extern
+void mtk_thermal_cooling_device_unregister_wrapper(struct thermal_cooling_device *cdev);
+
+extern int mtk_thermal_zone_bind_cooling_device_wrapper
+(struct thermal_zone_device *tz, int trip, struct thermal_cooling_device *cdev);
+
+extern int mtk_thermal_zone_bind_trigger_trip(struct thermal_zone_device *tz, int trip, int mode);
+#define mtk_thermal_zone_device_register      mtk_thermal_zone_device_register_wrapper
+#define mtk_thermal_zone_device_unregister    mtk_thermal_zone_device_unregister_wrapper
+#define mtk_thermal_cooling_device_unregister mtk_thermal_cooling_device_unregister_wrapper
+#define mtk_thermal_cooling_device_register   mtk_thermal_cooling_device_register_wrapper
+#define mtk_thermal_zone_bind_cooling_device  mtk_thermal_zone_bind_cooling_device_wrapper
+
+#endif
+
+typedef enum {
+	MTK_THERMAL_SENSOR_CPU = 0,
+	MTK_THERMAL_SENSOR_ABB,
+	MTK_THERMAL_SENSOR_PMIC,
+	MTK_THERMAL_SENSOR_BATTERY,
+	MTK_THERMAL_SENSOR_MD1,
+	MTK_THERMAL_SENSOR_MD2,
+	MTK_THERMAL_SENSOR_WIFI,
+	MTK_THERMAL_SENSOR_BATTERY2,
+	MTK_THERMAL_SENSOR_BUCK,
+	MTK_THERMAL_SENSOR_AP,
+	MTK_THERMAL_SENSOR_PCB1,
+	MTK_THERMAL_SENSOR_PCB2,
+	MTK_THERMAL_SENSOR_SKIN,
+	MTK_THERMAL_SENSOR_XTAL,
+	MTK_THERMAL_SENSOR_MD_PA,
+
+	MTK_THERMAL_SENSOR_COUNT
+} MTK_THERMAL_SENSOR_ID;
+
+extern int mtk_thermal_get_temp(MTK_THERMAL_SENSOR_ID id);
+extern struct proc_dir_entry *mtk_thermal_get_proc_drv_therm_dir_entry(void);
+
+/* This API function is implemented in mediatek/kernel/drivers/leds/leds.c */
+extern int setMaxbrightness(int max_level, int enable);
+
+extern void machine_power_off(void);
+#endif
diff --git a/drivers/misc/mediatek/include/mt-plat/mtk_thermal_platform.h b/drivers/misc/mediatek/include/mt-plat/mtk_thermal_platform.h
new file mode 100644
index 00000000..3055740
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mtk_thermal_platform.h
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _MTK_THERMAL_PLATFORM_H
+#define _MTK_THERMAL_PLATFORM_H
+
+#include <linux/thermal.h>
+#include <mtk_thermal_typedefs.h>
+
+extern
+int mtk_thermal_get_cpu_info(int *nocores, int **cpufreq, int **cpuloading);
+
+extern
+int mtk_thermal_get_gpu_info(int *nocores, int **gpufreq, int **gpuloading);
+
+extern
+int mtk_thermal_get_batt_info(int *batt_voltage, int *batt_current, int *batt_temp);
+
+extern
+int mtk_thermal_get_extra_info(int *no_extra_attr,
+			       char ***attr_names, int **attr_values, char ***attr_unit);
+
+extern
+int mtk_thermal_force_get_batt_temp(void);
+
+
+enum {
+	MTK_THERMAL_SCEN_CALL = 0x1
+};
+
+extern
+unsigned int mtk_thermal_set_user_scenarios(unsigned int mask);
+
+extern
+unsigned int mtk_thermal_clear_user_scenarios(unsigned int mask);
+
+
+#if defined(CONFIG_MTK_SMART_BATTERY)
+/* global variable from battery driver... */
+extern kal_bool gFG_Is_Charging;
+#endif
+
+extern int force_get_tbat(void);
+#endif				/* _MTK_THERMAL_PLATFORM_H */
+
+
+typedef enum {
+	TA_DAEMON_CMD_GET_INIT_FLAG = 0,
+	TA_DAEMON_CMD_SET_DAEMON_PID,
+	TA_DAEMON_CMD_NOTIFY_DAEMON,
+	TA_DAEMON_CMD_NOTIFY_DAEMON_CATMINIT,
+	TA_DAEMON_CMD_SET_TTJ,
+	TA_DAEMON_CMD_GET_TPCB,
+
+	TA_DAEMON_CMD_TO_KERNEL_NUMBER
+} TA_DAEMON_CTRL_CMD_TO_KERNEL; /*must sync userspace/kernel: TA_DAEMON_CTRL_CMD_FROM_USER*/
+
+#define TAD_NL_MSG_T_HDR_LEN 12
+#define TAD_NL_MSG_MAX_LEN 2048
+
+struct tad_nl_msg_t {
+	unsigned int tad_cmd;
+	unsigned int tad_data_len;
+	unsigned int tad_ret_data_len;
+	char tad_data[TAD_NL_MSG_MAX_LEN];
+};
+
+enum {
+	TA_CATMPLUS = 1,
+	TA_CONTINUOUS = 2,
+	TA_CATMPLUS_TTJ = 3
+};
+
+
+struct cATM_params_t {
+	int CATM_ON;
+	int K_TT;
+	int K_SUM_TT_LOW;
+	int K_SUM_TT_HIGH;
+	int MIN_SUM_TT;
+	int MAX_SUM_TT;
+	int MIN_TTJ;
+	int CATMP_STEADY_TTJ_DELTA;
+};
+struct continuetm_params_t {
+	int STEADY_TARGET_TJ;
+	int MAX_TARGET_TJ;
+	int TRIP_TPCB;
+	int STEADY_TARGET_TPCB;
+};
+
+
+struct CATM_T {
+	struct cATM_params_t t_catm_par;
+	struct continuetm_params_t t_continuetm_par;
+};
+extern struct CATM_T thermal_atm_t;
+int wakeup_ta_algo(int flow_state);
+int ta_get_ttj(void);
+
+extern int mtk_thermal_get_tpcb_target(void);
+extern int tsatm_thermal_get_catm_type(void);
+
+
diff --git a/drivers/misc/mediatek/include/mt-plat/mtk_thermal_trace.h b/drivers/misc/mediatek/include/mt-plat/mtk_thermal_trace.h
new file mode 100644
index 00000000..1c23a9f
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mtk_thermal_trace.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM thermal
+
+#if !defined(_MTK_THERMAL_TRACE_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _MTK_THERMAL_TRACE_H
+
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(cooling_device_state,
+	    TP_PROTO(int device, unsigned long state),
+	    TP_ARGS(device, state), TP_STRUCT__entry(__field(int, device)
+						     __field(unsigned long, state)
+	    ),
+	    TP_fast_assign(__entry->device = device;
+			   __entry->state = state;),
+	    TP_printk("cooling_device=%d, state=%lu\n", __entry->device, __entry->state)
+);
+
+TRACE_EVENT(thermal_zone_state,
+	    TP_PROTO(int device, int state),
+	    TP_ARGS(device, state), TP_STRUCT__entry(__field(int, device)
+						     __field(int, state)
+	    ),
+	    TP_fast_assign(__entry->device = device;
+			   __entry->state = state;),
+	    TP_printk("thermal_zone=%d, state=%d\n", __entry->device, __entry->state)
+);
+#endif				/* _MTK_THERMAL_TRACE_H */
+
+/* This part must be outside protection */
+#undef TRACE_INCLUDE_PATH
+#define TRACE_INCLUDE_PATH .
+#define TRACE_INCLUDE_FILE mach/mtk_thermal_trace
+#include <trace/define_trace.h>
diff --git a/drivers/misc/mediatek/include/mt-plat/mtk_thermal_typedefs.h b/drivers/misc/mediatek/include/mt-plat/mtk_thermal_typedefs.h
new file mode 100644
index 00000000..dfcef3d
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mtk_thermal_typedefs.h
@@ -0,0 +1,241 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _TYPEDEFS_H
+#define _TYPEDEFS_H
+
+#include <linux/bug.h>
+
+/* --------------------------------------------------------------------------- */
+/* Basic Type Definitions */
+/* --------------------------------------------------------------------------- */
+
+typedef volatile unsigned char *P_kal_uint8;
+typedef volatile unsigned short *P_kal_uint16;
+typedef volatile unsigned int *P_kal_uint32;
+
+typedef long LONG;
+typedef unsigned char UBYTE;
+typedef short SHORT;
+
+typedef signed char kal_int8;
+typedef signed short kal_int16;
+typedef signed int kal_int32;
+typedef long long kal_int64;
+typedef unsigned char kal_uint8;
+typedef unsigned short kal_uint16;
+typedef unsigned int kal_uint32;
+typedef unsigned long long kal_uint64;
+typedef char kal_char;
+
+typedef unsigned int *UINT32P;
+typedef volatile unsigned short *UINT16P;
+typedef volatile unsigned char *UINT8P;
+typedef unsigned char *U8P;
+
+typedef volatile unsigned char *P_U8;
+typedef volatile signed char *P_S8;
+typedef volatile unsigned short *P_U16;
+typedef volatile signed short *P_S16;
+typedef volatile unsigned int *P_U32;
+typedef volatile signed int *P_S32;
+typedef unsigned long long *P_U64;
+typedef signed long long *P_S64;
+
+typedef unsigned char U8;
+typedef signed char S8;
+typedef unsigned short U16;
+typedef signed short S16;
+typedef unsigned int U32;
+typedef signed int S32;
+typedef unsigned long long U64;
+typedef signed long long S64;
+/* typedef unsigned char       bool; */
+
+typedef unsigned char UINT8;
+typedef unsigned short UINT16;
+typedef unsigned int UINT32;
+typedef unsigned short USHORT;
+typedef signed char INT8;
+typedef signed short INT16;
+typedef signed int INT32;
+typedef unsigned int DWORD;
+typedef void VOID;
+typedef unsigned char BYTE;
+typedef float FLOAT;
+
+typedef char *LPCSTR;
+typedef short *LPWSTR;
+
+
+/* --------------------------------------------------------------------------- */
+/* Constants */
+/* --------------------------------------------------------------------------- */
+
+#ifndef FALSE
+#define FALSE (0)
+#endif
+
+#ifndef TRUE
+#define TRUE  (1)
+#endif
+
+#ifndef NULL
+#define NULL  (0)
+#endif
+
+/* enum boolean {false, true}; */
+enum { RX, TX, NONE };
+
+#ifndef BOOL
+typedef unsigned char BOOL;
+#endif
+
+#ifndef BATTERY_BOOL
+#define BATTERY_BOOL
+typedef enum {
+	KAL_FALSE = 0,
+	KAL_TRUE = 1,
+} kal_bool;
+#endif
+
+/* --------------------------------------------------------------------------- */
+/* Type Casting */
+/* --------------------------------------------------------------------------- */
+
+#define AS_INT32(x)     (*(INT32 *)((void *)x))
+#define AS_INT16(x)     (*(INT16 *)((void *)x))
+#define AS_INT8(x)      (*(INT8  *)((void *)x))
+
+#define AS_UINT32(x)    (*(UINT32 *)((void *)x))
+#define AS_UINT16(x)    (*(UINT16 *)((void *)x))
+#define AS_UINT8(x)     (*(UINT8  *)((void *)x))
+
+
+/* --------------------------------------------------------------------------- */
+/* Register Manipulations */
+/* --------------------------------------------------------------------------- */
+
+#define READ_REGISTER_UINT32(reg) \
+	(*(volatile UINT32 * const)(reg))
+
+#define WRITE_REGISTER_UINT32(reg, val) \
+	((*(volatile UINT32 * const)(reg)) = (val))
+
+#define READ_REGISTER_UINT16(reg) \
+	((*(volatile UINT16 * const)(reg)))
+
+#define WRITE_REGISTER_UINT16(reg, val) \
+	((*(volatile UINT16 * const)(reg)) = (val))
+
+#define READ_REGISTER_UINT8(reg) \
+	((*(volatile UINT8 * const)(reg)))
+
+#define WRITE_REGISTER_UINT8(reg, val) \
+	((*(volatile UINT8 * const)(reg)) = (val))
+
+#define INREG8(x)           READ_REGISTER_UINT8((UINT8 *)((void *)(x)))
+#define OUTREG8(x, y)       WRITE_REGISTER_UINT8((UINT8 *)((void *)(x)), (UINT8)(y))
+#define SETREG8(x, y)       OUTREG8(x, INREG8(x)|(y))
+#define CLRREG8(x, y)       OUTREG8(x, INREG8(x)&~(y))
+#define MASKREG8(x, y, z)   OUTREG8(x, (INREG8(x)&~(y))|(z))
+
+#define INREG16(x)          READ_REGISTER_UINT16((UINT16 *)((void *)(x)))
+#define OUTREG16(x, y)      WRITE_REGISTER_UINT16((UINT16 *)((void *)(x)), (UINT16)(y))
+#define SETREG16(x, y)      OUTREG16(x, INREG16(x)|(y))
+#define CLRREG16(x, y)      OUTREG16(x, INREG16(x)&~(y))
+#define MASKREG16(x, y, z)  OUTREG16(x, (INREG16(x)&~(y))|(z))
+
+#define INREG32(x)          READ_REGISTER_UINT32((UINT32 *)((void *)(x)))
+#define OUTREG32(x, y)      WRITE_REGISTER_UINT32((UINT32 *)((void *)(x)), (UINT32)(y))
+#define SETREG32(x, y)      OUTREG32(x, INREG32(x)|(y))
+#define CLRREG32(x, y)      OUTREG32(x, INREG32(x)&~(y))
+#define MASKREG32(x, y, z)  OUTREG32(x, (INREG32(x)&~(y))|(z))
+
+
+#define DRV_Reg8(addr)              INREG8(addr)
+#define DRV_WriteReg8(addr, data)   OUTREG8(addr, data)
+#define DRV_SetReg8(addr, data)     SETREG8(addr, data)
+#define DRV_ClrReg8(addr, data)     CLRREG8(addr, data)
+
+#define DRV_Reg16(addr)             INREG16(addr)
+#define DRV_WriteReg16(addr, data)  OUTREG16(addr, data)
+#define DRV_SetReg16(addr, data)    SETREG16(addr, data)
+#define DRV_ClrReg16(addr, data)    CLRREG16(addr, data)
+
+#define DRV_Reg32(addr)             INREG32(addr)
+#define DRV_WriteReg32(addr, data)  OUTREG32(addr, data)
+#define DRV_SetReg32(addr, data)    SETREG32(addr, data)
+#define DRV_ClrReg32(addr, data)    CLRREG32(addr, data)
+
+/* !!! DEPRECATED, WILL BE REMOVED LATER !!! */
+#define DRV_Reg(addr)               DRV_Reg16(addr)
+#define DRV_WriteReg(addr, data)    DRV_WriteReg16(addr, data)
+#define DRV_SetReg(addr, data)      DRV_SetReg16(addr, data)
+#define DRV_ClrReg(addr, data)      DRV_ClrReg16(addr, data)
+
+
+/* --------------------------------------------------------------------------- */
+/* Compiler Time Deduction Macros */
+/* --------------------------------------------------------------------------- */
+
+
+
+/* --------------------------------------------------------------------------- */
+/* Assertions */
+/* --------------------------------------------------------------------------- */
+
+/*
+*#ifndef ASSERT
+*#define ASSERT(expr)        BUG_ON(!(expr))
+*#endif
+*
+*#ifndef NOT_IMPLEMENTED
+*#define NOT_IMPLEMENTED()   BUG_ON(1)
+*#endif
+*/
+#define STATIC_ASSERT(pred)         STATIC_ASSERT_X(pred, __LINE__)
+#define STATIC_ASSERT_X(pred, line) STATIC_ASSERT_XX(pred, line)
+#define STATIC_ASSERT_XX(pred, line) \
+extern char assertion_failed_at_##line[(pred) ? 1 : -1]
+
+/* --------------------------------------------------------------------------- */
+/* Resolve Compiler Warnings */
+/* --------------------------------------------------------------------------- */
+
+#define NOT_REFERENCED(x)   { (x) = (x); }
+
+
+/* --------------------------------------------------------------------------- */
+/* Utilities */
+/* --------------------------------------------------------------------------- */
+
+#define MAXIMUM(A, B)       (((A) > (B))?(A):(B))
+#define MINIMUM(A, B)       (((A) < (B))?(A):(B))
+
+#define ARY_SIZE(x) (sizeof((x)) / sizeof((x[0])))
+#define DVT_DELAYMACRO(u4Num)                                            \
+{                                                                        \
+	UINT32 u4Count = 0;                                                 \
+	for (u4Count = 0; u4Count < u4Num; u4Count++)			\
+		;							\
+}                                                                        \
+
+#define    A68351B      0
+#define    B68351B      1
+#define    B68351D      2
+#define    B68351E      3
+#define    UNKNOWN_IC_VERSION   0xFF
+
+
+#endif				/* _TYPEDEFS_H */
diff --git a/drivers/misc/mediatek/include/mt-plat/mtk_wcn_cmb_stub.h b/drivers/misc/mediatek/include/mt-plat/mtk_wcn_cmb_stub.h
new file mode 100644
index 00000000..0a4fda1
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/mtk_wcn_cmb_stub.h
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+/*! \file
+ *   \brief  Declaration of library functions
+ *
+ *   Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+#ifndef _MTK_WCN_CMB_STUB_H_
+#define _MTK_WCN_CMB_STUB_H_
+
+#include <linux/pm.h>
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+/* Audio GPIO naming style for 73/75/77 */
+/* #define MTK_WCN_CMB_AUD_IO_NAMING_STYLE_0 1 */
+/* Audio GPIO naming style for 89/8135 */
+/* #define MTK_WCN_CMB_AUD_IO_NAMING_STYLE_1 1 */
+/* Audio GPIO naming style for 6592 */
+/* #define MTK_WCN_CMB_AUD_IO_NAMING_STYLE_2 1 */
+/* Audio GPIO naming style for 6595 */
+#define MTK_WCN_CMB_AUD_IO_NAMING_STYLE_3 1
+#define MTK_WCN_CMB_FOR_SDIO_1V_AUTOK 1
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+typedef enum {
+	CMB_STUB_AIF_0 = 0,	/* 0000: BT_PCM_OFF & FM analog (line in/out) */
+	CMB_STUB_AIF_1 = 1,	/* 0001: BT_PCM_ON & FM analog (in/out) */
+	CMB_STUB_AIF_2 = 2,	/* 0010: BT_PCM_OFF & FM digital (I2S) */
+	CMB_STUB_AIF_3 = 3,	/* 0011: BT_PCM_ON & FM digital (I2S) (invalid in 73evb & 1.2 phone configuration) */
+	CMB_STUB_AIF_4 = 4, /* 0100: BT_I2S & FM disable in special projects, e.g. protea*/
+	CMB_STUB_AIF_MAX = 5,
+} CMB_STUB_AIF_X;
+
+/*COMBO_CHIP_AUDIO_PIN_CTRL*/
+typedef enum {
+	CMB_STUB_AIF_CTRL_DIS = 0,
+	CMB_STUB_AIF_CTRL_EN = 1,
+	CMB_STUB_AIF_CTRL_MAX = 2,
+} CMB_STUB_AIF_CTRL;
+
+typedef enum {
+	COMBO_FUNC_TYPE_BT = 0,
+	COMBO_FUNC_TYPE_FM = 1,
+	COMBO_FUNC_TYPE_GPS = 2,
+	COMBO_FUNC_TYPE_WIFI = 3,
+	COMBO_FUNC_TYPE_WMT = 4,
+	COMBO_FUNC_TYPE_STP = 5,
+	COMBO_FUNC_TYPE_NUM = 6
+} COMBO_FUNC_TYPE;
+
+typedef enum {
+	COMBO_IF_UART = 0,
+	COMBO_IF_MSDC = 1,
+	COMBO_IF_BTIF = 2,
+	COMBO_IF_MAX,
+} COMBO_IF;
+
+typedef void (*wmt_bgf_eirq_cb) (void);
+typedef int (*wmt_aif_ctrl_cb) (CMB_STUB_AIF_X, CMB_STUB_AIF_CTRL);
+typedef void (*wmt_func_ctrl_cb) (unsigned int, unsigned int);
+typedef signed long (*wmt_thermal_query_cb) (void);
+typedef int (*wmt_deep_idle_ctrl_cb) (unsigned int);
+typedef int (*wmt_func_do_reset) (unsigned int);
+
+/* for DVFS driver do 1v autok */
+#if MTK_WCN_CMB_FOR_SDIO_1V_AUTOK
+typedef unsigned int (*wmt_get_drv_status)(unsigned int);
+#endif
+
+typedef void (*msdc_sdio_irq_handler_t) (void *);	/* external irq handler */
+typedef void (*pm_callback_t) (pm_message_t state, void *data);
+
+struct sdio_ops {
+	void (*sdio_request_eirq)(msdc_sdio_irq_handler_t irq_handler, void *data);
+	void (*sdio_enable_eirq)(void);
+	void (*sdio_disable_eirq)(void);
+	void (*sdio_register_pm)(pm_callback_t pm_cb, void *data);
+};
+
+typedef struct _CMB_STUB_CB_ {
+	unsigned int size;	/* structure size */
+	/*wmt_bgf_eirq_cb bgf_eirq_cb; *//* remove bgf_eirq_cb from stub. handle it in platform */
+	wmt_aif_ctrl_cb aif_ctrl_cb;
+	wmt_func_ctrl_cb func_ctrl_cb;
+	wmt_thermal_query_cb thermal_query_cb;
+	wmt_deep_idle_ctrl_cb deep_idle_ctrl_cb;
+	wmt_func_do_reset wmt_do_reset_cb;
+#if MTK_WCN_CMB_FOR_SDIO_1V_AUTOK
+	wmt_get_drv_status get_drv_status_cb;
+#endif
+} CMB_STUB_CB, *P_CMB_STUB_CB;
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+extern struct sdio_ops mt_sdio_ops[4];
+
+extern int mtk_wcn_cmb_stub_reg(P_CMB_STUB_CB p_stub_cb);
+extern int mtk_wcn_cmb_stub_unreg(void);
+
+extern int mtk_wcn_cmb_stub_aif_ctrl(CMB_STUB_AIF_X state, CMB_STUB_AIF_CTRL ctrl);
+
+static inline int mtk_wcn_cmb_stub_audio_ctrl(CMB_STUB_AIF_X state)
+{
+/* return mtk_wcn_cmb_stub_aif_ctrl(state, 1); */
+	return 0;
+}
+
+extern int mt_combo_plt_enter_deep_idle(COMBO_IF src);
+extern int mt_combo_plt_exit_deep_idle(COMBO_IF src);
+
+/* Use new mtk_wcn_stub APIs instead of old mt_combo ones for kernel to control
+ * function on/off.
+ */
+extern void mtk_wcn_cmb_stub_func_ctrl(unsigned int type, unsigned int on);
+extern int mtk_wcn_cmb_stub_query_ctrl(void);
+extern int board_sdio_ctrl(unsigned int sdio_port_num, unsigned int on);
+extern int mtk_wcn_sdio_irq_flag_set(int falg);
+
+#if MTK_WCN_CMB_FOR_SDIO_1V_AUTOK
+extern int mtk_wcn_cmb_stub_1vautok_for_dvfs(void);
+#endif
+
+extern int mtk_wcn_wmt_chipid_query(void);
+extern void mtk_wcn_wmt_set_chipid(int chipid);
+
+/* mtk_uart_pdn_enable -- request uart port enter/exit deep idle mode, this API is defined in uart driver
+ *
+ * @ port - uart port name, Eg: "ttyMT0", "ttyMT1", "ttyMT2"
+ * @ enable - "1", enable deep idle; "0", disable deep idle
+ *
+ * Return 0 if success, else -1
+ */
+extern unsigned int mtk_uart_pdn_enable(char *port, int enable);
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+#endif /* _MTK_WCN_CMB_STUB_H_ */
diff --git a/drivers/misc/mediatek/include/mt-plat/rt-regmap.h b/drivers/misc/mediatek/include/mt-plat/rt-regmap.h
new file mode 100644
index 00000000..9a45e23
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/rt-regmap.h
@@ -0,0 +1,291 @@
+/* drivers/misc/mediatek/include/mt-plat/rt-regmap.h
+ * Header of Richtek regmap with debugfs Driver
+ *
+ * Copyright (C) 2014 Richtek Technology Corp.
+ * Jeff Chang <jeff_chang@richtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef MISC_MEDIATEK_RT_REGMAP_H
+#define MISC_MEDIATEK_RT_REGMAP_H
+
+#include <linux/debugfs.h>
+#include <linux/i2c.h>
+
+/* #define RT_REGMAP_VERSION	"1.1.11_G" */
+
+enum rt_access_mode {
+	RT_1BYTE_MODE = 1,
+	RT_2BYTE_MODE = 2,
+	RT_4BYTE_MODE = 4,
+};
+
+/* start : the start address of group
+ * end : the end address of group
+ * mode : access mode (1,2,4 bytes)
+ */
+struct rt_access_group {
+	u32 start;
+	u32 end;
+	enum rt_access_mode mode;
+};
+
+/* rt_reg_type
+ * RT_NORMAL	: Write data without mask
+ *			Read from cache
+ * RT_WBITS	: Write data with mask
+ *			Read from cache
+ * RT_VOLATILE	: Write data to chip directly
+ *			Read data from chip
+ * RT_RESERVE	: Reserve registers (Write/Read as RT_NORMAL)
+ */
+
+#define RT_REG_TYPE_MASK	(0x03)
+#define RT_NORMAL		(0x00)
+#define RT_WBITS		(0x01)
+#define RT_VOLATILE		(0x02)
+#define RT_RESERVE		(0x03)
+
+/* RT_WR_ONCE : write once will check write data and cache data,
+ *		if write data = cache data, data will not be writen.
+ */
+#define RT_WR_ONCE		(0x08)
+#define RT_NORMAL_WR_ONCE	(RT_NORMAL|RT_WR_ONCE)
+#define RT_WBITS_WR_ONCE	(RT_WBITS|RT_WR_ONCE)
+
+enum rt_data_format {
+	RT_LITTLE_ENDIAN,
+	RT_BIG_ENDIAN,
+};
+
+/* rt_regmap_mode
+ *  0  0  0  0  0  0  0  0
+ *	  |  |  |  |  |  |
+ *	  |  |  |  |__|  byte_mode
+ *        |  |__|   ||
+ *        |   ||   Cache_mode
+ *        |   Block_mode
+ *        Debug_mode
+ */
+
+#define RT_BYTE_MODE_MASK	(0x01)
+/* 1 byte for each register*/
+#define RT_SINGLE_BYTE		(0 << 0)
+/* multi bytes for each regiseter*/
+#define RT_MULTI_BYTE		(1 << 0)
+
+#define RT_CACHE_MODE_MASK	 (0x06)
+/* write to cache and chip synchronously */
+#define RT_CACHE_WR_THROUGH	 (0 << 1)
+/* write to cache and chip asynchronously */
+#define RT_CACHE_WR_BACK	 (1 << 1)
+/* disable cache */
+#define RT_CACHE_DISABLE	 (2 << 1)
+
+#define RT_IO_BLK_MODE_MASK (0x18)
+/* pass through all write function */
+#define RT_IO_PASS_THROUGH	(0 << 3)
+/* block all write function */
+#define RT_IO_BLK_ALL		(1 << 3)
+/* block cache write function */
+#define RT_IO_BLK_CACHE		(2 << 3)
+/* block chip write function */
+#define RT_IO_BLK_CHIP		(3 << 3)
+
+#define DBG_MODE_MASK	(0x20)
+/* create general debugfs for register map */
+#define RT_DBG_GENERAL	(0 << 5)
+/* create node for each regisetr map by register address*/
+#define RT_DBG_SPECIAL	(1 << 5)
+
+
+/* struct rt_register
+ *
+ * Ricktek register map structure for store mapping data
+ * @addr: register address.
+ * @name: register name.
+ * @size: register byte size.
+ * @reg_type: register R/W type ( RT_NORMAL, RT_WBITS, RT_VOLATILE, RT_RESERVE)
+ * @wbit_mask: register writeable bits mask;
+ * @cache_data: cache data for store cache value.
+ */
+struct rt_register {
+	u32 addr;
+	const char *name;
+	unsigned int size;
+	unsigned char reg_type;
+	unsigned char *wbit_mask;
+	unsigned char *cache_data;
+};
+
+/* Declare a rt_register by RT_REG_DECL
+ * @_addr: regisetr address.
+ * @_reg_length: register data length.
+ * @_reg_type: register type (rt_reg_type).
+ * @_mask: register writealbe mask.
+ */
+#define RT_REG_DECL(_addr, _reg_length, _reg_type, _mask_...)	\
+	static unsigned char rt_writable_mask_##_addr[_reg_length] = _mask_;\
+	static struct rt_register rt_register_##_addr = {	\
+		.addr = _addr, \
+		.size = _reg_length,\
+		.reg_type = _reg_type,\
+		.wbit_mask = rt_writable_mask_##_addr,\
+	}
+
+/* Declare a rt_register by RT_NAMED_REG_DECL
+ * @_name: a name for a rt_register.
+ */
+#define RT_NAMED_REG_DECL(_addr, _name, _reg_length, _reg_type, _mask_...) \
+	static unsigned char rt_writable_mask_##_addr[_reg_length] = _mask_;\
+	static struct rt_register rt_register_##_addr = {	\
+		.addr = _addr, \
+		.name = _name, \
+		.size = _reg_length,\
+		.reg_type = _reg_type,\
+		.wbit_mask = rt_writable_mask_##_addr,\
+	}
+
+#define RT_REG(_addr) (&rt_register_##_addr)
+
+/* rt_regmap_properties
+ * @name: the name of debug node.
+ * @aliases: alisis name of rt_regmap_device.
+ * @register_num: the number of rt_register_map registers.
+ * @rm: rt_regiseter_map pointer array.
+ * @group: register map access group.
+ * @rt_format: default is little endian.
+ * @rt_regmap_mode: rt_regmap_device mode.
+ * @io_log_en: enable/disable io log
+ */
+struct rt_regmap_properties {
+	const char *name;
+	const char *aliases;
+	int register_num;
+	struct rt_register **rm;
+	struct rt_access_group *group;
+	enum rt_data_format rt_format;
+	unsigned char rt_regmap_mode;
+	unsigned char io_log_en:1;
+};
+
+/* A passing struct for rt_regmap_reg_read and rt_regmap_reg_write function
+ * reg: regmap addr.
+ * mask: mask for update bits.
+ * rt_data: register value.
+ */
+struct rt_reg_data {
+	u32 reg;
+	u32 mask;
+	union {
+		u32 data_u32;
+		u16 data_u16;
+		u8 data_u8;
+		u8 data[4];
+	} rt_data;
+};
+
+struct rt_regmap_device;
+
+struct rt_debug_st {
+	void *info;
+	int id;
+};
+
+/* basic chip read/write function */
+struct rt_regmap_fops {
+	int (*read_device)(void *client, u32 addr, int leng, void *dst);
+	int (*write_device)(void *client, u32 addr, int leng, const void *src);
+};
+
+/* with slave address */
+extern struct rt_regmap_device*
+	rt_regmap_device_register_ex(struct rt_regmap_properties *props,
+				struct rt_regmap_fops *rops,
+				struct device *parent,
+				void *client, int slv_addr, void *drvdata);
+
+static inline struct rt_regmap_device*
+	rt_regmap_device_register(struct rt_regmap_properties *props,
+				struct rt_regmap_fops *rops,
+				struct device *parent,
+				struct i2c_client *client, void *drvdata)
+{
+	return rt_regmap_device_register_ex(props, rops, parent,
+		client, client->addr, drvdata);
+}
+
+extern void rt_regmap_device_unregister(struct rt_regmap_device *rd);
+
+extern int rt_regmap_cache_init(struct rt_regmap_device *rd);
+
+extern int rt_regmap_cache_reload(struct rt_regmap_device *rd);
+
+extern int rt_regmap_block_write(struct rt_regmap_device *rd, u32 reg,
+					int bytes, const void *rc);
+extern int rt_asyn_regmap_block_write(struct rt_regmap_device *rd, u32 reg,
+					int bytes, const void *rc);
+extern int rt_regmap_block_read(struct rt_regmap_device *rd, u32 reg,
+					int bytes, void *dst);
+
+extern int _rt_regmap_reg_read(struct rt_regmap_device *rd,
+					struct rt_reg_data *rrd);
+extern int _rt_regmap_reg_write(struct rt_regmap_device *rd,
+					struct rt_reg_data *rrd);
+extern int _rt_asyn_regmap_reg_write(struct rt_regmap_device *rd,
+					struct rt_reg_data *rrd);
+extern int _rt_regmap_update_bits(struct rt_regmap_device *rd,
+					struct rt_reg_data *rrd);
+
+static inline int rt_regmap_reg_read(struct rt_regmap_device *rd,
+					struct rt_reg_data *rrd, u32 reg)
+{
+	rrd->reg = reg;
+	return _rt_regmap_reg_read(rd, rrd);
+};
+
+static inline int rt_regmap_reg_write(struct rt_regmap_device *rd,
+			struct rt_reg_data *rrd, u32 reg, const u32 data)
+{
+	rrd->reg = reg;
+	rrd->rt_data.data_u32 = data;
+	return _rt_regmap_reg_write(rd, rrd);
+};
+
+static inline int rt_asyn_regmap_reg_write(struct rt_regmap_device *rd,
+			struct rt_reg_data *rrd, u32 reg, const u32 data)
+{
+	rrd->reg = reg;
+	rrd->rt_data.data_u32 = data;
+	return _rt_asyn_regmap_reg_write(rd, rrd);
+};
+
+static inline int rt_regmap_update_bits(struct rt_regmap_device *rd,
+			struct rt_reg_data *rrd, u32 reg, u32 mask, u32 data)
+{
+	rrd->reg = reg;
+	rrd->mask = mask;
+	rrd->rt_data.data_u32 = data;
+	return _rt_regmap_update_bits(rd, rrd);
+}
+
+extern void rt_regmap_cache_backup(struct rt_regmap_device *rd);
+
+extern void rt_regmap_cache_sync(struct rt_regmap_device *rd);
+extern void rt_regmap_cache_write_back(struct rt_regmap_device *rd, u32 reg);
+
+extern int rt_is_reg_readable(struct rt_regmap_device *rd, u32 reg);
+extern int rt_is_reg_volatile(struct rt_regmap_device *rd, u32 reg);
+extern int rt_get_regsize(struct rt_regmap_device *rd, u32 reg);
+extern void rt_cache_getlasterror(struct rt_regmap_device *rd, char *buf);
+extern void rt_cache_clrlasterror(struct rt_regmap_device *rd);
+
+extern int rt_regmap_add_debugfs(struct rt_regmap_device *rd, const char *name,
+		umode_t mode, void *data, const struct file_operations *fops);
+
+#define to_rt_regmap_device(obj) container_of(obj, struct rt_regmap_device, dev)
+
+#endif /*MISC_MEDIATEK_RT_REGMAP_H*/
diff --git a/drivers/misc/mediatek/include/mt-plat/sync_write.h b/drivers/misc/mediatek/include/mt-plat/sync_write.h
new file mode 100644
index 00000000..f9e5fe4
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/sync_write.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2015 MediaTek Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _MT_SYNC_WRITE_H
+#define _MT_SYNC_WRITE_H
+
+#if defined(__KERNEL__)
+
+#include <linux/io.h>
+#include <asm/cacheflush.h>
+
+/*
+ * Define macros.
+ */
+#define mt_reg_sync_writel(v, a) \
+	do {    \
+		__raw_writel((v), (void __force __iomem *)((a)));   \
+		mb();  \
+	} while (0)
+
+#define mt_reg_sync_writew(v, a) \
+	do {    \
+		__raw_writew((v), (void __force __iomem *)((a)));   \
+		mb();  \
+	} while (0)
+
+#define mt_reg_sync_writeb(v, a) \
+	do {    \
+		__raw_writeb((v), (void __force __iomem *)((a)));   \
+		mb();  \
+	} while (0)
+
+#ifdef CONFIG_64BIT
+#define mt_reg_sync_writeq(v, a) \
+	do {    \
+		__raw_writeq((v), (void __force __iomem *)((a)));   \
+		mb();  \
+	} while (0)
+#endif
+
+#else				/* __KERNEL__ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+
+#define mt_reg_sync_writel(v, a)        mt65xx_reg_sync_writel(v, a)
+#define mt_reg_sync_writew(v, a)        mt65xx_reg_sync_writew(v, a)
+#define mt_reg_sync_writeb(v, a)        mt65xx_reg_sync_writeb(v, a)
+
+#define mb()   \
+	{    \
+		__asm__ __volatile__ ("dsb" : : : "memory"); \
+	}
+
+#define mt65xx_reg_sync_writel(v, a) \
+	do {    \
+		*(volatile unsigned int *)(a) = (v);    \
+		mb(); \
+	} while (0)
+
+#define mt65xx_reg_sync_writew(v, a) \
+	do {    \
+		*(volatile unsigned short *)(a) = (v);    \
+		mb(); \
+	} while (0)
+
+#define mt65xx_reg_sync_writeb(v, a) \
+	do {    \
+		*(volatile unsigned char *)(a) = (v);    \
+		mb(); \
+	} while (0)
+
+#endif				/* __KERNEL__ */
+
+#endif				/* !_MT_SYNC_WRITE_H */
diff --git a/drivers/misc/mediatek/include/mt-plat/wakelock.h b/drivers/misc/mediatek/include/mt-plat/wakelock.h
new file mode 100644
index 00000000..f4a698a
--- /dev/null
+++ b/drivers/misc/mediatek/include/mt-plat/wakelock.h
@@ -0,0 +1,67 @@
+/* include/linux/wakelock.h
+ *
+ * Copyright (C) 2007-2012 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_WAKELOCK_H
+#define _LINUX_WAKELOCK_H
+
+#include <linux/ktime.h>
+#include <linux/device.h>
+
+/* A wake_lock prevents the system from entering suspend or other low power
+ * states when active. If the type is set to WAKE_LOCK_SUSPEND, the wake_lock
+ * prevents a full system suspend.
+ */
+
+enum {
+	WAKE_LOCK_SUSPEND, /* Prevent suspend */
+	WAKE_LOCK_TYPE_COUNT
+};
+
+struct wake_lock {
+	struct wakeup_source ws;
+};
+
+static inline void wake_lock_init(struct wake_lock *lock, int type,
+				  const char *name)
+{
+	wakeup_source_init(&lock->ws, name);
+}
+
+static inline void wake_lock_destroy(struct wake_lock *lock)
+{
+	wakeup_source_trash(&lock->ws);
+}
+
+static inline void wake_lock(struct wake_lock *lock)
+{
+	__pm_stay_awake(&lock->ws);
+}
+
+static inline void wake_lock_timeout(struct wake_lock *lock, long timeout)
+{
+	__pm_wakeup_event(&lock->ws, jiffies_to_msecs(timeout));
+}
+
+static inline void wake_unlock(struct wake_lock *lock)
+{
+	__pm_relax(&lock->ws);
+}
+
+static inline int wake_lock_active(struct wake_lock *lock)
+{
+	return lock->ws.active;
+}
+
+#endif
